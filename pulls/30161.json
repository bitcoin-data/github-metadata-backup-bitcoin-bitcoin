{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
    "id": 1885111284,
    "node_id": "PR_kwDOABII585wXIP0",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30161",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30161.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30161.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/f1148c5aa1fa27b3fc25ac8566b43833309fe747",
    "number": 30161,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "util: add VecDeque",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Extracted from #30126.\r\n\r\nThis adds a `VecDeque` data type, inspired by `std::deque`, but backed by a single allocated memory region used as a ring buffer instead of a linked list of arrays. This gives better memory locality and less allocation overhead, plus better guarantees (some C++ standard library implementations, though not libstdc++ and libc++, use a separate allocation per element in a deque).\r\n\r\nIt is intended for the candidate set search queue in #30126, but may be useful as a replacement for `std::deque` in other places too. It's not a full drop-in replacement, as I did not add iteration support which is unnecessary for the intended use case, but nothing prevents adding that if needed.\r\n\r\nEverything is tested through a simulation-based fuzz test that compares the behavior with normal `std::deque` equivalent operations, both for trivially-copyable/destructible types and others.\r\n",
    "labels": [
      {
        "id": 241832923,
        "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
        "name": "Utils/log/libs",
        "description": "",
        "color": "5319e7",
        "default": false
      },
      {
        "id": 5334691551,
        "node_id": "LA_kwDOABII588AAAABPfju3w",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
        "name": "CI failed",
        "description": "",
        "color": "cccccc",
        "default": false
      }
    ],
    "created_at": "2024-05-23T17:21:08Z",
    "updated_at": "2024-05-24T17:35:29Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "be225e3365d060f4af6635e62c031241239f2b3f",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sipa:202405_ringbuffer",
      "ref": "202405_ringbuffer",
      "sha": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 21,
        "stargazers_count": 85,
        "watchers_count": 85,
        "size": 240057,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-05-24T17:36:56Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2024-05-05T10:02:28Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "327f08bb0cd91a22249395adeb34549e3c86ca76",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35436,
        "stargazers_count": 76529,
        "watchers_count": 76529,
        "size": 259273,
        "default_branch": "master",
        "open_issues_count": 688,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-05-24T17:36:58Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-05-24T17:59:40Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 687,
    "deletions": 0,
    "changed_files": 4,
    "commits": 2,
    "review_comments": 21,
    "comments": 2
  },
  "events": [
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T17:23:42Z",
      "updated_at": "2024-05-23T17:23:42Z",
      "source": {
        "issue": {
          "id": 2301284495,
          "node_id": "PR_kwDOABII585vttq-",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/30126",
          "number": 30126,
          "state": "open",
          "state_reason": null,
          "title": "Low-level cluster linearization code",
          "body": "Depends on #30160 and #30161. Eventually #28676 will end up being based on this.\r\n\r\nThis introduces low-level optimized cluster linearization code, including tests and some benchmarks. It is currently not hooked up to anything.\r\n\r\nRoughly the commits are organized into 3 groups:\r\n* Repeat of part of #29625.\r\n* Introduce unoptimized versions of candidate finding and linearizations, plus benchmarks and tests.\r\n* Add various optimizations step by step.\r\n\r\nUltimately, what this PR adds is two functions `Linearize` and `PostLinearize`, which operate on instances of `DepGraph` (instances of which represent pre-processed transaction clusters) to produce and/or improve linearizations for that cluster.\r\n\r\nAlong the way two new data structures are introduced (`util/bitset.h` and `util/ringbuffer.h`), which could be useful more broadly. They have their own commits, which include tests.\r\n\r\n---\r\n\r\nTo provide assurance, the code heavily relies on fuzz tests. A novel approach is used here, where the fuzz input is parsed using the serialization.h framework rather than `FuzzedDataProvider`, with a custom serializer/deserializer for `DepGraph` objects. By including serialization, it's possible to ascertain that the format can represent every relevant cluster, as well as potentially permitting the construction of ad-hoc fuzz inputs from clusters (not included in this PR, but used during development).\r\n\r\n---\r\n\r\nFor an explanation of the algorithms, see my posts on [linearization](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303), [LIMO](https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825), and [post-linearization](https://delvingbitcoin.org/t/linearization-post-processing-o-n-2-fancy-chunking/201) though with a few changes:\r\n* Bottleneck analysis is not performed; my thinking is that it only really helps with clusters that are already relatively cheap to linearize.\r\n* Connected component analysis is performed inside the search algorithm (creating initial work items per component for each candidate, rather than once at a higher level). This duplicates some work but is significantly simpler in implementation.\r\n* Ancestor-set based presplitting inside the search is replaced with using the best ancestor set as one of the LIMO set choices.\r\n* Work items are represented using an included set *inc* and an undefined set *und*, rather than included and excluded.\r\n* Potential sets *pot* are not computed for work items with empty *inc*.",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 164208572,
              "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
              "name": "Mempool",
              "color": "fef2c0",
              "default": false
            },
            {
              "id": 5334691551,
              "node_id": "LA_kwDOABII588AAAABPfju3w",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
              "name": "CI failed",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 7,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/30126",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/30126.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/30126.patch"
          },
          "created_at": "2024-05-16T20:29:15Z",
          "updated_at": "2024-05-24T17:37:03Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 12913817166,
      "node_id": "LE_lADOABII586J5NBmzwAAAAMBuTZO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12913817166",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T18:36:59Z",
      "label": {
        "name": "Utils/log/libs",
        "color": "5319e7"
      }
    },
    {
      "event": "reviewed",
      "id": 2077153695,
      "node_id": "PRR_kwDOABII5857ztmf",
      "url": null,
      "actor": null,
      "commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2077153695",
      "submitted_at": "2024-05-24T14:53:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "commented",
      "id": 2129732891,
      "node_id": "IC_kwDOABII585-8SUb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129732891",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T14:53:02Z",
      "updated_at": "2024-05-24T14:53:03Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30161).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2129732891",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12926712190,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMCffl-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12926712190",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T15:34:51Z"
    },
    {
      "event": "reviewed",
      "id": 2077094091,
      "node_id": "PRR_kwDOABII5857zfDL",
      "url": null,
      "actor": null,
      "commit_id": "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2077094091",
      "submitted_at": "2024-05-24T16:01:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927669713,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMCjJXR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927669713",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:08:16Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927889932,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMCj_IM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927889932",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:31:25Z"
    },
    {
      "event": "renamed",
      "id": 12927892872,
      "node_id": "RTE_lADOABII586J5NBmzwAAAAMCj_2I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927892872",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:31:46Z",
      "rename": {
        "from": "util: add RingBuffer",
        "to": "util: add VecDeque"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGY0ZDZmNGE4NTQ4YzYzZGJlZDcyYWE2MThkNjRiN2FjMmU3ZmNiYWQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "tree": {
        "sha": "5a8937d80de6dbe126673feebae887862784954b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5a8937d80de6dbe126673feebae887862784954b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4c387cb64ff4c74f911b1559fb0ef143ee6c268b",
          "sha": "4c387cb64ff4c74f911b1559fb0ef143ee6c268b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4c387cb64ff4c74f911b1559fb0ef143ee6c268b"
        }
      ],
      "message": "util: add VecDeque\n\nThis is an STL-like container that interface-wise looks like std::deque, but\nis backed by a (fixed size, with vector-like capacity/reserve) circular buffer.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-24T17:35:07Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-02-07T19:38:52Z"
      },
      "sha": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGYxMTQ4YzVhYTFmYTI3YjNmYzI1YWM4NTY2YjQzODMzMzA5ZmU3NDc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "tree": {
        "sha": "d9f5dbd4fda59844cade09beb4f4e56872a74860",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d9f5dbd4fda59844cade09beb4f4e56872a74860"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
          "sha": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad"
        }
      ],
      "message": "tests: add fuzz tests for VecDeque",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-24T17:35:11Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-23T17:03:39Z"
      },
      "sha": "f1148c5aa1fa27b3fc25ac8566b43833309fe747"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927921771,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMCkG5r",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927921771",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:35:23Z"
    },
    {
      "event": "labeled",
      "id": 12927922356,
      "node_id": "LE_lADOABII586J5NBmzwAAAAMCkHC0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927922356",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:35:27Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2130058565,
      "node_id": "IC_kwDOABII585-9h1F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130058565",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:35:28Z",
      "updated_at": "2024-05-24T17:35:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\nðŸš§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25390426376</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2130058565",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613576870",
      "pull_request_review_id": 2077094091,
      "id": 1613576870,
      "node_id": "PRRC_kwDOABII585gLTqm",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 58,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: Seems like this would be easier?\r\n```suggestion\r\n        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\r\n```",
      "created_at": "2024-05-24T14:31:17Z",
      "updated_at": "2024-05-24T16:46:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613576870",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613576870"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613595996",
      "pull_request_review_id": 2077094091,
      "id": 1613595996,
      "node_id": "PRRC_kwDOABII585gLYVc",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 61,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        // Pick one operation based on value of command. Not all operations are always applicable.\r\n        // Loop through the applicable ones until command reaches 0 (avoids the need to compute\r\n        // the number of applicable commands ahead of time).\r\n```",
      "created_at": "2024-05-24T14:44:12Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613595996",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613595996"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613608895",
      "pull_request_review_id": 2077153695,
      "id": 1613608895,
      "node_id": "PRRC_kwDOABII585gLbe_",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    inline size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 34,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\r\n```\r\n\r\nstyle-nit: I think `inline` can be dropped, according to https://en.cppreference.com/w/cpp/language/inline\r\n\r\n> A function defined entirely inside a [class/struct/union definition](https://en.cppreference.com/w/cpp/language/classes), whether it's a member function or a non-member friend function, is implicitly an inline function [...]\r\n\r\n",
      "created_at": "2024-05-24T14:52:59Z",
      "updated_at": "2024-05-24T14:53:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613608895",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613608895"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613637296",
      "pull_request_review_id": 2077094091,
      "id": 1613637296,
      "node_id": "PRRC_kwDOABII585gLiaw",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 63,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There's an assumption that at least one of the operations is applicable every time. Pretty obviously true but I assigned variables to all the possible conditions while reviewing and used it to add an assertion. Might be easier to read so I figured I'd leave a comment.\r\n```suggestion\r\n        const bool non_empty{num_buffers != 0};\r\n        const bool non_full{num_buffers < MAX_BUFFERS};\r\n        const bool partially_full{num_buffers > 0 && num_buffers < MAX_BUFFERS};\r\n        const bool multiple_exist{num_buffers > 1};\r\n        const bool existing_buffer_nonfull{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\r\n        const bool existing_buffer_nonempty{non_empty && !sim[idx].empty()};\r\n        assert(non_full || non_empty || partially_full);\r\n        \r\n        while (true) {\r\n```",
      "created_at": "2024-05-24T15:13:13Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613637296",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613637296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613660947",
      "pull_request_review_id": 2077094091,
      "id": 1613660947,
      "node_id": "PRRC_kwDOABII585gLoMT",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 305,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    // Create entry for this object in g_tracker and populate m_track_entry\r\n    void Register()\r\n```",
      "created_at": "2024-05-24T15:31:26Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613660947",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613660947"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 313,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613661502",
      "pull_request_review_id": 2077094091,
      "id": 1613661502,
      "node_id": "PRRC_kwDOABII585gLoU-",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 324,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    // Get value corresponding to this object in g_tracker\r\n    std::optional<uint64_t>& Deref()\r\n```",
      "created_at": "2024-05-24T15:31:47Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613661502",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613661502"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613663028",
      "pull_request_review_id": 2077094091,
      "id": 1613663028,
      "node_id": "PRRC_kwDOABII585gLos0",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }\n+\n+    TrackedObj& operator=(TrackedObj&& other)\n+    {\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+        return *this;\n+    }\n+\n+    friend bool operator==(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        return a.Deref() == b.Deref();\n+    }\n+\n+    friend std::strong_ordering operator<=>(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        // Libc++ 15 & 16 do not support std::optional<T>::operator<=> yet. See\n+        // https://reviews.llvm.org/D146392.\n+        if (!a.Deref().has_value() || !b.Deref().has_value()) {\n+            return a.Deref().has_value() <=> b.Deref().has_value();\n+        }\n+        return *a.Deref() <=> *b.Deref();\n+    }\n+\n+    static void CheckNoneExist()\n+    {\n+        assert(g_tracker.empty());\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(ringbuffer)\n+{\n+    // Run the test with simple uints (which are std::is_trivially_copyable_v).\n+    TestType<uint8_t, false>(buffer, 1);\n+    TestType<uint16_t, false>(buffer, 2);\n+    TestType<uint32_t, false>(buffer, 3);\n+    TestType<uint64_t, false>(buffer, 4);\n+    // Run the test with TrackedObjs (which are not).",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 404,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`static_assert(!std::is_trivially_copyable_v<TrackedObj<1>>)` ?",
      "created_at": "2024-05-24T15:32:32Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613663028",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613663028"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 404,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674426",
      "pull_request_review_id": 2077266898,
      "id": 1613674426,
      "node_id": "PRRC_kwDOABII585gLre6",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    inline size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 34,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613608895,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.\r\n\r\n`inline` does have an effect beyond making it an inline function (in GCC and Clang it increases the eagerness of the compiler to actually inline the function), but that's the sort of optimization one should only do guided by benchmarks, which I haven't done, so I dropped the `inline` here.",
      "created_at": "2024-05-24T15:37:14Z",
      "updated_at": "2024-05-24T15:37:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613674426",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674426"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613702058",
      "pull_request_review_id": 2077094091,
      "id": 1613702058,
      "node_id": "PRRC_kwDOABII585gLyOq",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 23,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I was slightly confused that this was called `RingBuffer` since the data structure itself doesn't act like a ring buffer i.e. will reallocate if adding items beyond capacity (I wrote `vExtraTxnForCompact` to use it before looking at the implementation and then realized I misunderstood the interface). But I now have read that `m_buffer` is the ring buffer - oops.",
      "created_at": "2024-05-24T15:57:09Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613702058",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613702058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613746327",
      "pull_request_review_id": 2077390047,
      "id": 1613746327,
      "node_id": "PRRC_kwDOABII585gL9CX",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 23,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "in_reply_to_id": 1613702058,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hmm, this is a good point. The `RingBuffer` class' interface isn't a ring buffer, but a deque; the implementation happens to use a ring buffer. Suggestions/bikeshedding for a better name welcome.",
      "created_at": "2024-05-24T16:33:21Z",
      "updated_at": "2024-05-24T16:33:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613746327",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613746327"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613757739",
      "pull_request_review_id": 2077411055,
      "id": 1613757739,
      "node_id": "PRRC_kwDOABII585gL_0r",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 58,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613576870,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"Integral in Rage\" sounds like a high-school metal band.",
      "created_at": "2024-05-24T16:42:55Z",
      "updated_at": "2024-05-24T16:42:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613757739",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613757739"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785731",
      "pull_request_review_id": 2077454937,
      "id": 1613785731,
      "node_id": "PRRC_kwDOABII585gMGqD",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 58,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613576870,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T17:08:34Z",
      "updated_at": "2024-05-24T17:08:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785731",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785818",
      "pull_request_review_id": 2077455089,
      "id": 1613785818,
      "node_id": "PRRC_kwDOABII585gMGra",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 61,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613595996,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T17:08:40Z",
      "updated_at": "2024-05-24T17:08:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785818",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785818"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785897",
      "pull_request_review_id": 2077455207,
      "id": 1613785897,
      "node_id": "PRRC_kwDOABII585gMGsp",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 63,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613637296,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T17:08:45Z",
      "updated_at": "2024-05-24T17:08:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785897",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785897"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785977",
      "pull_request_review_id": 2077455350,
      "id": 1613785977,
      "node_id": "PRRC_kwDOABII585gMGt5",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 324,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613661502,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T17:08:52Z",
      "updated_at": "2024-05-24T17:08:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785977",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785977"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786034",
      "pull_request_review_id": 2077455436,
      "id": 1613786034,
      "node_id": "PRRC_kwDOABII585gMGuy",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 23,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "in_reply_to_id": 1613702058,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In Rust they call it [`VecDeque`](https://doc.rust-lang.org/std/collections/struct.VecDeque.html), maybe that's a naming option? (It even rhymes!)",
      "created_at": "2024-05-24T17:08:55Z",
      "updated_at": "2024-05-24T17:08:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786034",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786034"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786106",
      "pull_request_review_id": 2077455546,
      "id": 1613786106,
      "node_id": "PRRC_kwDOABII585gMGv6",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 305,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613660947,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T17:09:00Z",
      "updated_at": "2024-05-24T17:09:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786106",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786106"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 313,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786217",
      "pull_request_review_id": 2077455736,
      "id": 1613786217,
      "node_id": "PRRC_kwDOABII585gMGxp",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }\n+\n+    TrackedObj& operator=(TrackedObj&& other)\n+    {\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+        return *this;\n+    }\n+\n+    friend bool operator==(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        return a.Deref() == b.Deref();\n+    }\n+\n+    friend std::strong_ordering operator<=>(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        // Libc++ 15 & 16 do not support std::optional<T>::operator<=> yet. See\n+        // https://reviews.llvm.org/D146392.\n+        if (!a.Deref().has_value() || !b.Deref().has_value()) {\n+            return a.Deref().has_value() <=> b.Deref().has_value();\n+        }\n+        return *a.Deref() <=> *b.Deref();\n+    }\n+\n+    static void CheckNoneExist()\n+    {\n+        assert(g_tracker.empty());\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(ringbuffer)\n+{\n+    // Run the test with simple uints (which are std::is_trivially_copyable_v).\n+    TestType<uint8_t, false>(buffer, 1);\n+    TestType<uint16_t, false>(buffer, 2);\n+    TestType<uint32_t, false>(buffer, 3);\n+    TestType<uint64_t, false>(buffer, 4);\n+    // Run the test with TrackedObjs (which are not).",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 404,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613663028,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done (and more).",
      "created_at": "2024-05-24T17:09:08Z",
      "updated_at": "2024-05-24T17:09:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786217",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786217"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 404,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613810244",
      "pull_request_review_id": 2077498512,
      "id": 1613810244,
      "node_id": "PRRC_kwDOABII585gMMpE",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 23,
      "commit_id": "f1148c5aa1fa27b3fc25ac8566b43833309fe747",
      "original_commit_id": "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "in_reply_to_id": 1613702058,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Renamed!",
      "created_at": "2024-05-24T17:32:13Z",
      "updated_at": "2024-05-24T17:32:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613810244",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613810244"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    }
  ]
}