{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
    "id": 1885111284,
    "node_id": "PR_kwDOABII585wXIP0",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30161",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30161.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30161.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
    "number": 30161,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "util: add VecDeque",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Extracted from #30126.\r\n\r\nThis adds a `VecDeque` data type, inspired by `std::deque`, but backed by a single allocated memory region used as a ring buffer instead of a linked list of arrays. This gives better memory locality and less allocation overhead, plus better guarantees (some C++ standard library implementations, though not libstdc++ and libc++, use a separate allocation per element in a deque).\r\n\r\nIt is intended for the candidate set search queue in #30126, but may be useful as a replacement for `std::deque` in other places too. It's not a full drop-in replacement, as I did not add iteration support which is unnecessary for the intended use case, but nothing prevents adding that if needed.\r\n\r\nEverything is tested through a simulation-based fuzz test that compares the behavior with normal `std::deque` equivalent operations, both for trivially-copyable/destructible types and others.\r\n",
    "labels": [
      {
        "id": 241832923,
        "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
        "name": "Utils/log/libs",
        "description": "",
        "color": "5319e7",
        "default": false
      },
      {
        "id": 5334691551,
        "node_id": "LA_kwDOABII588AAAABPfju3w",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
        "name": "CI failed",
        "description": "",
        "color": "cccccc",
        "default": false
      },
      {
        "id": 6861582155,
        "node_id": "LA_kwDOABII588AAAABmPtvSw",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20CMake%20port",
        "name": "Needs CMake port",
        "description": "",
        "color": "0e8a16",
        "default": false
      }
    ],
    "created_at": "2024-05-23T17:21:08Z",
    "updated_at": "2024-06-06T17:44:57Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "0af8fbb39c00228187da1bda9f15706fb8509487",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sipa:202405_ringbuffer",
      "ref": "202405_ringbuffer",
      "sha": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 21,
        "stargazers_count": 86,
        "watchers_count": 86,
        "size": 240429,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-06-06T17:51:01Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2024-06-02T01:19:44Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "1040a1fc807ed984020eeaa6e90b5bf070b61b05",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35474,
        "stargazers_count": 76756,
        "watchers_count": 76756,
        "size": 260208,
        "default_branch": "master",
        "open_issues_count": 682,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-06-06T17:51:04Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-06-06T17:39:30Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 805,
    "deletions": 0,
    "changed_files": 4,
    "commits": 2,
    "review_comments": 71,
    "comments": 15
  },
  "events": [
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T17:23:42Z",
      "updated_at": "2024-05-23T17:23:42Z",
      "source": {
        "issue": {
          "id": 2301284495,
          "node_id": "PR_kwDOABII585vttq-",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/30126",
          "number": 30126,
          "state": "open",
          "state_reason": null,
          "title": "Low-level cluster linearization code",
          "body": "Depends on #30160 and #30161. Eventually #28676 will end up being based on this.\r\n\r\nThis introduces low-level optimized cluster linearization code, including tests and some benchmarks. It is currently not hooked up to anything.\r\n\r\nRoughly the commits are organized into 3 groups:\r\n* Repeat of part of #29625.\r\n* Introduce unoptimized versions of candidate finding and linearizations, plus benchmarks and tests.\r\n* Add various optimizations step by step.\r\n\r\nUltimately, what this PR adds is functions `Linearize`, `PostLinearize`, and `MergeLinearizations` which operate on instances of `DepGraph` (instances of which represent pre-processed transaction clusters) to produce and/or improve linearizations for that cluster.\r\n\r\nAlong the way two new data structures are introduced (`util/bitset.h` and `util/ringbuffer.h`), which could be useful more broadly. They have their own commits, which include tests.\r\n\r\n---\r\n\r\nTo provide assurance, the code heavily relies on fuzz tests. A novel approach is used here, where the fuzz input is parsed using the serialization.h framework rather than `FuzzedDataProvider`, with a custom serializer/deserializer for `DepGraph` objects. By including serialization, it's possible to ascertain that the format can represent every relevant cluster, as well as potentially permitting the construction of ad-hoc fuzz inputs from clusters (not included in this PR, but used during development).\r\n\r\n---\r\n\r\nThe `Linearize(depgraph, iteration_limit, rng_seed, old_linearization)` function is an implementation of the (single) [LIMO](https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825) algorithm, with the $S$ in every iteration found as the best out of (a) the best remaining ancestor set and (b) randomized computationally-bounded search. It incrementally builds up a linearization by finding good topologically-valid subsets to move to the front, in such a way that the resulting linearization has a diagram that is at least as good as the `old_linearization` passed in (if any).\r\n* Despite using both best ancestor set and search, this is not Double LIMO, as no intersections between these are involved; just the best of the two.\r\n* The `iteration_limit` and `rng_seed` only control the (b) randomized search. Even with 0 iterations, the result will be as good as the old linearization, and the included sets at every point will have a feerate at least as high as the best remaining ancestor set at that point.\r\n\r\nThe search algorithm used in the (b) step above largely follows Section 2 of [How to linearize your cluster](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303#h-2-finding-high-feerate-subsets-5), though with a few changes:\r\n* Connected component analysis is performed inside the search algorithm (creating initial work items per component for each candidate), rather than once at a higher level. This duplicates some work but is significantly simpler in implementation.\r\n* No ancestor-set based presplitting inside the search is performed; instead, the `best` value is initialized with the best topologically valid set known to the LIMO algorithm before search starts: the better one out of the highest-feerate remaining ancestor set, and the highest-feerate prefix of remaining transactions in `old_linearization`.\r\n* Work items are represented using an included set *inc* and an undefined set *und*, rather than included and excluded.\r\n* Potential sets *pot* are not computed for work items with empty *inc*.\r\n\r\nAt a high level, the only missing optimization from that post is bottleneck analysis; my thinking is that it only really helps with clusters that are already relatively cheap to linearize (doing so would need to be done at a higher level, not inside the search algorithm).\r\n\r\nThe `PostLinearize(depgraph, linearization)` function performs an in-place improvement of `linearization`, using two iterations of the [Linearization post-processing](https://delvingbitcoin.org/t/linearization-post-processing-o-n-2-fancy-chunking/201/8) algorithm. The first running from back to front, the second from front to back.\n\nThe `MergeLinearizations(depgraph, linearization1, linearization2)` function computes a new linearization for the provided cluster, given two existing linearizations for that cluster, which is at least as good as both inputs. The algorithm is described at a high level in [merging incomparable linearizations](https://delvingbitcoin.org/t/merging-incomparable-linearizations/209).\r\n",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 164208572,
              "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
              "name": "Mempool",
              "color": "fef2c0",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 11,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/30126",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/30126.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/30126.patch"
          },
          "created_at": "2024-05-16T20:29:15Z",
          "updated_at": "2024-06-06T14:20:10Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 12913817166,
      "node_id": "LE_lADOABII586J5NBmzwAAAAMBuTZO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12913817166",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T18:36:59Z",
      "label": {
        "name": "Utils/log/libs",
        "color": "5319e7"
      }
    },
    {
      "event": "reviewed",
      "id": 2077153695,
      "node_id": "PRR_kwDOABII5857ztmf",
      "url": null,
      "actor": null,
      "commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2077153695",
      "submitted_at": "2024-05-24T14:53:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "commented",
      "id": 2129732891,
      "node_id": "IC_kwDOABII585-8SUb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129732891",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T14:53:02Z",
      "updated_at": "2024-06-06T17:40:10Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30161).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Stale ACK | [instagibbs](https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2150437453), [hebasto](https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2102299643) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#30126](https://github.com/bitcoin/bitcoin/pull/30126) (Low-level cluster linearization code by sipa)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2129732891",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12926712190,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMCffl-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12926712190",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T15:34:51Z"
    },
    {
      "event": "reviewed",
      "id": 2077094091,
      "node_id": "PRR_kwDOABII5857zfDL",
      "url": null,
      "actor": null,
      "commit_id": "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2077094091",
      "submitted_at": "2024-05-24T16:01:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927669713,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMCjJXR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927669713",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:08:16Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927889932,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMCj_IM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927889932",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:31:25Z"
    },
    {
      "event": "renamed",
      "id": 12927892872,
      "node_id": "RTE_lADOABII586J5NBmzwAAAAMCj_2I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927892872",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:31:46Z",
      "rename": {
        "from": "util: add RingBuffer",
        "to": "util: add VecDeque"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927921771,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMCkG5r",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927921771",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:35:23Z"
    },
    {
      "event": "labeled",
      "id": 12927922356,
      "node_id": "LE_lADOABII586J5NBmzwAAAAMCkHC0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927922356",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:35:27Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2130058565,
      "node_id": "IC_kwDOABII585-9h1F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130058565",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:35:28Z",
      "updated_at": "2024-05-24T17:35:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\nðŸš§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25390426376</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2130058565",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "reviewed",
      "id": 2077678840,
      "node_id": "PRR_kwDOABII58571tz4",
      "url": null,
      "actor": null,
      "commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2077678840",
      "submitted_at": "2024-05-24T19:17:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "unlabeled",
      "id": 12930212867,
      "node_id": "UNLE_lADOABII586J5NBmzwAAAAMCs2QD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12930212867",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T22:52:04Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12934322753,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMC8hpB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12934322753",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-25T23:58:43Z"
    },
    {
      "event": "commented",
      "id": 2131728449,
      "node_id": "IC_kwDOABII585_D5hB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2131728449",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-26T00:01:14Z",
      "updated_at": "2024-05-26T00:01:14Z",
      "author_association": "MEMBER",
      "body": "Apparently `std::is_trivially_default_constructible_v<T>` does not imply you can just memset 0 to construct the objects (or at least, I can't find evidence of that). So I've dropped that branch.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2131728449",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "labeled",
      "id": 12945161931,
      "node_id": "LE_lADOABII586J5NBmzwAAAAMDl37L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12945161931",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T12:09:26Z",
      "label": {
        "name": "Needs CMake port",
        "color": "0e8a16"
      }
    },
    {
      "event": "commented",
      "id": 2133351751,
      "node_id": "IC_kwDOABII585_KF1H",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133351751",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T12:12:11Z",
      "updated_at": "2024-05-27T12:12:11Z",
      "author_association": "MEMBER",
      "body": "Concept ACK.",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2133351751",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "commented",
      "id": 2133434672,
      "node_id": "IC_kwDOABII585_KaEw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133434672",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T12:59:30Z",
      "updated_at": "2024-05-27T12:59:30Z",
      "author_association": "MEMBER",
      "body": "> It's not a full drop-in replacement...\r\n\r\nThen, perhaps, it's a good chance to avoid `size_t` for parameter and return types in the interface?\r\n\r\nSee: [Signed and Unsigned Types in Interfaces](https://www.aristeia.com/Papers/C++ReportColumns/sep95.pdf)",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2133434672",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "commented",
      "id": 2133774404,
      "node_id": "IC_kwDOABII585_LtBE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133774404",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T16:04:53Z",
      "updated_at": "2024-05-27T16:04:53Z",
      "author_association": "MEMBER",
      "body": "@hebasto I do prefer to stay compatible with the `std::deque` interface, even if just for matching behavior users would expect. ",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2133774404",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "mentioned",
      "id": 12947859789,
      "node_id": "MEE_lADOABII586J5NBmzwAAAAMDwKlN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12947859789",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T16:04:54Z"
    },
    {
      "event": "subscribed",
      "id": 12947859795,
      "node_id": "SE_lADOABII586J5NBmzwAAAAMDwKlT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12947859795",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T16:04:54Z"
    },
    {
      "event": "reviewed",
      "id": 2082248884,
      "node_id": "PRR_kwDOABII5858HJi0",
      "url": null,
      "actor": null,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2082248884",
      "submitted_at": "2024-05-28T09:30:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "reviewed",
      "id": 2082303692,
      "node_id": "PRR_kwDOABII5858HW7M",
      "url": null,
      "actor": null,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2082303692",
      "submitted_at": "2024-05-28T09:55:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "reviewed",
      "id": 2082368339,
      "node_id": "PRR_kwDOABII5858HmtT",
      "url": null,
      "actor": null,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2082368339",
      "submitted_at": "2024-05-28T10:24:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "reviewed",
      "id": 2082390454,
      "node_id": "PRR_kwDOABII5858HsG2",
      "url": null,
      "actor": null,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2082390454",
      "submitted_at": "2024-05-28T10:33:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "reviewed",
      "id": 2082411034,
      "node_id": "PRR_kwDOABII5858HxIa",
      "url": null,
      "actor": null,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2082411034",
      "submitted_at": "2024-05-28T10:44:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "reviewed",
      "id": 2076000498,
      "node_id": "PRR_kwDOABII5857vUDy",
      "url": null,
      "actor": null,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2076000498",
      "submitted_at": "2024-05-28T12:19:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12957128657,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMEThfR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12957128657",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T12:47:49Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12957227476,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMET5nU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12957227476",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T12:55:07Z"
    },
    {
      "event": "reviewed",
      "id": 2085655168,
      "node_id": "PRR_kwDOABII5858UJKA",
      "url": null,
      "actor": null,
      "commit_id": "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2085655168",
      "submitted_at": "2024-05-29T14:50:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12976633293,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMFd7XN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12976633293",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-29T19:52:47Z"
    },
    {
      "event": "reviewed",
      "id": 2088303122,
      "node_id": "PRR_kwDOABII5858ePoS",
      "url": null,
      "actor": null,
      "commit_id": "a5a27bae11e14743c08812307cedc9dfb47efebf",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2088303122",
      "submitted_at": "2024-05-30T13:32:55Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12986690423,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMGESt3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12986690423",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T14:04:09Z"
    },
    {
      "event": "reviewed",
      "id": 2088628907,
      "node_id": "PRR_kwDOABII5858ffKr",
      "url": null,
      "actor": null,
      "commit_id": "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2088628907",
      "submitted_at": "2024-05-30T15:27:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "reviewed",
      "id": 2088736908,
      "node_id": "PRR_kwDOABII5858f5iM",
      "url": null,
      "actor": null,
      "commit_id": "ecb278bb19c53b007380e262fa86d809255eeb49",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK ecb278bb19c53b007380e262fa86d809255eeb49, I have reviewed the code and it looks OK.\r\n\r\nIt seems worth considering to add a couple of edge cases to the `src/test/fuzz/vecdeque.cpp` like self-assignment and self-swap.",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2088736908",
      "submitted_at": "2024-05-30T16:01:56Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13040235194,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMJQjK6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13040235194",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T18:15:12Z"
    },
    {
      "event": "commented",
      "id": 2148130643,
      "node_id": "IC_kwDOABII586ACd9T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148130643",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T18:15:40Z",
      "updated_at": "2024-06-04T18:15:40Z",
      "author_association": "MEMBER",
      "body": "@hebasto Good idea, self copy-assignment was indeed broken! Fixed, and added tests for self copy/move/swap.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2148130643",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "mentioned",
      "id": 13040240113,
      "node_id": "MEE_lADOABII586J5NBmzwAAAAMJQkXx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13040240113",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T18:15:41Z"
    },
    {
      "event": "subscribed",
      "id": 13040240128,
      "node_id": "SE_lADOABII586J5NBmzwAAAAMJQkYA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13040240128",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T18:15:41Z"
    },
    {
      "event": "commented",
      "id": 2148229582,
      "node_id": "IC_kwDOABII586AC2HO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148229582",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T19:15:49Z",
      "updated_at": "2024-06-04T19:15:49Z",
      "author_association": "MEMBER",
      "body": "> @hebasto Good idea, self copy-assignment was indeed broken! Fixed, and added tests for self copy/move/swap.\r\n\r\nI suspect this is probably broken in several of our other classes as well. Speaking for myself at least, I almost always forget about correctness there and never look for it in review.\r\n\r\nFWIW I tried using the [bugprone-unhandled-self-assignment](https://clang.llvm.org/extra/clang-tidy/checks/bugprone/unhandled-self-assignment.html) clang-tidy check which does catch the problem, but it also throws a false-positive for this solution (as well as every other that I tried :( )",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2148229582",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "mentioned",
      "id": 13040847752,
      "node_id": "MEE_lADOABII586J5NBmzwAAAAMJS4uI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13040847752",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T19:15:51Z"
    },
    {
      "event": "subscribed",
      "id": 13040847773,
      "node_id": "SE_lADOABII586J5NBmzwAAAAMJS4ud",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13040847773",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T19:15:51Z"
    },
    {
      "event": "commented",
      "id": 2148252096,
      "node_id": "IC_kwDOABII586AC7nA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148252096",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T19:30:33Z",
      "updated_at": "2024-06-04T19:30:33Z",
      "author_association": "MEMBER",
      "body": "@theuni What if the comparison is changed to `if (this == &other) return *this;`?",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2148252096",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "mentioned",
      "id": 13040988545,
      "node_id": "MEE_lADOABII586J5NBmzwAAAAMJTbGB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13040988545",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T19:30:34Z"
    },
    {
      "event": "subscribed",
      "id": 13040988559,
      "node_id": "SE_lADOABII586J5NBmzwAAAAMJTbGP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13040988559",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T19:30:34Z"
    },
    {
      "event": "reviewed",
      "id": 2096682721,
      "node_id": "PRR_kwDOABII5858-Nbh",
      "url": null,
      "actor": null,
      "commit_id": "9b04e8864b2807c94a03b9093cfa8c836d7c7116",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reviewed through 9b04e8864b2807c94a03b9093cfa8c836d7c7116, but I need to look closer at the fuzz cases",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2096682721",
      "submitted_at": "2024-06-04T19:31:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "commented",
      "id": 2148290427,
      "node_id": "IC_kwDOABII586ADE97",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148290427",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T19:42:53Z",
      "updated_at": "2024-06-04T19:46:51Z",
      "author_association": "MEMBER",
      "body": "> `if (this == &other) return *this;`\r\n\r\nHuh, that worked. But this (the one I tried) doesn't\r\n```c++\r\nif (*this == other) return *this;\r\n```\r\n\r\nEdit: facepalm",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2148290427",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "commented",
      "id": 2148299043,
      "node_id": "IC_kwDOABII586ADHEj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148299043",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T19:46:20Z",
      "updated_at": "2024-06-04T19:46:20Z",
      "author_association": "MEMBER",
      "body": "Oh, duh, that's a totally different comparison. Ofc that didn't do what I wanted :)",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2148299043",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13041775801,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMJWbS5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13041775801",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T20:54:07Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13042263572,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMJYSYU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13042263572",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T21:53:40Z"
    },
    {
      "event": "commented",
      "id": 2148476988,
      "node_id": "IC_kwDOABII586ADyg8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148476988",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T21:54:18Z",
      "updated_at": "2024-06-04T21:54:18Z",
      "author_association": "MEMBER",
      "body": "Added a few missing `compare_fn` calls, and also added branches to the fuzz test to exercise `pop_front()` and `pop_back()`, which were apparently missing.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2148476988",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13042285975,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMJYX2X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13042285975",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T21:55:54Z"
    },
    {
      "event": "reviewed",
      "id": 2098403329,
      "node_id": "PRR_kwDOABII5859ExgB",
      "url": null,
      "actor": null,
      "commit_id": "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2098403329",
      "submitted_at": "2024-06-05T08:29:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "commented",
      "id": 2150437453,
      "node_id": "IC_kwDOABII586ALRJN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2150437453",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-05T16:05:22Z",
      "updated_at": "2024-06-05T16:05:22Z",
      "author_association": "MEMBER",
      "body": "ACK e4ecb8217ada3dae1c1645a8d0a12e14b0f935da\r\n\r\nverified fuzz target coverage and sensible invariant checks are being enforced\r\n",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2150437453",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "review_requested",
      "id": 13053919013,
      "node_id": "RRE_lADOABII586J5NBmzwAAAAMKEv8l",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13053919013",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-05T16:05:27Z",
      "requested_reviewer": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-05T17:53:42Z",
      "updated_at": "2024-06-05T17:53:42Z",
      "source": {
        "issue": {
          "id": 2336496623,
          "node_id": "PR_kwDOABII585xljfH",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30234",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30234/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30234/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30234/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/30234",
          "number": 30234,
          "state": "open",
          "state_reason": null,
          "title": "Enable clang-tidy checks for self-assignment",
          "body": "See comment here: https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2148229582\r\n\r\nOur code failed these checks in two places, which have been fixed up here. Though these appear to have been harmless, adding the check avoids the copy in the self-assignment case so there should be no downside.\r\n\r\nAdditionally, minisketch failed the check as well. See https://github.com/sipa/minisketch/pull/87\r\n\r\nAfter fixing up the violations, turn on the aggressive clang-tidy check.\r\n\r\nNote that I only locally tested bitcoind sources. It's possible that additional fixups are required for tests/fuzzers/etc. We'll see what c-i thinks.\r\n\r\nNote for reviewers: `git diff -w` makes this trivial to review.",
          "user": {
            "login": "theuni",
            "id": 417043,
            "node_id": "MDQ6VXNlcjQxNzA0Mw==",
            "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/theuni",
            "html_url": "https://github.com/theuni",
            "followers_url": "https://api.github.com/users/theuni/followers",
            "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
            "organizations_url": "https://api.github.com/users/theuni/orgs",
            "repos_url": "https://api.github.com/users/theuni/repos",
            "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/theuni/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 5334691551,
              "node_id": "LA_kwDOABII588AAAABPfju3w",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
              "name": "CI failed",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 8,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30234",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/30234",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/30234.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/30234.patch"
          },
          "created_at": "2024-06-05T17:53:41Z",
          "updated_at": "2024-06-06T14:05:05Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 2102299643,
      "node_id": "PRR_kwDOABII5859Tov7",
      "url": null,
      "actor": null,
      "commit_id": "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "re-ACK e4ecb8217ada3dae1c1645a8d0a12e14b0f935da, I agree with changes since my recent [review](https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2088736908).",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2102299643",
      "submitted_at": "2024-06-06T15:25:17Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDMyZDE1OTAxYWJiNzAxZGE3MDc3NjFiYmQzYWI2MGFhOTU2YmViYjU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/32d15901abb701da707761bbd3ab60aa956bebb5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/32d15901abb701da707761bbd3ab60aa956bebb5",
      "tree": {
        "sha": "8b045e01e6ae44e0323f45de2170e7fbc7c86699",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8b045e01e6ae44e0323f45de2170e7fbc7c86699"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1040a1fc807ed984020eeaa6e90b5bf070b61b05",
          "sha": "1040a1fc807ed984020eeaa6e90b5bf070b61b05",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/1040a1fc807ed984020eeaa6e90b5bf070b61b05"
        }
      ],
      "message": "util: add VecDeque\n\nThis is an STL-like container that interface-wise looks like std::deque, but\nis backed by a (fixed size, with vector-like capacity/reserve) circular buffer.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-06T17:39:26Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-02-07T19:38:52Z"
      },
      "sha": "32d15901abb701da707761bbd3ab60aa956bebb5"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13070234440,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMLC_NI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13070234440",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T17:40:06Z"
    },
    {
      "event": "commented",
      "id": 2153072603,
      "node_id": "IC_kwDOABII586AVUfb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2153072603",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T17:41:16Z",
      "updated_at": "2024-06-06T17:41:16Z",
      "author_association": "MEMBER",
      "body": "I've added some doxygen comments on `VecDeque`.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2153072603",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGZjZGQzNTdkZjg5YWE4NjM5YjdmN2UyYmI1MzdiZDJmMDc5ZGYzYjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "tree": {
        "sha": "361d4faff89d8525bcd15f6bde00f5b9e36f7ac8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/361d4faff89d8525bcd15f6bde00f5b9e36f7ac8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/32d15901abb701da707761bbd3ab60aa956bebb5",
          "sha": "32d15901abb701da707761bbd3ab60aa956bebb5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/32d15901abb701da707761bbd3ab60aa956bebb5"
        }
      ],
      "message": "tests: add fuzz tests for VecDeque",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-06T17:44:39Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-23T17:03:39Z"
      },
      "sha": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13070279762,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMLDKRS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13070279762",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T17:44:51Z"
    },
    {
      "event": "labeled",
      "id": 13070280442,
      "node_id": "LE_lADOABII586J5NBmzwAAAAMLDKb6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13070280442",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T17:44:55Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2153078101,
      "node_id": "IC_kwDOABII586AVV1V",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2153078101",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T17:44:56Z",
      "updated_at": "2024-06-06T17:44:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\nðŸš§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25906521916</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2153078101",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613576870",
      "pull_request_review_id": 2077094091,
      "id": 1613576870,
      "node_id": "PRRC_kwDOABII585gLTqm",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 58,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: Seems like this would be easier?\r\n```suggestion\r\n        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\r\n```",
      "created_at": "2024-05-24T14:31:17Z",
      "updated_at": "2024-05-24T16:46:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613576870",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613576870"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613595996",
      "pull_request_review_id": 2077094091,
      "id": 1613595996,
      "node_id": "PRRC_kwDOABII585gLYVc",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 61,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        // Pick one operation based on value of command. Not all operations are always applicable.\r\n        // Loop through the applicable ones until command reaches 0 (avoids the need to compute\r\n        // the number of applicable commands ahead of time).\r\n```",
      "created_at": "2024-05-24T14:44:12Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613595996",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613595996"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613608895",
      "pull_request_review_id": 2077153695,
      "id": 1613608895,
      "node_id": "PRRC_kwDOABII585gLbe_",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    inline size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 34,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\r\n```\r\n\r\nstyle-nit: I think `inline` can be dropped, according to https://en.cppreference.com/w/cpp/language/inline\r\n\r\n> A function defined entirely inside a [class/struct/union definition](https://en.cppreference.com/w/cpp/language/classes), whether it's a member function or a non-member friend function, is implicitly an inline function [...]\r\n\r\n",
      "created_at": "2024-05-24T14:52:59Z",
      "updated_at": "2024-05-24T14:53:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613608895",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613608895"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613637296",
      "pull_request_review_id": 2077094091,
      "id": 1613637296,
      "node_id": "PRRC_kwDOABII585gLiaw",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 63,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There's an assumption that at least one of the operations is applicable every time. Pretty obviously true but I assigned variables to all the possible conditions while reviewing and used it to add an assertion. Might be easier to read so I figured I'd leave a comment.\r\n```suggestion\r\n        const bool non_empty{num_buffers != 0};\r\n        const bool non_full{num_buffers < MAX_BUFFERS};\r\n        const bool partially_full{num_buffers > 0 && num_buffers < MAX_BUFFERS};\r\n        const bool multiple_exist{num_buffers > 1};\r\n        const bool existing_buffer_nonfull{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\r\n        const bool existing_buffer_nonempty{non_empty && !sim[idx].empty()};\r\n        assert(non_full || non_empty || partially_full);\r\n        \r\n        while (true) {\r\n```",
      "created_at": "2024-05-24T15:13:13Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613637296",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613637296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613660947",
      "pull_request_review_id": 2077094091,
      "id": 1613660947,
      "node_id": "PRRC_kwDOABII585gLoMT",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 305,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    // Create entry for this object in g_tracker and populate m_track_entry\r\n    void Register()\r\n```",
      "created_at": "2024-05-24T15:31:26Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613660947",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613660947"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 313,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613661502",
      "pull_request_review_id": 2077094091,
      "id": 1613661502,
      "node_id": "PRRC_kwDOABII585gLoU-",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 324,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    // Get value corresponding to this object in g_tracker\r\n    std::optional<uint64_t>& Deref()\r\n```",
      "created_at": "2024-05-24T15:31:47Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613661502",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613661502"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613663028",
      "pull_request_review_id": 2077094091,
      "id": 1613663028,
      "node_id": "PRRC_kwDOABII585gLos0",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }\n+\n+    TrackedObj& operator=(TrackedObj&& other)\n+    {\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+        return *this;\n+    }\n+\n+    friend bool operator==(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        return a.Deref() == b.Deref();\n+    }\n+\n+    friend std::strong_ordering operator<=>(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        // Libc++ 15 & 16 do not support std::optional<T>::operator<=> yet. See\n+        // https://reviews.llvm.org/D146392.\n+        if (!a.Deref().has_value() || !b.Deref().has_value()) {\n+            return a.Deref().has_value() <=> b.Deref().has_value();\n+        }\n+        return *a.Deref() <=> *b.Deref();\n+    }\n+\n+    static void CheckNoneExist()\n+    {\n+        assert(g_tracker.empty());\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(ringbuffer)\n+{\n+    // Run the test with simple uints (which are std::is_trivially_copyable_v).\n+    TestType<uint8_t, false>(buffer, 1);\n+    TestType<uint16_t, false>(buffer, 2);\n+    TestType<uint32_t, false>(buffer, 3);\n+    TestType<uint64_t, false>(buffer, 4);\n+    // Run the test with TrackedObjs (which are not).",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 404,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`static_assert(!std::is_trivially_copyable_v<TrackedObj<1>>)` ?",
      "created_at": "2024-05-24T15:32:32Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613663028",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613663028"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 404,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674426",
      "pull_request_review_id": 2077266898,
      "id": 1613674426,
      "node_id": "PRRC_kwDOABII585gLre6",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    inline size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 34,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613608895,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.\r\n\r\n`inline` does have an effect beyond making it an inline function (in GCC and Clang it increases the eagerness of the compiler to actually inline the function), but that's the sort of optimization one should only do guided by benchmarks, which I haven't done, so I dropped the `inline` here.",
      "created_at": "2024-05-24T15:37:14Z",
      "updated_at": "2024-05-24T15:37:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613674426",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674426"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613702058",
      "pull_request_review_id": 2077094091,
      "id": 1613702058,
      "node_id": "PRRC_kwDOABII585gLyOq",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 23,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I was slightly confused that this was called `RingBuffer` since the data structure itself doesn't act like a ring buffer i.e. will reallocate if adding items beyond capacity (I wrote `vExtraTxnForCompact` to use it before looking at the implementation and then realized I misunderstood the interface). But I now have read that `m_buffer` is the ring buffer - oops.",
      "created_at": "2024-05-24T15:57:09Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613702058",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613702058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613746327",
      "pull_request_review_id": 2077390047,
      "id": 1613746327,
      "node_id": "PRRC_kwDOABII585gL9CX",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 23,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "in_reply_to_id": 1613702058,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hmm, this is a good point. The `RingBuffer` class' interface isn't a ring buffer, but a deque; the implementation happens to use a ring buffer. Suggestions/bikeshedding for a better name welcome.",
      "created_at": "2024-05-24T16:33:21Z",
      "updated_at": "2024-05-24T16:33:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613746327",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613746327"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613757739",
      "pull_request_review_id": 2077411055,
      "id": 1613757739,
      "node_id": "PRRC_kwDOABII585gL_0r",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 58,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613576870,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"Integral in Rage\" sounds like a high-school metal band.",
      "created_at": "2024-05-24T16:42:55Z",
      "updated_at": "2024-05-24T16:42:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613757739",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613757739"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785731",
      "pull_request_review_id": 2077454937,
      "id": 1613785731,
      "node_id": "PRRC_kwDOABII585gMGqD",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 58,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613576870,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T17:08:34Z",
      "updated_at": "2024-05-24T17:08:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785731",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785818",
      "pull_request_review_id": 2077455089,
      "id": 1613785818,
      "node_id": "PRRC_kwDOABII585gMGra",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 61,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613595996,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T17:08:40Z",
      "updated_at": "2024-05-24T17:08:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785818",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785818"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785897",
      "pull_request_review_id": 2077455207,
      "id": 1613785897,
      "node_id": "PRRC_kwDOABII585gMGsp",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 63,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613637296,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T17:08:45Z",
      "updated_at": "2024-05-24T17:08:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785897",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785897"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785977",
      "pull_request_review_id": 2077455350,
      "id": 1613785977,
      "node_id": "PRRC_kwDOABII585gMGt5",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 324,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613661502,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T17:08:52Z",
      "updated_at": "2024-05-24T17:08:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785977",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785977"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786034",
      "pull_request_review_id": 2077455436,
      "id": 1613786034,
      "node_id": "PRRC_kwDOABII585gMGuy",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 23,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "in_reply_to_id": 1613702058,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In Rust they call it [`VecDeque`](https://doc.rust-lang.org/std/collections/struct.VecDeque.html), maybe that's a naming option? (It even rhymes!)",
      "created_at": "2024-05-24T17:08:55Z",
      "updated_at": "2024-05-24T17:08:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786034",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786034"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786106",
      "pull_request_review_id": 2077455546,
      "id": 1613786106,
      "node_id": "PRRC_kwDOABII585gMGv6",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 305,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613660947,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T17:09:00Z",
      "updated_at": "2024-05-24T17:09:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786106",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786106"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 313,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786217",
      "pull_request_review_id": 2077455736,
      "id": 1613786217,
      "node_id": "PRRC_kwDOABII585gMGxp",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }\n+\n+    TrackedObj& operator=(TrackedObj&& other)\n+    {\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+        return *this;\n+    }\n+\n+    friend bool operator==(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        return a.Deref() == b.Deref();\n+    }\n+\n+    friend std::strong_ordering operator<=>(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        // Libc++ 15 & 16 do not support std::optional<T>::operator<=> yet. See\n+        // https://reviews.llvm.org/D146392.\n+        if (!a.Deref().has_value() || !b.Deref().has_value()) {\n+            return a.Deref().has_value() <=> b.Deref().has_value();\n+        }\n+        return *a.Deref() <=> *b.Deref();\n+    }\n+\n+    static void CheckNoneExist()\n+    {\n+        assert(g_tracker.empty());\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(ringbuffer)\n+{\n+    // Run the test with simple uints (which are std::is_trivially_copyable_v).\n+    TestType<uint8_t, false>(buffer, 1);\n+    TestType<uint16_t, false>(buffer, 2);\n+    TestType<uint32_t, false>(buffer, 3);\n+    TestType<uint64_t, false>(buffer, 4);\n+    // Run the test with TrackedObjs (which are not).",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 404,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613663028,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done (and more).",
      "created_at": "2024-05-24T17:09:08Z",
      "updated_at": "2024-05-24T17:09:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786217",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786217"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 404,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613810244",
      "pull_request_review_id": 2077498512,
      "id": 1613810244,
      "node_id": "PRRC_kwDOABII585gMMpE",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 23,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "in_reply_to_id": 1613702058,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Renamed!",
      "created_at": "2024-05-24T17:32:13Z",
      "updated_at": "2024-05-24T17:32:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613810244",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613810244"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613915882",
      "pull_request_review_id": 2077678840,
      "id": 1613915882,
      "node_id": "PRRC_kwDOABII585gMmbq",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "path": "src/util/vecdeque.h",
      "position": 183,
      "original_position": 171,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could do (i think 3?) memcmp here if `is_trivially_copyable_v`, but maybe it's not worth the complexity of differing offsets.",
      "created_at": "2024-05-24T19:17:04Z",
      "updated_at": "2024-05-24T19:17:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613915882",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613915882"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 183,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613922119",
      "pull_request_review_id": 2077689045,
      "id": 1613922119,
      "node_id": "PRRC_kwDOABII585gMn9H",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "path": "src/util/vecdeque.h",
      "position": 183,
      "original_position": 171,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "in_reply_to_id": 1613915882,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Trivially copyable does not imply a trivial `operator!=`, I think.",
      "created_at": "2024-05-24T19:19:53Z",
      "updated_at": "2024-05-24T19:22:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613922119",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613922119"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 183,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613925002",
      "pull_request_review_id": 2077694876,
      "id": 1613925002,
      "node_id": "PRRC_kwDOABII585gMoqK",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "path": "src/util/vecdeque.h",
      "position": 183,
      "original_position": 171,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "in_reply_to_id": 1613915882,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "From https://en.cppreference.com/w/cpp/types/is_trivially_copyable:\r\n\"Objects of trivially-copyable types that are not potentially-overlapping subobjects are the only C++ objects that may be safely copied with [std::memcpy](https://en.cppreference.com/w/cpp/string/byte/memcpy) or serialized to/from binary files with [std::ofstream::write()](https://en.cppreference.com/w/cpp/io/basic_ostream/write) / [std::ifstream::read()](https://en.cppreference.com/w/cpp/io/basic_istream/read).\"\r\n\r\nI assume anything that can be memcpy'd can be memcmp'd.",
      "created_at": "2024-05-24T19:22:58Z",
      "updated_at": "2024-05-24T19:23:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613925002",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613925002"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 183,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613941027",
      "pull_request_review_id": 2077727864,
      "id": 1613941027,
      "node_id": "PRRC_kwDOABII585gMskj",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "path": "src/util/vecdeque.h",
      "position": 183,
      "original_position": 171,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "in_reply_to_id": 1613915882,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I certainly see why it's reasonable why trivial types would have a trivial comparison operator, but there is no guarantee for that. I think you can have a trivially-constructible type with an complex `operator==` (for such a type you'd expect that something that was memcpy'd you end up with a result that satisfies ==, but I don't think that's required, and it also doesn't work the other way around: objects could satisfy == without being bitwise identical).",
      "created_at": "2024-05-24T19:31:04Z",
      "updated_at": "2024-05-24T19:31:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613941027",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613941027"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 183,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613943540",
      "pull_request_review_id": 2077737706,
      "id": 1613943540,
      "node_id": "PRRC_kwDOABII585gMtL0",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "path": "src/util/vecdeque.h",
      "position": 183,
      "original_position": 171,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "in_reply_to_id": 1613915882,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ok, yeah, agreed.",
      "created_at": "2024-05-24T19:34:39Z",
      "updated_at": "2024-05-24T19:34:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613943540",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613943540"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 183,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614029973",
      "pull_request_review_id": 2078066616,
      "id": 1614029973,
      "node_id": "PRRC_kwDOABII585gNCSV",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "path": "src/util/vecdeque.h",
      "position": 183,
      "original_position": 171,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "in_reply_to_id": 1613915882,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Just adding for posterity because I went down a rabbit hole for this:\r\n\r\nIt seems clang's `__is_trivially_equality_comparable` builtin would do what we want here:\r\n> Returns true if comparing two objects of the provided type is known to be equivalent to comparing their object representations. Note that types containing padding bytes are never trivially equality comparable.\r\n\r\n[From libc++](https://github.com/llvm/llvm-project/blob/main/libcxx/include/__type_traits/is_equality_comparable.h#L36C1-L37C41):\r\n```c++\r\n// A type is_trivially_equality_comparable if the expression `a == b` is equivalent to `std::memcmp(&a, &b, sizeof(T))`\r\n// (with `a` and `b` being of type `T`).\r\n```\r\nNot that it's worth using here.",
      "created_at": "2024-05-24T21:14:50Z",
      "updated_at": "2024-05-24T22:11:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1614029973",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614029973"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 183,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614066880",
      "pull_request_review_id": 2078108333,
      "id": 1614066880,
      "node_id": "PRRC_kwDOABII585gNLTA",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "path": "src/util/vecdeque.h",
      "position": 183,
      "original_position": 171,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "in_reply_to_id": 1613915882,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Interesting!",
      "created_at": "2024-05-24T21:56:18Z",
      "updated_at": "2024-05-24T21:56:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1614066880",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614066880"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 183,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616905695",
      "pull_request_review_id": 2082248884,
      "id": 1616905695,
      "node_id": "PRRC_kwDOABII585gYAXf",
      "diff_hunk": "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 29,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "in_reply_to_id": null,
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: \r\n```suggestion\r\n    /** Number of objects in the container. m_size <= m_capacity. */\r\n```",
      "created_at": "2024-05-28T09:30:29Z",
      "updated_at": "2024-05-28T09:30:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616905695",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616905695"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616940538",
      "pull_request_review_id": 2082303692,
      "id": 1616940538,
      "node_id": "PRRC_kwDOABII585gYI36",
      "diff_hunk": "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 39,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "in_reply_to_id": null,
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What is the purpose of this line here? It doesn't look like a pre-condition for the function arguments. It seems it should be used as a post-condition for `m_capacity` mutators (including this function) and `m_offset` mutators, no?",
      "created_at": "2024-05-28T09:55:18Z",
      "updated_at": "2024-05-28T09:55:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616940538",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616940538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616978938",
      "pull_request_review_id": 2082368339,
      "id": 1616978938,
      "node_id": "PRRC_kwDOABII585gYSP6",
      "diff_hunk": "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 57,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "in_reply_to_id": null,
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Does it make sense to skip this call if `std::is_trivially_destructible_v<T>`?",
      "created_at": "2024-05-28T10:24:31Z",
      "updated_at": "2024-05-28T10:24:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616978938",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616978938"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616992405",
      "pull_request_review_id": 2082390454,
      "id": 1616992405,
      "node_id": "PRRC_kwDOABII585gYViV",
      "diff_hunk": "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at<T>(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 117,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "in_reply_to_id": null,
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Both functions `clear()` and `ResizeDown()` could be declared `noexcept`.",
      "created_at": "2024-05-28T10:33:37Z",
      "updated_at": "2024-05-28T10:33:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1616992405",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1616992405"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617005071",
      "pull_request_review_id": 2082411034,
      "id": 1617005071,
      "node_id": "PRRC_kwDOABII585gYYoP",
      "diff_hunk": "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at<T>(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);",
      "path": "src/util/vecdeque.h",
      "position": 136,
      "original_position": 128,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "in_reply_to_id": null,
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The move assignment operator preserves the capacity. Maybe do the same here for consistency?",
      "created_at": "2024-05-28T10:44:18Z",
      "updated_at": "2024-05-28T10:44:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617005071",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617005071"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 136,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617126230",
      "pull_request_review_id": 2076000498,
      "id": 1617126230,
      "node_id": "PRRC_kwDOABII585gY2NW",
      "diff_hunk": "@@ -0,0 +1,423 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on VecDeque type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<VecDeque<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const VecDeque<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        int command = provider.ConsumeIntegral<uint8_t>() % 32;\n+        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\n+        const size_t num_buffers = sim.size();\n+        // Pick one operation based on value of command. Not all operations are always applicable.\n+        // Loop through the applicable ones until command reaches 0 (which avoids the need to\n+        // compute the number of applicable commands ahead of time).\n+        const bool non_empty{num_buffers != 0};\n+        const bool non_full{num_buffers < MAX_BUFFERS};\n+        const bool partially_full{non_empty && non_full};\n+        const bool multiple_exist{num_buffers > 1};\n+        const bool existing_buffer_non_full{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\n+        const bool existing_buffer_non_empty{non_empty && !sim[idx].empty()};\n+        assert(non_full || non_empty);\n+        while (true) {\n+            if (non_full && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = VecDeque<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Move construct. */\n+                VecDeque<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % num_buffers]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Move assign. */\n+                VecDeque<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const VecDeque<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    /** Create entry for this object in g_tracker and populate m_track_entry. */\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    /** Get value corresponding to this object in g_tracker. */\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    /** Get value corresponding to this object in g_tracker. */\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }\n+\n+    TrackedObj& operator=(TrackedObj&& other)\n+    {\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+        return *this;\n+    }\n+\n+    friend bool operator==(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        return a.Deref() == b.Deref();\n+    }\n+\n+    friend std::strong_ordering operator<=>(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        // Libc++ 15 & 16 do not support std::optional<T>::operator<=> yet. See\n+        // https://reviews.llvm.org/D146392.\n+        if (!a.Deref().has_value() || !b.Deref().has_value()) {\n+            return a.Deref().has_value() <=> b.Deref().has_value();\n+        }\n+        return *a.Deref() <=> *b.Deref();\n+    }\n+\n+    static void CheckNoneExist()\n+    {\n+        assert(g_tracker.empty());\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(ringbuffer)",
      "path": "src/test/fuzz/vecdeque.cpp",
      "position": null,
      "original_position": 407,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "in_reply_to_id": null,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "*`FUZZ_TARGET(vecdeque)`",
      "created_at": "2024-05-28T12:06:33Z",
      "updated_at": "2024-05-28T12:19:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617126230",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617126230"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 407,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617135964",
      "pull_request_review_id": 2076000498,
      "id": 1617135964,
      "node_id": "PRRC_kwDOABII585gY4lc",
      "diff_hunk": "@@ -0,0 +1,423 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <iostream>",
      "path": "src/test/fuzz/vecdeque.cpp",
      "position": null,
      "original_position": 10,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "in_reply_to_id": null,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Appears to be unused? Compiled without it on Clang.",
      "created_at": "2024-05-28T12:13:23Z",
      "updated_at": "2024-05-28T12:19:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617135964",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617135964"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 10,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617187166",
      "pull_request_review_id": 2082693918,
      "id": 1617187166,
      "node_id": "PRRC_kwDOABII585gZFFe",
      "diff_hunk": "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 29,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "in_reply_to_id": 1616905695,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-05-28T12:48:01Z",
      "updated_at": "2024-05-28T12:48:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617187166",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617187166"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617189498",
      "pull_request_review_id": 2082697686,
      "id": 1617189498,
      "node_id": "PRRC_kwDOABII585gZFp6",
      "diff_hunk": "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 39,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "in_reply_to_id": 1616940538,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's an invariant, but it was poorly described, which I've hopefully addressed now (see `m_offset` docstring).",
      "created_at": "2024-05-28T12:49:35Z",
      "updated_at": "2024-05-28T12:49:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617189498",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617189498"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190116",
      "pull_request_review_id": 2082698640,
      "id": 1617190116,
      "node_id": "PRRC_kwDOABII585gZFzk",
      "diff_hunk": "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 57,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "in_reply_to_id": 1616978938,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think so, since that case doesn't let us avoid the loop.",
      "created_at": "2024-05-28T12:50:01Z",
      "updated_at": "2024-05-28T12:50:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617190116",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190282",
      "pull_request_review_id": 2082698943,
      "id": 1617190282,
      "node_id": "PRRC_kwDOABII585gZF2K",
      "diff_hunk": "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at<T>(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 117,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "in_reply_to_id": 1616992405,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch, done.",
      "created_at": "2024-05-28T12:50:08Z",
      "updated_at": "2024-05-28T12:50:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617190282",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190282"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617193263",
      "pull_request_review_id": 2082703737,
      "id": 1617193263,
      "node_id": "PRRC_kwDOABII585gZGkv",
      "diff_hunk": "@@ -0,0 +1,252 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at<T>(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);",
      "path": "src/util/vecdeque.h",
      "position": 136,
      "original_position": 128,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "in_reply_to_id": 1617005071,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it's better to match `std::vector` behavior here (technically, spec doesn't say anything about the capacity of a copied element, but common implementations make it just big enough to hold the copied data, I believe).",
      "created_at": "2024-05-28T12:52:12Z",
      "updated_at": "2024-05-28T12:52:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617193263",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617193263"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 136,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617193395",
      "pull_request_review_id": 2082703918,
      "id": 1617193395,
      "node_id": "PRRC_kwDOABII585gZGmz",
      "diff_hunk": "@@ -0,0 +1,423 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on VecDeque type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<VecDeque<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const VecDeque<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        int command = provider.ConsumeIntegral<uint8_t>() % 32;\n+        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\n+        const size_t num_buffers = sim.size();\n+        // Pick one operation based on value of command. Not all operations are always applicable.\n+        // Loop through the applicable ones until command reaches 0 (which avoids the need to\n+        // compute the number of applicable commands ahead of time).\n+        const bool non_empty{num_buffers != 0};\n+        const bool non_full{num_buffers < MAX_BUFFERS};\n+        const bool partially_full{non_empty && non_full};\n+        const bool multiple_exist{num_buffers > 1};\n+        const bool existing_buffer_non_full{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\n+        const bool existing_buffer_non_empty{non_empty && !sim[idx].empty()};\n+        assert(non_full || non_empty);\n+        while (true) {\n+            if (non_full && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = VecDeque<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Move construct. */\n+                VecDeque<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % num_buffers]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Move assign. */\n+                VecDeque<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const VecDeque<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    /** Create entry for this object in g_tracker and populate m_track_entry. */\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    /** Get value corresponding to this object in g_tracker. */\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    /** Get value corresponding to this object in g_tracker. */\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }\n+\n+    TrackedObj& operator=(TrackedObj&& other)\n+    {\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+        return *this;\n+    }\n+\n+    friend bool operator==(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        return a.Deref() == b.Deref();\n+    }\n+\n+    friend std::strong_ordering operator<=>(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        // Libc++ 15 & 16 do not support std::optional<T>::operator<=> yet. See\n+        // https://reviews.llvm.org/D146392.\n+        if (!a.Deref().has_value() || !b.Deref().has_value()) {\n+            return a.Deref().has_value() <=> b.Deref().has_value();\n+        }\n+        return *a.Deref() <=> *b.Deref();\n+    }\n+\n+    static void CheckNoneExist()\n+    {\n+        assert(g_tracker.empty());\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(ringbuffer)",
      "path": "src/test/fuzz/vecdeque.cpp",
      "position": null,
      "original_position": 407,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "in_reply_to_id": 1617126230,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-05-28T12:52:18Z",
      "updated_at": "2024-05-28T12:52:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617193395",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617193395"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 407,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617197710",
      "pull_request_review_id": 2082710679,
      "id": 1617197710,
      "node_id": "PRRC_kwDOABII585gZHqO",
      "diff_hunk": "@@ -0,0 +1,423 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <iostream>",
      "path": "src/test/fuzz/vecdeque.cpp",
      "position": null,
      "original_position": 10,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "in_reply_to_id": 1617135964,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed!",
      "created_at": "2024-05-28T12:55:11Z",
      "updated_at": "2024-05-28T12:55:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1617197710",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617197710"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 10,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619032750",
      "pull_request_review_id": 2085655168,
      "id": 1619032750,
      "node_id": "PRRC_kwDOABII585ggHqu",
      "diff_hunk": "@@ -0,0 +1,254 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at<T>(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);\n+    }\n+\n+    template<typename U>\n+    void push_back(U&& elem)",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 192,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "in_reply_to_id": null,
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Using this approach instead of two distinct signatures -- `void push_back(const T&)` and `void push_back(T&&)`  -- can lead to some confusion in error messages.\r\n\r\nConsider this:\r\n```c++\r\nstruct A { int m_a{0}; } a;\r\nstruct B { int m_b{0}; } b;\r\n\r\nstd::vector<A> v;\r\nv.push_back(a);\r\n// ERROR:\r\n// no known conversion for argument 1 from â€˜Bâ€™ to â€˜const std::vector<A>::value_type&â€™ {aka â€˜const A&â€™}\r\n// no known conversion for argument 1 from â€˜Bâ€™ to â€˜std::vector<A>::value_type&&â€™ {aka â€˜A&&â€™}\r\n// v.push_back(b);  \r\n\r\n\r\nVecDeque<A> vd;\r\nvd.push_back(a);\r\n// ERROR:\r\n// cannot convert â€˜Bâ€™ to â€˜intâ€™ in initialization\r\n// vd.push_back(b);\r\n```",
      "created_at": "2024-05-29T14:50:16Z",
      "updated_at": "2024-05-29T14:50:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1619032750",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619032750"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": 191,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619089090",
      "pull_request_review_id": 2085746802,
      "id": 1619089090,
      "node_id": "PRRC_kwDOABII585ggVbC",
      "diff_hunk": "@@ -0,0 +1,254 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at<T>(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);\n+    }\n+\n+    template<typename U>\n+    void push_back(U&& elem)",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 192,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "in_reply_to_id": 1619032750,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Your code here doesn't use `B` anywhere, so I suspect the comments don't match the code.",
      "created_at": "2024-05-29T15:26:12Z",
      "updated_at": "2024-05-29T15:26:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1619089090",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619089090"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": 191,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619408564",
      "pull_request_review_id": 2086286791,
      "id": 1619408564,
      "node_id": "PRRC_kwDOABII585ghja0",
      "diff_hunk": "@@ -0,0 +1,254 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at<T>(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);\n+    }\n+\n+    template<typename U>\n+    void push_back(U&& elem)",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 192,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "03cfb8673669edaf275e382e4a0a83d6a377c259",
      "in_reply_to_id": 1619032750,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think I understand though; the argument to `push_back` or `push_front` should not be inferred but be fixed to be (a reference to) `T`. Done.",
      "created_at": "2024-05-29T19:58:38Z",
      "updated_at": "2024-05-29T19:58:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1619408564",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619408564"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": 191,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620728482",
      "pull_request_review_id": 2088303122,
      "id": 1620728482,
      "node_id": "PRRC_kwDOABII585gmlqi",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);\n+    }\n+\n+    void push_back(T&& elem)\n+    {\n+        if (m_size == m_capacity) Reallocate((m_size + 1) * 2);\n+        std::construct_at(m_buffer + Index(m_size), std::move(elem));\n+        ++m_size;\n+    }\n+\n+    void push_back(const T& elem)\n+    {\n+        if (m_size == m_capacity) Reallocate((m_size + 1) * 2);\n+        std::construct_at(m_buffer + Index(m_size), std::move(elem));\n+        ++m_size;\n+    }",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 203,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "a5a27bae11e14743c08812307cedc9dfb47efebf",
      "in_reply_to_id": null,
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Does `std::move(const T&)` make sense here? The `std::construct_at` won't be able to modify `elem` due to its `const`ness, right?",
      "created_at": "2024-05-30T13:32:54Z",
      "updated_at": "2024-05-30T13:36:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620728482",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620728482"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": 198,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620771700",
      "pull_request_review_id": 2088359274,
      "id": 1620771700,
      "node_id": "PRRC_kwDOABII585gmwN0",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);\n+    }\n+\n+    void push_back(T&& elem)\n+    {\n+        if (m_size == m_capacity) Reallocate((m_size + 1) * 2);\n+        std::construct_at(m_buffer + Index(m_size), std::move(elem));\n+        ++m_size;\n+    }\n+\n+    void push_back(const T& elem)\n+    {\n+        if (m_size == m_capacity) Reallocate((m_size + 1) * 2);\n+        std::construct_at(m_buffer + Index(m_size), std::move(elem));\n+        ++m_size;\n+    }",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 203,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "a5a27bae11e14743c08812307cedc9dfb47efebf",
      "in_reply_to_id": 1620728482,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That depends on `T`'s move constructor. Typically, this won't do anything, but it's not impossible for a `T::T(const T&&)` constructor to exist (and this may make sense if `T` has `mutable` member variables).",
      "created_at": "2024-05-30T13:55:48Z",
      "updated_at": "2024-05-30T13:55:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620771700",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620771700"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": 198,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620773911",
      "pull_request_review_id": 2088362062,
      "id": 1620773911,
      "node_id": "PRRC_kwDOABII585gmwwX",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);\n+    }\n+\n+    void push_back(T&& elem)\n+    {\n+        if (m_size == m_capacity) Reallocate((m_size + 1) * 2);\n+        std::construct_at(m_buffer + Index(m_size), std::move(elem));\n+        ++m_size;\n+    }\n+\n+    void push_back(const T& elem)\n+    {\n+        if (m_size == m_capacity) Reallocate((m_size + 1) * 2);\n+        std::construct_at(m_buffer + Index(m_size), std::move(elem));\n+        ++m_size;\n+    }",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 203,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "a5a27bae11e14743c08812307cedc9dfb47efebf",
      "in_reply_to_id": 1620728482,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Actually, no, you're right. Even if this does anything, it won't be the desired behavior. Will remove.",
      "created_at": "2024-05-30T13:56:58Z",
      "updated_at": "2024-05-30T13:56:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620773911",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620773911"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": 198,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620955671",
      "pull_request_review_id": 2088628907,
      "id": 1620955671,
      "node_id": "PRRC_kwDOABII585gndIX",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);",
      "path": "src/util/vecdeque.h",
      "position": 210,
      "original_position": 188,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's a shame that this triggers a reallocation when `m_offset == 0`. Might it be worth optimizing for that case?",
      "created_at": "2024-05-30T15:27:28Z",
      "updated_at": "2024-05-30T15:27:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620955671",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620955671"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 210,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620982315",
      "pull_request_review_id": 2088687850,
      "id": 1620982315,
      "node_id": "PRRC_kwDOABII585gnjor",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);",
      "path": "src/util/vecdeque.h",
      "position": 210,
      "original_position": 188,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "in_reply_to_id": 1620955671,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Actually, same comment for `operator=` as well. Maybe it'd be worth a special case in `Reallocate()` itself instead.",
      "created_at": "2024-05-30T15:41:13Z",
      "updated_at": "2024-05-30T15:41:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620982315",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620982315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 210,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620986696",
      "pull_request_review_id": 2088698131,
      "id": 1620986696,
      "node_id": "PRRC_kwDOABII585gnktI",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);",
      "path": "src/util/vecdeque.h",
      "position": 210,
      "original_position": 188,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "in_reply_to_id": 1620955671,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Are you imagining something like `realloc` on the buffer? AFAIK that just doesn't exist in C++; if you want to shrink an object, you need to construct a new object of smaller size and copy over.",
      "created_at": "2024-05-30T15:44:15Z",
      "updated_at": "2024-05-30T15:44:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1620986696",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620986696"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 210,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1621023146",
      "pull_request_review_id": 2088752200,
      "id": 1621023146,
      "node_id": "PRRC_kwDOABII585gntmq",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;\n+        for (size_t i = 0; i < a.m_size; ++i) {\n+            if (a[i] != b[i]) return false;\n+        }\n+        return true;\n+    }\n+\n+    std::strong_ordering friend operator<=>(const VecDeque& a, const VecDeque& b)\n+    {\n+        size_t pos_a{0}, pos_b{0};\n+        while (pos_a < a.m_size && pos_b < b.m_size) {\n+            auto cmp = a[pos_a++] <=> b[pos_b++];\n+            if (cmp != 0) return cmp;\n+        }\n+        return a.m_size <=> b.m_size;\n+    }\n+\n+    void reserve(size_t capacity)\n+    {\n+        if (capacity > m_capacity) Reallocate(capacity);\n+    }\n+\n+    void shrink_to_fit()\n+    {\n+        if (m_capacity > m_size) Reallocate(m_size);",
      "path": "src/util/vecdeque.h",
      "position": 210,
      "original_position": 188,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "in_reply_to_id": 1620955671,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Grr, right.",
      "created_at": "2024-05-30T16:08:29Z",
      "updated_at": "2024-05-30T16:08:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1621023146",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1621023146"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 210,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626177967",
      "pull_request_review_id": 2096682721,
      "id": 1626177967,
      "node_id": "PRRC_kwDOABII585g7YGv",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 27,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "you can ignore this if you don't like it\r\n```Suggestion\r\n    /** m_buffer + m_offset points to first object in queue. m_offset = 0 if m_capacity is 0; otherwise\r\n```",
      "created_at": "2024-06-04T15:00:56Z",
      "updated_at": "2024-06-04T19:31:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626177967",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626177967"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626291871",
      "pull_request_review_id": 2096682721,
      "id": 1626291871,
      "node_id": "PRRC_kwDOABII585g7z6f",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 73,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`s/Index/BufferIndex/` reduces my mental load fwiw",
      "created_at": "2024-06-04T16:19:06Z",
      "updated_at": "2024-06-04T19:31:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626291871",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626291871"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626321220",
      "pull_request_review_id": 2096682721,
      "id": 1626321220,
      "node_id": "PRRC_kwDOABII585g77FE",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on VecDeque type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<VecDeque<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const VecDeque<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        int command = provider.ConsumeIntegral<uint8_t>() % 32;\n+        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\n+        const size_t num_buffers = sim.size();\n+        // Pick one operation based on value of command. Not all operations are always applicable.\n+        // Loop through the applicable ones until command reaches 0 (which avoids the need to\n+        // compute the number of applicable commands ahead of time).\n+        const bool non_empty{num_buffers != 0};\n+        const bool non_full{num_buffers < MAX_BUFFERS};\n+        const bool partially_full{non_empty && non_full};\n+        const bool multiple_exist{num_buffers > 1};\n+        const bool existing_buffer_non_full{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\n+        const bool existing_buffer_non_empty{non_empty && !sim[idx].empty()};\n+        assert(non_full || non_empty);\n+        while (true) {\n+            if (non_full && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = VecDeque<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Move construct. */\n+                VecDeque<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % num_buffers]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Move assign. */\n+                VecDeque<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);",
      "path": "src/test/fuzz/vecdeque.cpp",
      "position": null,
      "original_position": 165,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "ecb278bb19c53b007380e262fa86d809255eeb49",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Putting bounds on the capacity growth seems useful here and a few other spots, even if it doesn't necessarily have to be this tight.\r\n```\r\n                if (old_cap > old_size) {\r\n                    assert(real[idx].capacity() == old_cap);\r\n                } else {\r\n                    assert(real[idx].capacity() > old_cap);\r\n                    assert(real[idx].capacity() <= 2 * (old_cap + 1));\r\n                }\r\n```",
      "created_at": "2024-06-04T16:43:42Z",
      "updated_at": "2024-06-04T19:31:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626321220",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626321220"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 180,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626341902",
      "pull_request_review_id": 2096682721,
      "id": 1626341902,
      "node_id": "PRRC_kwDOABII585g8AIO",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on VecDeque type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<VecDeque<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const VecDeque<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        int command = provider.ConsumeIntegral<uint8_t>() % 32;\n+        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\n+        const size_t num_buffers = sim.size();\n+        // Pick one operation based on value of command. Not all operations are always applicable.\n+        // Loop through the applicable ones until command reaches 0 (which avoids the need to\n+        // compute the number of applicable commands ahead of time).\n+        const bool non_empty{num_buffers != 0};\n+        const bool non_full{num_buffers < MAX_BUFFERS};\n+        const bool partially_full{non_empty && non_full};\n+        const bool multiple_exist{num_buffers > 1};\n+        const bool existing_buffer_non_full{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\n+        const bool existing_buffer_non_empty{non_empty && !sim[idx].empty()};\n+        assert(non_full || non_empty);\n+        while (true) {\n+            if (non_full && command-- == 0) {",
      "path": "src/test/fuzz/vecdeque.cpp",
      "position": 70,
      "original_position": 70,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "ecb278bb19c53b007380e262fa86d809255eeb49",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Calling `compare_fn` here seems more complete than picking and choosing when to call it before the final check\r\n```Suggestion\r\n            if (!real.empty()) compare_fn(real[idx], sim[idx]);\r\n            if (non_full && command-- == 0) {\r\n```",
      "created_at": "2024-06-04T17:01:04Z",
      "updated_at": "2024-06-04T19:31:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626341902",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626341902"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 70,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626387016",
      "pull_request_review_id": 2096682721,
      "id": 1626387016,
      "node_id": "PRRC_kwDOABII585g8LJI",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }",
      "path": "src/util/vecdeque.h",
      "position": 36,
      "original_position": 35,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "gave an attempt\r\n```Suggestion\r\n    /** Returns the number of populated objects from m_offset to end of allocated memory. */\r\n    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\r\n```",
      "created_at": "2024-06-04T17:35:42Z",
      "updated_at": "2024-06-04T19:31:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626387016",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626387016"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 36,
      "original_line": 36,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626395824",
      "pull_request_review_id": 2096682721,
      "id": 1626395824,
      "node_id": "PRRC_kwDOABII585g8NSw",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {",
      "path": "src/util/vecdeque.h",
      "position": 48,
      "original_position": 47,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "double checking: `first_part == 0` implies `m_size == 0`?",
      "created_at": "2024-06-04T17:42:07Z",
      "updated_at": "2024-06-04T19:31:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626395824",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626395824"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 48,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626448996",
      "pull_request_review_id": 2096682721,
      "id": 1626448996,
      "node_id": "PRRC_kwDOABII585g8aRk",
      "diff_hunk": "@@ -0,0 +1,269 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        if (other.m_buffer == m_buffer) return *this;",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 129,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "5d06357207b570b1c2a66b318545087666fe8605",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "seems ever so slightly more direct, even though this seems correct as is\r\n```Suggestion\r\n        if (&other == this) return *this;\r\n```",
      "created_at": "2024-06-04T18:29:48Z",
      "updated_at": "2024-06-04T19:31:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626448996",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626448996"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626544077",
      "pull_request_review_id": 2097289437,
      "id": 1626544077,
      "node_id": "PRRC_kwDOABII585g8xfN",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {",
      "path": "src/util/vecdeque.h",
      "position": 48,
      "original_position": 47,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "in_reply_to_id": 1626395824,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed!",
      "created_at": "2024-06-04T20:04:11Z",
      "updated_at": "2024-06-04T20:04:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626544077",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626544077"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 48,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626579091",
      "pull_request_review_id": 2097348195,
      "id": 1626579091,
      "node_id": "PRRC_kwDOABII585g86CT",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 27,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "in_reply_to_id": 1626177967,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-04T20:40:38Z",
      "updated_at": "2024-06-04T20:40:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626579091",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626579091"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626579194",
      "pull_request_review_id": 2097348355,
      "id": 1626579194,
      "node_id": "PRRC_kwDOABII585g86D6",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 73,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "in_reply_to_id": 1626291871,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-04T20:40:43Z",
      "updated_at": "2024-06-04T20:40:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626579194",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626579194"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626579310",
      "pull_request_review_id": 2097348513,
      "id": 1626579310,
      "node_id": "PRRC_kwDOABII585g86Fu",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on VecDeque type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<VecDeque<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const VecDeque<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        int command = provider.ConsumeIntegral<uint8_t>() % 32;\n+        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\n+        const size_t num_buffers = sim.size();\n+        // Pick one operation based on value of command. Not all operations are always applicable.\n+        // Loop through the applicable ones until command reaches 0 (which avoids the need to\n+        // compute the number of applicable commands ahead of time).\n+        const bool non_empty{num_buffers != 0};\n+        const bool non_full{num_buffers < MAX_BUFFERS};\n+        const bool partially_full{non_empty && non_full};\n+        const bool multiple_exist{num_buffers > 1};\n+        const bool existing_buffer_non_full{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\n+        const bool existing_buffer_non_empty{non_empty && !sim[idx].empty()};\n+        assert(non_full || non_empty);\n+        while (true) {\n+            if (non_full && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = VecDeque<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Move construct. */\n+                VecDeque<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % num_buffers]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Move assign. */\n+                VecDeque<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);",
      "path": "src/test/fuzz/vecdeque.cpp",
      "position": null,
      "original_position": 165,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "ecb278bb19c53b007380e262fa86d809255eeb49",
      "in_reply_to_id": 1626321220,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-04T20:40:48Z",
      "updated_at": "2024-06-04T20:40:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626579310",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626579310"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 180,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626580105",
      "pull_request_review_id": 2097349729,
      "id": 1626580105,
      "node_id": "PRRC_kwDOABII585g86SJ",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on VecDeque type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<VecDeque<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const VecDeque<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        int command = provider.ConsumeIntegral<uint8_t>() % 32;\n+        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\n+        const size_t num_buffers = sim.size();\n+        // Pick one operation based on value of command. Not all operations are always applicable.\n+        // Loop through the applicable ones until command reaches 0 (which avoids the need to\n+        // compute the number of applicable commands ahead of time).\n+        const bool non_empty{num_buffers != 0};\n+        const bool non_full{num_buffers < MAX_BUFFERS};\n+        const bool partially_full{non_empty && non_full};\n+        const bool multiple_exist{num_buffers > 1};\n+        const bool existing_buffer_non_full{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\n+        const bool existing_buffer_non_empty{non_empty && !sim[idx].empty()};\n+        assert(non_full || non_empty);\n+        while (true) {\n+            if (non_full && command-- == 0) {",
      "path": "src/test/fuzz/vecdeque.cpp",
      "position": 70,
      "original_position": 70,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "ecb278bb19c53b007380e262fa86d809255eeb49",
      "in_reply_to_id": 1626341902,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I didn't take this suggestion. The current code should be invoking `compare_fn` whenever an element is destructed or destructively overwritten; that's not necessarily number `idx` though.",
      "created_at": "2024-06-04T20:41:37Z",
      "updated_at": "2024-06-04T20:41:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626580105",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626580105"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 70,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626580268",
      "pull_request_review_id": 2097350020,
      "id": 1626580268,
      "node_id": "PRRC_kwDOABII585g86Us",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }",
      "path": "src/util/vecdeque.h",
      "position": 36,
      "original_position": 35,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "in_reply_to_id": 1626387016,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-04T20:41:49Z",
      "updated_at": "2024-06-04T20:41:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626580268",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626580268"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 36,
      "original_line": 36,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626580385",
      "pull_request_review_id": 2097350198,
      "id": 1626580385,
      "node_id": "PRRC_kwDOABII585g86Wh",
      "diff_hunk": "@@ -0,0 +1,269 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + Index(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        if (other.m_buffer == m_buffer) return *this;",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 129,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "5d06357207b570b1c2a66b318545087666fe8605",
      "in_reply_to_id": 1626448996,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-04T20:41:56Z",
      "updated_at": "2024-06-04T20:41:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626580385",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626580385"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626581320",
      "pull_request_review_id": 2097351889,
      "id": 1626581320,
      "node_id": "PRRC_kwDOABII585g86lI",
      "diff_hunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset = 0 if m_capacity is 0; otherwise\n+     *  m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {",
      "path": "src/util/vecdeque.h",
      "position": 48,
      "original_position": 47,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "0eba7219a2ab94e2aa92f35ea1b681f168ac6384",
      "in_reply_to_id": 1626395824,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added an `Assume` to reflect this.",
      "created_at": "2024-06-04T20:42:52Z",
      "updated_at": "2024-06-04T20:42:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1626581320",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626581320"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 48,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1627251261",
      "pull_request_review_id": 2098403329,
      "id": 1627251261,
      "node_id": "PRRC_kwDOABII585g_eI9",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object in queue. m_offset = 0 if m_capacity is 0;\n+     *  otherwise 0 <= m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. 0 <= m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    /** Returns the number of populated objects between m_offset and the end of the buffer. */\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;",
      "path": "src/util/vecdeque.h",
      "position": 43,
      "original_position": 43,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "in_reply_to_id": null,
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would early return for `capacity == 0` simplify the code?",
      "created_at": "2024-06-05T08:29:57Z",
      "updated_at": "2024-06-05T08:29:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1627251261",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1627251261"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": 42,
      "original_start_line": 42,
      "start_side": "RIGHT",
      "line": 43,
      "original_line": 43,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1627725865",
      "pull_request_review_id": 2099091053,
      "id": 1627725865,
      "node_id": "PRRC_kwDOABII585hBSAp",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object in queue. m_offset = 0 if m_capacity is 0;\n+     *  otherwise 0 <= m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. 0 <= m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    /** Returns the number of populated objects between m_offset and the end of the buffer. */\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;",
      "path": "src/util/vecdeque.h",
      "position": 43,
      "original_position": 43,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "in_reply_to_id": 1627251261,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We may still need to deallocate the old buffer in that case.",
      "created_at": "2024-06-05T13:06:12Z",
      "updated_at": "2024-06-05T13:06:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1627725865",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1627725865"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": 42,
      "original_start_line": 42,
      "start_side": "RIGHT",
      "line": 43,
      "original_line": 43,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1629747141",
      "pull_request_review_id": 2102299643,
      "id": 1629747141,
      "node_id": "PRRC_kwDOABII585hI_fF",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object in queue. m_offset = 0 if m_capacity is 0;\n+     *  otherwise 0 <= m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. 0 <= m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    /** Returns the number of populated objects between m_offset and the end of the buffer. */\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t BufferIndex(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + BufferIndex(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + BufferIndex(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        if (&other == this) return *this;",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 130,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "in_reply_to_id": null,
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Does it make sense to label branches with the `[[likely]]` and `[[unlikely]]` attributes here?",
      "created_at": "2024-06-06T15:22:40Z",
      "updated_at": "2024-06-06T15:25:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1629747141",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1629747141"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1629750737",
      "pull_request_review_id": 2102299643,
      "id": 1629750737,
      "node_id": "PRRC_kwDOABII585hJAXR",
      "diff_hunk": "@@ -0,0 +1,488 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on VecDeque type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<VecDeque<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const VecDeque<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        int command = provider.ConsumeIntegral<uint8_t>() % 64;\n+        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\n+        const size_t num_buffers = sim.size();\n+        // Pick one operation based on value of command. Not all operations are always applicable.\n+        // Loop through the applicable ones until command reaches 0 (which avoids the need to\n+        // compute the number of applicable commands ahead of time).\n+        const bool non_empty{num_buffers != 0};\n+        const bool non_full{num_buffers < MAX_BUFFERS};\n+        const bool partially_full{non_empty && non_full};\n+        const bool multiple_exist{num_buffers > 1};\n+        const bool existing_buffer_non_full{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\n+        const bool existing_buffer_non_empty{non_empty && !sim[idx].empty()};\n+        assert(non_full || non_empty);\n+        while (true) {\n+            if (non_full && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* resize() */\n+                compare_fn(real[idx], sim[idx]);\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* clear() */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Copy construct default. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = VecDeque<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Move construct. */\n+                VecDeque<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % num_buffers]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Move assign. */\n+                VecDeque<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Self swap() */\n+                swap(real[idx], real[idx]);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Self-copy assign. */\n+                real[idx] = real[idx];\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Self-move assign. */\n+                real[idx] = std::move(real[idx]);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) {\n+                    assert(real[idx].capacity() == old_cap);\n+                } else {\n+                    assert(real[idx].capacity() > old_cap);\n+                    assert(real[idx].capacity() <= 2 * (old_cap + 1));\n+                }\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) {\n+                    assert(real[idx].capacity() == old_cap);\n+                } else {\n+                    assert(real[idx].capacity() > old_cap);\n+                    assert(real[idx].capacity() <= 2 * (old_cap + 1));\n+                }\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) {\n+                    assert(real[idx].capacity() == old_cap);\n+                } else {\n+                    assert(real[idx].capacity() > old_cap);\n+                    assert(real[idx].capacity() <= 2 * (old_cap + 1));\n+                }\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) {\n+                    assert(real[idx].capacity() == old_cap);\n+                } else {\n+                    assert(real[idx].capacity() > old_cap);\n+                    assert(real[idx].capacity() <= 2 * (old_cap + 1));\n+                }\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) {\n+                    assert(real[idx].capacity() == old_cap);\n+                } else {\n+                    assert(real[idx].capacity() > old_cap);\n+                    assert(real[idx].capacity() <= 2 * (old_cap + 1));\n+                }\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) {\n+                    assert(real[idx].capacity() == old_cap);\n+                } else {\n+                    assert(real[idx].capacity() > old_cap);\n+                    assert(real[idx].capacity() <= 2 * (old_cap + 1));\n+                }\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* pop_front() */\n+                assert(sim[idx].front() == real[idx].front());\n+                size_t old_size = real[idx].size();\n+                sim[idx].pop_front();\n+                real[idx].pop_front();\n+                assert(real[idx].size() == old_size - 1);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* pop_back() */\n+                assert(sim[idx].back() == real[idx].back());\n+                size_t old_size = real[idx].size();\n+                sim[idx].pop_back();\n+                real[idx].pop_back();\n+                assert(real[idx].size() == old_size - 1);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const VecDeque<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    /** Create entry for this object in g_tracker and populate m_track_entry. */\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    /** Get value corresponding to this object in g_tracker. */\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    /** Get value corresponding to this object in g_tracker. */\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }",
      "path": "src/test/fuzz/vecdeque.cpp",
      "position": null,
      "original_position": 440,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "in_reply_to_id": null,
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This copy assignment can be amended to handle the self-assignment as well to do not conflict with https://github.com/bitcoin/bitcoin/pull/30234.",
      "created_at": "2024-06-06T15:25:04Z",
      "updated_at": "2024-06-06T15:25:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1629750737",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1629750737"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": 436,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 441,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1629970936",
      "pull_request_review_id": 2102703313,
      "id": 1629970936,
      "node_id": "PRRC_kwDOABII585hJ2H4",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object in queue. m_offset = 0 if m_capacity is 0;\n+     *  otherwise 0 <= m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. 0 <= m_size <= m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    /** Returns the number of populated objects between m_offset and the end of the buffer. */\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+        Assume((m_offset == 0 && m_capacity == 0) || m_offset < m_capacity);\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t BufferIndex(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size) noexcept\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + BufferIndex(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            while (m_size < size) {\n+                std::construct_at(m_buffer + BufferIndex(m_size));\n+                ++m_size;\n+            }\n+        }\n+    }\n+\n+    void clear() noexcept { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        if (&other == this) return *this;",
      "path": "src/util/vecdeque.h",
      "position": null,
      "original_position": 130,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "in_reply_to_id": 1629747141,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-06T17:40:22Z",
      "updated_at": "2024-06-06T17:40:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1629970936",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1629970936"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1629971528",
      "pull_request_review_id": 2102705080,
      "id": 1629971528,
      "node_id": "PRRC_kwDOABII585hJ2RI",
      "diff_hunk": "@@ -0,0 +1,488 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/vecdeque.h>\n+\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on VecDeque type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<VecDeque<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const VecDeque<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        int command = provider.ConsumeIntegral<uint8_t>() % 64;\n+        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\n+        const size_t num_buffers = sim.size();\n+        // Pick one operation based on value of command. Not all operations are always applicable.\n+        // Loop through the applicable ones until command reaches 0 (which avoids the need to\n+        // compute the number of applicable commands ahead of time).\n+        const bool non_empty{num_buffers != 0};\n+        const bool non_full{num_buffers < MAX_BUFFERS};\n+        const bool partially_full{non_empty && non_full};\n+        const bool multiple_exist{num_buffers > 1};\n+        const bool existing_buffer_non_full{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\n+        const bool existing_buffer_non_empty{non_empty && !sim[idx].empty()};\n+        assert(non_full || non_empty);\n+        while (true) {\n+            if (non_full && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* resize() */\n+                compare_fn(real[idx], sim[idx]);\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* clear() */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Copy construct default. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = VecDeque<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (partially_full && command-- == 0) {\n+                /* Move construct. */\n+                VecDeque<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % num_buffers]);\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (multiple_exist && command-- == 0) {\n+                /* Move assign. */\n+                VecDeque<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % num_buffers];\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Self swap() */\n+                swap(real[idx], real[idx]);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Self-copy assign. */\n+                real[idx] = real[idx];\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* Self-move assign. */\n+                real[idx] = std::move(real[idx]);\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (non_empty && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) {\n+                    assert(real[idx].capacity() == old_cap);\n+                } else {\n+                    assert(real[idx].capacity() > old_cap);\n+                    assert(real[idx].capacity() <= 2 * (old_cap + 1));\n+                }\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) {\n+                    assert(real[idx].capacity() == old_cap);\n+                } else {\n+                    assert(real[idx].capacity() > old_cap);\n+                    assert(real[idx].capacity() <= 2 * (old_cap + 1));\n+                }\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) {\n+                    assert(real[idx].capacity() == old_cap);\n+                } else {\n+                    assert(real[idx].capacity() > old_cap);\n+                    assert(real[idx].capacity() <= 2 * (old_cap + 1));\n+                }\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) {\n+                    assert(real[idx].capacity() == old_cap);\n+                } else {\n+                    assert(real[idx].capacity() > old_cap);\n+                    assert(real[idx].capacity() <= 2 * (old_cap + 1));\n+                }\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) {\n+                    assert(real[idx].capacity() == old_cap);\n+                } else {\n+                    assert(real[idx].capacity() > old_cap);\n+                    assert(real[idx].capacity() <= 2 * (old_cap + 1));\n+                }\n+                break;\n+            }\n+            if (existing_buffer_non_full && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) {\n+                    assert(real[idx].capacity() == old_cap);\n+                } else {\n+                    assert(real[idx].capacity() > old_cap);\n+                    assert(real[idx].capacity() <= 2 * (old_cap + 1));\n+                }\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* pop_front() */\n+                assert(sim[idx].front() == real[idx].front());\n+                size_t old_size = real[idx].size();\n+                sim[idx].pop_front();\n+                real[idx].pop_front();\n+                assert(real[idx].size() == old_size - 1);\n+                break;\n+            }\n+            if (existing_buffer_non_empty && command-- == 0) {\n+                /* pop_back() */\n+                assert(sim[idx].back() == real[idx].back());\n+                size_t old_size = real[idx].size();\n+                sim[idx].pop_back();\n+                real[idx].pop_back();\n+                assert(real[idx].size() == old_size - 1);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const VecDeque<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    /** Create entry for this object in g_tracker and populate m_track_entry. */\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    /** Get value corresponding to this object in g_tracker. */\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    /** Get value corresponding to this object in g_tracker. */\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }",
      "path": "src/test/fuzz/vecdeque.cpp",
      "position": null,
      "original_position": 440,
      "commit_id": "fcdd357df89aa8639b7f7e2bb537bd2f079df3b1",
      "original_commit_id": "e4ecb8217ada3dae1c1645a8d0a12e14b0f935da",
      "in_reply_to_id": 1629750737,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, though naive self-assignment isn't actually broken here. It's just test code though, so better to be more obviously correct.",
      "created_at": "2024-06-06T17:40:51Z",
      "updated_at": "2024-06-06T17:40:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1629971528",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1629971528"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": 436,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 441,
      "side": "RIGHT"
    }
  ]
}