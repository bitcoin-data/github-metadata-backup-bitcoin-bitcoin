{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747",
    "id": 2591037188,
    "node_id": "PR_kwDOABII586acBcE",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/32747",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/32747.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/32747.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32747",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32747/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/03ce73a820b485fbdbb854d9d3947ff1e6d87880",
    "number": 32747,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Introduce SockMan (\"lite\"): low-level socket handling for HTTP",
    "user": {
      "login": "pinheadmz",
      "id": 2084648,
      "node_id": "MDQ6VXNlcjIwODQ2NDg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pinheadmz",
      "html_url": "https://github.com/pinheadmz",
      "followers_url": "https://api.github.com/users/pinheadmz/followers",
      "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
      "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
      "repos_url": "https://api.github.com/users/pinheadmz/repos",
      "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Introduces a new low-level socket manager `SockMan` as an abstract class with virtual functions for implementing higher-level networking protocols like HTTP. This is the next step in https://github.com/bitcoin/bitcoin/issues/31194\r\n\r\nThis is a minimal, alternative version of #30988 (\"Split CConnman\") without any changes to working code (P2P is not affected). It adds a stripped-down version of the `SockMan` introduced in that pull request that implements only what is needed for the HTTP server implemented in #32061 (i.e. no I2P stuff and for now, no outbound connection stuff). Exclusions from the original `SockMan` pull request can be checked with:\r\n\r\n```\r\ngit diff vasild/sockman \\\r\nsrc/common/sockman.h \\\r\nsrc/common/sockman.cpp\r\n```\r\n\r\nThe commit order has been flipped quite a bit because the original PR incrementally pulls logic out of `net` wheras this PR builds a new system from the bottom-up. Otherwise I tried to keep all the `SockMan` code in order so reviewers of the original PR would be familiar with it.\r\n\r\nIt also adds unit tests by introducing a `SocketTestingSetup` which mocks network sockets by returning a queue of `DynSock` from `CreateSock()`. HTTP server tests in #32061 will be rebased on this framework as well.\r\n\r\n",
    "labels": [],
    "created_at": "2025-06-13T18:36:49Z",
    "updated_at": "2025-10-15T18:51:40Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "714e2407319c5b6c026bbbe24f5df21329d7c37a",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "pinheadmz:sockman-lite",
      "ref": "sockman-lite",
      "sha": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 61248407,
        "node_id": "MDEwOlJlcG9zaXRvcnk2MTI0ODQwNw==",
        "name": "bitcoin",
        "full_name": "pinheadmz/bitcoin",
        "owner": {
          "login": "pinheadmz",
          "id": 2084648,
          "node_id": "MDQ6VXNlcjIwODQ2NDg=",
          "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/pinheadmz",
          "html_url": "https://github.com/pinheadmz",
          "followers_url": "https://api.github.com/users/pinheadmz/followers",
          "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
          "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
          "repos_url": "https://api.github.com/users/pinheadmz/repos",
          "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/pinheadmz/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/pinheadmz/bitcoin",
        "archive_url": "https://api.github.com/repos/pinheadmz/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/pinheadmz/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/pinheadmz/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/pinheadmz/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/pinheadmz/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/pinheadmz/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/pinheadmz/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/pinheadmz/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/pinheadmz/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/pinheadmz/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/pinheadmz/bitcoin/events",
        "forks_url": "https://api.github.com/repos/pinheadmz/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/pinheadmz/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/pinheadmz/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/pinheadmz/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/pinheadmz/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/pinheadmz/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/pinheadmz/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/pinheadmz/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/pinheadmz/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/pinheadmz/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/pinheadmz/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/pinheadmz/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/pinheadmz/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:pinheadmz/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/pinheadmz/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/pinheadmz/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/pinheadmz/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/pinheadmz/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/pinheadmz/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/pinheadmz/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/pinheadmz/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/pinheadmz/bitcoin/hooks",
        "svn_url": "https://github.com/pinheadmz/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 1,
        "stargazers_count": 3,
        "watchers_count": 3,
        "size": 284744,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-10-15T15:27:59Z",
        "created_at": "2016-06-15T23:48:20Z",
        "updated_at": "2025-09-26T10:10:12Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "9314113b295af0f4eab6397c5870115b647721d1",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 38032,
        "stargazers_count": 86195,
        "watchers_count": 86195,
        "size": 294954,
        "default_branch": "master",
        "open_issues_count": 823,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-10-15T14:01:00Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-10-15T18:33:36Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 949,
    "deletions": 14,
    "changed_files": 10,
    "commits": 11,
    "review_comments": 82,
    "comments": 4
  },
  "events": [
    {
      "event": "commented",
      "id": 2971261595,
      "node_id": "IC_kwDOABII586xGdqb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2971261595",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-13T18:36:52Z",
      "updated_at": "2025-10-15T18:51:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32747.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [w0xlt](https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-2937305602), [hodlinator](https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-3022243737) |\n| Stale ACK | [vasild](https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-3279884844) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#33210](https://github.com/bitcoin/bitcoin/pull/33210) (fuzz: enhance wallet_fees by mocking mempool stuff by brunoerg)\n* [#32015](https://github.com/bitcoin/bitcoin/pull/32015) (net: replace manual reference counting of CNode with shared_ptr by vasild)\n* [#30988](https://github.com/bitcoin/bitcoin/pull/30988) (Split CConnman by vasild)\n* [#26812](https://github.com/bitcoin/bitcoin/pull/26812) (test: add end-to-end tests for CConnman and PeerManager by vasild)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->\n### LLM Linter (✨ experimental)\n\nPossible typos and grammar issues:\n\n- \"Each connection is assigned an unique id of this type.\" -> \"Each connection is assigned a unique id of this type.\" [Use \"a\" before a word starting with a consonant sound; \"an unique\" is ungrammatical.]\n- \"Returns the I/O pipes from the mock client so we can read response datasent to it.\" -> \"Returns the I/O pipes from the mock client so we can read response data sent to it.\" [\"datasent\" is a typo/concatenation; should be two words \"data sent\" for clarity.]\n\n<sup>drahtbot_id_5_m</sup>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#issuecomment-2971261595",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32747"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18139663432,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAAQ5NUxI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18139663432",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d8274e91c0c8ebb4d6d4ae16ed82a5c2e7dd8bd1",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/d8274e91c0c8ebb4d6d4ae16ed82a5c2e7dd8bd1",
      "created_at": "2025-06-13T19:03:02Z"
    },
    {
      "event": "labeled",
      "id": 18139665382,
      "node_id": "LE_lADOABII5867bDTqzwAAAAQ5NVPm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18139665382",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-13T19:03:13Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2971365995,
      "node_id": "IC_kwDOABII586xG3Jr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2971365995",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-13T19:03:15Z",
      "updated_at": "2025-06-13T19:03:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n🚧 At least one of the CI tasks failed.\n<sub>Task `MSan, depends`: https://github.com/bitcoin/bitcoin/runs/44070031695</sub>\n<sub>LLM reason (✨ experimental): MemorySanitizer detected use of uninitialized memory during sockman_tests, causing CI failure.</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#issuecomment-2971365995",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32747"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18140182279,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAAQ5PTcH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18140182279",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "55a329ac85df21a88c166519ad684f84b6124b77",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/55a329ac85df21a88c166519ad684f84b6124b77",
      "created_at": "2025-06-13T19:43:49Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18140539333,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAAQ5QqnF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18140539333",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2d79cd7dbe7ed06691dd7b44a5227c1a7b849c6f",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/2d79cd7dbe7ed06691dd7b44a5227c1a7b849c6f",
      "created_at": "2025-06-13T20:12:20Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18149846423,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAAQ50K2X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18149846423",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "created_at": "2025-06-14T14:55:11Z"
    },
    {
      "event": "unlabeled",
      "id": 18150107930,
      "node_id": "UNLE_lADOABII5867bDTqzwAAAAQ51Ksa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18150107930",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-14T15:49:34Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2975549723,
      "node_id": "IC_kwDOABII586xW0kb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2975549723",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-16T08:21:26Z",
      "updated_at": "2025-06-16T08:21:26Z",
      "author_association": "MEMBER",
      "body": "I was able to switch https://github.com/Sjors/bitcoin/pull/50 to use this instead of https://github.com/bitcoin/bitcoin/pull/30988 without have to change anything. So it makes sense to me to focus on this PR first, as it's smaller. Thoughts @vasild?",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#issuecomment-2975549723",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32747"
    },
    {
      "event": "mentioned",
      "id": 18164809141,
      "node_id": "MEE_lADOABII5867bDTqzwAAAAQ6tP21",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18164809141",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-16T08:21:27Z"
    },
    {
      "event": "subscribed",
      "id": 18164809169,
      "node_id": "SE_lADOABII5867bDTqzwAAAAQ6tP3R",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18164809169",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-16T08:21:27Z"
    },
    {
      "event": "reviewed",
      "id": 2937305602,
      "node_id": "PRR_kwDOABII586vE7oC",
      "url": null,
      "actor": null,
      "commit_id": "5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-17T23:19:57Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK.\r\nAre the functions in this PR to replace Connam functions like `CConnman::BindListenPort`, `CConnman::InitBinds`, etc...?",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-2937305602",
      "submitted_at": "2025-06-17T23:19:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "commented",
      "id": 2983561305,
      "node_id": "IC_kwDOABII586x1YhZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2983561305",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-18T10:04:16Z",
      "updated_at": "2025-06-18T10:04:16Z",
      "author_association": "MEMBER",
      "body": "> replace Connman functions\r\n\r\nIn this PR they are just protocol-agnostic copies of those ConnMan functions. Just the socket stuff without the Bitcoin stuff. We could still proceed with the reactor in #30988 after this is merged and actually replace the socket stuff in ConnMan with SockMan but this PR is minimized with the focus being the socket needs of the HTTP server in #32061",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#issuecomment-2983561305",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32747"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18259049739,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAARAUv0L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18259049739",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/130708803dd623c37e21bf72887ea84cf59460cc",
      "created_at": "2025-06-21T22:24:55Z"
    },
    {
      "event": "reviewed",
      "id": 2945433124,
      "node_id": "PRR_kwDOABII586vj74k",
      "url": null,
      "actor": null,
      "commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-23T10:09:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "Approach ACK 5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-2945433124",
      "submitted_at": "2025-06-23T10:09:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18282616969,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAARBupiJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18282616969",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/3e7abceecfd790bc0887f647d3f731328e19810f",
      "created_at": "2025-06-23T23:20:31Z"
    },
    {
      "event": "reviewed",
      "id": 2951071498,
      "node_id": "PRR_kwDOABII586v5ccK",
      "url": null,
      "actor": null,
      "commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-24T00:43:03Z",
      "author_association": "MEMBER",
      "body": "Rebase to address review by @vasild THANKS!",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-2951071498",
      "submitted_at": "2025-06-24T00:43:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "reviewed",
      "id": 2958772275,
      "node_id": "PRR_kwDOABII586wW0gz",
      "url": null,
      "actor": null,
      "commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-25T15:57:16Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK 3e7abceecfd790bc0887f647d3f731328e19810f",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-2958772275",
      "submitted_at": "2025-06-25T15:57:16Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "review_requested",
      "id": 18319901223,
      "node_id": "RRE_lADOABII5867bDTqzwAAAARD84In",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18319901223",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-25T15:57:20Z",
      "requested_reviewer": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_request_removed",
      "id": 18437288730,
      "node_id": "RRRE_lADOABII5867bDTqzwAAAARK8rMa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18437288730",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-02T18:08:06Z",
      "requested_reviewer": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 18437288752,
      "node_id": "RRE_lADOABII5867bDTqzwAAAARK8rMw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18437288752",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-02T18:08:06Z",
      "requested_reviewer": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 18643934953,
      "node_id": "RRE_lADOABII5867bDTqzwAAAARXQ97p",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18643934953",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-15T18:05:16Z",
      "requested_reviewer": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 3049290299,
      "node_id": "PRR_kwDOABII5861wHo7",
      "url": null,
      "actor": null,
      "commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-23T22:45:50Z",
      "author_association": "MEMBER",
      "body": "Began reviewing, then realized that I was reviewing the same code twice with the two \"modernize\" commits following \"original\" commits.\r\n\r\nPropose to either (1) make clear in the commit message where the code is being pulled from, and that it will be re-styled afterward, or (2) squash the modernization commits into the previous ones. Thereby easing life a bit for your reviewers :)",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-3049290299",
      "submitted_at": "2025-07-23T22:42:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "review_requested",
      "id": 18783846194,
      "node_id": "RRE_lADOABII5867bDTqzwAAAARfmr8y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18783846194",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-23T22:42:33Z",
      "requested_reviewer": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19038417625,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAARuxzLZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19038417625",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/598bee6bd590757565d2564ae86cf46b5eea4399",
      "created_at": "2025-08-07T15:34:40Z"
    },
    {
      "event": "reviewed",
      "id": 3097669539,
      "node_id": "PRR_kwDOABII5864oq-j",
      "url": null,
      "actor": null,
      "commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-07T15:35:54Z",
      "author_association": "MEMBER",
      "body": "3e7abceecf -> 598bee6bd5\r\n\r\nAddress nits from @jonatack including commit messages that indicate code is copied from CConnman and will be modernized in following commits.",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-3097669539",
      "submitted_at": "2025-08-07T15:35:54Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "reviewed",
      "id": 3022243737,
      "node_id": "PRR_kwDOABII5860I8eZ",
      "url": null,
      "actor": null,
      "commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-16T12:21:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK 598bee6bd590757565d2564ae86cf46b5eea4399\r\n\r\n### Concept\r\n\r\nAgree with exploring this avenue of introducing `SockMan` without touching `CConnman`. Given @theuni's comment in https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2702063374, I'm still curious how he would suggest improving it as far as event-loop/send-receive/threading goes.\r\n\r\n### Commit approach\r\n\r\nThink it's fine so far to pair the commits (copy+modernize, ...). It enables reviewers to review the copying and then diffing over 2 commits at once to see what changed in combination.\r\n\r\n### Suggestions branch\r\n\r\nhttps://github.com/bitcoin/bitcoin/compare/598bee6bd590757565d2564ae86cf46b5eea4399...hodlinator:bitcoin:pr/32747_suggestions\r\n\r\nOrdered my suggestion commits starting from:\r\n* Trivial - Example: use `std::byte` (44bf80cd90b573d739b3519810449eab6a109992).\r\n* Slightly controversial - Example: decreased `shared_ptr` mentioned ~above~below.\r\n* More arbitrary - Example: rename `ConnectionSockets` => `ConnectionSocket` (650ff1d0762d05b9ea34d527840c5e6c7762afce), probably there are reasons I don't know for the naming.\r\n\r\n### Hodlinator's `shared_ptr` corner\r\n\r\n`shared_ptr` signals heavily ambiguous ownership. It seems like if there is a socket manager, it should be the one controlling the lifetime of all of them. But since the socket code is already so `shared_ptr`-heavy, it's more like a global network API with some objects with value-like semantics thrown in. *And maybe I can learn to live with that for now.* Few socket operations entail looping over a `vector` of them anyway, which weakens the argument for centralizing ownership. Wrapping them in `shared_ptr` means they can contain inlined data that is \"pinned\" to that place in memory with decreased risk of being moved and causing issues (even though that could be trivially worked around through internal pointer indirection).",
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-3022243737",
      "submitted_at": "2025-08-26T09:42:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19709142510,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAASWwaXu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19709142510",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "created_at": "2025-09-15T19:22:52Z"
    },
    {
      "event": "reviewed",
      "id": 3217223929,
      "node_id": "PRR_kwDOABII586_wvD5",
      "url": null,
      "actor": null,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-15T19:31:22Z",
      "author_association": "MEMBER",
      "body": "Rebase to e007e1b57d addresses excellent thorough review from @hodlinator (THANKS!). Most significant changes involve casting arguments to socket functions (see #33378) and cleaning up protected/private membership of `SockMan`. I have locally rebased #32061 on these changes and everything still passes ;-) I will update that PR soon based on these changes.",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-3217223929",
      "submitted_at": "2025-09-15T19:31:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "referenced",
      "id": 19785563981,
      "node_id": "REFE_lADOABII5867bDTqzwAAAASbT79N",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19785563981",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "eaf2c464758b41638dd0dc85723d05b8ee60672e",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eaf2c464758b41638dd0dc85723d05b8ee60672e",
      "created_at": "2025-09-18T20:54:08Z"
    },
    {
      "event": "reviewed",
      "id": 3279884844,
      "node_id": "PRR_kwDOABII587DfxIs",
      "url": null,
      "actor": null,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-29T13:37:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-3279884844",
      "submitted_at": "2025-09-29T13:37:35Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "review_requested",
      "id": 19984606493,
      "node_id": "RRE_lADOABII5867bDTqzwAAAASnLOUd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19984606493",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-29T13:37:40Z",
      "requested_reviewer": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 3282387933,
      "node_id": "PRR_kwDOABII587DpUPd",
      "url": null,
      "actor": null,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-30T19:15:26Z",
      "author_association": "CONTRIBUTOR",
      "body": "I'm not immersed in this to give a meaningful ack yet, but please see a few of my comments.\n\nMy main observation is that we're introducing tests and new code at the same time and I find it hard to follow what the relation between the two is - how do I tell if they're doing what they're supposed to.\nGiven that this is meant to replace libevent, I wonder if we could add either a wrapper to libevent and cover it with tests as a first step (could be done in a separate standalone PR as well) and slowly replace the methods we rely on from libevent with our own implementation while the tests keep passing and as a last step delete libevent abstraction completely. That would reassure me personally that the new code isn't just dead weight we're adding to the code, but that we're slowly strangling out a dependency with small focused changes covered with tests where I can debug both the old or new behavior and make absolutely sure they behave in the same way.\n \nI would also prefer new code to be fully covered with tests, especially since none of the error cases and ipv6 part seem to be.",
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-3282387933",
      "submitted_at": "2025-09-30T19:15:26Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "labeled",
      "id": 20122275106,
      "node_id": "LE_lADOABII5867bDTqzwAAAASvYY0i",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20122275106",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-06T17:51:17Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU2YjIyYTU4NGU4NjczOWFlNTllMGY1NmE5YjgxNzE4MmRhODMwMzA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56b22a584e86739ae59e0f56a9b817182da83030",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/56b22a584e86739ae59e0f56a9b817182da83030",
      "tree": {
        "sha": "e528c349fce682db17608718e1f90e298cae254b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e528c349fce682db17608718e1f90e298cae254b"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e528c349fce682db17608718e1f90e298cae254b\nparent 6c4fe401e908cff1b67d80035b117aae15fe7db6\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749059576 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1760450283 -0400\n\nSockMan: introduce class and implement binding to listening socket\n\nIntroduce a new low-level socket managing class `SockMan`.\n\nBindListenPort() is copied from CConnMan in net.cpp and will\nbe modernized in the next commit.\n\nUnit-test it with a new class `SocketTestingSetup` which mocks\n`CreateSock()` and will enable mock client I/O in future commits.\n\n`SockMan` and `SocketTestingSetup` are designed to be generic and\nreusbale for higher-level network protocol implementation and testing.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjuVvcACgkQ5+KYS2KJ\nyToL0Q//VlmPgAA6nfPvMVTRdJU03CB0mEAAENbuf7mlgoEAgAnBvLXQbuc+a3KS\nLoSDJmy+qZgMTDzwPqdL0+qjvQwsTIOkS7DSohpttqLEgB4MwdyX9ulEpp6SNtd3\nfRh8Jt3k5d3fhMCfFRQmY1ng9DR2LRTzvg2OaHk3sEOAEvU97ErK1Z2HI+TchNWv\n2a/Id620s75Xf3bq+N09JKsu8VC4FUZGPI5b3O5+4Z6wiccqWLVC67jDIjKxvSa/\nYBiZJsE6Kl/2F9qdzs6d13sGLbVdQnAm4Sr8Rr3YsIw/DDydzZ1tmX++2mgCDyJB\n/mqatBAGw/oWgydCsLQ4IH2LZDE2oxZ+6OeUvlsKd8i7vdgllOpcOSYBRnCY8Yxm\n2EOL6UBJLwe7DB90RRkWLsfVKyP6JoUskuqrJvNQmWf1mBhv1236SZ1JNIvtpk82\np8YWTU59DT9vyPnhKpA1BQ4WPt+a+VzVjsrUlfzk9pPN4ntuK/6K6s2kGnnu4Urt\ne6Mv6svGNj7CDo+uB4b6pqVeFQQGyzoUzB9LHR9GSy3ziLM25dX/D8a4A7yd7hVf\nYRAQ4sucrLHPYsddvUf9Jpyz7jzeJClWAUggGaBXSHcnONav49WWHdySAQkn3imC\nFyDCriT9c3uxRIoU/4gHoyyGP/S7HC+ehfPZqQhkipix4aLbRWg=\n=esfe\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6c4fe401e908cff1b67d80035b117aae15fe7db6",
          "sha": "6c4fe401e908cff1b67d80035b117aae15fe7db6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6c4fe401e908cff1b67d80035b117aae15fe7db6"
        }
      ],
      "message": "SockMan: introduce class and implement binding to listening socket\n\nIntroduce a new low-level socket managing class `SockMan`.\n\nBindListenPort() is copied from CConnMan in net.cpp and will\nbe modernized in the next commit.\n\nUnit-test it with a new class `SocketTestingSetup` which mocks\n`CreateSock()` and will enable mock client I/O in future commits.\n\n`SockMan` and `SocketTestingSetup` are designed to be generic and\nreusbale for higher-level network protocol implementation and testing.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-10-14T13:58:03Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-04T17:52:56Z"
      },
      "sha": "56b22a584e86739ae59e0f56a9b817182da83030"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE5MmExYmE3NzhhOTYyYmZiNzg0NWNjMjZlMThiYmQ1YzQzNTFlYjU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/192a1ba778a962bfb7845cc26e18bbd5c4351eb5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/192a1ba778a962bfb7845cc26e18bbd5c4351eb5",
      "tree": {
        "sha": "2961be2f364c9d0b56eef71a4dfd7fe20720a96e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2961be2f364c9d0b56eef71a4dfd7fe20720a96e"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 2961be2f364c9d0b56eef71a4dfd7fe20720a96e\nparent 56b22a584e86739ae59e0f56a9b817182da83030\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749059790 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1760455951 -0400\n\nstyle: modernize the style of SockMan::BindListenPort()\n\nIt was copied verbatim from `CConnman::BindListenPort()` in the previous\ncommit. Modernize its variables and style and log the error messages\nfrom the caller. Also categorize the informative messages to the \"net\"\ncategory because they are quite specific to the networking layer.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjubRMACgkQ5+KYS2KJ\nyTphOQ/+PSRTuezoRSrpHgGDi/L8hAP/GuQdOxwtI+/yZyEtjOJcYYzQ/xZODxfA\nNAzvHeSTPEiE5DvUkmzHX0ksdjWvn6SkMgr4gOLVLLjnRrzru+dBK4HV71K3wDI8\nhTiN2PKoMDvXl3vV1+bFOTFJyLOXS2byaZbX9caP6aw32UcaENag3FIiRoEvLUcI\nPMxn+q9M10O+YgR0EcoLWOQKrLOLlg6RavyuRpl2j936doanK6bwKfWFuTTnks0e\nm4l7+EknV0bieB0mkjLR6MdoehSGkZ/NoObCxTgG3A8pFd1Dv64rAM9gEa0R0hjD\n0DcQzu0yEOQtdX9GRfKWAm5dephPa9T2/ixraNgseF7mXD/SGg2uk6sih+LOT01L\nfS5sI+7DTMBZ0/UmMAHQ3LOVFqAVuo6LfBWrwD+xOUG1S1LlkIsAUbfMep/ihvkW\nfCIXcCLIWAn+xJD1eeqegi+AlpE/hjuOXflSdDG8IbI32beaQRhdrndbnVHBTHop\ndycr017QthSQtTXq8Yum0Fq4omWtg5FxS+izZQJcO2OThXcxsCoNfNIJDHbAY08x\n3FMdNcFkrVxTkGDpxURJJWp6FjrZp6xHJvUHRkS+EnQhNHod+xZ4642q3YLyGmyH\nJGq9vxQN/bnvPEws9Ne6+EPYB/AT/osx39GIecMjLeGKT3OoeAE=\n=BGFX\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56b22a584e86739ae59e0f56a9b817182da83030",
          "sha": "56b22a584e86739ae59e0f56a9b817182da83030",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/56b22a584e86739ae59e0f56a9b817182da83030"
        }
      ],
      "message": "style: modernize the style of SockMan::BindListenPort()\n\nIt was copied verbatim from `CConnman::BindListenPort()` in the previous\ncommit. Modernize its variables and style and log the error messages\nfrom the caller. Also categorize the informative messages to the \"net\"\ncategory because they are quite specific to the networking layer.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-10-14T15:32:31Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-04T17:56:30Z"
      },
      "sha": "192a1ba778a962bfb7845cc26e18bbd5c4351eb5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDczNWExMmExYTkwZDA0MGJjNjZmOGQ3YTA1YWM1NjFhNDNmYmFiYTI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/735a12a1a90d040bc66f8d7a05ac561a43fbaba2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/735a12a1a90d040bc66f8d7a05ac561a43fbaba2",
      "tree": {
        "sha": "2b65f09d69fcdc439dc012d8c58b3b6b2f4b0c9d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2b65f09d69fcdc439dc012d8c58b3b6b2f4b0c9d"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 2b65f09d69fcdc439dc012d8c58b3b6b2f4b0c9d\nparent 192a1ba778a962bfb7845cc26e18bbd5c4351eb5\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749060853 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1760456445 -0400\n\nSockMan: implement and test AcceptConnection()\n\nAcceptConnection() is mostly copied from CConmann in net.cpp\nand will be modernized in the following commit.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjubv8ACgkQ5+KYS2KJ\nyTrt+w//aSIRvry8Huh2f4ety+A4J6vB0S0fR7AoZ2W/v8LdJggTcqhNbUZ/3AtH\npo5NYSv3nCLTJXlUgSy1oNn+Xd5+LS5c+ZRyFBLfV9FpmuKWWboFv08NgJFwjl9t\nO23Rd2CKwYXoQfZZZIcdUmB/Xv0ZvarjuGbN2olewFCuy8jXiyEdaczaYlmJo1zL\nnICGaQe7Bk2KoiOmnAp5oWsP/8ENDXJVGR9hB/3OtbITVGuwSB219wJxYOPrvk+V\nJujTBsYxNQtdMRUGcEelOLa1z5t9teVOxHOi5Uqj2ss+rx0tRud3eoOCk96g1O5c\nB5VBl6sHP0VJNT8zZOlO4QaXkZHi5XcGbD3s2rr6fCeu+P0VSuclrNCSRX8bRAJ6\nsy2nCsWxhBFbpsX9xsyQ8UzSloW4K9xEggrgAWAFzOw6qh1j0iquywdNotu3ioHE\nb7OYENkS7q1gmtMBpwgPPvLkQCEygm/pcl+wrGjldXExXyenkwc2XTGNlUNu1w03\noVy++bFBoTKrOHscVwq/ltwq7er7zuYn+5OCBjH8zOuet3zw+Nl13wfoNPpLjuOV\nPE8zD15ZHHQdpriqr1tNo2eBOWn18dI/5pR/BUU+v3JCGcjyt3PIlNiR+PBf8oWp\n7WTA2kXGNjh4Wy31E2rUwK12zdZUUgLxmPgZ5vABNqgEkZpy9MQ=\n=wa9V\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/192a1ba778a962bfb7845cc26e18bbd5c4351eb5",
          "sha": "192a1ba778a962bfb7845cc26e18bbd5c4351eb5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/192a1ba778a962bfb7845cc26e18bbd5c4351eb5"
        }
      ],
      "message": "SockMan: implement and test AcceptConnection()\n\nAcceptConnection() is mostly copied from CConmann in net.cpp\nand will be modernized in the following commit.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-10-14T15:40:45Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-04T18:14:13Z"
      },
      "sha": "735a12a1a90d040bc66f8d7a05ac561a43fbaba2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA1ZDU5M2U5YWE2ZWZlYTNiNTMzZDUwNzIwN2QxZWRkNGM2ZjAxZjM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/05d593e9aa6efea3b533d507207d1edd4c6f01f3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/05d593e9aa6efea3b533d507207d1edd4c6f01f3",
      "tree": {
        "sha": "8e567980185b262047696ee85ee97703058c9304",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8e567980185b262047696ee85ee97703058c9304"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 8e567980185b262047696ee85ee97703058c9304\nparent 735a12a1a90d040bc66f8d7a05ac561a43fbaba2\nauthor Vasil Dimov <vd@FreeBSD.org> 1726586947 +0200\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1760456458 -0400\n\nstyle: modernize the style of SockMan::AcceptConnection()\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjubwoACgkQ5+KYS2KJ\nyTqZzA//Ygc33z+lFT+KjZe1PHtWB7xlNkXMUJCYJ63dDz1x3XribfzjJA8oNk2a\nR26Y65EKN5LcDRMHvlScFilmhiRrlVb24+9wiTUhteD/PQx0oDv3/lyvH5+jT34P\nLUdqWaV8l7moEw26RJVo4/b/BR5k5u7qr1h/ugDzqc62NZ9jz7Q/Q4E/HMSifmNg\nBrDQTpixdGvHtP6jpqh31gRsO7nQPqIkVI1i6PZujv/8hERIL+BZNguZBwnLZQWA\ngJ5VVfk59sM2i6a27aGmzgfnBprdZaVCTau3FFr7ZX55wrFZK4Ni8P8Pzpf5XDB6\nbSFV5fzKQK8beeJ5KZCqDTmHRwpQb7oXejXIr76yMSCWAVe1d74CGgITLXmleAVp\n7oWzdZk99oJKsHkProcCcCAx4LQYhwa4es60aVEwiTdycL+eYYgh/J8Lbp6fIyJa\no4bpyefO71K6mHn7tsjm72c9BEkB6+Mp5JZE2TxViLKdrUNa1s0ShjzHCboVPFVe\nQ4Y4CMBREVBEEVqa5/DVQw8hv+2pPQjgcA9yeRCnad5wEpDtJSpC9sgtvUeswQW0\nVCwFYpx0rk0PK826QLj8CAYYtZhl9X3kSdCOvG0GsmiIXa98vDlwGmgq+0OF5SBn\n0uORCGHzVo5JQXE8LknSpkLIZ9YuHAV2A02jWmqmHEjTYh17+Lw=\n=/Zj6\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/735a12a1a90d040bc66f8d7a05ac561a43fbaba2",
          "sha": "735a12a1a90d040bc66f8d7a05ac561a43fbaba2",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/735a12a1a90d040bc66f8d7a05ac561a43fbaba2"
        }
      ],
      "message": "style: modernize the style of SockMan::AcceptConnection()",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-10-14T15:40:58Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-09-17T15:29:07Z"
      },
      "sha": "05d593e9aa6efea3b533d507207d1edd4c6f01f3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk1MTA2ZTFkMjJjZmVhYWYxNDlhZGU5ZTgwMmJlNzNiYmM2YTAxYTk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/95106e1d22cfeaaf149ade9e802be73bbc6a01a9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/95106e1d22cfeaaf149ade9e802be73bbc6a01a9",
      "tree": {
        "sha": "7e6d9e50e52a514e0afc5e75947b7e8af1f2aa00",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7e6d9e50e52a514e0afc5e75947b7e8af1f2aa00"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 7e6d9e50e52a514e0afc5e75947b7e8af1f2aa00\nparent 05d593e9aa6efea3b533d507207d1edd4c6f01f3\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749061156 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1760456735 -0400\n\nSockMan: generate sequential Ids for each newly accepted connection\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjucB8ACgkQ5+KYS2KJ\nyTrBBQ/9EP/DOXeGkbGPgojNzEn34I/t/6UZ+f8SzUWKDDvWJECmlECKAWZyIFpP\nZnmv/QQPdpIHjZ3ZBw4PAxqNjxGZp/8eCW7OCzjFpf4PCpKmaBwMn1qGy6TYmupp\n0U3sZubdwLCrjniE204m/GrxfUg6erpNrfKtsAcYoEmtZLTTsXtg2KSGEWn+JPHj\npEvRRfJfxhAK+N651aGJGxO3uTUNKhjAT57uMIgVVgpRomVvNbJoF5wdKTMPpgdJ\nwvamjqpJKy9dfSYSvabdATCiW5OkFnPdBLkI85NC+fwqFxh+t2kUSmthGSjLya1H\nK5+U7J3GmfKYphY81i4RxxYuQgVa+NILx2OtZyu9A/jKdxMn/ORSvGSo72OUYe56\nRD49Jx54tME6DgMsBwl8zJREuUaFdqFr9S9HWMThqssXm5eDcOKfHzszBoh6U4sk\neF8Gkr1vaPfIz2aUPnh0l86u/8wP9q5K8VEQZBFZ8Dtb4Z6xjd8GyW18vKW3lz7g\nyPieuUUcrhvUaBUs/N6i1nAtujw0HP2PA0K9/20P+vyYWF6J7xW9rwEWL1ToDR4O\n/qWEUlBow1aqCODsaplmI7BiQiu9L2dmVJwnpalnIYxM+NH4KTs5lxApd/lUTard\nt2L6s0myeQ5wmukIj0f5JbkbEWczd+hRkMNXuw+bfosU/J+oNS0=\n=uJ2N\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/05d593e9aa6efea3b533d507207d1edd4c6f01f3",
          "sha": "05d593e9aa6efea3b533d507207d1edd4c6f01f3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/05d593e9aa6efea3b533d507207d1edd4c6f01f3"
        }
      ],
      "message": "SockMan: generate sequential Ids for each newly accepted connection\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-10-14T15:45:35Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-04T18:19:16Z"
      },
      "sha": "95106e1d22cfeaaf149ade9e802be73bbc6a01a9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDAxMGRmMmZkYWIwM2Y5MjhlMWZhZmJlYjJhMTQ2ODQ0ZWM3NDM2NjI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/010df2fdab03f928e1fafbeb2a146844ec743662",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/010df2fdab03f928e1fafbeb2a146844ec743662",
      "tree": {
        "sha": "dbde92e9e903ce7264904bec0735f352af50a81e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dbde92e9e903ce7264904bec0735f352af50a81e"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree dbde92e9e903ce7264904bec0735f352af50a81e\nparent 95106e1d22cfeaaf149ade9e802be73bbc6a01a9\nauthor Matthew Zipkin <pinheadmz@pm.me> 1750703761 -0700\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1760457175 -0400\n\n[move-only] Make GetBindAddress() callable from outside net.cpp\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjucd0ACgkQ5+KYS2KJ\nyTrQGw/+KLZKs7oHcyIighG3PqlSgGg2x2xXeBbJIgYJUZHXYIP6Hiqk8ihkhaNw\nvRuKMR1ScZaY5PcdG7rfc+qgqWrchScYFE3q+M6PPubYvvLyP5s5TZwlcwl4lStn\nSXz+VfQ3XF+uuCnyw2A352hg+DxS9UALen7GC/uY6sauZ28/Kk+z0ly8qwSwRrFR\ny2VGPuz3OA48sGWGhNEYyq7y1sVWj5MIxWNXba17X/2ZhnLSJc+cME9nEqazygQL\nNKg6CLaCvhEoQyVmZcgNbJRH2VfiJG+nIIzMC7OMImBQew3zmQhGXlChWf+UzIzE\nodqxSvep4n8M4rkgWJwfUhDVWTtMoKOq2B0O2C13fkQq8P9npjKB0ysrGq90cArk\nuW2itVynuL5yh7/MgmuxEtsfrdxBgB9Y3unbvXfyiXVDz/vwZkz8EwUxg/S0J5+/\nDKftUjI3YV5LgT9xTAecLW0vVboFdezNgPEDOghODRh9xK/kl86K5Gh4ctCvEg1t\nmQVVKKwiAwrWjZEJ4t+MJu0XYjuCA2FZRPy5sk/PMv3HDpi+qXe9brSE+2vf3F+/\nV+hYscJ/jDSFTnPZ9JZtuquQ0qAbSd9/WaSNYdqydZ5m8mjnPIatWRUqqk+7ieeB\ngfLPxr7mI1eqaICLP5Of0wkpg58Y6wthwjTvpvxjS31CNFqrDJI=\n=Z0WA\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/95106e1d22cfeaaf149ade9e802be73bbc6a01a9",
          "sha": "95106e1d22cfeaaf149ade9e802be73bbc6a01a9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/95106e1d22cfeaaf149ade9e802be73bbc6a01a9"
        }
      ],
      "message": "[move-only] Make GetBindAddress() callable from outside net.cpp",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-10-14T15:52:55Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-23T18:36:01Z"
      },
      "sha": "010df2fdab03f928e1fafbeb2a146844ec743662"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDhmMmFiMjM5YTdiNGYyY2UwMmZmY2ZlYzExYmZjNjZlOTQ3OTUzYjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8f2ab239a7b4f2ce02ffcfec11bfc66e947953b1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8f2ab239a7b4f2ce02ffcfec11bfc66e947953b1",
      "tree": {
        "sha": "bf5cdca3416155a33bacc9581c1e1ca671b4cd2d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bf5cdca3416155a33bacc9581c1e1ca671b4cd2d"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree bf5cdca3416155a33bacc9581c1e1ca671b4cd2d\nparent 010df2fdab03f928e1fafbeb2a146844ec743662\nauthor Matthew Zipkin <pinheadmz@pm.me> 1760460554 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1760460554 -0400\n\nModernize GetBindAddress()\n\nReplace the C-style casting with C++ reinterpret_cast\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjufwoACgkQ5+KYS2KJ\nyTp/eA//SID7oaRljC8xdgkAGxHdQr+s3c0KvZ0jRxN5pctSMlmpUOwGXxDZAnDK\nHeZTjgkQa88Izr3UX+vzQBDA3JAku4q0zc250mOnlZeDGWjIgQpOr/0sBOGzR8Ey\n9wuxOMIFRkecEMQU/brKFHZuqawDHmT0h4Hr7lghSxX3Uiqr7XMQ3EDKyNVODnbf\njKXBJJVusEKsmdDU8XCunuwCoguNtqkLy/rel5wjB1TVy1vhI1oyN1+kI2Y652xH\nBmK4vyDgne9XrHWGC3zUjjsCwk2XbTBor7EgM8O3CmKS5E3ISx/34uZtXABs4aiZ\nKH+Dp8/2H2kabOxKmzEwVxwxk4jEEwWDTTvL0ucOvPh2lP35pSKgsHAriWC0jfx/\n39GiXDx2wHaqkdV+aIgCov2LpDyYuC5+9wooENDcG59jEj/gpntBqYoQrWzLXCp1\n0xDtLH37luwfs6HOkQesDbLRybB5ITAXYMdAarFFMGN5tIrlCVaZS8AhC13eixN1\ncXV8vWXicwm77tXZ/M7J+dCNI83FRQ6gXKSIvztFxeKt7Fb+rXr/ZuQtz61gsyDT\n6YaGTq9cgoIEI9tRh0hC8Ak3jZsJvVhPzosDZDcDuDap8aUhrl6bfawBkxkACnDh\naRZXNezpwFtml4FV6rVFYcqSoMo7zBkgj6I2rKsKXmCmXD1kzHg=\n=VFzK\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/010df2fdab03f928e1fafbeb2a146844ec743662",
          "sha": "010df2fdab03f928e1fafbeb2a146844ec743662",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/010df2fdab03f928e1fafbeb2a146844ec743662"
        }
      ],
      "message": "Modernize GetBindAddress()\n\nReplace the C-style casting with C++ reinterpret_cast",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-10-14T16:49:14Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-10-14T16:49:14Z"
      },
      "sha": "8f2ab239a7b4f2ce02ffcfec11bfc66e947953b1"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDgzMGQ5NTFlODg3YjgwYzVmNzA1OTY5OWNiNjMxNGVkMGU4ODg2ZWI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/830d951e887b80c5f7059699cb6314ed0e8886eb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/830d951e887b80c5f7059699cb6314ed0e8886eb",
      "tree": {
        "sha": "e2c0e776d4b34f9e623f5a582b5058ecddb109d3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e2c0e776d4b34f9e623f5a582b5058ecddb109d3"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e2c0e776d4b34f9e623f5a582b5058ecddb109d3\nparent 8f2ab239a7b4f2ce02ffcfec11bfc66e947953b1\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749754636 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1760460568 -0400\n\nSockMan: start an I/O loop in a new thread and accept connections\n\nSocket handling methods are copied from CConnMan:\n\n`CConnman::GenerateWaitSockets()` goes to\n`SockMan::GenerateWaitSockets()`.\n\n`CConnman::ThreadSocketHandler()` and\n`CConnman::SocketHandler()` are combined into\n`SockMan::ThreadSocketHandler()`.\n\n`CConnman::SocketHandlerListening()` goes to\n`SockMan::SocketHandlerListening()`.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIyBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjufxgACgkQ5+KYS2KJ\nyTqyDA/4+dPfkYG743ZCGehrc1Oqtb18K0l6c9bePwYeTaTVin/+RcJywFtA3AaC\nXMhvxEd44vREvX6vlKaVex3yTCVyq/HLKN/+VITpmZ+zcqt/TsRhHBCCN/VIOn7B\n/+0tQIG+mjEObbfXH5zu5EocbNKUnl66a8IPae1Nt6PfLqKH19FaYO9jAAYzUSLS\neSaIPktDyOgsztb5Ewse+I78hh+uIJiVOxH3QOHVWedDWs1PCXTGcajYQD3a4/dq\nwRhh0YsaKjiNihsSaRTgoCT04t1S2RrkWuDYyIBqYyhDxer4cXFKEs0WThI88KqJ\nwsQr1DbHrciiYhSzATHTBzrqCptLXhwUcxpOAdHXDmTch/l8007DhCpg0nt4HjRl\nmHr1IlX9MbE6N9FFWI0vC0FkRiTvp2R+9A4v5RZ+s+wsskqHs32LzaFmhMab6stT\naz+P6QdbrLkAVWkZRnDf3EqdL0clxRUV/q4siswtkeCKNRVTRPwDNd2vYUN6+Y1F\n2I+2ze7kDUfwGx2UcSYnXsrW6O++BSqzLTniAxWoy66bBBStEcQEIhrbofCa4Vl7\nRmLOJJj3YZrleCb0ujPrH1UK/QyaPETpNWSzJZEvrAZTadqeOQKYcM5ye4MFhEpP\nm30sVMoXOLbi9Z5u/PVxURtvb9PTVTe8mvgQ70LWj0M2MlGEGQ==\n=Yx4i\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8f2ab239a7b4f2ce02ffcfec11bfc66e947953b1",
          "sha": "8f2ab239a7b4f2ce02ffcfec11bfc66e947953b1",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8f2ab239a7b4f2ce02ffcfec11bfc66e947953b1"
        }
      ],
      "message": "SockMan: start an I/O loop in a new thread and accept connections\n\nSocket handling methods are copied from CConnMan:\n\n`CConnman::GenerateWaitSockets()` goes to\n`SockMan::GenerateWaitSockets()`.\n\n`CConnman::ThreadSocketHandler()` and\n`CConnman::SocketHandler()` are combined into\n`SockMan::ThreadSocketHandler()`.\n\n`CConnman::SocketHandlerListening()` goes to\n`SockMan::SocketHandlerListening()`.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-10-14T16:49:28Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-12T18:57:16Z"
      },
      "sha": "830d951e887b80c5f7059699cb6314ed0e8886eb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDRhOTkzN2EzMDM4NDFkMTAwZWExZWZkMTNmYTk0Y2RmOGIzNTk5YmM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4a9937a303841d100ea1efd13fa94cdf8b3599bc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4a9937a303841d100ea1efd13fa94cdf8b3599bc",
      "tree": {
        "sha": "359661c023f83e68ecaa181f5fc5d303fbf86cf0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/359661c023f83e68ecaa181f5fc5d303fbf86cf0"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 359661c023f83e68ecaa181f5fc5d303fbf86cf0\nparent 830d951e887b80c5f7059699cb6314ed0e8886eb\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749756905 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1760460568 -0400\n\nSockMan: handle connected sockets: read data from socket\n\n`CConnman::SocketHandlerConnected()` copied to\n`SockMan::SocketHandlerConnected()`.\n\nTesting this requires adding a new feature to the SocketTestingSetup,\ninserting a \"request\" payload into the mock client that connects\nto us.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjufxgACgkQ5+KYS2KJ\nyTodJBAAzrukWQBs100jvQMc4Ov+T/VThBTGfFaof6KYj7kQHSKHoooUmnEBQdi+\nHdR0eJsjVB45MJVtxVZUFKcF9DJro0xFHs05FrSK1tI8JwyJITr3l9rxZzpA8tNA\naTwrITL/Vhn8zEdScft+xVbpr3a0jWu3EvXdDXbCkqnIHaHxMGV+lCAhpCJPB8e5\nMpZwAB7FFaraSEy0ygCBfRq9x04oJnEOIkAyT6Hk2QzB6nI6IdkgV60npsiRmUrJ\nDJmf9n+LTbkjLScXk3gkXLufYTD3shdXJiTVE4/4UspUPi1C4yjx8HBg7DC0HI+E\nD47toGjgmgQBALONVuJQKDgRyn+0WlBaZ4AIYC7rt9pmfm9XM5PHdib3Eo6cVzd9\nHOXX+aw/IrlIgRz3P8oMyPL4TRPYQJgcCeXvM0U8/Mj9zeZW6COzvTkhutP9opPZ\n5q+O3tzvxvSGHuGuzDzLD6Prp4Cp3dsBo3PL0XLqBNGINH0gmsXQ+IA4X4oHzqkQ\nr7/x/2Rev8rja1lod0Y9Q5vjtU6A3OhZiVZ4xscb+JgUxGxJJFrI4UAmzwqKo+wS\noTJPLNgPkRJ6VbpV/92lBpALq0VoYDNfqj9SsbV5YSWsB0tx8zsDpJFDjQ0ovI6P\nYuv3KdZVgxUwoukBmFztwFQTOGuIA67WSa5YYXDBZg+e00Lc5DI=\n=IPRn\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/830d951e887b80c5f7059699cb6314ed0e8886eb",
          "sha": "830d951e887b80c5f7059699cb6314ed0e8886eb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/830d951e887b80c5f7059699cb6314ed0e8886eb"
        }
      ],
      "message": "SockMan: handle connected sockets: read data from socket\n\n`CConnman::SocketHandlerConnected()` copied to\n`SockMan::SocketHandlerConnected()`.\n\nTesting this requires adding a new feature to the SocketTestingSetup,\ninserting a \"request\" payload into the mock client that connects\nto us.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-10-14T16:49:28Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-12T19:35:05Z"
      },
      "sha": "4a9937a303841d100ea1efd13fa94cdf8b3599bc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGFiMGI3NzljNzY1ZGM0MmU3ZGU1MjhjYTU1OTcxNmQ3NzI5NTkxM2Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ab0b779c765dc42e7de528ca559716d77295913d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ab0b779c765dc42e7de528ca559716d77295913d",
      "tree": {
        "sha": "cfb39ae2095244ac55a5494b7ff77ef251c961e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cfb39ae2095244ac55a5494b7ff77ef251c961e2"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree cfb39ae2095244ac55a5494b7ff77ef251c961e2\nparent 4a9937a303841d100ea1efd13fa94cdf8b3599bc\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749824279 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1760460568 -0400\n\nSockMan: handle connected sockets: write data to socket\n\nSockets-touching bits from `CConnman::SocketSendData()` copied to\n`SockMan::SendBytes()`.\n\nTesting this requires adding a new feature to the SocketTestingSetup,\nreturning the DynSock I/O pipes from the mock socket so the received\ndata can be checked.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjufxgACgkQ5+KYS2KJ\nyTp+iQ//dQwYix5mStvq1jquRQh0H6XkHT1tHrpZz6FA9nzI0mx92/kQi/OF40sg\nTfDNtHFOqALftRUAF23D0sdz7YRSWgAjYb6nGVnRKwudcA5IDXuAXJRbpR1ENJle\ncdIRHCJR+28YaRnrQV3EjV5EFd9x2qOwBtDy4kBh7cbko8pIFkDe1rvt8S7BZChW\nto1ljwVssr9kZqpWKBbk/kQKYTvAlNdSTdDXACVZYJJKH5B5sFLLN3e0F5/nS3g+\njoqxOplvQdHZ1mRtxqzOn53uw15HUI/S6ulqjftcMom+uLVsXQWvfPJ7K9FuVSl+\nJ2iCrf1LirKiRIML+EEadxm4K90sDkR+shsoML89Q6tshuyU0hBWA0oBhEiF8my1\nRrivK7D+vKhemYaVp04srRTw92D8hQUYYjPBLQF/NguAQVJ5VwxBZqJJak9yKN2L\nh8FFO/bQCuP8DpbXklVRkuF32fc9iqc2RMlAc//1rx7by4RSk0jkciMPGUZt87RY\nuytQircCYhZg//DmUIUbP2gYB6KfemuDcMGS8ZTGkWiPSG7JbeUCIe8lfzci/fsi\n5LmKf6P7eVwzCSvmRnY4FrhoNhMghFfW3tNv6mqd95XMBXOfRROoAZmjxHz5CfTN\nDWsj0hhkKR5hmR6ktZCovFBHd/NYc5a1fzL4u4LobXa9rOU53Y4=\n=FOcN\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4a9937a303841d100ea1efd13fa94cdf8b3599bc",
          "sha": "4a9937a303841d100ea1efd13fa94cdf8b3599bc",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4a9937a303841d100ea1efd13fa94cdf8b3599bc"
        }
      ],
      "message": "SockMan: handle connected sockets: write data to socket\n\nSockets-touching bits from `CConnman::SocketSendData()` copied to\n`SockMan::SendBytes()`.\n\nTesting this requires adding a new feature to the SocketTestingSetup,\nreturning the DynSock I/O pipes from the mock socket so the received\ndata can be checked.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-10-14T16:49:28Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-13T14:17:59Z"
      },
      "sha": "ab0b779c765dc42e7de528ca559716d77295913d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDAzY2U3M2E4MjBiNDg1ZmJkYmI4NTRkOWQzOTQ3ZmYxZTZkODc4ODA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "tree": {
        "sha": "d8d9411e8cc37a4f0cdde646ca35da23bdada642",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d8d9411e8cc37a4f0cdde646ca35da23bdada642"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree d8d9411e8cc37a4f0cdde646ca35da23bdada642\nparent ab0b779c765dc42e7de528ca559716d77295913d\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749825814 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1760460568 -0400\n\nSockMan: dispatch cyclical events from I/O loop\n\nCopy from some parts of `CConnman::SocketHandlerConnected()` and\n`CConnman::ThreadSocketHandler()` to:\n`EventIOLoopCompletedForOne(id)` and `EventIOLoopCompletedForAll()`.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjufxgACgkQ5+KYS2KJ\nyToD1hAAp29/dku3D3MOcBgaBx+Nvbd61pVNQtDpix3S6F0bS1E8zzuqOr4aC0Of\nZ7u+8p8dp6aKU3qqMzfnkba1n+rZXYvURvQlwjmUZ+IKDUejNRc4OJXiCwLuzCsv\ni1RZtoEItNpc9O/qiD2k7ygZPfYnrxryF3iBDzQt2hANADY+6wC8xZHFLerTmMsh\nBI4p1rjI1b8ljIqRClClRwHndnyBF7k/9WDb9XIN2gUmGNLDRvRZJnCUGTrwvopa\nOlud4tbbfUFDLoMZ8kS409G0UAmroakvBsYAENBh7iJ1F4BlBYWOSJHXElDvQ4yI\nrdlL5fRdsnr+FA94avuWHkXb7LJc//aJtrY1ZOlUM1jbOYN3b63Jts2SJlEcIDUQ\nggr5I7OIjd1QV7uuWSt5hAFKhC5dJil41tTERMjD06yP7dvyTIflVpWGUXZl/x2l\naGP9PJQd67BmTB6KBZfwkXojMvWYXneQ5rwmT6CJ11SFlFTAbz25LUkep4yPMMTN\nNJW8ziUTgNEJhn1AFio7qixWww8EK2CMyWt9hTVmi8P/wJ13tG296D3V5Gsti4z7\nlzy9oNjvDLzUyn/7Z/FDgI4hPZfGgkS13Ea3oiAC4mELoYB57GN64QM118q+e8nX\nBhQV+360hXkLlLBAFsolfyyLG84xmOc0H8BXzZ5/lxMl4/UGi+c=\n=AxVx\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ab0b779c765dc42e7de528ca559716d77295913d",
          "sha": "ab0b779c765dc42e7de528ca559716d77295913d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ab0b779c765dc42e7de528ca559716d77295913d"
        }
      ],
      "message": "SockMan: dispatch cyclical events from I/O loop\n\nCopy from some parts of `CConnman::SocketHandlerConnected()` and\n`CConnman::ThreadSocketHandler()` to:\n`EventIOLoopCompletedForOne(id)` and `EventIOLoopCompletedForAll()`.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-10-14T16:49:28Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-13T14:43:34Z"
      },
      "sha": "03ce73a820b485fbdbb854d9d3947ff1e6d87880"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20275738370,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAAS4hzcC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20275738370",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "created_at": "2025-10-14T17:33:53Z"
    },
    {
      "event": "reviewed",
      "id": 3324351471,
      "node_id": "PRR_kwDOABII587GJZPv",
      "url": null,
      "actor": null,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-14T17:41:22Z",
      "author_association": "MEMBER",
      "body": "Rebase to 03ce73a820b485fbdbb854d9d3947ff1e6d87880 address conflicts with master, as well as silent conflict from https://github.com/bitcoin/bitcoin/pull/33378. Address feedback from @l0rinc THANKS -- mostly improving \"modernization\" of the code borrowed from `Connman`.\n\nThere is a bigger question about the approach in this PR, which adds code that is dead for now but required for https://github.com/bitcoin/bitcoin/pull/32061. I am going to explore other ways to introduce this code more incrementally, or maybe we can start off by writing `SockMan` as a libevent wrapper, and then replace libevent with our own code once the libevent behavior is asserted by tests.",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-3324351471",
      "submitted_at": "2025-10-14T17:41:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "unlabeled",
      "id": 20276155753,
      "node_id": "UNLE_lADOABII5867bDTqzwAAAAS4jZVp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20276155753",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-14T17:56:38Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2158577472",
      "pull_request_review_id": 2945433124,
      "id": 2158577472,
      "node_id": "PRRC_kwDOABII586AqUdA",
      "diff_hunk": "@@ -0,0 +1,155 @@\n+// Copyright (c) 2021-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::vector<uint8_t> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData() EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received;\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received.assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Larger payloads may require multiple write operations in production\n+                // but since there is no actual network socket involved in the test\n+                // we should be able to simplify.\n+                BOOST_CHECK_EQUAL(sent, m_respond.size());\n+                // Only send the response once\n+                m_respond.clear();\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 90,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9299d5dbc5 `SockMan: introduce class and implement binding to listening socket`\r\n\r\nnit, ensure `Lookup()` succeeded before continuing because below `addr_bind.value()` is used unconditionally:\r\n\r\n```cpp\r\nBOOST_REQUIRE(addr.has_value());\r\n```",
      "created_at": "2025-06-20T10:15:06Z",
      "updated_at": "2025-06-23T10:09:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2158577472",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2158577472"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2158822151",
      "pull_request_review_id": 2945433124,
      "id": 2158822151,
      "node_id": "PRRC_kwDOABII586ArQMH",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 29,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`GetBindAddress()` is the same as in `net.cpp`. It is nice to have this PR remove 0 lines, but I think it is better to make an exception and move the function from `net.cpp` to `netbase.{h,cpp}` and use that from both `net.cpp` and `common/sockman.cpp`.",
      "created_at": "2025-06-20T12:14:30Z",
      "updated_at": "2025-06-23T10:09:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2158822151",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2158822151"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 17,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161187096",
      "pull_request_review_id": 2945433124,
      "id": 2161187096,
      "node_id": "PRRC_kwDOABII586A0RkY",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSockets(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAll();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }\n+\n+        // Service (send/receive) each of the already connected sockets.\n+        SocketHandlerConnected(io_readiness);\n+\n+        // Accept new connections from listening sockets.\n+        SocketHandlerListening(io_readiness.events_per_sock);",
      "path": "src/common/sockman.cpp",
      "position": 258,
      "original_position": 267,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "_674a5ff8f1 `SockMan: handle connected sockets: read data from socket`_\r\n\r\nIn the commit message: `s/conencts/connects/`",
      "created_at": "2025-06-23T09:48:37Z",
      "updated_at": "2025-06-23T10:09:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2161187096",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161187096"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 258,
      "original_line": 258,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161205701",
      "pull_request_review_id": 2945433124,
      "id": 2161205701,
      "node_id": "PRRC_kwDOABII586A0WHF",
      "diff_hunk": "@@ -0,0 +1,151 @@\n+// Copyright (c) 2021-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::vector<uint8_t> m_received;",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 26,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "_674a5ff8f1 `SockMan: handle connected sockets: read data from socket`_\r\n\r\n`m_received` would better be per-client:\r\n```cpp\r\nstd::unordered_map<Id, std::vector<uint8_t>> m_received;\r\n```\r\nand then adjust `EventGotData()` to plug the data in the client's slot:\r\n```cpp\r\nm_received[id].assign(data.begin(), data.end());\r\n```\r\nand `GetReceivedData()` to get the data for the client:\r\n```cpp\r\nGetReceivedData(Id id)\r\n{\r\n    return m_received[id];\r\n}\r\n```",
      "created_at": "2025-06-23T09:57:18Z",
      "updated_at": "2025-06-23T10:09:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2161205701",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161205701"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161216030",
      "pull_request_review_id": 2945433124,
      "id": 2161216030,
      "node_id": "PRRC_kwDOABII586A0Yoe",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,",
      "path": "src/common/sockman.cpp",
      "position": 123,
      "original_position": 191,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "_3f796b69c8 `SockMan: handle connected sockets: write data to socket`_\r\n\r\nIn the commit message: `s/recevied/received/`",
      "created_at": "2025-06-23T10:02:53Z",
      "updated_at": "2025-06-23T10:09:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2161216030",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161216030"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 123,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162235428",
      "pull_request_review_id": 2951071498,
      "id": 2162235428,
      "node_id": "PRRC_kwDOABII586A4Rgk",
      "diff_hunk": "@@ -0,0 +1,155 @@\n+// Copyright (c) 2021-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::vector<uint8_t> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData() EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received;\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received.assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Larger payloads may require multiple write operations in production\n+                // but since there is no actual network socket involved in the test\n+                // we should be able to simplify.\n+                BOOST_CHECK_EQUAL(sent, m_respond.size());\n+                // Only send the response once\n+                m_respond.clear();\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 90,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "in_reply_to_id": 2158577472,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "👍 ",
      "created_at": "2025-06-23T18:18:35Z",
      "updated_at": "2025-06-24T00:43:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2162235428",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162235428"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162288958",
      "pull_request_review_id": 2951071498,
      "id": 2162288958,
      "node_id": "PRRC_kwDOABII586A4ek-",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 29,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "in_reply_to_id": 2158822151,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Oh yes thanks, done by inserting a move-only commit",
      "created_at": "2025-06-23T18:32:08Z",
      "updated_at": "2025-06-24T00:43:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2162288958",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162288958"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 17,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162324748",
      "pull_request_review_id": 2951071498,
      "id": 2162324748,
      "node_id": "PRRC_kwDOABII586A4nUM",
      "diff_hunk": "@@ -0,0 +1,151 @@\n+// Copyright (c) 2021-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::vector<uint8_t> m_received;",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 26,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "in_reply_to_id": 2161205701,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good catch, taken. I was hoping to get away with only ever using one client in this test but this makes more sense for coverage anyway ;-)",
      "created_at": "2025-06-23T18:47:07Z",
      "updated_at": "2025-06-24T00:43:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2162324748",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162324748"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162325395",
      "pull_request_review_id": 2951071498,
      "id": 2162325395,
      "node_id": "PRRC_kwDOABII586A4neT",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSockets(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAll();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }\n+\n+        // Service (send/receive) each of the already connected sockets.\n+        SocketHandlerConnected(io_readiness);\n+\n+        // Accept new connections from listening sockets.\n+        SocketHandlerListening(io_readiness.events_per_sock);",
      "path": "src/common/sockman.cpp",
      "position": 258,
      "original_position": 267,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "in_reply_to_id": 2161187096,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "👍 ",
      "created_at": "2025-06-23T18:47:22Z",
      "updated_at": "2025-06-24T00:43:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2162325395",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162325395"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 258,
      "original_line": 258,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162331716",
      "pull_request_review_id": 2951071498,
      "id": 2162331716,
      "node_id": "PRRC_kwDOABII586A4pBE",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,",
      "path": "src/common/sockman.cpp",
      "position": 123,
      "original_position": 191,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "in_reply_to_id": 2161216030,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "👍 ",
      "created_at": "2025-06-23T18:51:26Z",
      "updated_at": "2025-06-24T00:43:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2162331716",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162331716"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 123,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2226846994",
      "pull_request_review_id": 3049290299,
      "id": 2226846994,
      "node_id": "PRRC_kwDOABII586Euv0S",
      "diff_hunk": "@@ -17,6 +17,7 @@\n #include <pubkey.h>\n #include <stdexcept>\n #include <test/util/random.h>\n+#include <test/util/net.h>",
      "path": "src/test/util/setup_common.h",
      "position": 4,
      "original_position": 4,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "535daaf15fd754335116d17833a45261cdff4e93 nit, sort",
      "created_at": "2025-07-23T22:24:36Z",
      "updated_at": "2025-07-23T22:42:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2226846994",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2226846994"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 19,
      "original_line": 19,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2226848616",
      "pull_request_review_id": 3049290299,
      "id": 2226848616,
      "node_id": "PRRC_kwDOABII586EuwNo",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2021-2022 The Bitcoin Core developers",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "535daaf15fd754335116d17833a45261cdff4e93 (edit, or is this due to the code already existing, if yes, please mention this in the commit message)\r\n\r\n```suggestion\r\n// Copyright (c) 2025-present The Bitcoin Core developers\r\n```",
      "created_at": "2025-07-23T22:25:30Z",
      "updated_at": "2025-07-23T22:46:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2226848616",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2226848616"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260675972",
      "pull_request_review_id": 3097669539,
      "id": 2260675972,
      "node_id": "PRRC_kwDOABII586Gvy2E",
      "diff_hunk": "@@ -17,6 +17,7 @@\n #include <pubkey.h>\n #include <stdexcept>\n #include <test/util/random.h>\n+#include <test/util/net.h>",
      "path": "src/test/util/setup_common.h",
      "position": 4,
      "original_position": 4,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "in_reply_to_id": 2226846994,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "fixed, thanks",
      "created_at": "2025-08-07T15:26:59Z",
      "updated_at": "2025-08-07T15:35:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2260675972",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260675972"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 19,
      "original_line": 19,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260702590",
      "pull_request_review_id": 3097669539,
      "id": 2260702590,
      "node_id": "PRRC_kwDOABII586Gv5V-",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2021-2022 The Bitcoin Core developers",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "in_reply_to_id": 2226848616,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks, removed the years entirely which seems to be the style for new files.",
      "created_at": "2025-08-07T15:34:03Z",
      "updated_at": "2025-08-07T15:35:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2260702590",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260702590"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288381255",
      "pull_request_review_id": 3022243737,
      "id": 2288381255,
      "node_id": "PRRC_kwDOABII586IZe1H",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 128,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could we avoid public data in the initial version?\r\n```C++\r\n    void InterruptNet() { interruptNet(); }\r\n\r\n    const std::vector<std::shared_ptr<Sock>>& ListenSockets() const { return m_listen; }\r\n```\r\nAlternatively make them `protected` and expose them in `TestSockMan`.",
      "created_at": "2025-08-20T14:33:17Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2288381255",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288381255"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 120,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288986758",
      "pull_request_review_id": 3022243737,
      "id": 2288986758,
      "node_id": "PRRC_kwDOABII586IbyqG",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 26,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Might as well:\r\n```suggestion\r\n        std::vector<std::pair<Id, CService>> m_connections GUARDED_BY(m_connections_mutex);\r\n\r\n        // Received data is written here by the SockMan I/O thread\r\n        // and tested by the main thread.\r\n        Mutex m_received_mutex;\r\n        std::unordered_map<Id, std::vector<uint8_t>> m_received GUARDED_BY(m_received_mutex);\r\n```",
      "created_at": "2025-08-20T18:39:53Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2288986758",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288986758"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 21,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288991450",
      "pull_request_review_id": 3022243737,
      "id": 2288991450,
      "node_id": "PRRC_kwDOABII586Ibzza",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 66,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit:\r\n```suggestion\r\n        }\r\n        virtual void EventGotEOF(Id id) override {}\r\n        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {}\r\n```",
      "created_at": "2025-08-20T18:42:14Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2288991450",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288991450"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 64,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288996230",
      "pull_request_review_id": 3022243737,
      "id": 2288996230,
      "node_id": "PRRC_kwDOABII586Ib0-G",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Remove sent bytes until entire response is sent.\n+                m_respond.erase(m_respond.begin(), m_respond.begin() + sent);\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};\n+    BOOST_REQUIRE(addr_bind.has_value());\n+    bilingual_str strError;",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 88,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nits:\r\n1. Should be snake_case.\r\n2. Could be put with the block that uses it.",
      "created_at": "2025-08-20T18:44:37Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2288996230",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288996230"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2289014362",
      "pull_request_review_id": 3022243737,
      "id": 2289014362,
      "node_id": "PRRC_kwDOABII586Ib5Za",
      "diff_hunk": "@@ -270,6 +271,24 @@ std::unique_ptr<T> MakeNoLogFileContext(const ChainType chain_type = ChainType::\n     return std::make_unique<T>(chain_type, opts);\n }\n \n+class SocketTestingSetup : public BasicTestingSetup\n+{\n+public:\n+    explicit SocketTestingSetup();\n+    ~SocketTestingSetup();\n+\n+    // Connect to the socket with a mock client (a DynSock) and send pre-loaded data.\n+    // Returns the I/O pipes from the mock client so we can read response datasent to it.\n+    std::shared_ptr<DynSock::Pipes> ConnectClient(const std::vector<uint8_t>& data);",
      "path": "src/test/util/setup_common.h",
      "position": 1,
      "original_position": 20,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "More modern:\r\n```suggestion\r\n    std::shared_ptr<DynSock::Pipes> ConnectClient(std::span<const std::byte> data);\r\n```",
      "created_at": "2025-08-20T18:53:25Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2289014362",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2289014362"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2289081739",
      "pull_request_review_id": 3022243737,
      "id": 2289081739,
      "node_id": "PRRC_kwDOABII586IcJ2L",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Remove sent bytes until entire response is sent.\n+                m_respond.erase(m_respond.begin(), m_respond.begin() + sent);\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};\n+    BOOST_REQUIRE(addr_bind.has_value());\n+    bilingual_str strError;\n+\n+    // Init state\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 0);\n+    // Bind to mock Listening Socket\n+    BOOST_REQUIRE(sockman.BindAndStartListening(addr_bind.value(), strError));\n+    // We are bound and listening\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 1);\n+\n+    // Name the SockMan I/O thread\n+    SockMan::Options options{\"test_sockman\"};\n+    // Start the I/O loop\n+    sockman.StartSocketsThreads(options);\n+\n+    // No connections yet\n+    BOOST_CHECK_EQUAL(sockman.GetConnectionsCount(), 0);\n+\n+    // Create a mock client with a data payload to send\n+    // and add it to the local CreateSock queue\n+    const std::vector<uint8_t> request = {'b', 'i', 't', 's'};\n+    auto pipes{ConnectClient(request)};\n+\n+    // Wait up to a minute to find and connect the client in the I/O loop\n+    int attempts{6000};\n+    while (sockman.GetConnectionsCount() < 1) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Inspect the connection\n+    auto client{sockman.GetFirstConnection()};\n+    BOOST_CHECK_EQUAL(client.second.ToStringAddrPort(), \"5.5.5.5:6789\");\n+\n+    // Wait up to a minute to read the data from the connection\n+    attempts = 6000;\n+    while (!std::ranges::equal(sockman.GetReceivedData(client.first), request)) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Wait up to a minute to write our response data back to the connection\n+    attempts = 6000;\n+    size_t expected_response_size = sockman.m_respond.size();\n+    std::vector<uint8_t> actually_received(expected_response_size);\n+    while (!std::ranges::equal(actually_received, sockman.m_respond)) {\n+        // Read the data received by the mock socket\n+        ssize_t bytes_read = pipes->send.GetBytes((void *)actually_received.data(), expected_response_size);",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 134,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: No need to cast to `void*`:\r\n```suggestion\r\n        ssize_t bytes_read = pipes->send.GetBytes(actually_received.data(), expected_response_size);\r\n```",
      "created_at": "2025-08-20T19:21:13Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2289081739",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2289081739"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293235155",
      "pull_request_review_id": 3022243737,
      "id": 2293235155,
      "node_id": "PRRC_kwDOABII586Ir_3T",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Maybe update/remove year? (Not a copyright lawyer).",
      "created_at": "2025-08-22T09:39:52Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293235155",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293235155"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293246152",
      "pull_request_review_id": 3022243737,
      "id": 2293246152,
      "node_id": "PRRC_kwDOABII586IsCjI",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] id Id of the connection whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that connection will be omitted.\n+     */\n+    virtual void EventReadyToSend(Id id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] id Connection for which the data arrived.\n+     * @param[in] data Received data.\n+     */\n+    virtual void EventGotData(Id id, std::span<const uint8_t> data) = 0;\n+\n+    /**\n+     * Called when the remote peer has sent an EOF on the socket. This is a graceful\n+     * close of their writing side, we can still send and they will receive, if it\n+     * makes sense at the application level.\n+     * @param[in] id Connection whose socket got EOF.\n+     */\n+    virtual void EventGotEOF(Id id) = 0;\n+\n+    /**\n+     * Called when we get an irrecoverable error trying to read from a socket.\n+     * @param[in] id Connection whose socket got an error.\n+     * @param[in] errmsg Message describing the error.\n+     */\n+    virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) = 0;\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Can be used to temporarily pause sends on a connection.\n+     * SockMan would only call Send() if this returns true.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next call to EventReadyToSend().\n+     */\n+    virtual bool ShouldTryToSend(Id id) const;\n+\n+    /**\n+     * SockMan would only call Recv() on a connection's socket if this returns true.\n+     * Can be used to temporarily pause receives on a connection.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next receive.\n+     */\n+    virtual bool ShouldTryToRecv(Id id) const;\n+\n+    /**\n+     * SockMan has completed the current send+recv iteration for a given connection.\n+     * It will do another send+recv for this connection after processing all other connections.\n+     * Can be used to execute periodic tasks for a given connection.\n+     * The implementation in SockMan does nothing.\n+     * @param[in] id Connection for which send+recv has been done.\n+     */\n+    virtual void EventIOLoopCompletedForOne(Id id);\n+\n+    /**\n+     * SockMan has completed send+recv for all connections.\n+     * Can be used to execute periodic tasks for all connections, like closing\n+     * connections due to higher level logic.\n+     * The implementation in SockMan does nothing.\n+     */\n+    virtual void EventIOLoopCompletedForAll();\n+\n+    /**\n+     * The sockets used by a connection.\n+     */\n+    struct ConnectionSockets {\n+        explicit ConnectionSockets(std::unique_ptr<Sock>&& s)\n+            : sock{std::move(s)}\n+        {\n+        }\n+\n+        /**\n+         * Mutex that serializes the Send() and Recv() calls on `sock`.\n+         */\n+        Mutex mutex;\n+\n+        /**\n+         * Underlying socket.\n+         * `shared_ptr` (instead of `unique_ptr`) is used to avoid premature close of the\n+         * underlying file descriptor by one thread while another thread is poll(2)-ing\n+         * it for activity.\n+         * @see https://github.com/bitcoin/bitcoin/issues/21744 for details.\n+         */\n+        std::shared_ptr<Sock> sock;\n+    };\n+\n+    /**\n+     * Info about which socket has which event ready and its connection id.\n+     */\n+    struct IOReadiness {\n+        /**\n+         * Map of socket -> socket events. For example:\n+         * socket1 -> { requested = SEND|RECV, occurred = RECV }\n+         * socket2 -> { requested = SEND, occurred = SEND }\n+         */\n+        Sock::EventsPerSock events_per_sock;\n+\n+        /**\n+         * Map of socket -> connection id (in `m_connected`). For example\n+         * socket1 -> id=23\n+         * socket2 -> id=56\n+         */\n+        std::unordered_map<Sock::EventsPerSock::key_type,\n+                           SockMan::Id,\n+                           Sock::HashSharedPtrSock,\n+                           Sock::EqualSharedPtrSock>\n+            ids_per_sock;\n+    };\n+\n+    /**\n+     * Check connected and listening sockets for IO readiness and process them accordingly.\n+     */\n+    void ThreadSocketHandler()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate a collection of sockets to check for IO readiness.\n+     * @return Sockets to check for readiness plus an aux map to find the\n+     * corresponding connection id given a socket.\n+     */\n+    IOReadiness GenerateWaitSockets()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Do the read/write for connected sockets that are ready for IO.\n+     * @param[in] io_readiness Which sockets are ready and their connection ids.\n+     */\n+    void SocketHandlerConnected(const IOReadiness& io_readiness)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Accept incoming connections, one from each read-ready listening socket.\n+     * @param[in] events_per_sock Sockets that are ready for IO.\n+     */\n+    void SocketHandlerListening(const Sock::EventsPerSock& events_per_sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Retrieve an entry from m_connected.\n+     * @param[in] id Connection id to search for.\n+     * @return ConnectionSockets for the given connection id or empty shared_ptr if not found.\n+     */\n+    std::shared_ptr<ConnectionSockets> GetConnectionSockets(Id id) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * The id to assign to the next created connection. Used to generate ids of connections.",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 303,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit:\r\n```suggestion\r\n     * Used to generate ids for new connections.\r\n```",
      "created_at": "2025-08-22T09:44:53Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293246152",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293246152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 303,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293305352",
      "pull_request_review_id": 3022243737,
      "id": 2293305352,
      "node_id": "PRRC_kwDOABII586IsRAI",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 34,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could assert that various conditions are true:\r\n```suggestion\r\n    virtual ~SockMan()\r\n    {\r\n        assert(!m_thread_socket_handler.joinable()); // Missing call to JoinSocketsThreads()\r\n        assert(m_connected.empty()); // Missing call to CloseConnection()\r\n        assert(m_listen.empty()); // Missing call to StopListening()\r\n    }\r\n```\r\nhttps://en.cppreference.com/w/cpp/thread/thread/join.html#Postconditions",
      "created_at": "2025-08-22T10:11:06Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293305352",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293305352"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293330692",
      "pull_request_review_id": 3022243737,
      "id": 2293330692,
      "node_id": "PRRC_kwDOABII586IsXME",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 113,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could verify that we are operating on one of our own listen sockets?\r\n```suggestion\r\n{\r\n    Assume(std::ranges::find_if(m_listen, [&](const auto& sock) { return sock.get() == &listen_sock; }) != m_listen.end());\r\n```",
      "created_at": "2025-08-22T10:19:46Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293330692",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293330692"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 113,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293785752",
      "pull_request_review_id": 3022243737,
      "id": 2293785752,
      "node_id": "PRRC_kwDOABII586IuGSY",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 39,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Cast can be omitted here and a few lines down for `IPV6_V6ONLY` and `IPV6_PROTECTION_LEVEL`:\r\n```suggestion\r\n    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == SOCKET_ERROR) {\r\n```",
      "created_at": "2025-08-22T13:46:14Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293785752",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293785752"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293830000",
      "pull_request_review_id": 3022243737,
      "id": 2293830000,
      "node_id": "PRRC_kwDOABII586IuRFw",
      "diff_hunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    SockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr{Lookup(\"0.0.0.0\", 0, false)};",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 18,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "72864e46283550d408ca4a826786491e7cb36100",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Could call this `addr_bind` from first commit instead of renaming it later.",
      "created_at": "2025-08-22T14:03:43Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293830000",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293830000"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293838294",
      "pull_request_review_id": 3022243737,
      "id": 2293838294,
      "node_id": "PRRC_kwDOABII586IuTHW",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 88,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should these 3 not be `protected`/`private`?",
      "created_at": "2025-08-22T14:07:24Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293838294",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293838294"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 73,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293846814",
      "pull_request_review_id": 3022243737,
      "id": 2293846814,
      "node_id": "PRRC_kwDOABII586IuVMe",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] id Id of the connection whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that connection will be omitted.\n+     */\n+    virtual void EventReadyToSend(Id id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] id Connection for which the data arrived.\n+     * @param[in] data Received data.\n+     */\n+    virtual void EventGotData(Id id, std::span<const uint8_t> data) = 0;\n+\n+    /**\n+     * Called when the remote peer has sent an EOF on the socket. This is a graceful\n+     * close of their writing side, we can still send and they will receive, if it\n+     * makes sense at the application level.\n+     * @param[in] id Connection whose socket got EOF.\n+     */\n+    virtual void EventGotEOF(Id id) = 0;\n+\n+    /**\n+     * Called when we get an irrecoverable error trying to read from a socket.\n+     * @param[in] id Connection whose socket got an error.\n+     * @param[in] errmsg Message describing the error.\n+     */\n+    virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) = 0;\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Can be used to temporarily pause sends on a connection.\n+     * SockMan would only call Send() if this returns true.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next call to EventReadyToSend().\n+     */\n+    virtual bool ShouldTryToSend(Id id) const;\n+\n+    /**\n+     * SockMan would only call Recv() on a connection's socket if this returns true.\n+     * Can be used to temporarily pause receives on a connection.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next receive.\n+     */\n+    virtual bool ShouldTryToRecv(Id id) const;\n+\n+    /**\n+     * SockMan has completed the current send+recv iteration for a given connection.\n+     * It will do another send+recv for this connection after processing all other connections.\n+     * Can be used to execute periodic tasks for a given connection.\n+     * The implementation in SockMan does nothing.\n+     * @param[in] id Connection for which send+recv has been done.\n+     */\n+    virtual void EventIOLoopCompletedForOne(Id id);\n+\n+    /**\n+     * SockMan has completed send+recv for all connections.\n+     * Can be used to execute periodic tasks for all connections, like closing\n+     * connections due to higher level logic.\n+     * The implementation in SockMan does nothing.\n+     */\n+    virtual void EventIOLoopCompletedForAll();\n+\n+    /**\n+     * The sockets used by a connection.\n+     */\n+    struct ConnectionSockets {",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 222,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What is the reason for plural form?\r\n```suggestion\r\n    struct ConnectionSocket {\r\n```",
      "created_at": "2025-08-22T14:10:06Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293846814",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293846814"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293866540",
      "pull_request_review_id": 3022243737,
      "id": 2293866540,
      "node_id": "PRRC_kwDOABII586IuaAs",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSockets(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 203,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: -cast +newline\r\n```suggestion\r\n        return sockets->sock->Send(data.data(), data.size(), flags);\r\n    )};\r\n```",
      "created_at": "2025-08-22T14:17:57Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293866540",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293866540"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293894853",
      "pull_request_review_id": 3022243737,
      "id": 2293894853,
      "node_id": "PRRC_kwDOABII586Iug7F",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)",
      "path": "src/test/sockman_tests.cpp",
      "position": 55,
      "original_position": 51,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: I liked the style you had in sockman.h\r\n```suggestion\r\n            EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\r\n```",
      "created_at": "2025-08-22T14:29:14Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293894853",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293894853"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 55,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297305441",
      "pull_request_review_id": 3022243737,
      "id": 2297305441,
      "node_id": "PRRC_kwDOABII586I7hlh",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 110,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n                      std::span<const std::byte> data,\r\n```",
      "created_at": "2025-08-25T07:13:18Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2297305441",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297305441"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297308601",
      "pull_request_review_id": 3022243737,
      "id": 2297308601,
      "node_id": "PRRC_kwDOABII586I7iW5",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSockets(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAll();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }\n+\n+        // Service (send/receive) each of the already connected sockets.\n+        SocketHandlerConnected(io_readiness);\n+\n+        // Accept new connections from listening sockets.\n+        SocketHandlerListening(io_readiness.events_per_sock);\n+    }\n+}\n+\n+SockMan::IOReadiness SockMan::GenerateWaitSockets()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    IOReadiness io_readiness;\n+\n+    for (const auto& sock : m_listen) {\n+        io_readiness.events_per_sock.emplace(sock, Sock::Events{Sock::RECV});\n+    }\n+\n+    auto connected_snapshot{WITH_LOCK(m_connected_mutex, return m_connected;)};\n+\n+    for (const auto& [id, sockets] : connected_snapshot) {\n+        const bool select_recv{ShouldTryToRecv(id)};\n+        const bool select_send{ShouldTryToSend(id)};\n+        if (!select_recv && !select_send) continue;\n+\n+        Sock::Event event = (select_send ? Sock::SEND : 0) | (select_recv ? Sock::RECV : 0);\n+        io_readiness.events_per_sock.emplace(sockets->sock, Sock::Events{event});\n+        io_readiness.ids_per_sock.emplace(sockets->sock, id);\n+    }\n+\n+    return io_readiness;\n+}\n+\n+void SockMan::SocketHandlerConnected(const IOReadiness& io_readiness)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    for (const auto& [sock, events] : io_readiness.events_per_sock) {\n+        if (interruptNet) {\n+            return;\n+        }\n+\n+        auto it{io_readiness.ids_per_sock.find(sock)};\n+        if (it == io_readiness.ids_per_sock.end()) {\n+            continue;\n+        }\n+        const Id id{it->second};\n+\n+        bool send_ready = events.occurred & Sock::SEND; // Sock::SEND could only be set if ShouldTryToSend() has returned true in GenerateWaitSockets().\n+        bool recv_ready = events.occurred & Sock::RECV; // Sock::RECV could only be set if ShouldTryToRecv() has returned true in GenerateWaitSockets().\n+        bool err_ready = events.occurred & Sock::ERR;\n+\n+        if (send_ready) {\n+            bool cancel_recv;\n+\n+            EventReadyToSend(id, cancel_recv);\n+\n+            if (cancel_recv) {\n+                recv_ready = false;\n+            }\n+        }\n+\n+        if (recv_ready || err_ready) {\n+            uint8_t buf[0x10000]; // typical socket buffer is 8K-64K\n+\n+            auto sockets{GetConnectionSockets(id)};\n+            if (!sockets) {\n+                continue;\n+            }\n+\n+            const ssize_t nrecv{WITH_LOCK(\n+                sockets->mutex,\n+                return sockets->sock->Recv(buf, sizeof(buf), MSG_DONTWAIT);)};\n+\n+            if (nrecv < 0) { // In all cases (including -1 and 0) EventIOLoopCompletedForOne() should be executed after this, don't change the code to skip it.\n+                const int err = WSAGetLastError();\n+                if (err != WSAEWOULDBLOCK && err != WSAEMSGSIZE && err != WSAEINTR && err != WSAEINPROGRESS) {\n+                    EventGotPermanentReadError(id, NetworkErrorString(err));\n+                }\n+            } else if (nrecv == 0) {\n+                EventGotEOF(id);",
      "path": "src/common/sockman.cpp",
      "position": 334,
      "original_position": 329,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should we close the connection if we get EOF? See 972ee5cf6544c5c1ea4d445dc9c6fed16136c10c.",
      "created_at": "2025-08-25T07:15:05Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2297308601",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297308601"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 334,
      "original_line": 334,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297310218",
      "pull_request_review_id": 3022243737,
      "id": 2297310218,
      "node_id": "PRRC_kwDOABII586I7iwK",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] id Id of the connection whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that connection will be omitted.\n+     */\n+    virtual void EventReadyToSend(Id id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] id Connection for which the data arrived.\n+     * @param[in] data Received data.\n+     */\n+    virtual void EventGotData(Id id, std::span<const uint8_t> data) = 0;",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 164,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n    virtual void EventGotData(Id id, std::span<const std::byte> data) = 0;\r\n```",
      "created_at": "2025-08-25T07:15:57Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2297310218",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297310218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297336625",
      "pull_request_review_id": 3022243737,
      "id": 2297336625,
      "node_id": "PRRC_kwDOABII586I7pMx",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 63,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It could be more realistic to account for network stream being broken up:\r\n```suggestion\r\n            auto& vec{m_received[id]};\r\n            vec.insert(vec.end(), data.begin(), data.end());\r\n```\r\nImplemented a slightly tangential change in my suggestions branch to make `DynSock[::Pipe]` support simulating partial I/O in the vein of TCP/IP streams, see a5e7157563fc9866a75908cef65f7353109b6976.",
      "created_at": "2025-08-25T07:29:04Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2297336625",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297336625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300320948",
      "pull_request_review_id": 3022243737,
      "id": 2300320948,
      "node_id": "PRRC_kwDOABII586JHBy0",
      "diff_hunk": "@@ -601,6 +601,42 @@ void TestChain100Setup::MockMempoolMinFee(const CFeeRate& target_feerate)\n     m_node.mempool->TrimToSize(0);\n     assert(m_node.mempool->GetMinFee() == target_feerate);\n }\n+\n+SocketTestingSetup::SocketTestingSetup()\n+    : m_create_sock_orig{CreateSock}\n+{\n+    CreateSock = [this](int, int, int) {\n+        // This is a mock Listening Socket that a server can \"bind\" to and\n+        // listen to for incoming connections. We won't need to access its I/O\n+        // pipes because we don't read or write directly to it. It will return\n+        // Connected Sockets from the queue via its Accept() method.\n+        return std::make_unique<DynSock>(std::make_shared<DynSock::Pipes>(), m_accepted_sockets);\n+    };\n+};\n+\n+SocketTestingSetup::~SocketTestingSetup()\n+{\n+    CreateSock = m_create_sock_orig;\n+}\n+\n+std::shared_ptr<DynSock::Pipes> SocketTestingSetup::ConnectClient(const std::vector<uint8_t>& data)\n+{\n+    // I/O pipes for a mock Connected Socket we can read and write to.\n+    std::shared_ptr<DynSock::Pipes> connected_socket_pipes(std::make_shared<DynSock::Pipes>());\n+\n+    // Insert the payload\n+    connected_socket_pipes->recv.PushBytes(data.data(), data.size());\n+\n+    // Create the Mock Connected Socket that represents a client.\n+    // It needs I/O pipes but its queue can remain empty\n+    std::unique_ptr<DynSock> connected_socket{std::make_unique<DynSock>(connected_socket_pipes, std::make_shared<DynSock::Queue>())};",
      "path": "src/test/util/setup_common.cpp",
      "position": 32,
      "original_position": 32,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Managed to remove `shared_ptr` usage internally in `DynSock`, see commit 7e894f39c41e2ba332aafc5879d7d7380cbcf2fd from my suggestions branch.",
      "created_at": "2025-08-26T09:03:00Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2300320948",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300320948"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 647,
      "original_line": 647,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300323835",
      "pull_request_review_id": 3022243737,
      "id": 2300323835,
      "node_id": "PRRC_kwDOABII586JHCf7",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Remove sent bytes until entire response is sent.\n+                m_respond.erase(m_respond.begin(), m_respond.begin() + sent);\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};\n+    BOOST_REQUIRE(addr_bind.has_value());\n+    bilingual_str strError;\n+\n+    // Init state\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 0);\n+    // Bind to mock Listening Socket\n+    BOOST_REQUIRE(sockman.BindAndStartListening(addr_bind.value(), strError));\n+    // We are bound and listening\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 1);\n+\n+    // Name the SockMan I/O thread\n+    SockMan::Options options{\"test_sockman\"};\n+    // Start the I/O loop\n+    sockman.StartSocketsThreads(options);\n+\n+    // No connections yet\n+    BOOST_CHECK_EQUAL(sockman.GetConnectionsCount(), 0);\n+\n+    // Create a mock client with a data payload to send\n+    // and add it to the local CreateSock queue\n+    const std::vector<uint8_t> request = {'b', 'i', 't', 's'};\n+    auto pipes{ConnectClient(request)};\n+\n+    // Wait up to a minute to find and connect the client in the I/O loop\n+    int attempts{6000};\n+    while (sockman.GetConnectionsCount() < 1) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Inspect the connection\n+    auto client{sockman.GetFirstConnection()};\n+    BOOST_CHECK_EQUAL(client.second.ToStringAddrPort(), \"5.5.5.5:6789\");\n+\n+    // Wait up to a minute to read the data from the connection\n+    attempts = 6000;\n+    while (!std::ranges::equal(sockman.GetReceivedData(client.first), request)) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Wait up to a minute to write our response data back to the connection\n+    attempts = 6000;\n+    size_t expected_response_size = sockman.m_respond.size();\n+    std::vector<uint8_t> actually_received(expected_response_size);\n+    while (!std::ranges::equal(actually_received, sockman.m_respond)) {\n+        // Read the data received by the mock socket\n+        ssize_t bytes_read = pipes->send.GetBytes((void *)actually_received.data(), expected_response_size);",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 134,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Implemented simulating partial transfer of stream in 6a74e1e9a7393ad51d7a1590384c8a6771b04972 (requires parent commit).",
      "created_at": "2025-08-26T09:04:07Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2300323835",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300323835"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300366190",
      "pull_request_review_id": 3022243737,
      "id": 2300366190,
      "node_id": "PRRC_kwDOABII586JHM1u",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;",
      "path": "src/common/sockman.h",
      "position": 122,
      "original_position": 147,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could add an `EventConnectionClosed()` to mirror this? See 0ca4fac1009017cddff9864ec9cac73d613d67f4.",
      "created_at": "2025-08-26T09:20:37Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2300366190",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300366190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": 120,
      "original_start_line": 145,
      "start_side": "RIGHT",
      "line": 122,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344586648",
      "pull_request_review_id": 3217223929,
      "id": 2344586648,
      "node_id": "PRRC_kwDOABII586Lv42Y",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSockets(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAll();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }\n+\n+        // Service (send/receive) each of the already connected sockets.\n+        SocketHandlerConnected(io_readiness);\n+\n+        // Accept new connections from listening sockets.\n+        SocketHandlerListening(io_readiness.events_per_sock);\n+    }\n+}\n+\n+SockMan::IOReadiness SockMan::GenerateWaitSockets()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    IOReadiness io_readiness;\n+\n+    for (const auto& sock : m_listen) {\n+        io_readiness.events_per_sock.emplace(sock, Sock::Events{Sock::RECV});\n+    }\n+\n+    auto connected_snapshot{WITH_LOCK(m_connected_mutex, return m_connected;)};\n+\n+    for (const auto& [id, sockets] : connected_snapshot) {\n+        const bool select_recv{ShouldTryToRecv(id)};\n+        const bool select_send{ShouldTryToSend(id)};\n+        if (!select_recv && !select_send) continue;\n+\n+        Sock::Event event = (select_send ? Sock::SEND : 0) | (select_recv ? Sock::RECV : 0);\n+        io_readiness.events_per_sock.emplace(sockets->sock, Sock::Events{event});\n+        io_readiness.ids_per_sock.emplace(sockets->sock, id);\n+    }\n+\n+    return io_readiness;\n+}\n+\n+void SockMan::SocketHandlerConnected(const IOReadiness& io_readiness)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    for (const auto& [sock, events] : io_readiness.events_per_sock) {\n+        if (interruptNet) {\n+            return;\n+        }\n+\n+        auto it{io_readiness.ids_per_sock.find(sock)};\n+        if (it == io_readiness.ids_per_sock.end()) {\n+            continue;\n+        }\n+        const Id id{it->second};\n+\n+        bool send_ready = events.occurred & Sock::SEND; // Sock::SEND could only be set if ShouldTryToSend() has returned true in GenerateWaitSockets().\n+        bool recv_ready = events.occurred & Sock::RECV; // Sock::RECV could only be set if ShouldTryToRecv() has returned true in GenerateWaitSockets().\n+        bool err_ready = events.occurred & Sock::ERR;\n+\n+        if (send_ready) {\n+            bool cancel_recv;\n+\n+            EventReadyToSend(id, cancel_recv);\n+\n+            if (cancel_recv) {\n+                recv_ready = false;\n+            }\n+        }\n+\n+        if (recv_ready || err_ready) {\n+            uint8_t buf[0x10000]; // typical socket buffer is 8K-64K\n+\n+            auto sockets{GetConnectionSockets(id)};\n+            if (!sockets) {\n+                continue;\n+            }\n+\n+            const ssize_t nrecv{WITH_LOCK(\n+                sockets->mutex,\n+                return sockets->sock->Recv(buf, sizeof(buf), MSG_DONTWAIT);)};\n+\n+            if (nrecv < 0) { // In all cases (including -1 and 0) EventIOLoopCompletedForOne() should be executed after this, don't change the code to skip it.\n+                const int err = WSAGetLastError();\n+                if (err != WSAEWOULDBLOCK && err != WSAEMSGSIZE && err != WSAEINTR && err != WSAEINPROGRESS) {\n+                    EventGotPermanentReadError(id, NetworkErrorString(err));\n+                }\n+            } else if (nrecv == 0) {\n+                EventGotEOF(id);",
      "path": "src/common/sockman.cpp",
      "position": 334,
      "original_position": 329,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2297308601,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That's for the consumer / child class of `SockMan` to decide!\r\n\r\nFor example in the HTTP server follow-up to this it's here: \r\n\r\nhttps://github.com/bitcoin/bitcoin/pull/32061/commits/badf3c38b3b1dab2d209a8e2c709e83afe9e4402#diff-63c8cb9c9dd61d50d59afd5c39914e1c259f8743030b637a7896a0746c851ef1R1208",
      "created_at": "2025-09-12T15:19:24Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2344586648",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344586648"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 334,
      "original_line": 334,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344930562",
      "pull_request_review_id": 3217223929,
      "id": 2344930562,
      "node_id": "PRRC_kwDOABII586LxM0C",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSockets(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 203,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293866540,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for catching this, opened https://github.com/bitcoin/bitcoin/pull/33378 to clean up several such casts in existing code since this chunk was essentially copied from `net.cpp`.",
      "created_at": "2025-09-12T17:01:59Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2344930562",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344930562"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344946486",
      "pull_request_review_id": 3217223929,
      "id": 2344946486,
      "node_id": "PRRC_kwDOABII586LxQs2",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 128,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2288381255,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes will make these data private/protected and add public helpers.",
      "created_at": "2025-09-12T17:07:54Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2344946486",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344946486"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 120,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344956173",
      "pull_request_review_id": 3217223929,
      "id": 2344956173,
      "node_id": "PRRC_kwDOABII586LxTEN",
      "diff_hunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    SockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr{Lookup(\"0.0.0.0\", 0, false)};",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 18,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "72864e46283550d408ca4a826786491e7cb36100",
      "in_reply_to_id": 2293830000,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yep thanks",
      "created_at": "2025-09-12T17:11:14Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2344956173",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344956173"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344995517",
      "pull_request_review_id": 3217223929,
      "id": 2344995517,
      "node_id": "PRRC_kwDOABII586Lxcq9",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Remove sent bytes until entire response is sent.\n+                m_respond.erase(m_respond.begin(), m_respond.begin() + sent);\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};\n+    BOOST_REQUIRE(addr_bind.has_value());\n+    bilingual_str strError;",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 88,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2288996230,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2025-09-12T17:27:50Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2344995517",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344995517"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344997699",
      "pull_request_review_id": 3217223929,
      "id": 2344997699,
      "node_id": "PRRC_kwDOABII586LxdND",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293235155,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "You're right for new files we're removing the year(s) entirely.",
      "created_at": "2025-09-12T17:29:03Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2344997699",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344997699"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345010900",
      "pull_request_review_id": 3217223929,
      "id": 2345010900,
      "node_id": "PRRC_kwDOABII586LxgbU",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 39,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293785752,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good catch see https://github.com/bitcoin/bitcoin/pull/33378",
      "created_at": "2025-09-12T17:35:47Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345010900",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345010900"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345020780",
      "pull_request_review_id": 3217223929,
      "id": 2345020780,
      "node_id": "PRRC_kwDOABII586Lxi1s",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 113,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293330692,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Sure taken",
      "created_at": "2025-09-12T17:41:05Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345020780",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345020780"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 113,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345071368",
      "pull_request_review_id": 3217223929,
      "id": 2345071368,
      "node_id": "PRRC_kwDOABII586LxvMI",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 88,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293838294,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yeah they can be thanks.",
      "created_at": "2025-09-12T18:07:50Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345071368",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345071368"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 73,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345103522",
      "pull_request_review_id": 3217223929,
      "id": 2345103522,
      "node_id": "PRRC_kwDOABII586Lx3Ci",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 26,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2288986758,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "👍 ",
      "created_at": "2025-09-12T18:26:02Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345103522",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345103522"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 21,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345117449",
      "pull_request_review_id": 3217223929,
      "id": 2345117449,
      "node_id": "PRRC_kwDOABII586Lx6cJ",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] id Id of the connection whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that connection will be omitted.\n+     */\n+    virtual void EventReadyToSend(Id id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] id Connection for which the data arrived.\n+     * @param[in] data Received data.\n+     */\n+    virtual void EventGotData(Id id, std::span<const uint8_t> data) = 0;\n+\n+    /**\n+     * Called when the remote peer has sent an EOF on the socket. This is a graceful\n+     * close of their writing side, we can still send and they will receive, if it\n+     * makes sense at the application level.\n+     * @param[in] id Connection whose socket got EOF.\n+     */\n+    virtual void EventGotEOF(Id id) = 0;\n+\n+    /**\n+     * Called when we get an irrecoverable error trying to read from a socket.\n+     * @param[in] id Connection whose socket got an error.\n+     * @param[in] errmsg Message describing the error.\n+     */\n+    virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) = 0;\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Can be used to temporarily pause sends on a connection.\n+     * SockMan would only call Send() if this returns true.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next call to EventReadyToSend().\n+     */\n+    virtual bool ShouldTryToSend(Id id) const;\n+\n+    /**\n+     * SockMan would only call Recv() on a connection's socket if this returns true.\n+     * Can be used to temporarily pause receives on a connection.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next receive.\n+     */\n+    virtual bool ShouldTryToRecv(Id id) const;\n+\n+    /**\n+     * SockMan has completed the current send+recv iteration for a given connection.\n+     * It will do another send+recv for this connection after processing all other connections.\n+     * Can be used to execute periodic tasks for a given connection.\n+     * The implementation in SockMan does nothing.\n+     * @param[in] id Connection for which send+recv has been done.\n+     */\n+    virtual void EventIOLoopCompletedForOne(Id id);\n+\n+    /**\n+     * SockMan has completed send+recv for all connections.\n+     * Can be used to execute periodic tasks for all connections, like closing\n+     * connections due to higher level logic.\n+     * The implementation in SockMan does nothing.\n+     */\n+    virtual void EventIOLoopCompletedForAll();\n+\n+    /**\n+     * The sockets used by a connection.\n+     */\n+    struct ConnectionSockets {",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 222,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293846814,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'll fix, this is leftover from the original SockMan PR #30988 where this struct also included an I2P session.",
      "created_at": "2025-09-12T18:32:39Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345117449",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345117449"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345170456",
      "pull_request_review_id": 3217223929,
      "id": 2345170456,
      "node_id": "PRRC_kwDOABII586LyHYY",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 34,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293305352,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok I'll add these checks but I'm nervous about `assert()` so I'm going to use `Assume()` for now. In this case if there is a broken assumption it will only occur during server shutdown, but I don't want to terminate the program early in case there is still wallet cleanup scheduled after `~SockMan`. Lemme know if you think it should still be `assert()`.",
      "created_at": "2025-09-12T18:58:02Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345170456",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345170456"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345178689",
      "pull_request_review_id": 3217223929,
      "id": 2345178689,
      "node_id": "PRRC_kwDOABII586LyJZB",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)",
      "path": "src/test/sockman_tests.cpp",
      "position": 55,
      "original_position": 51,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293894853,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "🆒 ",
      "created_at": "2025-09-12T19:02:10Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345178689",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345178689"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 55,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345192358",
      "pull_request_review_id": 3217223929,
      "id": 2345192358,
      "node_id": "PRRC_kwDOABII586LyMum",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 66,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2288991450,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "👍 ",
      "created_at": "2025-09-12T19:07:24Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345192358",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345192358"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 64,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345201886",
      "pull_request_review_id": 3217223929,
      "id": 2345201886,
      "node_id": "PRRC_kwDOABII586LyPDe",
      "diff_hunk": "@@ -270,6 +271,24 @@ std::unique_ptr<T> MakeNoLogFileContext(const ChainType chain_type = ChainType::\n     return std::make_unique<T>(chain_type, opts);\n }\n \n+class SocketTestingSetup : public BasicTestingSetup\n+{\n+public:\n+    explicit SocketTestingSetup();\n+    ~SocketTestingSetup();\n+\n+    // Connect to the socket with a mock client (a DynSock) and send pre-loaded data.\n+    // Returns the I/O pipes from the mock client so we can read response datasent to it.\n+    std::shared_ptr<DynSock::Pipes> ConnectClient(const std::vector<uint8_t>& data);",
      "path": "src/test/util/setup_common.h",
      "position": 1,
      "original_position": 20,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2289014362,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i like it thanks",
      "created_at": "2025-09-12T19:11:06Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345201886",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345201886"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345254860",
      "pull_request_review_id": 3217223929,
      "id": 2345254860,
      "node_id": "PRRC_kwDOABII586Lyb_M",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] id Id of the connection whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that connection will be omitted.\n+     */\n+    virtual void EventReadyToSend(Id id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] id Connection for which the data arrived.\n+     * @param[in] data Received data.\n+     */\n+    virtual void EventGotData(Id id, std::span<const uint8_t> data) = 0;",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 164,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2297310218,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yes thanks",
      "created_at": "2025-09-12T19:37:28Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345254860",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345254860"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345282425",
      "pull_request_review_id": 3217223929,
      "id": 2345282425,
      "node_id": "PRRC_kwDOABII586Lyit5",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 110,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2297305441,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yes thanks",
      "created_at": "2025-09-12T19:49:41Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345282425",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345282425"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345329538",
      "pull_request_review_id": 3217223929,
      "id": 2345329538,
      "node_id": "PRRC_kwDOABII586LyuOC",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Remove sent bytes until entire response is sent.\n+                m_respond.erase(m_respond.begin(), m_respond.begin() + sent);\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};\n+    BOOST_REQUIRE(addr_bind.has_value());\n+    bilingual_str strError;\n+\n+    // Init state\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 0);\n+    // Bind to mock Listening Socket\n+    BOOST_REQUIRE(sockman.BindAndStartListening(addr_bind.value(), strError));\n+    // We are bound and listening\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 1);\n+\n+    // Name the SockMan I/O thread\n+    SockMan::Options options{\"test_sockman\"};\n+    // Start the I/O loop\n+    sockman.StartSocketsThreads(options);\n+\n+    // No connections yet\n+    BOOST_CHECK_EQUAL(sockman.GetConnectionsCount(), 0);\n+\n+    // Create a mock client with a data payload to send\n+    // and add it to the local CreateSock queue\n+    const std::vector<uint8_t> request = {'b', 'i', 't', 's'};\n+    auto pipes{ConnectClient(request)};\n+\n+    // Wait up to a minute to find and connect the client in the I/O loop\n+    int attempts{6000};\n+    while (sockman.GetConnectionsCount() < 1) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Inspect the connection\n+    auto client{sockman.GetFirstConnection()};\n+    BOOST_CHECK_EQUAL(client.second.ToStringAddrPort(), \"5.5.5.5:6789\");\n+\n+    // Wait up to a minute to read the data from the connection\n+    attempts = 6000;\n+    while (!std::ranges::equal(sockman.GetReceivedData(client.first), request)) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Wait up to a minute to write our response data back to the connection\n+    attempts = 6000;\n+    size_t expected_response_size = sockman.m_respond.size();\n+    std::vector<uint8_t> actually_received(expected_response_size);\n+    while (!std::ranges::equal(actually_received, sockman.m_respond)) {\n+        // Read the data received by the mock socket\n+        ssize_t bytes_read = pipes->send.GetBytes((void *)actually_received.data(), expected_response_size);",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 134,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2289081739,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "you're right thanks",
      "created_at": "2025-09-12T20:04:03Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345329538",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345329538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349207386",
      "pull_request_review_id": 3217223929,
      "id": 2349207386,
      "node_id": "PRRC_kwDOABII586MBg9a",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] id Id of the connection whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that connection will be omitted.\n+     */\n+    virtual void EventReadyToSend(Id id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] id Connection for which the data arrived.\n+     * @param[in] data Received data.\n+     */\n+    virtual void EventGotData(Id id, std::span<const uint8_t> data) = 0;\n+\n+    /**\n+     * Called when the remote peer has sent an EOF on the socket. This is a graceful\n+     * close of their writing side, we can still send and they will receive, if it\n+     * makes sense at the application level.\n+     * @param[in] id Connection whose socket got EOF.\n+     */\n+    virtual void EventGotEOF(Id id) = 0;\n+\n+    /**\n+     * Called when we get an irrecoverable error trying to read from a socket.\n+     * @param[in] id Connection whose socket got an error.\n+     * @param[in] errmsg Message describing the error.\n+     */\n+    virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) = 0;\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Can be used to temporarily pause sends on a connection.\n+     * SockMan would only call Send() if this returns true.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next call to EventReadyToSend().\n+     */\n+    virtual bool ShouldTryToSend(Id id) const;\n+\n+    /**\n+     * SockMan would only call Recv() on a connection's socket if this returns true.\n+     * Can be used to temporarily pause receives on a connection.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next receive.\n+     */\n+    virtual bool ShouldTryToRecv(Id id) const;\n+\n+    /**\n+     * SockMan has completed the current send+recv iteration for a given connection.\n+     * It will do another send+recv for this connection after processing all other connections.\n+     * Can be used to execute periodic tasks for a given connection.\n+     * The implementation in SockMan does nothing.\n+     * @param[in] id Connection for which send+recv has been done.\n+     */\n+    virtual void EventIOLoopCompletedForOne(Id id);\n+\n+    /**\n+     * SockMan has completed send+recv for all connections.\n+     * Can be used to execute periodic tasks for all connections, like closing\n+     * connections due to higher level logic.\n+     * The implementation in SockMan does nothing.\n+     */\n+    virtual void EventIOLoopCompletedForAll();\n+\n+    /**\n+     * The sockets used by a connection.\n+     */\n+    struct ConnectionSockets {\n+        explicit ConnectionSockets(std::unique_ptr<Sock>&& s)\n+            : sock{std::move(s)}\n+        {\n+        }\n+\n+        /**\n+         * Mutex that serializes the Send() and Recv() calls on `sock`.\n+         */\n+        Mutex mutex;\n+\n+        /**\n+         * Underlying socket.\n+         * `shared_ptr` (instead of `unique_ptr`) is used to avoid premature close of the\n+         * underlying file descriptor by one thread while another thread is poll(2)-ing\n+         * it for activity.\n+         * @see https://github.com/bitcoin/bitcoin/issues/21744 for details.\n+         */\n+        std::shared_ptr<Sock> sock;\n+    };\n+\n+    /**\n+     * Info about which socket has which event ready and its connection id.\n+     */\n+    struct IOReadiness {\n+        /**\n+         * Map of socket -> socket events. For example:\n+         * socket1 -> { requested = SEND|RECV, occurred = RECV }\n+         * socket2 -> { requested = SEND, occurred = SEND }\n+         */\n+        Sock::EventsPerSock events_per_sock;\n+\n+        /**\n+         * Map of socket -> connection id (in `m_connected`). For example\n+         * socket1 -> id=23\n+         * socket2 -> id=56\n+         */\n+        std::unordered_map<Sock::EventsPerSock::key_type,\n+                           SockMan::Id,\n+                           Sock::HashSharedPtrSock,\n+                           Sock::EqualSharedPtrSock>\n+            ids_per_sock;\n+    };\n+\n+    /**\n+     * Check connected and listening sockets for IO readiness and process them accordingly.\n+     */\n+    void ThreadSocketHandler()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate a collection of sockets to check for IO readiness.\n+     * @return Sockets to check for readiness plus an aux map to find the\n+     * corresponding connection id given a socket.\n+     */\n+    IOReadiness GenerateWaitSockets()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Do the read/write for connected sockets that are ready for IO.\n+     * @param[in] io_readiness Which sockets are ready and their connection ids.\n+     */\n+    void SocketHandlerConnected(const IOReadiness& io_readiness)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Accept incoming connections, one from each read-ready listening socket.\n+     * @param[in] events_per_sock Sockets that are ready for IO.\n+     */\n+    void SocketHandlerListening(const Sock::EventsPerSock& events_per_sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Retrieve an entry from m_connected.\n+     * @param[in] id Connection id to search for.\n+     * @return ConnectionSockets for the given connection id or empty shared_ptr if not found.\n+     */\n+    std::shared_ptr<ConnectionSockets> GetConnectionSockets(Id id) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * The id to assign to the next created connection. Used to generate ids of connections.",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 303,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293246152,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I guess the two sentences are a bit redundant, I'm going to keep the first and lose the second, though.",
      "created_at": "2025-09-15T14:30:20Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2349207386",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349207386"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 303,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349899039",
      "pull_request_review_id": 3217223929,
      "id": 2349899039,
      "node_id": "PRRC_kwDOABII586MEJ0f",
      "diff_hunk": "@@ -601,6 +601,42 @@ void TestChain100Setup::MockMempoolMinFee(const CFeeRate& target_feerate)\n     m_node.mempool->TrimToSize(0);\n     assert(m_node.mempool->GetMinFee() == target_feerate);\n }\n+\n+SocketTestingSetup::SocketTestingSetup()\n+    : m_create_sock_orig{CreateSock}\n+{\n+    CreateSock = [this](int, int, int) {\n+        // This is a mock Listening Socket that a server can \"bind\" to and\n+        // listen to for incoming connections. We won't need to access its I/O\n+        // pipes because we don't read or write directly to it. It will return\n+        // Connected Sockets from the queue via its Accept() method.\n+        return std::make_unique<DynSock>(std::make_shared<DynSock::Pipes>(), m_accepted_sockets);\n+    };\n+};\n+\n+SocketTestingSetup::~SocketTestingSetup()\n+{\n+    CreateSock = m_create_sock_orig;\n+}\n+\n+std::shared_ptr<DynSock::Pipes> SocketTestingSetup::ConnectClient(const std::vector<uint8_t>& data)\n+{\n+    // I/O pipes for a mock Connected Socket we can read and write to.\n+    std::shared_ptr<DynSock::Pipes> connected_socket_pipes(std::make_shared<DynSock::Pipes>());\n+\n+    // Insert the payload\n+    connected_socket_pipes->recv.PushBytes(data.data(), data.size());\n+\n+    // Create the Mock Connected Socket that represents a client.\n+    // It needs I/O pipes but its queue can remain empty\n+    std::unique_ptr<DynSock> connected_socket{std::make_unique<DynSock>(connected_socket_pipes, std::make_shared<DynSock::Queue>())};",
      "path": "src/test/util/setup_common.cpp",
      "position": 32,
      "original_position": 32,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2300320948,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm going to keep the `shared_ptr` advice under consideration but didn't apply it to this rebase.",
      "created_at": "2025-09-15T19:23:39Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2349899039",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349899039"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 647,
      "original_line": 647,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349903446",
      "pull_request_review_id": 3217223929,
      "id": 2349903446,
      "node_id": "PRRC_kwDOABII586MEK5W",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 63,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2297336625,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This is cool but I don't think it's necessary for this PR. In https://github.com/bitcoin/bitcoin/pull/32061 there is more robust testing with real sockets (not `DynSock`) and I think the combining of chunks of data from separate packets is more appropriate one level up (for example in this HTTP server). But I'm also open to integrating this kind of test in the current sockman PR if you think its important",
      "created_at": "2025-09-15T19:25:42Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2349903446",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349903446"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349903778",
      "pull_request_review_id": 3217223929,
      "id": 2349903778,
      "node_id": "PRRC_kwDOABII586MEK-i",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Remove sent bytes until entire response is sent.\n+                m_respond.erase(m_respond.begin(), m_respond.begin() + sent);\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};\n+    BOOST_REQUIRE(addr_bind.has_value());\n+    bilingual_str strError;\n+\n+    // Init state\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 0);\n+    // Bind to mock Listening Socket\n+    BOOST_REQUIRE(sockman.BindAndStartListening(addr_bind.value(), strError));\n+    // We are bound and listening\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 1);\n+\n+    // Name the SockMan I/O thread\n+    SockMan::Options options{\"test_sockman\"};\n+    // Start the I/O loop\n+    sockman.StartSocketsThreads(options);\n+\n+    // No connections yet\n+    BOOST_CHECK_EQUAL(sockman.GetConnectionsCount(), 0);\n+\n+    // Create a mock client with a data payload to send\n+    // and add it to the local CreateSock queue\n+    const std::vector<uint8_t> request = {'b', 'i', 't', 's'};\n+    auto pipes{ConnectClient(request)};\n+\n+    // Wait up to a minute to find and connect the client in the I/O loop\n+    int attempts{6000};\n+    while (sockman.GetConnectionsCount() < 1) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Inspect the connection\n+    auto client{sockman.GetFirstConnection()};\n+    BOOST_CHECK_EQUAL(client.second.ToStringAddrPort(), \"5.5.5.5:6789\");\n+\n+    // Wait up to a minute to read the data from the connection\n+    attempts = 6000;\n+    while (!std::ranges::equal(sockman.GetReceivedData(client.first), request)) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Wait up to a minute to write our response data back to the connection\n+    attempts = 6000;\n+    size_t expected_response_size = sockman.m_respond.size();\n+    std::vector<uint8_t> actually_received(expected_response_size);\n+    while (!std::ranges::equal(actually_received, sockman.m_respond)) {\n+        // Read the data received by the mock socket\n+        ssize_t bytes_read = pipes->send.GetBytes((void *)actually_received.data(), expected_response_size);",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 134,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2300323835,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "see above re: packets and chunks",
      "created_at": "2025-09-15T19:25:54Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2349903778",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349903778"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349907985",
      "pull_request_review_id": 3217223929,
      "id": 2349907985,
      "node_id": "PRRC_kwDOABII586MEMAR",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;",
      "path": "src/common/sockman.h",
      "position": 122,
      "original_position": 147,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2300366190,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "No harm in this I suppose but it's not really needed by the HTTP server, we already log client disconnections when calling `CloseConnection()`",
      "created_at": "2025-09-15T19:28:15Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2349907985",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349907985"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": 120,
      "original_start_line": 145,
      "start_side": "RIGHT",
      "line": 122,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389700626",
      "pull_request_review_id": 3282387933,
      "id": 2389700626,
      "node_id": "PRRC_kwDOABII586Ob_AS",
      "diff_hunk": "@@ -9,68 +9,80 @@\n #include <netbase.h>\n #include <util/sock.h>\n \n-bool SockMan::BindListenPort(const CService& addrBind, bilingual_str& strError)\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n {\n-    int nOne = 1;\n-\n     // Create socket for listening for incoming connections\n-    struct sockaddr_storage sockaddr;\n-    socklen_t len = sizeof(sockaddr);\n-    if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))\n-    {\n-        strError = Untranslated(strprintf(\"Bind address family for %s not supported\", addrBind.ToStringAddrPort()));\n-        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n         return false;\n     }\n \n-    std::unique_ptr<Sock> sock = CreateSock(addrBind.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP);\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n     if (!sock) {\n-        strError = Untranslated(strprintf(\"Couldn't open socket for incoming connections (socket returned error %s)\", NetworkErrorString(WSAGetLastError())));\n-        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n         return false;\n     }\n \n+    int one{1};",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 34,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "6b5b652ac36b325f2bdba8d4442506ad8c78c570",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: I know this was the original name as well, but variables (by their name) should reflect the purpose of their usage, not their value. `ipv6_only{1}` or `tcp_nodelay{1}` might make the context more obvious (if that's indeed what they're goal is.",
      "created_at": "2025-09-30T02:40:18Z",
      "updated_at": "2025-09-30T19:15:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2389700626",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389700626"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 30,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389703932",
      "pull_request_review_id": 3282387933,
      "id": 2389703932,
      "node_id": "PRRC_kwDOABII586Ob_z8",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 24,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "if error message is tied to a `false` return value, can we return `std::optional<bilingual_str>` instead of having both a return value and an output parameter?\n```C++\nstd::optional<bilingual_str> BindAndStartListening(const CService& to)\n{\n    sockaddr_storage storage;\n    socklen_t len{sizeof(storage)};\n    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n        return Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n    }\n...\n```",
      "created_at": "2025-09-30T02:43:40Z",
      "updated_at": "2025-09-30T19:15:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2389703932",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389703932"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 23,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389716205",
      "pull_request_review_id": 3282387933,
      "id": 2389716205,
      "node_id": "PRRC_kwDOABII586OcCzt",
      "diff_hunk": "@@ -951,3 +946,16 @@ CService MaybeFlipIPv6toCJDNS(const CService& service)\n     }\n     return ret;\n }\n+\n+CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {",
      "path": "src/netbase.cpp",
      "position": 1,
      "original_position": 33,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "when`reinterpret_cast<sockaddr*>(&storage)` as in `SockMan::BindAndStartListening` and when c-style cast?",
      "created_at": "2025-09-30T02:54:48Z",
      "updated_at": "2025-09-30T19:15:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2389716205",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389716205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 955,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389728358",
      "pull_request_review_id": 3282387933,
      "id": 2389728358,
      "node_id": "PRRC_kwDOABII586OcFxm",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(one)) == SOCKET_ERROR) {",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 51,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "are we testing this code in any way?\nAnd can we enable compile and be type-checking and make it `if constexpr` instead of using macros?",
      "created_at": "2025-09-30T03:06:25Z",
      "updated_at": "2025-09-30T19:15:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2389728358",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389728358"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389732096",
      "pull_request_review_id": 3282387933,
      "id": 2389732096,
      "node_id": "PRRC_kwDOABII586OcGsA",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 23,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "seems to me we're not testing any of these unhappy paths - could we do that or is it too much work?",
      "created_at": "2025-09-30T03:10:30Z",
      "updated_at": "2025-09-30T19:15:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2389732096",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389732096"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389737802",
      "pull_request_review_id": 3282387933,
      "id": 2389737802,
      "node_id": "PRRC_kwDOABII586OcIFK",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             &prot_level,\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const std::byte> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSocket(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(data.data(), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 187,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "what's the difference between this an the `one` (without const) above? Can we unify their naming so that they represent the meaning of what they're storing instead of the value?",
      "created_at": "2025-09-30T03:16:52Z",
      "updated_at": "2025-09-30T19:15:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2389737802",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389737802"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 187,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389738877",
      "pull_request_review_id": 3282387933,
      "id": 2389738877,
      "node_id": "PRRC_kwDOABII586OcIV9",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             &prot_level,\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const std::byte> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSocket(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(data.data(), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",",
      "path": "src/common/sockman.cpp",
      "position": 191,
      "original_position": 189,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: most logs don't need a trailing newline anymore",
      "created_at": "2025-09-30T03:18:12Z",
      "updated_at": "2025-09-30T19:15:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2389738877",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389738877"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 191,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389740440",
      "pull_request_review_id": 3282387933,
      "id": 2389740440,
      "node_id": "PRRC_kwDOABII586OcIuY",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             &prot_level,\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const std::byte> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSocket(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(data.data(), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSocket>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    // Make sure we only operate on our own listening sockets\n+    Assume(std::ranges::find_if(m_listen, [&](const auto& sock) { return sock.get() == &listen_sock; }) != m_listen.end());",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 208,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We don't actually need the value here, just that it exists, right?\n\n```suggestion\n    Assume(std::ranges::any_of(m_listen, [&](const auto& sock) { return sock.get() == &listen_sock; }));\n```",
      "created_at": "2025-09-30T03:19:56Z",
      "updated_at": "2025-09-30T19:15:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2389740440",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389740440"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 208,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389762328",
      "pull_request_review_id": 3282387933,
      "id": 2389762328,
      "node_id": "PRRC_kwDOABII586OcOEY",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {",
      "path": "src/common/sockman.cpp",
      "position": 24,
      "original_position": 22,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I understand that we need different sizes for ipv4 and ipv6, hence these ugly polimorphism-mimicking structures, but I'm wondering if there's a way to hide this ugliness in the C++ code with either decicated structures or something lke `std::variant<sockaddr_in, sockaddr_in6>`",
      "created_at": "2025-09-30T03:40:32Z",
      "updated_at": "2025-09-30T19:15:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2389762328",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389762328"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 24,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389766029",
      "pull_request_review_id": 3282387933,
      "id": 2389766029,
      "node_id": "PRRC_kwDOABII586OcO-N",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             &prot_level,\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const std::byte> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSocket(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE",
      "path": "src/common/sockman.cpp",
      "position": 141,
      "original_position": 141,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "can we have some explanation here, it's not self-explanatory. The source location had:\n>        // We rely on the 'more' value returned by GetBytesToSend to correctly predict whether more\n>        // bytes are still to be sent, to correctly set the MSG_MORE flag. As a sanity check,\n>        // verify that the previously returned 'more' was correct.",
      "created_at": "2025-09-30T03:44:10Z",
      "updated_at": "2025-09-30T19:15:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2389766029",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2389766029"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 141,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2420892943",
      "pull_request_review_id": 3324351471,
      "id": 2420892943,
      "node_id": "PRRC_kwDOABII586QS-UP",
      "diff_hunk": "@@ -9,68 +9,80 @@\n #include <netbase.h>\n #include <util/sock.h>\n \n-bool SockMan::BindListenPort(const CService& addrBind, bilingual_str& strError)\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n {\n-    int nOne = 1;\n-\n     // Create socket for listening for incoming connections\n-    struct sockaddr_storage sockaddr;\n-    socklen_t len = sizeof(sockaddr);\n-    if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))\n-    {\n-        strError = Untranslated(strprintf(\"Bind address family for %s not supported\", addrBind.ToStringAddrPort()));\n-        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n         return false;\n     }\n \n-    std::unique_ptr<Sock> sock = CreateSock(addrBind.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP);\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n     if (!sock) {\n-        strError = Untranslated(strprintf(\"Couldn't open socket for incoming connections (socket returned error %s)\", NetworkErrorString(WSAGetLastError())));\n-        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n         return false;\n     }\n \n+    int one{1};",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 34,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "6b5b652ac36b325f2bdba8d4442506ad8c78c570",
      "in_reply_to_id": 2389700626,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good call, this value is setting a boolean option to `true` so I made the variable name more explicit, in the \"modernize\" commit.",
      "created_at": "2025-10-10T15:37:47Z",
      "updated_at": "2025-10-14T17:41:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2420892943",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2420892943"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 30,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2421300798",
      "pull_request_review_id": 3324351471,
      "id": 2421300798,
      "node_id": "PRRC_kwDOABII586QUh4-",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {",
      "path": "src/common/sockman.cpp",
      "position": 24,
      "original_position": 22,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": 2389762328,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This is a reasonable note but I think it's out of scope for this PR, since `GetSockAddr()` is used so many other places in the code. Wrapping `sockaddr_storage` for C++ style could also be applied to `Accept()`, `Connect()`, `Bind()` and probably a few others. I'll open a new PR for that cleanup, similar to https://github.com/bitcoin/bitcoin/pull/33378 ",
      "created_at": "2025-10-10T17:12:37Z",
      "updated_at": "2025-10-14T17:41:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2421300798",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2421300798"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 24,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2421914543",
      "pull_request_review_id": 3324351471,
      "id": 2421914543,
      "node_id": "PRRC_kwDOABII586QW3uv",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 24,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": 2389703932,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good call, will use `util::Result` here and remove the error string as an \"out\" parameter.",
      "created_at": "2025-10-10T19:43:49Z",
      "updated_at": "2025-10-14T17:41:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2421914543",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2421914543"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 23,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2421943022",
      "pull_request_review_id": 3324351471,
      "id": 2421943022,
      "node_id": "PRRC_kwDOABII586QW-ru",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 23,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": 2389732096,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'll add coverage for as many as I can. But I think all I can do from this level is try to bind to an address with an invalid family (i.e. \"NET_ONION\").",
      "created_at": "2025-10-10T19:51:53Z",
      "updated_at": "2025-10-14T17:41:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2421943022",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2421943022"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2429400209",
      "pull_request_review_id": 3324351471,
      "id": 2429400209,
      "node_id": "PRRC_kwDOABII586QzbSR",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(one)) == SOCKET_ERROR) {",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 51,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": 2389728358,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think we could reliably test these paths in ci because such socket operations depend so much on the platform.\n\nWe *could* create additional child classes of `DynSock` for the unit tests, so we have mock socket variants that fail each specific option, but I'm not sure we'd get enough value from those tests to be worth the work. Could be a follow up.",
      "created_at": "2025-10-14T14:24:23Z",
      "updated_at": "2025-10-14T17:41:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2429400209",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2429400209"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2429404525",
      "pull_request_review_id": 3324351471,
      "id": 2429404525,
      "node_id": "PRRC_kwDOABII586QzcVt",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             &prot_level,\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const std::byte> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSocket(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(data.data(), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",",
      "path": "src/common/sockman.cpp",
      "position": 191,
      "original_position": 189,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": 2389738877,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "that's nice, thanks",
      "created_at": "2025-10-14T14:25:46Z",
      "updated_at": "2025-10-14T17:41:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2429404525",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2429404525"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 191,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2429627125",
      "pull_request_review_id": 3324351471,
      "id": 2429627125,
      "node_id": "PRRC_kwDOABII586Q0Sr1",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             &prot_level,\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const std::byte> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSocket(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(data.data(), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSocket>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    // Make sure we only operate on our own listening sockets\n+    Assume(std::ranges::find_if(m_listen, [&](const auto& sock) { return sock.get() == &listen_sock; }) != m_listen.end());",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 208,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": 2389740440,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yes thanks",
      "created_at": "2025-10-14T15:35:47Z",
      "updated_at": "2025-10-14T17:41:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2429627125",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2429627125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 208,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2429694223",
      "pull_request_review_id": 3324351471,
      "id": 2429694223,
      "node_id": "PRRC_kwDOABII586Q0jEP",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             &prot_level,\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const std::byte> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSocket(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(data.data(), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 187,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": 2389737802,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "good call ill set a `static constexpr` for all the times we do this in the module, overriding https://github.com/bitcoin/bitcoin/pull/32747/files#r2420892943",
      "created_at": "2025-10-14T15:58:33Z",
      "updated_at": "2025-10-14T17:41:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2429694223",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2429694223"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 187,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2429730411",
      "pull_request_review_id": 3324351471,
      "id": 2429730411,
      "node_id": "PRRC_kwDOABII586Q0r5r",
      "diff_hunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             &prot_level,\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const std::byte> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSocket(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE",
      "path": "src/common/sockman.cpp",
      "position": 141,
      "original_position": 141,
      "commit_id": "03ce73a820b485fbdbb854d9d3947ff1e6d87880",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": 2389766029,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "sure, added.",
      "created_at": "2025-10-14T16:10:40Z",
      "updated_at": "2025-10-14T17:41:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2429730411",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2429730411"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 141,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2429818401",
      "pull_request_review_id": 3324351471,
      "id": 2429818401,
      "node_id": "PRRC_kwDOABII586Q1BYh",
      "diff_hunk": "@@ -951,3 +946,16 @@ CService MaybeFlipIPv6toCJDNS(const CService& service)\n     }\n     return ret;\n }\n+\n+CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {",
      "path": "src/netbase.cpp",
      "position": 1,
      "original_position": 33,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "in_reply_to_id": 2389716205,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "good idea, i'll insert a new \"modernize\" commit after the move-only `GetBindAddress` commit",
      "created_at": "2025-10-14T16:42:30Z",
      "updated_at": "2025-10-14T17:41:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2429818401",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2429818401"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 955,
      "side": "RIGHT"
    }
  ]
}