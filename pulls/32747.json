{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747",
    "id": 2591037188,
    "node_id": "PR_kwDOABII586acBcE",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/32747",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/32747.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/32747.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32747",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32747/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
    "number": 32747,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Introduce SockMan (\"lite\"): low-level socket handling for HTTP",
    "user": {
      "login": "pinheadmz",
      "id": 2084648,
      "node_id": "MDQ6VXNlcjIwODQ2NDg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pinheadmz",
      "html_url": "https://github.com/pinheadmz",
      "followers_url": "https://api.github.com/users/pinheadmz/followers",
      "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
      "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
      "repos_url": "https://api.github.com/users/pinheadmz/repos",
      "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Introduces a new low-level socket manager `SockMan` as an abstract class with virtual functions for implementing higher-level networking protocols like HTTP. This is the next step in https://github.com/bitcoin/bitcoin/issues/31194\r\n\r\nThis is a minimal, alternative version of #30988 (\"Split CConnman\") without any changes to working code (P2P is not affected). It adds a stripped-down version of the `SockMan` introduced in that pull request that implements only what is needed for the HTTP server implemented in #32061 (i.e. no I2P stuff and for now, no outbound connection stuff). Exclusions from the original `SockMan` pull request can be checked with:\r\n\r\n```\r\ngit diff vasild/sockman \\\r\nsrc/common/sockman.h \\\r\nsrc/common/sockman.cpp\r\n```\r\n\r\nThe commit order has been flipped quite a bit because the original PR incrementally pulls logic out of `net` wheras this PR builds a new system from the bottom-up. Otherwise I tried to keep all the `SockMan` code in order so reviewers of the original PR would be familiar with it.\r\n\r\nIt also adds unit tests by introducing a `SocketTestingSetup` which mocks network sockets by returning a queue of `DynSock` from `CreateSock()`. HTTP server tests in #32061 will be rebased on this framework as well.\r\n\r\n",
    "labels": [],
    "created_at": "2025-06-13T18:36:49Z",
    "updated_at": "2025-09-18T08:55:14Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "de57c9ae3cc74326ca092ac294740acc93150d7a",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "pinheadmz:sockman-lite",
      "ref": "sockman-lite",
      "sha": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 61248407,
        "node_id": "MDEwOlJlcG9zaXRvcnk2MTI0ODQwNw==",
        "name": "bitcoin",
        "full_name": "pinheadmz/bitcoin",
        "owner": {
          "login": "pinheadmz",
          "id": 2084648,
          "node_id": "MDQ6VXNlcjIwODQ2NDg=",
          "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/pinheadmz",
          "html_url": "https://github.com/pinheadmz",
          "followers_url": "https://api.github.com/users/pinheadmz/followers",
          "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
          "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
          "repos_url": "https://api.github.com/users/pinheadmz/repos",
          "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/pinheadmz/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/pinheadmz/bitcoin",
        "archive_url": "https://api.github.com/repos/pinheadmz/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/pinheadmz/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/pinheadmz/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/pinheadmz/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/pinheadmz/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/pinheadmz/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/pinheadmz/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/pinheadmz/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/pinheadmz/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/pinheadmz/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/pinheadmz/bitcoin/events",
        "forks_url": "https://api.github.com/repos/pinheadmz/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/pinheadmz/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/pinheadmz/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/pinheadmz/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/pinheadmz/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/pinheadmz/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/pinheadmz/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/pinheadmz/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/pinheadmz/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/pinheadmz/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/pinheadmz/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/pinheadmz/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/pinheadmz/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:pinheadmz/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/pinheadmz/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/pinheadmz/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/pinheadmz/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/pinheadmz/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/pinheadmz/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/pinheadmz/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/pinheadmz/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/pinheadmz/bitcoin/hooks",
        "svn_url": "https://github.com/pinheadmz/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 1,
        "stargazers_count": 2,
        "watchers_count": 2,
        "size": 284090,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-09-16T10:26:12Z",
        "created_at": "2016-06-15T23:48:20Z",
        "updated_at": "2025-06-10T17:35:30Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "2d6a0c464912c325faf35d4ad28b1990e828b414",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 37806,
        "stargazers_count": 85552,
        "watchers_count": 85552,
        "size": 293697,
        "default_branch": "master",
        "open_issues_count": 795,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-09-17T19:39:21Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-09-18T08:50:38Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 941,
    "deletions": 14,
    "changed_files": 10,
    "commits": 10,
    "review_comments": 62,
    "comments": 4
  },
  "events": [
    {
      "event": "commented",
      "id": 2971261595,
      "node_id": "IC_kwDOABII586xGdqb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2971261595",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-13T18:36:52Z",
      "updated_at": "2025-09-18T08:55:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32747.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [w0xlt](https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-2937305602), [hodlinator](https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-3022243737) |\n| Stale ACK | [vasild](https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-2958772275) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#33210](https://github.com/bitcoin/bitcoin/pull/33210) (fuzz: enhance wallet_fees by mocking mempool stuff by brunoerg)\n* [#26812](https://github.com/bitcoin/bitcoin/pull/26812) (test: add end-to-end tests for CConnman and PeerManager by vasild)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->\n### LLM Linter (âœ¨ experimental)\n\nPossible typos and grammar issues:\n\n- \"Each connection is assigned an unique id of this type.\" -> \"a unique id\" [use \"a\" before words starting with a consonant sound; \"an unique\" is grammatically incorrect]\n\n- \"Returns the I/O pipes from the mock client so we can read response datasent to it.\" -> \"response data sent\" [missing space between \"data\" and \"sent\", making the phrase hard to parse]\n\n<sup>drahtbot_id_5_m</sup>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#issuecomment-2971261595",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32747"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18139663432,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAAQ5NUxI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18139663432",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d8274e91c0c8ebb4d6d4ae16ed82a5c2e7dd8bd1",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/d8274e91c0c8ebb4d6d4ae16ed82a5c2e7dd8bd1",
      "created_at": "2025-06-13T19:03:02Z"
    },
    {
      "event": "labeled",
      "id": 18139665382,
      "node_id": "LE_lADOABII5867bDTqzwAAAAQ5NVPm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18139665382",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-13T19:03:13Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2971365995,
      "node_id": "IC_kwDOABII586xG3Jr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2971365995",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-13T19:03:15Z",
      "updated_at": "2025-06-13T19:03:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Task `MSan, depends`: https://github.com/bitcoin/bitcoin/runs/44070031695</sub>\n<sub>LLM reason (âœ¨ experimental): MemorySanitizer detected use of uninitialized memory during sockman_tests, causing CI failure.</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#issuecomment-2971365995",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32747"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18140182279,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAAQ5PTcH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18140182279",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "55a329ac85df21a88c166519ad684f84b6124b77",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/55a329ac85df21a88c166519ad684f84b6124b77",
      "created_at": "2025-06-13T19:43:49Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18140539333,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAAQ5QqnF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18140539333",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2d79cd7dbe7ed06691dd7b44a5227c1a7b849c6f",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/2d79cd7dbe7ed06691dd7b44a5227c1a7b849c6f",
      "created_at": "2025-06-13T20:12:20Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18149846423,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAAQ50K2X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18149846423",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "created_at": "2025-06-14T14:55:11Z"
    },
    {
      "event": "unlabeled",
      "id": 18150107930,
      "node_id": "UNLE_lADOABII5867bDTqzwAAAAQ51Ksa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18150107930",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-14T15:49:34Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2975549723,
      "node_id": "IC_kwDOABII586xW0kb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2975549723",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-16T08:21:26Z",
      "updated_at": "2025-06-16T08:21:26Z",
      "author_association": "MEMBER",
      "body": "I was able to switch https://github.com/Sjors/bitcoin/pull/50 to use this instead of https://github.com/bitcoin/bitcoin/pull/30988 without have to change anything. So it makes sense to me to focus on this PR first, as it's smaller. Thoughts @vasild?",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#issuecomment-2975549723",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32747"
    },
    {
      "event": "mentioned",
      "id": 18164809141,
      "node_id": "MEE_lADOABII5867bDTqzwAAAAQ6tP21",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18164809141",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-16T08:21:27Z"
    },
    {
      "event": "subscribed",
      "id": 18164809169,
      "node_id": "SE_lADOABII5867bDTqzwAAAAQ6tP3R",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18164809169",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-16T08:21:27Z"
    },
    {
      "event": "reviewed",
      "id": 2937305602,
      "node_id": "PRR_kwDOABII586vE7oC",
      "url": null,
      "actor": null,
      "commit_id": "5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-17T23:19:57Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK.\r\nAre the functions in this PR to replace Connam functions like `CConnman::BindListenPort`, `CConnman::InitBinds`, etc...?",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-2937305602",
      "submitted_at": "2025-06-17T23:19:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "commented",
      "id": 2983561305,
      "node_id": "IC_kwDOABII586x1YhZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2983561305",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-18T10:04:16Z",
      "updated_at": "2025-06-18T10:04:16Z",
      "author_association": "MEMBER",
      "body": "> replace Connman functions\r\n\r\nIn this PR they are just protocol-agnostic copies of those ConnMan functions. Just the socket stuff without the Bitcoin stuff. We could still proceed with the reactor in #30988 after this is merged and actually replace the socket stuff in ConnMan with SockMan but this PR is minimized with the focus being the socket needs of the HTTP server in #32061",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#issuecomment-2983561305",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32747"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18259049739,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAARAUv0L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18259049739",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/130708803dd623c37e21bf72887ea84cf59460cc",
      "created_at": "2025-06-21T22:24:55Z"
    },
    {
      "event": "reviewed",
      "id": 2945433124,
      "node_id": "PRR_kwDOABII586vj74k",
      "url": null,
      "actor": null,
      "commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-23T10:09:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "Approach ACK 5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-2945433124",
      "submitted_at": "2025-06-23T10:09:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18282616969,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAARBupiJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18282616969",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/3e7abceecfd790bc0887f647d3f731328e19810f",
      "created_at": "2025-06-23T23:20:31Z"
    },
    {
      "event": "reviewed",
      "id": 2951071498,
      "node_id": "PRR_kwDOABII586v5ccK",
      "url": null,
      "actor": null,
      "commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-24T00:43:03Z",
      "author_association": "MEMBER",
      "body": "Rebase to address review by @vasild THANKS!",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-2951071498",
      "submitted_at": "2025-06-24T00:43:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "reviewed",
      "id": 2958772275,
      "node_id": "PRR_kwDOABII586wW0gz",
      "url": null,
      "actor": null,
      "commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-25T15:57:16Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK 3e7abceecfd790bc0887f647d3f731328e19810f",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-2958772275",
      "submitted_at": "2025-06-25T15:57:16Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "review_requested",
      "id": 18319901223,
      "node_id": "RRE_lADOABII5867bDTqzwAAAARD84In",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18319901223",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-25T15:57:20Z",
      "requested_reviewer": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_request_removed",
      "id": 18437288730,
      "node_id": "RRRE_lADOABII5867bDTqzwAAAARK8rMa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18437288730",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-02T18:08:06Z",
      "requested_reviewer": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 18437288752,
      "node_id": "RRE_lADOABII5867bDTqzwAAAARK8rMw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18437288752",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-02T18:08:06Z",
      "requested_reviewer": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 18643934953,
      "node_id": "RRE_lADOABII5867bDTqzwAAAARXQ97p",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18643934953",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-15T18:05:16Z",
      "requested_reviewer": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 3049290299,
      "node_id": "PRR_kwDOABII5861wHo7",
      "url": null,
      "actor": null,
      "commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-23T22:45:50Z",
      "author_association": "MEMBER",
      "body": "Began reviewing, then realized that I was reviewing the same code twice with the two \"modernize\" commits following \"original\" commits.\r\n\r\nPropose to either (1) make clear in the commit message where the code is being pulled from, and that it will be re-styled afterward, or (2) squash the modernization commits into the previous ones. Thereby easing life a bit for your reviewers :)",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-3049290299",
      "submitted_at": "2025-07-23T22:42:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "review_requested",
      "id": 18783846194,
      "node_id": "RRE_lADOABII5867bDTqzwAAAARfmr8y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18783846194",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-23T22:42:33Z",
      "requested_reviewer": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19038417625,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAARuxzLZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19038417625",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/598bee6bd590757565d2564ae86cf46b5eea4399",
      "created_at": "2025-08-07T15:34:40Z"
    },
    {
      "event": "reviewed",
      "id": 3097669539,
      "node_id": "PRR_kwDOABII5864oq-j",
      "url": null,
      "actor": null,
      "commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-07T15:35:54Z",
      "author_association": "MEMBER",
      "body": "3e7abceecf -> 598bee6bd5\r\n\r\nAddress nits from @jonatack including commit messages that indicate code is copied from CConnman and will be modernized in following commits.",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-3097669539",
      "submitted_at": "2025-08-07T15:35:54Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "reviewed",
      "id": 3022243737,
      "node_id": "PRR_kwDOABII5860I8eZ",
      "url": null,
      "actor": null,
      "commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-16T12:21:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK 598bee6bd590757565d2564ae86cf46b5eea4399\r\n\r\n### Concept\r\n\r\nAgree with exploring this avenue of introducing `SockMan` without touching `CConnman`. Given @theuni's comment in https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2702063374, I'm still curious how he would suggest improving it as far as event-loop/send-receive/threading goes.\r\n\r\n### Commit approach\r\n\r\nThink it's fine so far to pair the commits (copy+modernize, ...). It enables reviewers to review the copying and then diffing over 2 commits at once to see what changed in combination.\r\n\r\n### Suggestions branch\r\n\r\nhttps://github.com/bitcoin/bitcoin/compare/598bee6bd590757565d2564ae86cf46b5eea4399...hodlinator:bitcoin:pr/32747_suggestions\r\n\r\nOrdered my suggestion commits starting from:\r\n* Trivial - Example: use `std::byte` (44bf80cd90b573d739b3519810449eab6a109992).\r\n* Slightly controversial - Example: decreased `shared_ptr` mentioned ~above~below.\r\n* More arbitrary - Example: rename `ConnectionSockets` => `ConnectionSocket` (650ff1d0762d05b9ea34d527840c5e6c7762afce), probably there are reasons I don't know for the naming.\r\n\r\n### Hodlinator's `shared_ptr` corner\r\n\r\n`shared_ptr` signals heavily ambiguous ownership. It seems like if there is a socket manager, it should be the one controlling the lifetime of all of them. But since the socket code is already so `shared_ptr`-heavy, it's more like a global network API with some objects with value-like semantics thrown in. *And maybe I can learn to live with that for now.* Few socket operations entail looping over a `vector` of them anyway, which weakens the argument for centralizing ownership. Wrapping them in `shared_ptr` means they can contain inlined data that is \"pinned\" to that place in memory with decreased risk of being moved and causing issues (even though that could be trivially worked around through internal pointer indirection).",
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-3022243737",
      "submitted_at": "2025-08-26T09:42:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDNkMjU5NDRjOTgxM2VkY2JmMzViYWRlZDZmZWM0M2Q4NWNhOWE0YTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3d25944c9813edcbf35baded6fec43d85ca9a4a6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/3d25944c9813edcbf35baded6fec43d85ca9a4a6",
      "tree": {
        "sha": "fb198a157c7dd7e8b35d02f8c37b773534a3f594",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fb198a157c7dd7e8b35d02f8c37b773534a3f594"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree fb198a157c7dd7e8b35d02f8c37b773534a3f594\nparent 65b26507b84a870a39a43b2ad4fd78e539773fa0\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749059576 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1757952422 -0400\n\nSockMan: introduce class and implement binding to listening socket\n\nIntroduce a new low-level socket managing class `SockMan`.\n\nBindListenPort() is copied from CConnMan in net.cpp and will\nbe modernized in the next commit.\n\nUnit-test it with a new class `SocketTestingSetup` which mocks\n`CreateSock()` and will enable mock client I/O in future commits.\n\n`SockMan` and `SocketTestingSetup` are designed to be generic and\nreusbale for higher-level network protocol implementation and testing.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjIOagACgkQ5+KYS2KJ\nyTq34Q/9FazWlFiIOe73paCOlwft1MoPSG0If3LN5F03fLFsX0esWVzT9tt35S+O\nLYdrfgtzTzbQhg/7hpN87zd9GEqD8f6ID4VJ/sys8NGm6xppMezHxkF70qt2clsr\nKOeJ4O1lxvMR1SkVX2v1lHrXiaPdLh3d/ZjQGMEGC+NSPx+0mPOR6PEBbjhjs+cb\ncBCbUkT+a3tzr8oUr9VjLnThj+xcRRNay8Mi2cR0COGKLgv7chmlByHFW2nXOv2V\nDuNpPGlvaubtCewOFM/ZyqGXROKybGtAQNm5Yzvj0vIZPAlwEMcbpcwBrpPYjkMJ\n4ZNLFRnrOysg628lZ93udHI/tvFYPVbBJyLo8f39iDtc8VHyr262AOiTljHa6TRW\noYKgkrW9WQh6aU7WndIe9G8ztU7RJ5mtgALdUzXz1kPgx6vPTvktqjYtwnMoQ5EV\nf3cbrv+HXqYysUafC1NVEuy3HL9EfxKxnxXbMqQ6w3jOJd+FKjKI9U+XdIxdLae1\nkmHg9DCmA1OfxELFU52MQqKZQxaK6iF1KtmI9IKMgjeF6gnjQNMRfueGOow5M9/p\nLTRyTnTPALp19zHszwY/palJhS5d8fSt2R7YBoFrmPi1A6se4A+Bq2/vVxQIYa4n\n6Gk5e/r+Un3EmEhJOZlEaYmcVUdQh58Q6O5rIz5WmZHllxy7mbI=\n=+9vz\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/65b26507b84a870a39a43b2ad4fd78e539773fa0",
          "sha": "65b26507b84a870a39a43b2ad4fd78e539773fa0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/65b26507b84a870a39a43b2ad4fd78e539773fa0"
        }
      ],
      "message": "SockMan: introduce class and implement binding to listening socket\n\nIntroduce a new low-level socket managing class `SockMan`.\n\nBindListenPort() is copied from CConnMan in net.cpp and will\nbe modernized in the next commit.\n\nUnit-test it with a new class `SocketTestingSetup` which mocks\n`CreateSock()` and will enable mock client I/O in future commits.\n\n`SockMan` and `SocketTestingSetup` are designed to be generic and\nreusbale for higher-level network protocol implementation and testing.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-09-15T16:07:02Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-04T17:52:56Z"
      },
      "sha": "3d25944c9813edcbf35baded6fec43d85ca9a4a6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZiNWI2NTJhYzM2YjMyNWYyYmRiYThkNDQ0MjUwNmFkOGM3OGM1NzA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6b5b652ac36b325f2bdba8d4442506ad8c78c570",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6b5b652ac36b325f2bdba8d4442506ad8c78c570",
      "tree": {
        "sha": "0424ba3555b854481ee448b2a208fcf9c1324f65",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0424ba3555b854481ee448b2a208fcf9c1324f65"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 0424ba3555b854481ee448b2a208fcf9c1324f65\nparent 3d25944c9813edcbf35baded6fec43d85ca9a4a6\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749059790 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1757952433 -0400\n\nstyle: modernize the style of SockMan::BindListenPort()\n\nIt was copied verbatim from `CConnman::BindListenPort()` in the previous\ncommit. Modernize its variables and style and log the error messages\nfrom the caller. Also categorize the informative messages to the \"net\"\ncategory because they are quite specific to the networking layer.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjIObEACgkQ5+KYS2KJ\nyTqcrw/9GKKbnGb3KjLa2TNGDpU6zLsGMdRVt9mqR6WLlzhHO3dSapfC22ipUt0G\nkRn2Rn5HiptLyhie9z3YnT3jtrvE+WE4N1MWKrQSJ8qZ2lwfTmsChhsKOys3lSF1\nGm2f1qXPCy7Eb0imJdHOoy1jnp8xiylLlr2puUM54y6WbGN5of0s/iUD1TzuBw26\ncZw7M4tloJRI8AWwNeJciE6/HLQuF3CG4Njh2teElqQPQnor46RPbsBu+beamZbg\n/W2PY7D+19O7XdIKXfudHGqwrcmv/cD3QtGGtfs5XUBfj2Ule/FWArED7KwNTpmZ\nnIai4tKfQQzfkfKc0U9gYDVhSaVR8ZO9Yx0RTvJ5JmjgU8KZIxfCfbRX2Na6SBTR\nxhHj94/iVPZdWDeVnED1Tv1swx9ihgT2mdLItC4jxwokYczG207UB/18xMjPO6A1\nAlx6pIIIMXC5w8QmljGPzCpmqgICjRuovSgE1ORSa0xGdg6hkr/o8GIwzrGRh49t\nXLiRJLzTRzveJ3kcSjg7BZhh4eUQxgk/BTjlByfj8DJlE9DiXpCi5V3GwO8EJsw3\nEYO9WLaiGE0R/jZw9none37U1ms2EywurvFVNGiNH0WRKfoVa6miRPt+Zi0FRBSs\nX9qWIScUWGosCDDroOS8C14YpetduofcR2ZGc0KKnIu585mjW9Y=\n=ww2N\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3d25944c9813edcbf35baded6fec43d85ca9a4a6",
          "sha": "3d25944c9813edcbf35baded6fec43d85ca9a4a6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/3d25944c9813edcbf35baded6fec43d85ca9a4a6"
        }
      ],
      "message": "style: modernize the style of SockMan::BindListenPort()\n\nIt was copied verbatim from `CConnman::BindListenPort()` in the previous\ncommit. Modernize its variables and style and log the error messages\nfrom the caller. Also categorize the informative messages to the \"net\"\ncategory because they are quite specific to the networking layer.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-09-15T16:07:13Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-04T17:56:30Z"
      },
      "sha": "6b5b652ac36b325f2bdba8d4442506ad8c78c570"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZkYWVkNzUzMzE3NGYxYWJkZDM5OTZjOTE3NGQwMDYxNTBmOTdhZWI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6daed7533174f1abdd3996c9174d006150f97aeb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6daed7533174f1abdd3996c9174d006150f97aeb",
      "tree": {
        "sha": "28968a213de99e15d3ff9abb651e9bef41495fd2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/28968a213de99e15d3ff9abb651e9bef41495fd2"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 28968a213de99e15d3ff9abb651e9bef41495fd2\nparent 6b5b652ac36b325f2bdba8d4442506ad8c78c570\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749060853 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1757952433 -0400\n\nSockMan: implement and test AcceptConnection()\n\nAcceptConnection() is mostly copied from CConmann in net.cpp\nand will be modernized in the following commit.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjIObEACgkQ5+KYS2KJ\nyTpi4xAAy5Qfn9nwhq7wPUHrcCsN9AcUhT22yVM8qGqW1Ps7yIGBAWnlU0HWXqQH\notfi1wcEMGt+UFkZTDBPzl4eTj6qlrUFGPq0VFS6sf93cdz3tAkSOOnjjQHRVD6f\nlSHGPOteqeRcf4pWi1P0xC2JrCRwugN2XCkjPFVod0oqz0JtZ2ThQHyFYVSDKQE1\nQnFW5UTRto+HvfvPk8bDO+P37QHa3zVmpKpcBj3AwP+6HeWIc4HnxIcV1n4UcZ+6\ny86dGKjMG7uKsiFjY1TBxU6oskDywMTy4k9lZyFYEmnVEvbEMVB/xyk/xmFhNnWo\npEkPgAWhNK0hTJVs64MngMEAl0FJ6BpyEF8rLubyMvM2h1dfpUIdeapaes5oOKZw\nsWPYseqg9Qe0BSw9EefQPsvRzWvBX1/R9gb934QnH8WC0R5w/vUBnRb0U0XLwqjm\nKJ4+waBTZPkLXsQD8UDp9kJYIh4Hbq9yF239d/0QcY7coYAqGa9P78g2WzIJaVHF\n0aslPPVJYrbVXiPojbpUgeV82kvhsCaAhi+wZoasbJ2DX9JDEbnZJOZmINHDZ7dv\n+ABmYCPIoOrUocn/BIjyW15bozyao28ZAgY9YmAeeW1jN7Uxezkm/G+2/sfFirSU\nhQCGo767oN8Dhgy0J2wzFThOYXAfn9sE0NWt4EtPyNldbshXMTY=\n=ZxQd\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6b5b652ac36b325f2bdba8d4442506ad8c78c570",
          "sha": "6b5b652ac36b325f2bdba8d4442506ad8c78c570",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6b5b652ac36b325f2bdba8d4442506ad8c78c570"
        }
      ],
      "message": "SockMan: implement and test AcceptConnection()\n\nAcceptConnection() is mostly copied from CConmann in net.cpp\nand will be modernized in the following commit.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-09-15T16:07:13Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-04T18:14:13Z"
      },
      "sha": "6daed7533174f1abdd3996c9174d006150f97aeb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDY0YjEzNjA1ZGNiNTFiZjY3MTNjNzBkNGIzZmE0MWVmYWYxY2M5MTg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/64b13605dcb51bf6713c70d4b3fa41efaf1cc918",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/64b13605dcb51bf6713c70d4b3fa41efaf1cc918",
      "tree": {
        "sha": "dc63792f4d01d78d03cda2acebfbb2062493ca8a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dc63792f4d01d78d03cda2acebfbb2062493ca8a"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree dc63792f4d01d78d03cda2acebfbb2062493ca8a\nparent 6daed7533174f1abdd3996c9174d006150f97aeb\nauthor Vasil Dimov <vd@FreeBSD.org> 1726586947 +0200\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1757952433 -0400\n\nstyle: modernize the style of SockMan::AcceptConnection()\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjIObEACgkQ5+KYS2KJ\nyTodCw/+K7kH8Nz0YYZi0f1eS+ZXKg7QAEcfa9uPs7z1bPnVVT7KcDcNSqE61Qes\n542ePDon4MfzWrY8YChzno/SMDGEk5Q2WNUYdVeIXXJvuVuZGw9jTSW8y2FE1p69\nj72Es3A1GIMK/9Lu6sH68iFriMAGccDVMvSnd2dbH8a2t3/XLEDj5H6QaKOZMSuT\nL9TOYqz94tcumFgX1V+bYTXGbaKFn2JWwZLPGdddahCVmtqQFWR0acLEMHtkl60g\n+2uz45U3eYAqhlQ/sBD8PpOWrc01foxaNk8R5hN24i/5BLVtc3GLz4RYMptI7ofX\n30xPRvow+mpB3tR39mLbKCPHk8EgjPv4ADyfCG+zZQmFP03KQC+qr1EYoFf2AraD\nQGgB5xa8YdVA4uyVy0v7NozTgpsHfG1wFKiv2cSS+pq25DFfPYJwGq95LAN7dnJK\npGrvdhIKDJ+U3/u/FBh6merx9G7gUc5ltFVAufSv3Jx91frUj8j8Gd+VyLgZ6hQo\n2fYQgtDbmGgJVDvQXm724hsjCcPmAAoZmESUI8ISXq875B56BTpQqmMy3SJju5Z9\nKekbOakXJ3x6NMuQ0QG752Pp6h+LD6p+4pPI9VzKa25obmrYAQVuux8830vPIMsm\nuqgtnWchE1HLeVPFNgP+VuNURhKh52zlridnl01MeKU2vi87p+I=\n=42Ur\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6daed7533174f1abdd3996c9174d006150f97aeb",
          "sha": "6daed7533174f1abdd3996c9174d006150f97aeb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6daed7533174f1abdd3996c9174d006150f97aeb"
        }
      ],
      "message": "style: modernize the style of SockMan::AcceptConnection()",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-09-15T16:07:13Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-09-17T15:29:07Z"
      },
      "sha": "64b13605dcb51bf6713c70d4b3fa41efaf1cc918"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU4NjNhOTgxMzE3YWUxMjQ0Yzk3MTNjMGNhZjBkNGUyOWEyNzY5NWQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e863a981317ae1244c9713c0caf0d4e29a27695d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e863a981317ae1244c9713c0caf0d4e29a27695d",
      "tree": {
        "sha": "21014869bc9d67d4f40f9270eb706a7b2f1091fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/21014869bc9d67d4f40f9270eb706a7b2f1091fb"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 21014869bc9d67d4f40f9270eb706a7b2f1091fb\nparent 64b13605dcb51bf6713c70d4b3fa41efaf1cc918\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749061156 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1757952433 -0400\n\nSockMan: generate sequential Ids for each newly accepted connection\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjIObEACgkQ5+KYS2KJ\nyTqfCA//X7+4tv2aUjCjFjMMbr07YtSL7jTCW6R+QP68ZgCZOT1DoUdgXJTMnM0l\nJezVG9NNdU7oJu4KOBfj69Ngn+PPaS8kCFm+GDnDtCHFvCCNOLMeBFO4Mk7ReM5k\nMRSOQC38NzDAV1ZzV+J9ZYmKblmRoIzRb7zH1PnacVXgnG1j4GsQLtDl3aCg+k0o\nZUppBlW0gB9Dn7CE8Ybtw7KWD7pjYxzwf4DZC8NXbdIgleBZcSH/JOA1AGOMFuO1\nnrRivFmT8kGKFmUwpQn34Y44fLR100R7cyCFmlTclCqWU5I/nk0jV51dEzT1psKS\nbypzKaSx68/2aBJzZ6MEbyZ4oX4D58ASYj3wtazrGBxQtOMt4sKLsgCiD8YLrJr1\nb36Tf3yMFccd6d+cAOrx8SlOJRiYoaXtIocu/pJu49+wLuJ1K7ez/o88+sYCefSi\nJX5vf3gVAmHDYlNXURdkg9yxdI5SBQ7zxk+3o/brXR4gPCeLmeXYjgaQeC9g6Cr1\nDaKNbEa7TYv9Rigk7p/7jQzzMcKjqsavzZ2cbVKx4XgMYK8oYwmuxsk0U012JV3O\nK4x+GlfIuypqKRgEr8VTRPDHdjQfOjMT4murPZk/9xUbEae661qJ2Io4So/EotxK\nb84pFkJnotz7Y6YDszVSTpbHtK88agHBehwJdkINrnYcWnT0YVo=\n=AIFi\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/64b13605dcb51bf6713c70d4b3fa41efaf1cc918",
          "sha": "64b13605dcb51bf6713c70d4b3fa41efaf1cc918",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/64b13605dcb51bf6713c70d4b3fa41efaf1cc918"
        }
      ],
      "message": "SockMan: generate sequential Ids for each newly accepted connection\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-09-15T16:07:13Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-04T18:19:16Z"
      },
      "sha": "e863a981317ae1244c9713c0caf0d4e29a27695d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDUzMTEyOGRmOWYyY2VjYjI1MzI2ZmViMjdhZTEwYzUwZTNmNWUyNmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/531128df9f2cecb25326feb27ae10c50e3f5e26a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/531128df9f2cecb25326feb27ae10c50e3f5e26a",
      "tree": {
        "sha": "c907f3e7bb5be0dfcfe9249b74eeb98b20d2bfaf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c907f3e7bb5be0dfcfe9249b74eeb98b20d2bfaf"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree c907f3e7bb5be0dfcfe9249b74eeb98b20d2bfaf\nparent e863a981317ae1244c9713c0caf0d4e29a27695d\nauthor Matthew Zipkin <pinheadmz@pm.me> 1750703761 -0700\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1757952434 -0400\n\n[move-only] Make GetBindAddress() callable from outside net.cpp\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjIObIACgkQ5+KYS2KJ\nyTr2WA//ec3D2sd/lod1WcNXsZNQur4OuWzglm6XlCv5yfaq5UgrEubkBm3VfAGP\nXUk4miWyV2XU/CLBmOFuv/c866LIbHejp1/TZ/OUqs5MC5F3zVo2MuFZh3szrRjt\n64XG/vWLUT27OfmgvGe1+LitRAkBEKKqlysO1FQvXYZN2UO/RNPnO/KMl1dFWW1q\nBs7UzvbwARPe8pqQWoohVOUVzxK8h1eK6/FAYcEWgASqB5hG6EfdvzQT+cwIE1y5\nqYXj4Erb6C5NHzURnuEdAeM0FjttW/aDPGXQAEiMHW9AaipoRbxe50Q7F6pMEHKu\n/4ae7sofCnSoqANcSJUInvPstPAj6duELaS16QBJ3X9uSVUrADyUfV4Hk9vXRqYv\npBqqaNTt6SuUYdnx5vkS3vkuO4I9gXupy6JV/GNoh4V5H8zK7UAV92Dd1fxNEcPO\n1A5djfWbl+vtnwWHJo+KcRijUYv0MRI8KMAtcx+Ov0KqKPuoINANJbz1BWxs2nb8\nqL6v+1oyHIO0Nls7u1642/Me1upTt47F9a0W6CXzIg9yRw0mhMafhMKOubSrj315\nbsHWHfbIN23Mi4lhCWARHs/6L3XhWdmsEquglRjr7vBhRrWPMOx96aULgHMxwV9O\nyEMCSHrWE7Cp8woxdoj3EuYylEZb0/5Fkbmh0UvK6CFUDmze+BA=\n=8Kzz\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e863a981317ae1244c9713c0caf0d4e29a27695d",
          "sha": "e863a981317ae1244c9713c0caf0d4e29a27695d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e863a981317ae1244c9713c0caf0d4e29a27695d"
        }
      ],
      "message": "[move-only] Make GetBindAddress() callable from outside net.cpp",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-09-15T16:07:14Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-23T18:36:01Z"
      },
      "sha": "531128df9f2cecb25326feb27ae10c50e3f5e26a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDhlYTdkNzM5YmVkY2JjYzMwYmVkNDM2ZjUwZjU2MDc5MDg0NGM1NGM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8ea7d739bedcbcc30bed436f50f560790844c54c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8ea7d739bedcbcc30bed436f50f560790844c54c",
      "tree": {
        "sha": "f6013ea238e25654fe3f4af777932a4f3d9035a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f6013ea238e25654fe3f4af777932a4f3d9035a5"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree f6013ea238e25654fe3f4af777932a4f3d9035a5\nparent 531128df9f2cecb25326feb27ae10c50e3f5e26a\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749754636 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1757952434 -0400\n\nSockMan: start an I/O loop in a new thread and accept connections\n\nSocket handling methods are copied from CConnMan:\n\n`CConnman::GenerateWaitSockets()` goes to\n`SockMan::GenerateWaitSockets()`.\n\n`CConnman::ThreadSocketHandler()` and\n`CConnman::SocketHandler()` are combined into\n`SockMan::ThreadSocketHandler()`.\n\n`CConnman::SocketHandlerListening()` goes to\n`SockMan::SocketHandlerListening()`.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjIObIACgkQ5+KYS2KJ\nyToPZA/9F24k1G54IO2+zQoucPcTEv7f0/dj8docCRapDo5VDShtHco6BcvFlqGs\nrfe+XDQPhd532jq4Mnkl7a5BabHTWqNu5MwGyntUzC3MxFDfYqVusmk7nE+GOTGs\n5o7H0u0bjHecSn5KQxLUWzNBn1pGUxyfV12BqJcwFOS3giDD3MkFNLf6BvI4el97\n2eR3168gElhWP0BHL81ddwjlNpzCzm1MDbU6xiOv+DKcRQQTW7GVidacZBivXHoh\nKBDEdH0Vd29wEYkhYVZb7s+LdI5hFMDSPy7SYJitXTuA5dEDUu92AUtKk/syvD5i\nVHBMgZKX6ZDURvunxj/BMC9ZWJyGKbE121jkU2xi9kk7015ihIJxhkO7uEUbUwCj\n3wouN2vMfFUqkcnOOE49D7K+RcyqtcuWSENvjZBFHWQwAQyO0KegU8CPb+Bk4pJm\nqzbtoB2jR14ooGi63dfJxMPBM9eTK5uRiVv0pscpsOjAnF9sWugwYHa/q7Qwnp7I\nPz09xJhU/DM1ktQqKo9eOcS3sm1+UmHYyEidJd75O8WyIHcvABXzGCk1zg6Wj4tm\n2V29TAW4PfAgG9w5z0xxZ1xxSKppeoCWYv8cJXbpna1vR/mTl8Cb4fyW3elt7yoV\nDN2DaRkPVwGlmIj/ZXTGMgTCa7ud3NPvqOwdU0JCHA6WjsTTMzw=\n=vFBV\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/531128df9f2cecb25326feb27ae10c50e3f5e26a",
          "sha": "531128df9f2cecb25326feb27ae10c50e3f5e26a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/531128df9f2cecb25326feb27ae10c50e3f5e26a"
        }
      ],
      "message": "SockMan: start an I/O loop in a new thread and accept connections\n\nSocket handling methods are copied from CConnMan:\n\n`CConnman::GenerateWaitSockets()` goes to\n`SockMan::GenerateWaitSockets()`.\n\n`CConnman::ThreadSocketHandler()` and\n`CConnman::SocketHandler()` are combined into\n`SockMan::ThreadSocketHandler()`.\n\n`CConnman::SocketHandlerListening()` goes to\n`SockMan::SocketHandlerListening()`.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-09-15T16:07:14Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-12T18:57:16Z"
      },
      "sha": "8ea7d739bedcbcc30bed436f50f560790844c54c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDUxMzZjNDlkZWE4Y2ViOWU0M2NkYzMwZWQ4ZjQwZTM3ZDk0MmQ3ODY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5136c49dea8ceb9e43cdc30ed8f40e37d942d786",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5136c49dea8ceb9e43cdc30ed8f40e37d942d786",
      "tree": {
        "sha": "fa4a04209c553f79f2b3b3bfa2d7beddca5b4485",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fa4a04209c553f79f2b3b3bfa2d7beddca5b4485"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree fa4a04209c553f79f2b3b3bfa2d7beddca5b4485\nparent 8ea7d739bedcbcc30bed436f50f560790844c54c\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749756905 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1757952434 -0400\n\nSockMan: handle connected sockets: read data from socket\n\n`CConnman::SocketHandlerConnected()` copied to\n`SockMan::SocketHandlerConnected()`.\n\nTesting this requires adding a new feature to the SocketTestingSetup,\ninserting a \"request\" payload into the mock client that connects\nto us.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjIObIACgkQ5+KYS2KJ\nyToc9RAA1T0RsFLyAj2kCtAhKKu53tB2G+ljp1FzpHNJKHZn+DKXacxOTR9hrwDb\n3xz4esdEfXCaul4JhvEE3G23BlRRgWnfxCfpXnY3kwCIMVxqnu8V8B+rVLHcwIOV\nO1uH3D9b8VuLEftOqlOTE4p5rrdhj+D67ObGQUY9tJ9TYb+mUjzfFmLHR/nYIxAR\nKVGsn5OrAp0G/PwLkaBq0aQpvQoHA4E00oS8GH2l919ulKJdB5C9jam+4WmZ5P5k\nNWkLV9Gpe2TFspzs9KYGKh2nsz7s7E4NARsEN6ZAjnTzvZ8NJ98TukKjcD6lM6Ot\nKDDFkZXodYLR+91oRw9CdzAetBLW5jPECrB5abhlolX4TV8n4J5wKQ/vdEJyoO94\n7ONdsTMGpbekC+JzERTGOapweZEQ7ndIP2BM3CnJ3A/xtzLUjZndVeOvU1cAn8a+\nkzzHz1XxStDmuNRdBfPOYGkHkIWuWt56P+IA6dBda9BFC+K+WKePj+RzLR2FFTIV\nNYSNOjjvKb7o/EMoAjcdJhAS8o0oFhJDwue9Vz1U4aKlp3/LrQCsVkRHKhgKDz15\ntMhmB0N4FUOPqwb+JB8zmyFEWCApEdYWhky40fHgMpg9t5yaD/UhZYWP3nvpZLgV\n7gOMLkJT4R1puw7jttTU/9spXWyhC4EarR5iwVWGN1MhxP+fFXA=\n=dl3z\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8ea7d739bedcbcc30bed436f50f560790844c54c",
          "sha": "8ea7d739bedcbcc30bed436f50f560790844c54c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8ea7d739bedcbcc30bed436f50f560790844c54c"
        }
      ],
      "message": "SockMan: handle connected sockets: read data from socket\n\n`CConnman::SocketHandlerConnected()` copied to\n`SockMan::SocketHandlerConnected()`.\n\nTesting this requires adding a new feature to the SocketTestingSetup,\ninserting a \"request\" payload into the mock client that connects\nto us.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-09-15T16:07:14Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-12T19:35:05Z"
      },
      "sha": "5136c49dea8ceb9e43cdc30ed8f40e37d942d786"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDJhNWU5NGJjZjczOWU0NGRmNjIwNmVkMzMxZmUyODNiNDRhZjliZjc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2a5e94bcf739e44df6206ed331fe283b44af9bf7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/2a5e94bcf739e44df6206ed331fe283b44af9bf7",
      "tree": {
        "sha": "291dbaab34017bca0d9530e433ff4b9617a5290d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/291dbaab34017bca0d9530e433ff4b9617a5290d"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 291dbaab34017bca0d9530e433ff4b9617a5290d\nparent 5136c49dea8ceb9e43cdc30ed8f40e37d942d786\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749824279 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1757952434 -0400\n\nSockMan: handle connected sockets: write data to socket\n\nSockets-touching bits from `CConnman::SocketSendData()` copied to\n`SockMan::SendBytes()`.\n\nTesting this requires adding a new feature to the SocketTestingSetup,\nreturning the DynSock I/O pipes from the mock socket so the received\ndata can be checked.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjIObIACgkQ5+KYS2KJ\nyTr//w/+Onrj90iKbdJPAqjJlrZY+YPzTzjmq6vv8PL8lpJYGv/sO0n4cDeGk9HW\njWOiRHjMz8jJhehUdRNSNA/M/3v06NL8pVdEjlnkldsf8dNHW9CD9JLeeUBIcomh\nZN1KuPrqPFPvsCZ7GFhXqFhzwdGWO+7td3j6XgxoOD7mzDWK6VnM432QB9KVWJsS\nhrTc1kJBQHUGMta657Ia8pamXUQUm94HCsOUwX2Trf2qR05GbfjDm0Wq4kX+0SMi\ndjqsXgTKbOfnWSkUJcNvLaNsWOTHIsklxnA88xsMdOA8klR1iOOS0bFXtq9XRilO\nqNmmbFuj4uLtaOlGYSdlpOonhuHhSmrdJ+ntGKF5oTJ3LyLntia8Qjo3kZ4dmP+X\nthGqMWroemaJIrs1zbCtHsrUekJDFkcHFZYCkz24Jh+ylJ9EEpeoph5NdK6AMvJe\nTfR/MuAepXt4ybkHOMulpZOhAMTyIpsZfp48ks2zPZr4s08G8hXdAQPKkRGBl8md\n+XB3I1wg/J4RcAbWDuv970H99PLBFcw9HK2WQOBamnQf886iHc7DGGh1G1F8pRhx\nOuak6ZoAZ6yKQsLeI8pPp2E73KcvDaxleI0pwzOpNL5VVNfzGuYctrLDwClkJXRT\nhP5l9KbFglDacg8EqE4EpjJ3JdYxXIYJZ8/sNKsNJS53urX0hw0=\n=rX3C\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5136c49dea8ceb9e43cdc30ed8f40e37d942d786",
          "sha": "5136c49dea8ceb9e43cdc30ed8f40e37d942d786",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5136c49dea8ceb9e43cdc30ed8f40e37d942d786"
        }
      ],
      "message": "SockMan: handle connected sockets: write data to socket\n\nSockets-touching bits from `CConnman::SocketSendData()` copied to\n`SockMan::SendBytes()`.\n\nTesting this requires adding a new feature to the SocketTestingSetup,\nreturning the DynSock I/O pipes from the mock socket so the received\ndata can be checked.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-09-15T16:07:14Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-13T14:17:59Z"
      },
      "sha": "2a5e94bcf739e44df6206ed331fe283b44af9bf7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGUwMDdlMWI1N2Q1ZDQyYzJhOGQ5MzJkNWI5MWVlYzhhM2NhNzZlMTQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "tree": {
        "sha": "5b8f9fcdaa15fa671a086c211adad7264efb0d1c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5b8f9fcdaa15fa671a086c211adad7264efb0d1c"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 5b8f9fcdaa15fa671a086c211adad7264efb0d1c\nparent 2a5e94bcf739e44df6206ed331fe283b44af9bf7\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749825814 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1757952435 -0400\n\nSockMan: dispatch cyclical events from I/O loop\n\nCopy from some parts of `CConnman::SocketHandlerConnected()` and\n`CConnman::ThreadSocketHandler()` to:\n`EventIOLoopCompletedForOne(id)` and `EventIOLoopCompletedForAll()`.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmjIObMACgkQ5+KYS2KJ\nyTrtdQ/+JEuy89rvbfHCFH9CPbKkuN9ZoeNpwlAoGo4Qp6wY8vD3Y19vgHI+hYba\nSY+YiBNP4TFjtwVAy1Yw8r/4ngpwxHgOXG9i25gL3On3ggA1mWULnWdfSQFbIBFK\n7JQBhdNcFlEofwQBsQcGfKuW1mqcCCa/f5h4LpnQMMi3e2Fg10FwCXzBDxyOfQGo\npzmRJgEX/aC0LPPIrw7XQEaHoPks7j3aqBLJC0QBbAU1Vz5OMyw+F2TlteyfFvKp\n1QLLykKy22fqX3U//wkDg6NbgEjTdDnPrsvl3uQhpdwUkk5INNUvwl6GKAAW1RSZ\nl5grWQuYkuSCW6AidIKZ7GvIxHLjfeLkM0fC35a8ieNt+Aw37l0JFEga941oMiDi\ntqE3tn41fDBMozzpDjnyYr+j9GWhy+ym9bgXA41D4TCndx0Vm7Vr5iCpWF66KXC8\nedzIjInnJLiHED4C3FtiCQzgTXfU4VN9yp45KHwdStcxV47R9gQ1bNQT7JKbFzt2\n38K4fC8fdSHvYkTW7IJ4JfvywEjVtSD91LvsDKEDRXpJb6Of7Wx6G7YJ912MCERR\nrClG/jRd161u9+ufeRVyHopGu9SXRkXdtYfwfr1ORj9Rj1yQmP3IJcXmeSJ24ctI\nGralAOIn3nThnOtXLFdPF008UVE4NikAeEQp1SiPYzl1fam8NPE=\n=KOp/\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2a5e94bcf739e44df6206ed331fe283b44af9bf7",
          "sha": "2a5e94bcf739e44df6206ed331fe283b44af9bf7",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/2a5e94bcf739e44df6206ed331fe283b44af9bf7"
        }
      ],
      "message": "SockMan: dispatch cyclical events from I/O loop\n\nCopy from some parts of `CConnman::SocketHandlerConnected()` and\n`CConnman::ThreadSocketHandler()` to:\n`EventIOLoopCompletedForOne(id)` and `EventIOLoopCompletedForAll()`.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-09-15T16:07:15Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-13T14:43:34Z"
      },
      "sha": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19709142510,
      "node_id": "HRFPE_lADOABII5867bDTqzwAAAASWwaXu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19709142510",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "created_at": "2025-09-15T19:22:52Z"
    },
    {
      "event": "reviewed",
      "id": 3217223929,
      "node_id": "PRR_kwDOABII586_wvD5",
      "url": null,
      "actor": null,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-15T19:31:22Z",
      "author_association": "MEMBER",
      "body": "Rebase to e007e1b57d addresses excellent thorough review from @hodlinator (THANKS!). Most significant changes involve casting arguments to socket functions (see #33378) and cleaning up protected/private membership of `SockMan`. I have locally rebased #32061 on these changes and everything still passes ;-) I will update that PR soon based on these changes.",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#pullrequestreview-3217223929",
      "submitted_at": "2025-09-15T19:31:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2158577472",
      "pull_request_review_id": 2945433124,
      "id": 2158577472,
      "node_id": "PRRC_kwDOABII586AqUdA",
      "diff_hunk": "@@ -0,0 +1,155 @@\n+// Copyright (c) 2021-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::vector<uint8_t> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData() EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received;\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received.assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Larger payloads may require multiple write operations in production\n+                // but since there is no actual network socket involved in the test\n+                // we should be able to simplify.\n+                BOOST_CHECK_EQUAL(sent, m_respond.size());\n+                // Only send the response once\n+                m_respond.clear();\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};",
      "path": "src/test/sockman_tests.cpp",
      "position": 94,
      "original_position": 90,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9299d5dbc5 `SockMan: introduce class and implement binding to listening socket`\r\n\r\nnit, ensure `Lookup()` succeeded before continuing because below `addr_bind.value()` is used unconditionally:\r\n\r\n```cpp\r\nBOOST_REQUIRE(addr.has_value());\r\n```",
      "created_at": "2025-06-20T10:15:06Z",
      "updated_at": "2025-06-23T10:09:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2158577472",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2158577472"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 94,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2158822151",
      "pull_request_review_id": 2945433124,
      "id": 2158822151,
      "node_id": "PRRC_kwDOABII586ArQMH",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 29,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`GetBindAddress()` is the same as in `net.cpp`. It is nice to have this PR remove 0 lines, but I think it is better to make an exception and move the function from `net.cpp` to `netbase.{h,cpp}` and use that from both `net.cpp` and `common/sockman.cpp`.",
      "created_at": "2025-06-20T12:14:30Z",
      "updated_at": "2025-06-23T10:09:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2158822151",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2158822151"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 17,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161187096",
      "pull_request_review_id": 2945433124,
      "id": 2161187096,
      "node_id": "PRRC_kwDOABII586A0RkY",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSockets(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAll();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }\n+\n+        // Service (send/receive) each of the already connected sockets.\n+        SocketHandlerConnected(io_readiness);\n+\n+        // Accept new connections from listening sockets.\n+        SocketHandlerListening(io_readiness.events_per_sock);",
      "path": "src/common/sockman.cpp",
      "position": 256,
      "original_position": 267,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "_674a5ff8f1 `SockMan: handle connected sockets: read data from socket`_\r\n\r\nIn the commit message: `s/conencts/connects/`",
      "created_at": "2025-06-23T09:48:37Z",
      "updated_at": "2025-06-23T10:09:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2161187096",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161187096"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 256,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161205701",
      "pull_request_review_id": 2945433124,
      "id": 2161205701,
      "node_id": "PRRC_kwDOABII586A0WHF",
      "diff_hunk": "@@ -0,0 +1,151 @@\n+// Copyright (c) 2021-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::vector<uint8_t> m_received;",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 26,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "_674a5ff8f1 `SockMan: handle connected sockets: read data from socket`_\r\n\r\n`m_received` would better be per-client:\r\n```cpp\r\nstd::unordered_map<Id, std::vector<uint8_t>> m_received;\r\n```\r\nand then adjust `EventGotData()` to plug the data in the client's slot:\r\n```cpp\r\nm_received[id].assign(data.begin(), data.end());\r\n```\r\nand `GetReceivedData()` to get the data for the client:\r\n```cpp\r\nGetReceivedData(Id id)\r\n{\r\n    return m_received[id];\r\n}\r\n```",
      "created_at": "2025-06-23T09:57:18Z",
      "updated_at": "2025-06-23T10:09:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2161205701",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161205701"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161216030",
      "pull_request_review_id": 2945433124,
      "id": 2161216030,
      "node_id": "PRRC_kwDOABII586A0Yoe",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,",
      "path": "src/common/sockman.cpp",
      "position": 123,
      "original_position": 191,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "_3f796b69c8 `SockMan: handle connected sockets: write data to socket`_\r\n\r\nIn the commit message: `s/recevied/received/`",
      "created_at": "2025-06-23T10:02:53Z",
      "updated_at": "2025-06-23T10:09:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2161216030",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161216030"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 123,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162235428",
      "pull_request_review_id": 2951071498,
      "id": 2162235428,
      "node_id": "PRRC_kwDOABII586A4Rgk",
      "diff_hunk": "@@ -0,0 +1,155 @@\n+// Copyright (c) 2021-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::vector<uint8_t> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData() EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received;\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received.assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Larger payloads may require multiple write operations in production\n+                // but since there is no actual network socket involved in the test\n+                // we should be able to simplify.\n+                BOOST_CHECK_EQUAL(sent, m_respond.size());\n+                // Only send the response once\n+                m_respond.clear();\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};",
      "path": "src/test/sockman_tests.cpp",
      "position": 94,
      "original_position": 90,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "in_reply_to_id": 2158577472,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "ðŸ‘ ",
      "created_at": "2025-06-23T18:18:35Z",
      "updated_at": "2025-06-24T00:43:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2162235428",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162235428"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 94,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162288958",
      "pull_request_review_id": 2951071498,
      "id": 2162288958,
      "node_id": "PRRC_kwDOABII586A4ek-",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 29,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "5f7941187a12f6d1d180ee29b72b2a5ee7a578b8",
      "in_reply_to_id": 2158822151,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Oh yes thanks, done by inserting a move-only commit",
      "created_at": "2025-06-23T18:32:08Z",
      "updated_at": "2025-06-24T00:43:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2162288958",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162288958"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 17,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162324748",
      "pull_request_review_id": 2951071498,
      "id": 2162324748,
      "node_id": "PRRC_kwDOABII586A4nUM",
      "diff_hunk": "@@ -0,0 +1,151 @@\n+// Copyright (c) 2021-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::vector<uint8_t> m_received;",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 26,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "in_reply_to_id": 2161205701,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good catch, taken. I was hoping to get away with only ever using one client in this test but this makes more sense for coverage anyway ;-)",
      "created_at": "2025-06-23T18:47:07Z",
      "updated_at": "2025-06-24T00:43:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2162324748",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162324748"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162325395",
      "pull_request_review_id": 2951071498,
      "id": 2162325395,
      "node_id": "PRRC_kwDOABII586A4neT",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSockets(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAll();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }\n+\n+        // Service (send/receive) each of the already connected sockets.\n+        SocketHandlerConnected(io_readiness);\n+\n+        // Accept new connections from listening sockets.\n+        SocketHandlerListening(io_readiness.events_per_sock);",
      "path": "src/common/sockman.cpp",
      "position": 256,
      "original_position": 267,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "in_reply_to_id": 2161187096,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "ðŸ‘ ",
      "created_at": "2025-06-23T18:47:22Z",
      "updated_at": "2025-06-24T00:43:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2162325395",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162325395"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 256,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162331716",
      "pull_request_review_id": 2951071498,
      "id": 2162331716,
      "node_id": "PRRC_kwDOABII586A4pBE",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,",
      "path": "src/common/sockman.cpp",
      "position": 123,
      "original_position": 191,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "130708803dd623c37e21bf72887ea84cf59460cc",
      "in_reply_to_id": 2161216030,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "ðŸ‘ ",
      "created_at": "2025-06-23T18:51:26Z",
      "updated_at": "2025-06-24T00:43:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2162331716",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2162331716"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 123,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2226846994",
      "pull_request_review_id": 3049290299,
      "id": 2226846994,
      "node_id": "PRRC_kwDOABII586Euv0S",
      "diff_hunk": "@@ -17,6 +17,7 @@\n #include <pubkey.h>\n #include <stdexcept>\n #include <test/util/random.h>\n+#include <test/util/net.h>",
      "path": "src/test/util/setup_common.h",
      "position": 4,
      "original_position": 4,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "535daaf15fd754335116d17833a45261cdff4e93 nit, sort",
      "created_at": "2025-07-23T22:24:36Z",
      "updated_at": "2025-07-23T22:42:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2226846994",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2226846994"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 19,
      "original_line": 19,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2226848616",
      "pull_request_review_id": 3049290299,
      "id": 2226848616,
      "node_id": "PRRC_kwDOABII586EuwNo",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2021-2022 The Bitcoin Core developers",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "535daaf15fd754335116d17833a45261cdff4e93 (edit, or is this due to the code already existing, if yes, please mention this in the commit message)\r\n\r\n```suggestion\r\n// Copyright (c) 2025-present The Bitcoin Core developers\r\n```",
      "created_at": "2025-07-23T22:25:30Z",
      "updated_at": "2025-07-23T22:46:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2226848616",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2226848616"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260675972",
      "pull_request_review_id": 3097669539,
      "id": 2260675972,
      "node_id": "PRRC_kwDOABII586Gvy2E",
      "diff_hunk": "@@ -17,6 +17,7 @@\n #include <pubkey.h>\n #include <stdexcept>\n #include <test/util/random.h>\n+#include <test/util/net.h>",
      "path": "src/test/util/setup_common.h",
      "position": 4,
      "original_position": 4,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "in_reply_to_id": 2226846994,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "fixed, thanks",
      "created_at": "2025-08-07T15:26:59Z",
      "updated_at": "2025-08-07T15:35:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2260675972",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260675972"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 19,
      "original_line": 19,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260702590",
      "pull_request_review_id": 3097669539,
      "id": 2260702590,
      "node_id": "PRRC_kwDOABII586Gv5V-",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2021-2022 The Bitcoin Core developers",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "3e7abceecfd790bc0887f647d3f731328e19810f",
      "in_reply_to_id": 2226848616,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks, removed the years entirely which seems to be the style for new files.",
      "created_at": "2025-08-07T15:34:03Z",
      "updated_at": "2025-08-07T15:35:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2260702590",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260702590"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288381255",
      "pull_request_review_id": 3022243737,
      "id": 2288381255,
      "node_id": "PRRC_kwDOABII586IZe1H",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 128,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could we avoid public data in the initial version?\r\n```C++\r\n    void InterruptNet() { interruptNet(); }\r\n\r\n    const std::vector<std::shared_ptr<Sock>>& ListenSockets() const { return m_listen; }\r\n```\r\nAlternatively make them `protected` and expose them in `TestSockMan`.",
      "created_at": "2025-08-20T14:33:17Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2288381255",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288381255"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 120,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288986758",
      "pull_request_review_id": 3022243737,
      "id": 2288986758,
      "node_id": "PRRC_kwDOABII586IbyqG",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 26,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Might as well:\r\n```suggestion\r\n        std::vector<std::pair<Id, CService>> m_connections GUARDED_BY(m_connections_mutex);\r\n\r\n        // Received data is written here by the SockMan I/O thread\r\n        // and tested by the main thread.\r\n        Mutex m_received_mutex;\r\n        std::unordered_map<Id, std::vector<uint8_t>> m_received GUARDED_BY(m_received_mutex);\r\n```",
      "created_at": "2025-08-20T18:39:53Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2288986758",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288986758"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 21,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288991450",
      "pull_request_review_id": 3022243737,
      "id": 2288991450,
      "node_id": "PRRC_kwDOABII586Ibzza",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 66,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit:\r\n```suggestion\r\n        }\r\n        virtual void EventGotEOF(Id id) override {}\r\n        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {}\r\n```",
      "created_at": "2025-08-20T18:42:14Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2288991450",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288991450"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 64,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288996230",
      "pull_request_review_id": 3022243737,
      "id": 2288996230,
      "node_id": "PRRC_kwDOABII586Ib0-G",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Remove sent bytes until entire response is sent.\n+                m_respond.erase(m_respond.begin(), m_respond.begin() + sent);\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};\n+    BOOST_REQUIRE(addr_bind.has_value());\n+    bilingual_str strError;",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 88,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nits:\r\n1. Should be snake_case.\r\n2. Could be put with the block that uses it.",
      "created_at": "2025-08-20T18:44:37Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2288996230",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2288996230"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2289014362",
      "pull_request_review_id": 3022243737,
      "id": 2289014362,
      "node_id": "PRRC_kwDOABII586Ib5Za",
      "diff_hunk": "@@ -270,6 +271,24 @@ std::unique_ptr<T> MakeNoLogFileContext(const ChainType chain_type = ChainType::\n     return std::make_unique<T>(chain_type, opts);\n }\n \n+class SocketTestingSetup : public BasicTestingSetup\n+{\n+public:\n+    explicit SocketTestingSetup();\n+    ~SocketTestingSetup();\n+\n+    // Connect to the socket with a mock client (a DynSock) and send pre-loaded data.\n+    // Returns the I/O pipes from the mock client so we can read response datasent to it.\n+    std::shared_ptr<DynSock::Pipes> ConnectClient(const std::vector<uint8_t>& data);",
      "path": "src/test/util/setup_common.h",
      "position": 1,
      "original_position": 20,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "More modern:\r\n```suggestion\r\n    std::shared_ptr<DynSock::Pipes> ConnectClient(std::span<const std::byte> data);\r\n```",
      "created_at": "2025-08-20T18:53:25Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2289014362",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2289014362"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2289081739",
      "pull_request_review_id": 3022243737,
      "id": 2289081739,
      "node_id": "PRRC_kwDOABII586IcJ2L",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Remove sent bytes until entire response is sent.\n+                m_respond.erase(m_respond.begin(), m_respond.begin() + sent);\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};\n+    BOOST_REQUIRE(addr_bind.has_value());\n+    bilingual_str strError;\n+\n+    // Init state\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 0);\n+    // Bind to mock Listening Socket\n+    BOOST_REQUIRE(sockman.BindAndStartListening(addr_bind.value(), strError));\n+    // We are bound and listening\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 1);\n+\n+    // Name the SockMan I/O thread\n+    SockMan::Options options{\"test_sockman\"};\n+    // Start the I/O loop\n+    sockman.StartSocketsThreads(options);\n+\n+    // No connections yet\n+    BOOST_CHECK_EQUAL(sockman.GetConnectionsCount(), 0);\n+\n+    // Create a mock client with a data payload to send\n+    // and add it to the local CreateSock queue\n+    const std::vector<uint8_t> request = {'b', 'i', 't', 's'};\n+    auto pipes{ConnectClient(request)};\n+\n+    // Wait up to a minute to find and connect the client in the I/O loop\n+    int attempts{6000};\n+    while (sockman.GetConnectionsCount() < 1) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Inspect the connection\n+    auto client{sockman.GetFirstConnection()};\n+    BOOST_CHECK_EQUAL(client.second.ToStringAddrPort(), \"5.5.5.5:6789\");\n+\n+    // Wait up to a minute to read the data from the connection\n+    attempts = 6000;\n+    while (!std::ranges::equal(sockman.GetReceivedData(client.first), request)) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Wait up to a minute to write our response data back to the connection\n+    attempts = 6000;\n+    size_t expected_response_size = sockman.m_respond.size();\n+    std::vector<uint8_t> actually_received(expected_response_size);\n+    while (!std::ranges::equal(actually_received, sockman.m_respond)) {\n+        // Read the data received by the mock socket\n+        ssize_t bytes_read = pipes->send.GetBytes((void *)actually_received.data(), expected_response_size);",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 134,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: No need to cast to `void*`:\r\n```suggestion\r\n        ssize_t bytes_read = pipes->send.GetBytes(actually_received.data(), expected_response_size);\r\n```",
      "created_at": "2025-08-20T19:21:13Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2289081739",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2289081739"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293235155",
      "pull_request_review_id": 3022243737,
      "id": 2293235155,
      "node_id": "PRRC_kwDOABII586Ir_3T",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Maybe update/remove year? (Not a copyright lawyer).",
      "created_at": "2025-08-22T09:39:52Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293235155",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293235155"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293246152",
      "pull_request_review_id": 3022243737,
      "id": 2293246152,
      "node_id": "PRRC_kwDOABII586IsCjI",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] id Id of the connection whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that connection will be omitted.\n+     */\n+    virtual void EventReadyToSend(Id id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] id Connection for which the data arrived.\n+     * @param[in] data Received data.\n+     */\n+    virtual void EventGotData(Id id, std::span<const uint8_t> data) = 0;\n+\n+    /**\n+     * Called when the remote peer has sent an EOF on the socket. This is a graceful\n+     * close of their writing side, we can still send and they will receive, if it\n+     * makes sense at the application level.\n+     * @param[in] id Connection whose socket got EOF.\n+     */\n+    virtual void EventGotEOF(Id id) = 0;\n+\n+    /**\n+     * Called when we get an irrecoverable error trying to read from a socket.\n+     * @param[in] id Connection whose socket got an error.\n+     * @param[in] errmsg Message describing the error.\n+     */\n+    virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) = 0;\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Can be used to temporarily pause sends on a connection.\n+     * SockMan would only call Send() if this returns true.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next call to EventReadyToSend().\n+     */\n+    virtual bool ShouldTryToSend(Id id) const;\n+\n+    /**\n+     * SockMan would only call Recv() on a connection's socket if this returns true.\n+     * Can be used to temporarily pause receives on a connection.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next receive.\n+     */\n+    virtual bool ShouldTryToRecv(Id id) const;\n+\n+    /**\n+     * SockMan has completed the current send+recv iteration for a given connection.\n+     * It will do another send+recv for this connection after processing all other connections.\n+     * Can be used to execute periodic tasks for a given connection.\n+     * The implementation in SockMan does nothing.\n+     * @param[in] id Connection for which send+recv has been done.\n+     */\n+    virtual void EventIOLoopCompletedForOne(Id id);\n+\n+    /**\n+     * SockMan has completed send+recv for all connections.\n+     * Can be used to execute periodic tasks for all connections, like closing\n+     * connections due to higher level logic.\n+     * The implementation in SockMan does nothing.\n+     */\n+    virtual void EventIOLoopCompletedForAll();\n+\n+    /**\n+     * The sockets used by a connection.\n+     */\n+    struct ConnectionSockets {\n+        explicit ConnectionSockets(std::unique_ptr<Sock>&& s)\n+            : sock{std::move(s)}\n+        {\n+        }\n+\n+        /**\n+         * Mutex that serializes the Send() and Recv() calls on `sock`.\n+         */\n+        Mutex mutex;\n+\n+        /**\n+         * Underlying socket.\n+         * `shared_ptr` (instead of `unique_ptr`) is used to avoid premature close of the\n+         * underlying file descriptor by one thread while another thread is poll(2)-ing\n+         * it for activity.\n+         * @see https://github.com/bitcoin/bitcoin/issues/21744 for details.\n+         */\n+        std::shared_ptr<Sock> sock;\n+    };\n+\n+    /**\n+     * Info about which socket has which event ready and its connection id.\n+     */\n+    struct IOReadiness {\n+        /**\n+         * Map of socket -> socket events. For example:\n+         * socket1 -> { requested = SEND|RECV, occurred = RECV }\n+         * socket2 -> { requested = SEND, occurred = SEND }\n+         */\n+        Sock::EventsPerSock events_per_sock;\n+\n+        /**\n+         * Map of socket -> connection id (in `m_connected`). For example\n+         * socket1 -> id=23\n+         * socket2 -> id=56\n+         */\n+        std::unordered_map<Sock::EventsPerSock::key_type,\n+                           SockMan::Id,\n+                           Sock::HashSharedPtrSock,\n+                           Sock::EqualSharedPtrSock>\n+            ids_per_sock;\n+    };\n+\n+    /**\n+     * Check connected and listening sockets for IO readiness and process them accordingly.\n+     */\n+    void ThreadSocketHandler()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate a collection of sockets to check for IO readiness.\n+     * @return Sockets to check for readiness plus an aux map to find the\n+     * corresponding connection id given a socket.\n+     */\n+    IOReadiness GenerateWaitSockets()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Do the read/write for connected sockets that are ready for IO.\n+     * @param[in] io_readiness Which sockets are ready and their connection ids.\n+     */\n+    void SocketHandlerConnected(const IOReadiness& io_readiness)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Accept incoming connections, one from each read-ready listening socket.\n+     * @param[in] events_per_sock Sockets that are ready for IO.\n+     */\n+    void SocketHandlerListening(const Sock::EventsPerSock& events_per_sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Retrieve an entry from m_connected.\n+     * @param[in] id Connection id to search for.\n+     * @return ConnectionSockets for the given connection id or empty shared_ptr if not found.\n+     */\n+    std::shared_ptr<ConnectionSockets> GetConnectionSockets(Id id) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * The id to assign to the next created connection. Used to generate ids of connections.",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 303,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit:\r\n```suggestion\r\n     * Used to generate ids for new connections.\r\n```",
      "created_at": "2025-08-22T09:44:53Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293246152",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293246152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 303,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293305352",
      "pull_request_review_id": 3022243737,
      "id": 2293305352,
      "node_id": "PRRC_kwDOABII586IsRAI",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 34,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could assert that various conditions are true:\r\n```suggestion\r\n    virtual ~SockMan()\r\n    {\r\n        assert(!m_thread_socket_handler.joinable()); // Missing call to JoinSocketsThreads()\r\n        assert(m_connected.empty()); // Missing call to CloseConnection()\r\n        assert(m_listen.empty()); // Missing call to StopListening()\r\n    }\r\n```\r\nhttps://en.cppreference.com/w/cpp/thread/thread/join.html#Postconditions",
      "created_at": "2025-08-22T10:11:06Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293305352",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293305352"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293330692",
      "pull_request_review_id": 3022243737,
      "id": 2293330692,
      "node_id": "PRRC_kwDOABII586IsXME",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 113,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could verify that we are operating on one of our own listen sockets?\r\n```suggestion\r\n{\r\n    Assume(std::ranges::find_if(m_listen, [&](const auto& sock) { return sock.get() == &listen_sock; }) != m_listen.end());\r\n```",
      "created_at": "2025-08-22T10:19:46Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293330692",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293330692"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 113,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293785752",
      "pull_request_review_id": 3022243737,
      "id": 2293785752,
      "node_id": "PRRC_kwDOABII586IuGSY",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 39,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Cast can be omitted here and a few lines down for `IPV6_V6ONLY` and `IPV6_PROTECTION_LEVEL`:\r\n```suggestion\r\n    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == SOCKET_ERROR) {\r\n```",
      "created_at": "2025-08-22T13:46:14Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293785752",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293785752"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293830000",
      "pull_request_review_id": 3022243737,
      "id": 2293830000,
      "node_id": "PRRC_kwDOABII586IuRFw",
      "diff_hunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    SockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr{Lookup(\"0.0.0.0\", 0, false)};",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 18,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "72864e46283550d408ca4a826786491e7cb36100",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Could call this `addr_bind` from first commit instead of renaming it later.",
      "created_at": "2025-08-22T14:03:43Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293830000",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293830000"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293838294",
      "pull_request_review_id": 3022243737,
      "id": 2293838294,
      "node_id": "PRRC_kwDOABII586IuTHW",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 88,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should these 3 not be `protected`/`private`?",
      "created_at": "2025-08-22T14:07:24Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293838294",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293838294"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 73,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293846814",
      "pull_request_review_id": 3022243737,
      "id": 2293846814,
      "node_id": "PRRC_kwDOABII586IuVMe",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] id Id of the connection whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that connection will be omitted.\n+     */\n+    virtual void EventReadyToSend(Id id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] id Connection for which the data arrived.\n+     * @param[in] data Received data.\n+     */\n+    virtual void EventGotData(Id id, std::span<const uint8_t> data) = 0;\n+\n+    /**\n+     * Called when the remote peer has sent an EOF on the socket. This is a graceful\n+     * close of their writing side, we can still send and they will receive, if it\n+     * makes sense at the application level.\n+     * @param[in] id Connection whose socket got EOF.\n+     */\n+    virtual void EventGotEOF(Id id) = 0;\n+\n+    /**\n+     * Called when we get an irrecoverable error trying to read from a socket.\n+     * @param[in] id Connection whose socket got an error.\n+     * @param[in] errmsg Message describing the error.\n+     */\n+    virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) = 0;\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Can be used to temporarily pause sends on a connection.\n+     * SockMan would only call Send() if this returns true.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next call to EventReadyToSend().\n+     */\n+    virtual bool ShouldTryToSend(Id id) const;\n+\n+    /**\n+     * SockMan would only call Recv() on a connection's socket if this returns true.\n+     * Can be used to temporarily pause receives on a connection.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next receive.\n+     */\n+    virtual bool ShouldTryToRecv(Id id) const;\n+\n+    /**\n+     * SockMan has completed the current send+recv iteration for a given connection.\n+     * It will do another send+recv for this connection after processing all other connections.\n+     * Can be used to execute periodic tasks for a given connection.\n+     * The implementation in SockMan does nothing.\n+     * @param[in] id Connection for which send+recv has been done.\n+     */\n+    virtual void EventIOLoopCompletedForOne(Id id);\n+\n+    /**\n+     * SockMan has completed send+recv for all connections.\n+     * Can be used to execute periodic tasks for all connections, like closing\n+     * connections due to higher level logic.\n+     * The implementation in SockMan does nothing.\n+     */\n+    virtual void EventIOLoopCompletedForAll();\n+\n+    /**\n+     * The sockets used by a connection.\n+     */\n+    struct ConnectionSockets {",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 222,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What is the reason for plural form?\r\n```suggestion\r\n    struct ConnectionSocket {\r\n```",
      "created_at": "2025-08-22T14:10:06Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293846814",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293846814"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293866540",
      "pull_request_review_id": 3022243737,
      "id": 2293866540,
      "node_id": "PRRC_kwDOABII586IuaAs",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSockets(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 203,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: -cast +newline\r\n```suggestion\r\n        return sockets->sock->Send(data.data(), data.size(), flags);\r\n    )};\r\n```",
      "created_at": "2025-08-22T14:17:57Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293866540",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293866540"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293894853",
      "pull_request_review_id": 3022243737,
      "id": 2293894853,
      "node_id": "PRRC_kwDOABII586Iug7F",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)",
      "path": "src/test/sockman_tests.cpp",
      "position": 55,
      "original_position": 51,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: I liked the style you had in sockman.h\r\n```suggestion\r\n            EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\r\n```",
      "created_at": "2025-08-22T14:29:14Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2293894853",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2293894853"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 55,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297305441",
      "pull_request_review_id": 3022243737,
      "id": 2297305441,
      "node_id": "PRRC_kwDOABII586I7hlh",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 110,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n                      std::span<const std::byte> data,\r\n```",
      "created_at": "2025-08-25T07:13:18Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2297305441",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297305441"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297308601",
      "pull_request_review_id": 3022243737,
      "id": 2297308601,
      "node_id": "PRRC_kwDOABII586I7iW5",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSockets(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAll();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }\n+\n+        // Service (send/receive) each of the already connected sockets.\n+        SocketHandlerConnected(io_readiness);\n+\n+        // Accept new connections from listening sockets.\n+        SocketHandlerListening(io_readiness.events_per_sock);\n+    }\n+}\n+\n+SockMan::IOReadiness SockMan::GenerateWaitSockets()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    IOReadiness io_readiness;\n+\n+    for (const auto& sock : m_listen) {\n+        io_readiness.events_per_sock.emplace(sock, Sock::Events{Sock::RECV});\n+    }\n+\n+    auto connected_snapshot{WITH_LOCK(m_connected_mutex, return m_connected;)};\n+\n+    for (const auto& [id, sockets] : connected_snapshot) {\n+        const bool select_recv{ShouldTryToRecv(id)};\n+        const bool select_send{ShouldTryToSend(id)};\n+        if (!select_recv && !select_send) continue;\n+\n+        Sock::Event event = (select_send ? Sock::SEND : 0) | (select_recv ? Sock::RECV : 0);\n+        io_readiness.events_per_sock.emplace(sockets->sock, Sock::Events{event});\n+        io_readiness.ids_per_sock.emplace(sockets->sock, id);\n+    }\n+\n+    return io_readiness;\n+}\n+\n+void SockMan::SocketHandlerConnected(const IOReadiness& io_readiness)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    for (const auto& [sock, events] : io_readiness.events_per_sock) {\n+        if (interruptNet) {\n+            return;\n+        }\n+\n+        auto it{io_readiness.ids_per_sock.find(sock)};\n+        if (it == io_readiness.ids_per_sock.end()) {\n+            continue;\n+        }\n+        const Id id{it->second};\n+\n+        bool send_ready = events.occurred & Sock::SEND; // Sock::SEND could only be set if ShouldTryToSend() has returned true in GenerateWaitSockets().\n+        bool recv_ready = events.occurred & Sock::RECV; // Sock::RECV could only be set if ShouldTryToRecv() has returned true in GenerateWaitSockets().\n+        bool err_ready = events.occurred & Sock::ERR;\n+\n+        if (send_ready) {\n+            bool cancel_recv;\n+\n+            EventReadyToSend(id, cancel_recv);\n+\n+            if (cancel_recv) {\n+                recv_ready = false;\n+            }\n+        }\n+\n+        if (recv_ready || err_ready) {\n+            uint8_t buf[0x10000]; // typical socket buffer is 8K-64K\n+\n+            auto sockets{GetConnectionSockets(id)};\n+            if (!sockets) {\n+                continue;\n+            }\n+\n+            const ssize_t nrecv{WITH_LOCK(\n+                sockets->mutex,\n+                return sockets->sock->Recv(buf, sizeof(buf), MSG_DONTWAIT);)};\n+\n+            if (nrecv < 0) { // In all cases (including -1 and 0) EventIOLoopCompletedForOne() should be executed after this, don't change the code to skip it.\n+                const int err = WSAGetLastError();\n+                if (err != WSAEWOULDBLOCK && err != WSAEMSGSIZE && err != WSAEINTR && err != WSAEINPROGRESS) {\n+                    EventGotPermanentReadError(id, NetworkErrorString(err));\n+                }\n+            } else if (nrecv == 0) {\n+                EventGotEOF(id);",
      "path": "src/common/sockman.cpp",
      "position": 332,
      "original_position": 329,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should we close the connection if we get EOF? See 972ee5cf6544c5c1ea4d445dc9c6fed16136c10c.",
      "created_at": "2025-08-25T07:15:05Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2297308601",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297308601"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 332,
      "original_line": 332,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297310218",
      "pull_request_review_id": 3022243737,
      "id": 2297310218,
      "node_id": "PRRC_kwDOABII586I7iwK",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] id Id of the connection whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that connection will be omitted.\n+     */\n+    virtual void EventReadyToSend(Id id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] id Connection for which the data arrived.\n+     * @param[in] data Received data.\n+     */\n+    virtual void EventGotData(Id id, std::span<const uint8_t> data) = 0;",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 164,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n    virtual void EventGotData(Id id, std::span<const std::byte> data) = 0;\r\n```",
      "created_at": "2025-08-25T07:15:57Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2297310218",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297310218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297336625",
      "pull_request_review_id": 3022243737,
      "id": 2297336625,
      "node_id": "PRRC_kwDOABII586I7pMx",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 63,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It could be more realistic to account for network stream being broken up:\r\n```suggestion\r\n            auto& vec{m_received[id]};\r\n            vec.insert(vec.end(), data.begin(), data.end());\r\n```\r\nImplemented a slightly tangential change in my suggestions branch to make `DynSock[::Pipe]` support simulating partial I/O in the vein of TCP/IP streams, see a5e7157563fc9866a75908cef65f7353109b6976.",
      "created_at": "2025-08-25T07:29:04Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2297336625",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2297336625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300320948",
      "pull_request_review_id": 3022243737,
      "id": 2300320948,
      "node_id": "PRRC_kwDOABII586JHBy0",
      "diff_hunk": "@@ -601,6 +601,42 @@ void TestChain100Setup::MockMempoolMinFee(const CFeeRate& target_feerate)\n     m_node.mempool->TrimToSize(0);\n     assert(m_node.mempool->GetMinFee() == target_feerate);\n }\n+\n+SocketTestingSetup::SocketTestingSetup()\n+    : m_create_sock_orig{CreateSock}\n+{\n+    CreateSock = [this](int, int, int) {\n+        // This is a mock Listening Socket that a server can \"bind\" to and\n+        // listen to for incoming connections. We won't need to access its I/O\n+        // pipes because we don't read or write directly to it. It will return\n+        // Connected Sockets from the queue via its Accept() method.\n+        return std::make_unique<DynSock>(std::make_shared<DynSock::Pipes>(), m_accepted_sockets);\n+    };\n+};\n+\n+SocketTestingSetup::~SocketTestingSetup()\n+{\n+    CreateSock = m_create_sock_orig;\n+}\n+\n+std::shared_ptr<DynSock::Pipes> SocketTestingSetup::ConnectClient(const std::vector<uint8_t>& data)\n+{\n+    // I/O pipes for a mock Connected Socket we can read and write to.\n+    std::shared_ptr<DynSock::Pipes> connected_socket_pipes(std::make_shared<DynSock::Pipes>());\n+\n+    // Insert the payload\n+    connected_socket_pipes->recv.PushBytes(data.data(), data.size());\n+\n+    // Create the Mock Connected Socket that represents a client.\n+    // It needs I/O pipes but its queue can remain empty\n+    std::unique_ptr<DynSock> connected_socket{std::make_unique<DynSock>(connected_socket_pipes, std::make_shared<DynSock::Queue>())};",
      "path": "src/test/util/setup_common.cpp",
      "position": 32,
      "original_position": 32,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Managed to remove `shared_ptr` usage internally in `DynSock`, see commit 7e894f39c41e2ba332aafc5879d7d7380cbcf2fd from my suggestions branch.",
      "created_at": "2025-08-26T09:03:00Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2300320948",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300320948"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 632,
      "original_line": 632,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300323835",
      "pull_request_review_id": 3022243737,
      "id": 2300323835,
      "node_id": "PRRC_kwDOABII586JHCf7",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Remove sent bytes until entire response is sent.\n+                m_respond.erase(m_respond.begin(), m_respond.begin() + sent);\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};\n+    BOOST_REQUIRE(addr_bind.has_value());\n+    bilingual_str strError;\n+\n+    // Init state\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 0);\n+    // Bind to mock Listening Socket\n+    BOOST_REQUIRE(sockman.BindAndStartListening(addr_bind.value(), strError));\n+    // We are bound and listening\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 1);\n+\n+    // Name the SockMan I/O thread\n+    SockMan::Options options{\"test_sockman\"};\n+    // Start the I/O loop\n+    sockman.StartSocketsThreads(options);\n+\n+    // No connections yet\n+    BOOST_CHECK_EQUAL(sockman.GetConnectionsCount(), 0);\n+\n+    // Create a mock client with a data payload to send\n+    // and add it to the local CreateSock queue\n+    const std::vector<uint8_t> request = {'b', 'i', 't', 's'};\n+    auto pipes{ConnectClient(request)};\n+\n+    // Wait up to a minute to find and connect the client in the I/O loop\n+    int attempts{6000};\n+    while (sockman.GetConnectionsCount() < 1) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Inspect the connection\n+    auto client{sockman.GetFirstConnection()};\n+    BOOST_CHECK_EQUAL(client.second.ToStringAddrPort(), \"5.5.5.5:6789\");\n+\n+    // Wait up to a minute to read the data from the connection\n+    attempts = 6000;\n+    while (!std::ranges::equal(sockman.GetReceivedData(client.first), request)) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Wait up to a minute to write our response data back to the connection\n+    attempts = 6000;\n+    size_t expected_response_size = sockman.m_respond.size();\n+    std::vector<uint8_t> actually_received(expected_response_size);\n+    while (!std::ranges::equal(actually_received, sockman.m_respond)) {\n+        // Read the data received by the mock socket\n+        ssize_t bytes_read = pipes->send.GetBytes((void *)actually_received.data(), expected_response_size);",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 134,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Implemented simulating partial transfer of stream in 6a74e1e9a7393ad51d7a1590384c8a6771b04972 (requires parent commit).",
      "created_at": "2025-08-26T09:04:07Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2300323835",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300323835"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300366190",
      "pull_request_review_id": 3022243737,
      "id": 2300366190,
      "node_id": "PRRC_kwDOABII586JHM1u",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;",
      "path": "src/common/sockman.h",
      "position": 123,
      "original_position": 147,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could add an `EventConnectionClosed()` to mirror this? See 0ca4fac1009017cddff9864ec9cac73d613d67f4.",
      "created_at": "2025-08-26T09:20:37Z",
      "updated_at": "2025-08-26T09:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2300366190",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300366190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": 121,
      "original_start_line": 145,
      "start_side": "RIGHT",
      "line": 123,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344586648",
      "pull_request_review_id": 3217223929,
      "id": 2344586648,
      "node_id": "PRRC_kwDOABII586Lv42Y",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSockets(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAll();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }\n+\n+        // Service (send/receive) each of the already connected sockets.\n+        SocketHandlerConnected(io_readiness);\n+\n+        // Accept new connections from listening sockets.\n+        SocketHandlerListening(io_readiness.events_per_sock);\n+    }\n+}\n+\n+SockMan::IOReadiness SockMan::GenerateWaitSockets()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    IOReadiness io_readiness;\n+\n+    for (const auto& sock : m_listen) {\n+        io_readiness.events_per_sock.emplace(sock, Sock::Events{Sock::RECV});\n+    }\n+\n+    auto connected_snapshot{WITH_LOCK(m_connected_mutex, return m_connected;)};\n+\n+    for (const auto& [id, sockets] : connected_snapshot) {\n+        const bool select_recv{ShouldTryToRecv(id)};\n+        const bool select_send{ShouldTryToSend(id)};\n+        if (!select_recv && !select_send) continue;\n+\n+        Sock::Event event = (select_send ? Sock::SEND : 0) | (select_recv ? Sock::RECV : 0);\n+        io_readiness.events_per_sock.emplace(sockets->sock, Sock::Events{event});\n+        io_readiness.ids_per_sock.emplace(sockets->sock, id);\n+    }\n+\n+    return io_readiness;\n+}\n+\n+void SockMan::SocketHandlerConnected(const IOReadiness& io_readiness)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    for (const auto& [sock, events] : io_readiness.events_per_sock) {\n+        if (interruptNet) {\n+            return;\n+        }\n+\n+        auto it{io_readiness.ids_per_sock.find(sock)};\n+        if (it == io_readiness.ids_per_sock.end()) {\n+            continue;\n+        }\n+        const Id id{it->second};\n+\n+        bool send_ready = events.occurred & Sock::SEND; // Sock::SEND could only be set if ShouldTryToSend() has returned true in GenerateWaitSockets().\n+        bool recv_ready = events.occurred & Sock::RECV; // Sock::RECV could only be set if ShouldTryToRecv() has returned true in GenerateWaitSockets().\n+        bool err_ready = events.occurred & Sock::ERR;\n+\n+        if (send_ready) {\n+            bool cancel_recv;\n+\n+            EventReadyToSend(id, cancel_recv);\n+\n+            if (cancel_recv) {\n+                recv_ready = false;\n+            }\n+        }\n+\n+        if (recv_ready || err_ready) {\n+            uint8_t buf[0x10000]; // typical socket buffer is 8K-64K\n+\n+            auto sockets{GetConnectionSockets(id)};\n+            if (!sockets) {\n+                continue;\n+            }\n+\n+            const ssize_t nrecv{WITH_LOCK(\n+                sockets->mutex,\n+                return sockets->sock->Recv(buf, sizeof(buf), MSG_DONTWAIT);)};\n+\n+            if (nrecv < 0) { // In all cases (including -1 and 0) EventIOLoopCompletedForOne() should be executed after this, don't change the code to skip it.\n+                const int err = WSAGetLastError();\n+                if (err != WSAEWOULDBLOCK && err != WSAEMSGSIZE && err != WSAEINTR && err != WSAEINPROGRESS) {\n+                    EventGotPermanentReadError(id, NetworkErrorString(err));\n+                }\n+            } else if (nrecv == 0) {\n+                EventGotEOF(id);",
      "path": "src/common/sockman.cpp",
      "position": 332,
      "original_position": 329,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2297308601,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That's for the consumer / child class of `SockMan` to decide!\r\n\r\nFor example in the HTTP server follow-up to this it's here: \r\n\r\nhttps://github.com/bitcoin/bitcoin/pull/32061/commits/badf3c38b3b1dab2d209a8e2c709e83afe9e4402#diff-63c8cb9c9dd61d50d59afd5c39914e1c259f8743030b637a7896a0746c851ef1R1208",
      "created_at": "2025-09-12T15:19:24Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2344586648",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344586648"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 332,
      "original_line": 332,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344930562",
      "pull_request_review_id": 3217223929,
      "id": 2344930562,
      "node_id": "PRRC_kwDOABII586LxM0C",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(id, me, them)) {\n+        CloseConnection(id);\n+    }\n+}\n+\n+SockMan::Id SockMan::GetNewId()\n+{\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSockets(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 203,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293866540,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for catching this, opened https://github.com/bitcoin/bitcoin/pull/33378 to clean up several such casts in existing code since this chunk was essentially copied from `net.cpp`.",
      "created_at": "2025-09-12T17:01:59Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2344930562",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344930562"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344946486",
      "pull_request_review_id": 3217223929,
      "id": 2344946486,
      "node_id": "PRRC_kwDOABII586LxQs2",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 128,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2288381255,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes will make these data private/protected and add public helpers.",
      "created_at": "2025-09-12T17:07:54Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2344946486",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344946486"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 120,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344956173",
      "pull_request_review_id": 3217223929,
      "id": 2344956173,
      "node_id": "PRRC_kwDOABII586LxTEN",
      "diff_hunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    SockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr{Lookup(\"0.0.0.0\", 0, false)};",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 18,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "72864e46283550d408ca4a826786491e7cb36100",
      "in_reply_to_id": 2293830000,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yep thanks",
      "created_at": "2025-09-12T17:11:14Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2344956173",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344956173"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344995517",
      "pull_request_review_id": 3217223929,
      "id": 2344995517,
      "node_id": "PRRC_kwDOABII586Lxcq9",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Remove sent bytes until entire response is sent.\n+                m_respond.erase(m_respond.begin(), m_respond.begin() + sent);\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};\n+    BOOST_REQUIRE(addr_bind.has_value());\n+    bilingual_str strError;",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 88,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2288996230,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2025-09-12T17:27:50Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2344995517",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344995517"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344997699",
      "pull_request_review_id": 3217223929,
      "id": 2344997699,
      "node_id": "PRRC_kwDOABII586LxdND",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293235155,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "You're right for new files we're removing the year(s) entirely.",
      "created_at": "2025-09-12T17:29:03Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2344997699",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2344997699"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345010900",
      "pull_request_review_id": 3217223929,
      "id": 2345010900,
      "node_id": "PRRC_kwDOABII586LxgbU",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 39,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293785752,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good catch see https://github.com/bitcoin/bitcoin/pull/33378",
      "created_at": "2025-09-12T17:35:47Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345010900",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345010900"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345020780",
      "pull_request_review_id": 3217223929,
      "id": 2345020780,
      "node_id": "PRRC_kwDOABII586Lxi1s",
      "diff_hunk": "@@ -0,0 +1,372 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 113,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293330692,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Sure taken",
      "created_at": "2025-09-12T17:41:05Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345020780",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345020780"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 113,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345071368",
      "pull_request_review_id": 3217223929,
      "id": 2345071368,
      "node_id": "PRRC_kwDOABII586LxvMI",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 88,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293838294,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yeah they can be thanks.",
      "created_at": "2025-09-12T18:07:50Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345071368",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345071368"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 73,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345103522",
      "pull_request_review_id": 3217223929,
      "id": 2345103522,
      "node_id": "PRRC_kwDOABII586Lx3Ci",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 26,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2288986758,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "ðŸ‘ ",
      "created_at": "2025-09-12T18:26:02Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345103522",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345103522"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 21,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345117449",
      "pull_request_review_id": 3217223929,
      "id": 2345117449,
      "node_id": "PRRC_kwDOABII586Lx6cJ",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] id Id of the connection whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that connection will be omitted.\n+     */\n+    virtual void EventReadyToSend(Id id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] id Connection for which the data arrived.\n+     * @param[in] data Received data.\n+     */\n+    virtual void EventGotData(Id id, std::span<const uint8_t> data) = 0;\n+\n+    /**\n+     * Called when the remote peer has sent an EOF on the socket. This is a graceful\n+     * close of their writing side, we can still send and they will receive, if it\n+     * makes sense at the application level.\n+     * @param[in] id Connection whose socket got EOF.\n+     */\n+    virtual void EventGotEOF(Id id) = 0;\n+\n+    /**\n+     * Called when we get an irrecoverable error trying to read from a socket.\n+     * @param[in] id Connection whose socket got an error.\n+     * @param[in] errmsg Message describing the error.\n+     */\n+    virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) = 0;\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Can be used to temporarily pause sends on a connection.\n+     * SockMan would only call Send() if this returns true.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next call to EventReadyToSend().\n+     */\n+    virtual bool ShouldTryToSend(Id id) const;\n+\n+    /**\n+     * SockMan would only call Recv() on a connection's socket if this returns true.\n+     * Can be used to temporarily pause receives on a connection.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next receive.\n+     */\n+    virtual bool ShouldTryToRecv(Id id) const;\n+\n+    /**\n+     * SockMan has completed the current send+recv iteration for a given connection.\n+     * It will do another send+recv for this connection after processing all other connections.\n+     * Can be used to execute periodic tasks for a given connection.\n+     * The implementation in SockMan does nothing.\n+     * @param[in] id Connection for which send+recv has been done.\n+     */\n+    virtual void EventIOLoopCompletedForOne(Id id);\n+\n+    /**\n+     * SockMan has completed send+recv for all connections.\n+     * Can be used to execute periodic tasks for all connections, like closing\n+     * connections due to higher level logic.\n+     * The implementation in SockMan does nothing.\n+     */\n+    virtual void EventIOLoopCompletedForAll();\n+\n+    /**\n+     * The sockets used by a connection.\n+     */\n+    struct ConnectionSockets {",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 222,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293846814,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'll fix, this is leftover from the original SockMan PR #30988 where this struct also included an I2P session.",
      "created_at": "2025-09-12T18:32:39Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345117449",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345117449"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345170456",
      "pull_request_review_id": 3217223929,
      "id": 2345170456,
      "node_id": "PRRC_kwDOABII586LyHYY",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 34,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293305352,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok I'll add these checks but I'm nervous about `assert()` so I'm going to use `Assume()` for now. In this case if there is a broken assumption it will only occur during server shutdown, but I don't want to terminate the program early in case there is still wallet cleanup scheduled after `~SockMan`. Lemme know if you think it should still be `assert()`.",
      "created_at": "2025-09-12T18:58:02Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345170456",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345170456"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345178689",
      "pull_request_review_id": 3217223929,
      "id": 2345178689,
      "node_id": "PRRC_kwDOABII586LyJZB",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)",
      "path": "src/test/sockman_tests.cpp",
      "position": 55,
      "original_position": 51,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293894853,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "ðŸ†’ ",
      "created_at": "2025-09-12T19:02:10Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345178689",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345178689"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 55,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345192358",
      "pull_request_review_id": 3217223929,
      "id": 2345192358,
      "node_id": "PRRC_kwDOABII586LyMum",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 66,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2288991450,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "ðŸ‘ ",
      "created_at": "2025-09-12T19:07:24Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345192358",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345192358"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": 64,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345201886",
      "pull_request_review_id": 3217223929,
      "id": 2345201886,
      "node_id": "PRRC_kwDOABII586LyPDe",
      "diff_hunk": "@@ -270,6 +271,24 @@ std::unique_ptr<T> MakeNoLogFileContext(const ChainType chain_type = ChainType::\n     return std::make_unique<T>(chain_type, opts);\n }\n \n+class SocketTestingSetup : public BasicTestingSetup\n+{\n+public:\n+    explicit SocketTestingSetup();\n+    ~SocketTestingSetup();\n+\n+    // Connect to the socket with a mock client (a DynSock) and send pre-loaded data.\n+    // Returns the I/O pipes from the mock client so we can read response datasent to it.\n+    std::shared_ptr<DynSock::Pipes> ConnectClient(const std::vector<uint8_t>& data);",
      "path": "src/test/util/setup_common.h",
      "position": 1,
      "original_position": 20,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2289014362,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i like it thanks",
      "created_at": "2025-09-12T19:11:06Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345201886",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345201886"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345254860",
      "pull_request_review_id": 3217223929,
      "id": 2345254860,
      "node_id": "PRRC_kwDOABII586Lyb_M",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] id Id of the connection whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that connection will be omitted.\n+     */\n+    virtual void EventReadyToSend(Id id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] id Connection for which the data arrived.\n+     * @param[in] data Received data.\n+     */\n+    virtual void EventGotData(Id id, std::span<const uint8_t> data) = 0;",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 164,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2297310218,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yes thanks",
      "created_at": "2025-09-12T19:37:28Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345254860",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345254860"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345282425",
      "pull_request_review_id": 3217223929,
      "id": 2345282425,
      "node_id": "PRRC_kwDOABII586Lyit5",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 110,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2297305441,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yes thanks",
      "created_at": "2025-09-12T19:49:41Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345282425",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345282425"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345329538",
      "pull_request_review_id": 3217223929,
      "id": 2345329538,
      "node_id": "PRRC_kwDOABII586LyuOC",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Remove sent bytes until entire response is sent.\n+                m_respond.erase(m_respond.begin(), m_respond.begin() + sent);\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};\n+    BOOST_REQUIRE(addr_bind.has_value());\n+    bilingual_str strError;\n+\n+    // Init state\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 0);\n+    // Bind to mock Listening Socket\n+    BOOST_REQUIRE(sockman.BindAndStartListening(addr_bind.value(), strError));\n+    // We are bound and listening\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 1);\n+\n+    // Name the SockMan I/O thread\n+    SockMan::Options options{\"test_sockman\"};\n+    // Start the I/O loop\n+    sockman.StartSocketsThreads(options);\n+\n+    // No connections yet\n+    BOOST_CHECK_EQUAL(sockman.GetConnectionsCount(), 0);\n+\n+    // Create a mock client with a data payload to send\n+    // and add it to the local CreateSock queue\n+    const std::vector<uint8_t> request = {'b', 'i', 't', 's'};\n+    auto pipes{ConnectClient(request)};\n+\n+    // Wait up to a minute to find and connect the client in the I/O loop\n+    int attempts{6000};\n+    while (sockman.GetConnectionsCount() < 1) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Inspect the connection\n+    auto client{sockman.GetFirstConnection()};\n+    BOOST_CHECK_EQUAL(client.second.ToStringAddrPort(), \"5.5.5.5:6789\");\n+\n+    // Wait up to a minute to read the data from the connection\n+    attempts = 6000;\n+    while (!std::ranges::equal(sockman.GetReceivedData(client.first), request)) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Wait up to a minute to write our response data back to the connection\n+    attempts = 6000;\n+    size_t expected_response_size = sockman.m_respond.size();\n+    std::vector<uint8_t> actually_received(expected_response_size);\n+    while (!std::ranges::equal(actually_received, sockman.m_respond)) {\n+        // Read the data received by the mock socket\n+        ssize_t bytes_read = pipes->send.GetBytes((void *)actually_received.data(), expected_response_size);",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 134,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2289081739,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "you're right thanks",
      "created_at": "2025-09-12T20:04:03Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2345329538",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2345329538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349207386",
      "pull_request_review_id": 3217223929,
      "id": 2349207386,
      "node_id": "PRRC_kwDOABII586MBg9a",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] id Id of the connection whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that connection will be omitted.\n+     */\n+    virtual void EventReadyToSend(Id id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] id Connection for which the data arrived.\n+     * @param[in] data Received data.\n+     */\n+    virtual void EventGotData(Id id, std::span<const uint8_t> data) = 0;\n+\n+    /**\n+     * Called when the remote peer has sent an EOF on the socket. This is a graceful\n+     * close of their writing side, we can still send and they will receive, if it\n+     * makes sense at the application level.\n+     * @param[in] id Connection whose socket got EOF.\n+     */\n+    virtual void EventGotEOF(Id id) = 0;\n+\n+    /**\n+     * Called when we get an irrecoverable error trying to read from a socket.\n+     * @param[in] id Connection whose socket got an error.\n+     * @param[in] errmsg Message describing the error.\n+     */\n+    virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) = 0;\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Can be used to temporarily pause sends on a connection.\n+     * SockMan would only call Send() if this returns true.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next call to EventReadyToSend().\n+     */\n+    virtual bool ShouldTryToSend(Id id) const;\n+\n+    /**\n+     * SockMan would only call Recv() on a connection's socket if this returns true.\n+     * Can be used to temporarily pause receives on a connection.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next receive.\n+     */\n+    virtual bool ShouldTryToRecv(Id id) const;\n+\n+    /**\n+     * SockMan has completed the current send+recv iteration for a given connection.\n+     * It will do another send+recv for this connection after processing all other connections.\n+     * Can be used to execute periodic tasks for a given connection.\n+     * The implementation in SockMan does nothing.\n+     * @param[in] id Connection for which send+recv has been done.\n+     */\n+    virtual void EventIOLoopCompletedForOne(Id id);\n+\n+    /**\n+     * SockMan has completed send+recv for all connections.\n+     * Can be used to execute periodic tasks for all connections, like closing\n+     * connections due to higher level logic.\n+     * The implementation in SockMan does nothing.\n+     */\n+    virtual void EventIOLoopCompletedForAll();\n+\n+    /**\n+     * The sockets used by a connection.\n+     */\n+    struct ConnectionSockets {\n+        explicit ConnectionSockets(std::unique_ptr<Sock>&& s)\n+            : sock{std::move(s)}\n+        {\n+        }\n+\n+        /**\n+         * Mutex that serializes the Send() and Recv() calls on `sock`.\n+         */\n+        Mutex mutex;\n+\n+        /**\n+         * Underlying socket.\n+         * `shared_ptr` (instead of `unique_ptr`) is used to avoid premature close of the\n+         * underlying file descriptor by one thread while another thread is poll(2)-ing\n+         * it for activity.\n+         * @see https://github.com/bitcoin/bitcoin/issues/21744 for details.\n+         */\n+        std::shared_ptr<Sock> sock;\n+    };\n+\n+    /**\n+     * Info about which socket has which event ready and its connection id.\n+     */\n+    struct IOReadiness {\n+        /**\n+         * Map of socket -> socket events. For example:\n+         * socket1 -> { requested = SEND|RECV, occurred = RECV }\n+         * socket2 -> { requested = SEND, occurred = SEND }\n+         */\n+        Sock::EventsPerSock events_per_sock;\n+\n+        /**\n+         * Map of socket -> connection id (in `m_connected`). For example\n+         * socket1 -> id=23\n+         * socket2 -> id=56\n+         */\n+        std::unordered_map<Sock::EventsPerSock::key_type,\n+                           SockMan::Id,\n+                           Sock::HashSharedPtrSock,\n+                           Sock::EqualSharedPtrSock>\n+            ids_per_sock;\n+    };\n+\n+    /**\n+     * Check connected and listening sockets for IO readiness and process them accordingly.\n+     */\n+    void ThreadSocketHandler()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate a collection of sockets to check for IO readiness.\n+     * @return Sockets to check for readiness plus an aux map to find the\n+     * corresponding connection id given a socket.\n+     */\n+    IOReadiness GenerateWaitSockets()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Do the read/write for connected sockets that are ready for IO.\n+     * @param[in] io_readiness Which sockets are ready and their connection ids.\n+     */\n+    void SocketHandlerConnected(const IOReadiness& io_readiness)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Accept incoming connections, one from each read-ready listening socket.\n+     * @param[in] events_per_sock Sockets that are ready for IO.\n+     */\n+    void SocketHandlerListening(const Sock::EventsPerSock& events_per_sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Retrieve an entry from m_connected.\n+     * @param[in] id Connection id to search for.\n+     * @return ConnectionSockets for the given connection id or empty shared_ptr if not found.\n+     */\n+    std::shared_ptr<ConnectionSockets> GetConnectionSockets(Id id) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * The id to assign to the next created connection. Used to generate ids of connections.",
      "path": "src/common/sockman.h",
      "position": 1,
      "original_position": 303,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2293246152,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I guess the two sentences are a bit redundant, I'm going to keep the first and lose the second, though.",
      "created_at": "2025-09-15T14:30:20Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2349207386",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349207386"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 303,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349899039",
      "pull_request_review_id": 3217223929,
      "id": 2349899039,
      "node_id": "PRRC_kwDOABII586MEJ0f",
      "diff_hunk": "@@ -601,6 +601,42 @@ void TestChain100Setup::MockMempoolMinFee(const CFeeRate& target_feerate)\n     m_node.mempool->TrimToSize(0);\n     assert(m_node.mempool->GetMinFee() == target_feerate);\n }\n+\n+SocketTestingSetup::SocketTestingSetup()\n+    : m_create_sock_orig{CreateSock}\n+{\n+    CreateSock = [this](int, int, int) {\n+        // This is a mock Listening Socket that a server can \"bind\" to and\n+        // listen to for incoming connections. We won't need to access its I/O\n+        // pipes because we don't read or write directly to it. It will return\n+        // Connected Sockets from the queue via its Accept() method.\n+        return std::make_unique<DynSock>(std::make_shared<DynSock::Pipes>(), m_accepted_sockets);\n+    };\n+};\n+\n+SocketTestingSetup::~SocketTestingSetup()\n+{\n+    CreateSock = m_create_sock_orig;\n+}\n+\n+std::shared_ptr<DynSock::Pipes> SocketTestingSetup::ConnectClient(const std::vector<uint8_t>& data)\n+{\n+    // I/O pipes for a mock Connected Socket we can read and write to.\n+    std::shared_ptr<DynSock::Pipes> connected_socket_pipes(std::make_shared<DynSock::Pipes>());\n+\n+    // Insert the payload\n+    connected_socket_pipes->recv.PushBytes(data.data(), data.size());\n+\n+    // Create the Mock Connected Socket that represents a client.\n+    // It needs I/O pipes but its queue can remain empty\n+    std::unique_ptr<DynSock> connected_socket{std::make_unique<DynSock>(connected_socket_pipes, std::make_shared<DynSock::Queue>())};",
      "path": "src/test/util/setup_common.cpp",
      "position": 32,
      "original_position": 32,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2300320948,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm going to keep the `shared_ptr` advice under consideration but didn't apply it to this rebase.",
      "created_at": "2025-09-15T19:23:39Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2349899039",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349899039"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 632,
      "original_line": 632,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349903446",
      "pull_request_review_id": 3217223929,
      "id": 2349903446,
      "node_id": "PRRC_kwDOABII586MEK5W",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 63,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2297336625,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This is cool but I don't think it's necessary for this PR. In https://github.com/bitcoin/bitcoin/pull/32061 there is more robust testing with real sockets (not `DynSock`) and I think the combining of chunks of data from separate packets is more appropriate one level up (for example in this HTTP server). But I'm also open to integrating this kind of test in the current sockman PR if you think its important",
      "created_at": "2025-09-15T19:25:42Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2349903446",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349903446"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349903778",
      "pull_request_review_id": 3217223929,
      "id": 2349903778,
      "node_id": "PRRC_kwDOABII586MEK-i",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/sockman.h>\n+#include <test/util/setup_common.h>\n+#include <util/translation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(sockman_tests, SocketTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(test_sockman)\n+{\n+    class TestSockMan : public SockMan\n+    {\n+    public:\n+        // Connections are added from the SockMan I/O thread\n+        // but the test reads them from the main thread.\n+        Mutex m_connections_mutex;\n+        std::vector<std::pair<Id, CService>> m_connections;\n+\n+        // Received data is written here by the SockMan I/O thread\n+        // and tested by the main thread.\n+        Mutex m_received_mutex;\n+        std::unordered_map<Id, std::vector<uint8_t>> m_received;\n+        std::vector<uint8_t> m_respond{'o', 'k'};\n+\n+        size_t GetConnectionsCount() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.size();\n+        }\n+\n+        std::pair<Id, CService> GetFirstConnection() EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            return m_connections.front();\n+        }\n+\n+        std::vector<uint8_t> GetReceivedData(Id id) EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            return m_received[id];\n+        }\n+\n+    private:\n+        virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connections_mutex)\n+        {\n+            LOCK(m_connections_mutex);\n+            m_connections.emplace_back(id, them);\n+            return true;\n+        }\n+\n+        // When we receive data just store it in a member variable for testing.\n+        virtual void EventGotData(Id id, std::span<const uint8_t> data) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_received_mutex)\n+        {\n+            LOCK(m_received_mutex);\n+            m_received[id].assign(data.begin(), data.end());\n+        };\n+        virtual void EventGotEOF(Id id) override {};\n+        virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) override {};\n+\n+        // As soon as we can send data to the connected socket, send the preloaded response.\n+        // Data is sent by the SockMan I/O thread and read by the main test thread,\n+        // but the Mutex in SockMan::ConnectionSockets guards this.\n+        virtual void EventReadyToSend(Id id, bool& cancel_recv) override\n+        {\n+            cancel_recv = false;\n+            if (m_respond.size() > 0) {\n+                std::string errmsg;\n+                ssize_t sent = SendBytes(id, m_respond, /*will_send_more=*/false, errmsg);\n+                // Remove sent bytes until entire response is sent.\n+                m_respond.erase(m_respond.begin(), m_respond.begin() + sent);\n+            }\n+        }\n+    };\n+\n+    TestSockMan sockman;\n+\n+    // This address won't actually get used because we stubbed CreateSock()\n+    const std::optional<CService> addr_bind{Lookup(\"0.0.0.0\", 0, false)};\n+    BOOST_REQUIRE(addr_bind.has_value());\n+    bilingual_str strError;\n+\n+    // Init state\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 0);\n+    // Bind to mock Listening Socket\n+    BOOST_REQUIRE(sockman.BindAndStartListening(addr_bind.value(), strError));\n+    // We are bound and listening\n+    BOOST_REQUIRE_EQUAL(sockman.m_listen.size(), 1);\n+\n+    // Name the SockMan I/O thread\n+    SockMan::Options options{\"test_sockman\"};\n+    // Start the I/O loop\n+    sockman.StartSocketsThreads(options);\n+\n+    // No connections yet\n+    BOOST_CHECK_EQUAL(sockman.GetConnectionsCount(), 0);\n+\n+    // Create a mock client with a data payload to send\n+    // and add it to the local CreateSock queue\n+    const std::vector<uint8_t> request = {'b', 'i', 't', 's'};\n+    auto pipes{ConnectClient(request)};\n+\n+    // Wait up to a minute to find and connect the client in the I/O loop\n+    int attempts{6000};\n+    while (sockman.GetConnectionsCount() < 1) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Inspect the connection\n+    auto client{sockman.GetFirstConnection()};\n+    BOOST_CHECK_EQUAL(client.second.ToStringAddrPort(), \"5.5.5.5:6789\");\n+\n+    // Wait up to a minute to read the data from the connection\n+    attempts = 6000;\n+    while (!std::ranges::equal(sockman.GetReceivedData(client.first), request)) {\n+        std::this_thread::sleep_for(10ms);\n+        BOOST_REQUIRE(--attempts > 0);\n+    }\n+\n+    // Wait up to a minute to write our response data back to the connection\n+    attempts = 6000;\n+    size_t expected_response_size = sockman.m_respond.size();\n+    std::vector<uint8_t> actually_received(expected_response_size);\n+    while (!std::ranges::equal(actually_received, sockman.m_respond)) {\n+        // Read the data received by the mock socket\n+        ssize_t bytes_read = pipes->send.GetBytes((void *)actually_received.data(), expected_response_size);",
      "path": "src/test/sockman_tests.cpp",
      "position": 1,
      "original_position": 134,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2300323835,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "see above re: packets and chunks",
      "created_at": "2025-09-15T19:25:54Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2349903778",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349903778"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349907985",
      "pull_request_review_id": 3217223929,
      "id": 2349907985,
      "node_id": "PRRC_kwDOABII586MEMAR",
      "diff_hunk": "@@ -0,0 +1,322 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <netaddress.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new connection id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created connection.\n+     */\n+    Id GetNewId();\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;\n+\n+private:\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;",
      "path": "src/common/sockman.h",
      "position": 123,
      "original_position": 147,
      "commit_id": "e007e1b57d5d42c2a8d932d5b91eec8a3ca76e14",
      "original_commit_id": "598bee6bd590757565d2564ae86cf46b5eea4399",
      "in_reply_to_id": 2300366190,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "No harm in this I suppose but it's not really needed by the HTTP server, we already log client disconnections when calling `CloseConnection()`",
      "created_at": "2025-09-15T19:28:15Z",
      "updated_at": "2025-09-15T19:31:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32747#discussion_r2349907985",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2349907985"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32747"
        }
      },
      "start_line": 121,
      "original_start_line": 145,
      "start_side": "RIGHT",
      "line": 123,
      "original_line": 123,
      "side": "RIGHT"
    }
  ]
}