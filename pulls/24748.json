{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
    "id": 898370023,
    "node_id": "PR_kwDOABII5841jAnn",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/24748",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/24748.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/24748.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
    "number": 24748,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "test/BIP324: functional tests for v2 P2P encryption",
    "user": {
      "login": "stratospher",
      "id": 44024636,
      "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stratospher",
      "html_url": "https://github.com/stratospher",
      "followers_url": "https://api.github.com/users/stratospher/followers",
      "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
      "organizations_url": "https://api.github.com/users/stratospher/orgs",
      "repos_url": "https://api.github.com/users/stratospher/repos",
      "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/stratospher/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "This PR introduces support for v2 P2P encryption(BIP 324) in the existing functional test framework and adds functional tests for the same.\r\n\r\n### commits overview\r\n1. introduces a new class `EncryptedP2PState` to store the keys, functions for performing the initial v2 handshake and encryption/decryption.\r\n3. this class is used by `P2PConnection` in inbound/outbound connections to perform the initial v2 handshake before the v1 version handshake. Only after the initial v2 handshake is performed do application layer P2P messages(version, verack etc..) get exchanged. (in a v2 connection)\r\n    - `v2_state` is the object of class `EncryptedP2PState` in `P2PConnection` used to store its keys, session-id etc.\r\n    - a node [advertising](https://github.com/stratospher/blogosphere/blob/main/integration_test_bip324.md#advertising-to-support-v2-p2p) support for  v2 P2P is different from a node actually [supporting v2 P2P](https://github.com/stratospher/blogosphere/blob/main/integration_test_bip324.md#supporting-v2-p2p) (differ when false advertisement of services occur)\r\n        - introduce a boolean variable `supports_v2_p2p` in `P2PConnection` to denote if it supports v2 P2P.\r\n        - introduce a boolean variable `advertises_v2_p2p` to denote whether `P2PConnection` which mimics peer behaviour advertises V2 P2P support. Default option is `False`.\r\n    - In the test framework, you can create Inbound and Outbound connections to `TestNode`\r\n        1. During **Inbound Connections**, `P2PConnection` is the initiator [`TestNode` <--------- `P2PConnection`]\r\n            - Case 1:\r\n                - if the `TestNode` advertises/signals v2 P2P support (means `self.nodes[i]` set up with `\"-v2transport=1\"`), different behaviour will be exhibited based on whether:\r\n                    1. `P2PConnection` supports v2 P2P\r\n                    2. `P2PConnection` does not support v2 P2P\r\n               - In a real world scenario, the initiator node would intrinsically know if they support v2 P2P based on whatever code they choose to run. However, in the test scenario where we mimic peer behaviour, we have no way of knowing if `P2PConnection` should support v2 P2P or not. So `supports_v2_p2p` boolean variable is used as an option to enable support for v2 P2P in `P2PConnection`.\r\n              - Since the `TestNode` advertises v2 P2P support (using \"-v2transport=1\"), our initiator `P2PConnection` would send:\r\n                1. (if the `P2PConnection` supports v2 P2P) ellswift + garbage bytes to initiate the connection\r\n                2. (if the `P2PConnection` does not support v2 P2P) version message to initiate the connection\r\n           - Case 2:\r\n                - if the `TestNode` doesn't signal v2 P2P support; `P2PConnection` being the initiator would send version message to initiate a connection.\r\n       2. During **Outbound Connections** [TestNode --------> P2PConnection]\r\n           - initiator `TestNode` would send:\r\n                - (if the `P2PConnection` advertises v2 P2P) ellswift + garbage bytes to initiate the connection\r\n                - (if the `P2PConnection` advertises v2 P2P) version message to initiate the connection\r\n          - Suppose `P2PConnection` advertises v2 P2P support when it actually doesn't support v2 P2P (false advertisement scenario)\r\n               - `TestNode` sends ellswift + garbage bytes\r\n               - `P2PConnection` receives but can't process it and disconnects.\r\n               - `TestNode` then tries using v1 P2P and sends version message\r\n               - `P2PConnection` receives/processes this successfully and they communicate on v1 P2P\r\n\r\n4. the encrypted P2P messages follow a different format - 3 byte length + 1-13 byte message_type + payload + 16 byte MAC\r\n5. includes support for testing decoy messages and v2 connection downgrade(using false advertisement - when a v2 node makes an outbound connection to a node which doesn't support v2 but is advertised as v2 by some malicious\r\nintermediary)\r\n\r\n### run the tests\r\n* functional test - `test/functional/p2p_v2_encrypted.py` `test/functional/p2p_v2_earlykeyresponse.py`\r\n\r\nI'm also super grateful to @ dhruv for his really valuable feedback on this branch.\r\nAlso written a more elaborate explanation here - https://github.com/stratospher/blogosphere/blob/main/integration_test_bip324.md",
    "labels": [
      {
        "id": 62963516,
        "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
        "name": "Tests",
        "color": "d4c5f9",
        "default": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/61",
      "html_url": "https://github.com/bitcoin/bitcoin/milestone/61",
      "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/61/labels",
      "id": 9334188,
      "node_id": "MI_kwDOABII584Ajm2s",
      "number": 61,
      "state": "closed",
      "title": "27.0",
      "description": "",
      "creator": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "open_issues": 0,
      "closed_issues": 69,
      "created_at": "2023-04-27T08:01:57Z",
      "updated_at": "2024-04-16T08:33:17Z",
      "closed_at": "2024-04-16T08:33:17Z"
    },
    "created_at": "2022-04-03T20:14:51Z",
    "updated_at": "2025-05-17T06:08:12Z",
    "closed_at": "2024-01-29T17:31:51Z",
    "mergeable_state": "unknown",
    "merged": true,
    "merged_at": "2024-01-29T17:31:51Z",
    "merged_by": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "merge_commit_sha": "411ba32af21a56efa0a570b6aa8bf8f035410230",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "head": {
      "label": "stratospher:p2p-encryption-test",
      "ref": "p2p-encryption-test",
      "sha": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 379929443,
        "node_id": "MDEwOlJlcG9zaXRvcnkzNzk5Mjk0NDM=",
        "name": "bitcoin",
        "full_name": "stratospher/bitcoin",
        "owner": {
          "login": "stratospher",
          "id": 44024636,
          "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
          "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/stratospher",
          "html_url": "https://github.com/stratospher",
          "followers_url": "https://api.github.com/users/stratospher/followers",
          "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
          "organizations_url": "https://api.github.com/users/stratospher/orgs",
          "repos_url": "https://api.github.com/users/stratospher/repos",
          "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/stratospher/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/stratospher/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/stratospher/bitcoin",
        "archive_url": "https://api.github.com/repos/stratospher/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/stratospher/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/stratospher/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/stratospher/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/stratospher/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/stratospher/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/stratospher/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/stratospher/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/stratospher/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/stratospher/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/stratospher/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/stratospher/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/stratospher/bitcoin/events",
        "forks_url": "https://api.github.com/repos/stratospher/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/stratospher/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/stratospher/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/stratospher/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/stratospher/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/stratospher/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/stratospher/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/stratospher/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/stratospher/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/stratospher/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/stratospher/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/stratospher/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/stratospher/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/stratospher/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/stratospher/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/stratospher/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:stratospher/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/stratospher/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/stratospher/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/stratospher/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/stratospher/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/stratospher/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/stratospher/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/stratospher/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/stratospher/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/stratospher/bitcoin/hooks",
        "svn_url": "https://github.com/stratospher/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 0,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 269673,
        "default_branch": "master",
        "open_issues_count": 2,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-05-06T04:58:43Z",
        "created_at": "2021-06-24T13:12:06Z",
        "updated_at": "2025-05-06T04:59:19Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "207220ce8b767d8efdb5abf042ecf23d846ded73",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 37236,
        "stargazers_count": 83619,
        "watchers_count": 83619,
        "size": 282081,
        "default_branch": "master",
        "open_issues_count": 729,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-05-16T20:28:48Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-05-17T06:18:04Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 752,
    "deletions": 66,
    "changed_files": 15,
    "commits": 15,
    "review_comments": 195,
    "comments": 28
  },
  "events": [
    {
      "event": "labeled",
      "id": 6358791218,
      "node_id": "LE_lADOABII585G_btJzwAAAAF7A3Qy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6358791218",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-04-03T21:03:00Z",
      "label": {
        "name": "Build system",
        "color": "5319e7"
      }
    },
    {
      "event": "labeled",
      "id": 6358791219,
      "node_id": "LE_lADOABII585G_btJzwAAAAF7A3Qz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6358791219",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-04-03T21:03:00Z",
      "label": {
        "name": "P2P",
        "color": "006b75"
      }
    },
    {
      "event": "labeled",
      "id": 6358791221,
      "node_id": "LE_lADOABII585G_btJzwAAAAF7A3Q1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6358791221",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-04-03T21:03:00Z",
      "label": {
        "name": "RPC/REST/ZMQ",
        "color": "0052cc"
      }
    },
    {
      "event": "labeled",
      "id": 6358791222,
      "node_id": "LE_lADOABII585G_btJzwAAAAF7A3Q2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6358791222",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-04-03T21:03:00Z",
      "label": {
        "name": "Upstream",
        "color": "bfd4f2"
      }
    },
    {
      "event": "labeled",
      "id": 6358791223,
      "node_id": "LE_lADOABII585G_btJzwAAAAF7A3Q3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6358791223",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-04-03T21:03:00Z",
      "label": {
        "name": "Utils/log/libs",
        "color": "5319e7"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6363437415,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAF7Slln",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6363437415",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9880108fa76b249bcae52ab76fc6c51447d28535",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/9880108fa76b249bcae52ab76fc6c51447d28535",
      "created_at": "2022-04-04T14:10:25Z"
    },
    {
      "event": "commented",
      "id": 1088181500,
      "node_id": "IC_kwDOABII585A3FT8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1088181500",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-04-05T01:31:07Z",
      "updated_at": "2024-01-29T12:33:58Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/24748).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [mzumsande](https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1844567036), [theStack](https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1844474487), [naumenkogs](https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1914329134), [glozow](https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1848564888) |\n| Concept ACK | [jonatack](https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1091152739), [brunoerg](https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1092829016) |\n| Approach ACK | [sr-gi](https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1829978188) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#29279](https://github.com/bitcoin/bitcoin/pull/29279) (test: p2p: check disconnect due to lack of desirable service flags by theStack)\n* [#29016](https://github.com/bitcoin/bitcoin/pull/29016) (RPC: add new `listmempooltransactions` by niftynei)\n* [#28463](https://github.com/bitcoin/bitcoin/pull/28463) (p2p: Increase inbound capacity for block-relay only connections by mzumsande)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1088181500",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "commented",
      "id": 1091152739,
      "node_id": "IC_kwDOABII585BCatj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1091152739",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-04-07T07:03:29Z",
      "updated_at": "2022-04-07T07:03:29Z",
      "author_association": "MEMBER",
      "body": "Concept ACK",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1091152739",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "commented",
      "id": 1092829016,
      "node_id": "IC_kwDOABII585BIz9Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1092829016",
      "actor": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-04-08T12:54:02Z",
      "updated_at": "2022-04-08T12:54:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1092829016",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "labeled",
      "id": 6396929707,
      "node_id": "LE_lADOABII585G_btJzwAAAAF9SWar",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6396929707",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-04-08T14:33:00Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "convert_to_draft",
      "id": 7509322287,
      "node_id": "CTDE_lADOABII585G_btJzwAAAAG_lyov",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7509322287",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-03T17:17:03Z"
    },
    {
      "event": "commented",
      "id": 1265788740,
      "node_id": "IC_kwDOABII585LcmdE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1265788740",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-03T17:24:02Z",
      "updated_at": "2022-10-03T17:24:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "converting this PR into a draft. I'll push the updated version which includes the new spec changes in BIP 324 soon.",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1265788740",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8056726947,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAHgN-Wj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8056726947",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b4018b6c95a83cd4843c4f9d814f93d388f5343d",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/b4018b6c95a83cd4843c4f9d814f93d388f5343d",
      "created_at": "2022-12-16T13:37:12Z"
    },
    {
      "event": "unlabeled",
      "id": 8057195209,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAHgPwrJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8057195209",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-16T14:35:37Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "ready_for_review",
      "id": 8057992291,
      "node_id": "RFRE_lADOABII585G_btJzwAAAAHgSzRj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8057992291",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-16T16:09:16Z"
    },
    {
      "event": "commented",
      "id": 1355151959,
      "node_id": "IC_kwDOABII585QxfpX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1355151959",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-16T16:09:34Z",
      "updated_at": "2023-02-21T21:06:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "I've updated the PR to reflect the new spec changes in the BIP. It's built on top of #24545's 78c3ccc. Only the last 19 commits belong to this PR.\r\n\r\nUPDATE:\r\n- rebased on  #24545's f97a1a8\r\n- rebased on #24545's  a7fdbf6",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1355151959",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "labeled",
      "id": 8067569084,
      "node_id": "LE_lADOABII585G_btJzwAAAAHg3VW8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8067569084",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-19T09:35:50Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8449690575,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAH3pAvP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8449690575",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ac5b608e38de3a5b7ddd042ad5f2a1a5ba23df2d",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/ac5b608e38de3a5b7ddd042ad5f2a1a5ba23df2d",
      "created_at": "2023-02-06T17:00:49Z"
    },
    {
      "event": "unlabeled",
      "id": 8450456396,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAH3r7tM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8450456396",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-06T18:17:34Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 8527558983,
      "node_id": "LE_lADOABII585G_btJzwAAAAH8SDlH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8527558983",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-15T15:50:51Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1433257883,
      "node_id": "IC_kwDOABII585Vbceb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1433257883",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T15:22:46Z",
      "updated_at": "2023-02-16T15:22:46Z",
      "author_association": "MEMBER",
      "body": "Moved to draft given it's based on multiple other PRs.",
      "user": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1433257883",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "convert_to_draft",
      "id": 8538137665,
      "node_id": "CTDE_lADOABII585G_btJzwAAAAH86aRB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8538137665",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T15:22:52Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8574947780,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAH_G1HE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8574947780",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b55836d9a45f72dd5cd3388a9365d2b9d846f2db",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/b55836d9a45f72dd5cd3388a9365d2b9d846f2db",
      "created_at": "2023-02-21T21:04:59Z"
    },
    {
      "event": "unlabeled",
      "id": 8575191074,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAH_Hwgi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8575191074",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T21:40:03Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 8584300887,
      "node_id": "LE_lADOABII585G_btJzwAAAAH_qglX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8584300887",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-22T18:47:50Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8831535659,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAIOZoor",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8831535659",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "cee7a64bcc53a76bfe608c67f6798e13a8f66c5a",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/cee7a64bcc53a76bfe608c67f6798e13a8f66c5a",
      "created_at": "2023-03-23T19:26:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8848157660,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAIPZCvc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8848157660",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "edd0cadfaa9645c98f6e0e1c77a489afe4c279c8",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/edd0cadfaa9645c98f6e0e1c77a489afe4c279c8",
      "created_at": "2023-03-26T21:26:12Z"
    },
    {
      "event": "referenced",
      "id": 9690732740,
      "node_id": "REFE_lADOABII585G_btJzwAAAAJBnNjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9690732740",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "61d59fed74108f31eb4e9a2faa3f36422a37000e",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61d59fed74108f31eb4e9a2faa3f36422a37000e",
      "created_at": "2023-06-30T18:30:58Z"
    },
    {
      "event": "referenced",
      "id": 9692896427,
      "node_id": "REFE_lADOABII585G_btJzwAAAAJBvdyr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9692896427",
      "actor": {
        "login": "sidhujag",
        "id": 6238042,
        "node_id": "MDQ6VXNlcjYyMzgwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sidhujag",
        "html_url": "https://github.com/sidhujag",
        "followers_url": "https://api.github.com/users/sidhujag/followers",
        "following_url": "https://api.github.com/users/sidhujag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sidhujag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sidhujag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
        "organizations_url": "https://api.github.com/users/sidhujag/orgs",
        "repos_url": "https://api.github.com/users/sidhujag/repos",
        "events_url": "https://api.github.com/users/sidhujag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sidhujag/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "421153c7ada2e7658f5c5b9efa93330f7669e228",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/421153c7ada2e7658f5c5b9efa93330f7669e228",
      "created_at": "2023-07-01T02:08:29Z"
    },
    {
      "event": "unsubscribed",
      "id": 9699322835,
      "node_id": "UE_lADOABII585G_btJzwAAAAJCH-vT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9699322835",
      "actor": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-02T09:28:18Z"
    },
    {
      "event": "commented",
      "id": 1660838322,
      "node_id": "IC_kwDOABII585i_mGy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1660838322",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T18:07:49Z",
      "updated_at": "2023-08-29T21:12:05Z",
      "author_association": "MEMBER",
      "body": "@stratospher Rebasing on #28331 would let you revive this.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1660838322",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "mentioned",
      "id": 9979684893,
      "node_id": "MEE_lADOABII585G_btJzwAAAAJS1egd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9979684893",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T18:07:50Z"
    },
    {
      "event": "subscribed",
      "id": 9979684944,
      "node_id": "SE_lADOABII585G_btJzwAAAAJS1ehQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9979684944",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T18:07:50Z"
    },
    {
      "event": "unlabeled",
      "id": 9979720640,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAJS1nPA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9979720640",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T18:12:18Z",
      "label": {
        "name": "Build system",
        "color": "5319e7"
      }
    },
    {
      "event": "unlabeled",
      "id": 9979720644,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAJS1nPE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9979720644",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T18:12:18Z",
      "label": {
        "name": "RPC/REST/ZMQ",
        "color": "0052cc"
      }
    },
    {
      "event": "unlabeled",
      "id": 9979720652,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAJS1nPM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9979720652",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T18:12:18Z",
      "label": {
        "name": "P2P",
        "color": "006b75"
      }
    },
    {
      "event": "unlabeled",
      "id": 9979720655,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAJS1nPP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9979720655",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T18:12:18Z",
      "label": {
        "name": "Upstream",
        "color": "bfd4f2"
      }
    },
    {
      "event": "unlabeled",
      "id": 9979720657,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAJS1nPR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9979720657",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T18:12:18Z",
      "label": {
        "name": "Utils/log/libs",
        "color": "5319e7"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10325620668,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAJndHe8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10325620668",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "created_at": "2023-09-10T05:52:26Z"
    },
    {
      "event": "commented",
      "id": 1712724420,
      "node_id": "IC_kwDOABII585mFhnE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1712724420",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-10T06:04:02Z",
      "updated_at": "2023-09-10T06:04:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased on #28331. 2 things which affected the tests when rebasing were:\r\n1. `TestNode` can send garbage now\r\n2. since v1 reconnections are now attempted in a queue instead of immediately, there was a latency issue introduced in the tests in `add_outbound_p2p_connection()`",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1712724420",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "reviewed",
      "id": 1618745079,
      "node_id": "PRR_kwDOABII585gfBb3",
      "url": null,
      "actor": null,
      "commit_id": "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1618745079",
      "submitted_at": "2023-09-10T06:13:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "unlabeled",
      "id": 10325667100,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAJndS0c",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10325667100",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-10T06:24:45Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1618752060,
      "node_id": "PRR_kwDOABII585gfDI8",
      "url": null,
      "actor": null,
      "commit_id": "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "Brock124590",
        "id": 141978268,
        "node_id": "U_kgDOCHZqnA",
        "avatar_url": "https://avatars.githubusercontent.com/u/141978268?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Brock124590",
        "html_url": "https://github.com/Brock124590",
        "followers_url": "https://api.github.com/users/Brock124590/followers",
        "following_url": "https://api.github.com/users/Brock124590/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Brock124590/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Brock124590/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Brock124590/subscriptions",
        "organizations_url": "https://api.github.com/users/Brock124590/orgs",
        "repos_url": "https://api.github.com/users/Brock124590/repos",
        "events_url": "https://api.github.com/users/Brock124590/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Brock124590/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1618752060",
      "submitted_at": "2023-09-10T06:56:32Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10327013267,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAJnibeT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10327013267",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d9cc49f66250d7f0abff7667206ecc9735dd60cb",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/d9cc49f66250d7f0abff7667206ecc9735dd60cb",
      "created_at": "2023-09-10T18:04:08Z"
    },
    {
      "event": "labeled",
      "id": 10327013399,
      "node_id": "LE_lADOABII585G_btJzwAAAAJnibgX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10327013399",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-10T18:04:13Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 10331635131,
      "node_id": "LE_lADOABII585G_btJzwAAAAJn0D27",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10331635131",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T09:31:34Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10400366214,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAJr6P6G",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10400366214",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fee768d16c1ce6aaf81a10126db5aec013fdfedb",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/fee768d16c1ce6aaf81a10126db5aec013fdfedb",
      "created_at": "2023-09-18T16:30:16Z"
    },
    {
      "event": "unlabeled",
      "id": 10400633708,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAJr7RNs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10400633708",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-18T16:52:45Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10416306505,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAJs3DlJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10416306505",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e7360726732b0ca6d7c4e82b3e58d43133610eea",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/e7360726732b0ca6d7c4e82b3e58d43133610eea",
      "created_at": "2023-09-20T00:02:34Z"
    },
    {
      "event": "labeled",
      "id": 10433718790,
      "node_id": "LE_lADOABII585G_btJzwAAAAJt5eoG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10433718790",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-21T10:57:32Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10571553394,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAJ2HRpy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10571553394",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9ccce82c330af6e5ec5ea4cf118cb94d27047627",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/9ccce82c330af6e5ec5ea4cf118cb94d27047627",
      "created_at": "2023-10-06T07:11:50Z"
    },
    {
      "event": "unlabeled",
      "id": 10572114390,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAJ2JanW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10572114390",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-10-06T08:14:25Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1663063154,
      "node_id": "PRR_kwDOABII585jIFRy",
      "url": null,
      "actor": null,
      "commit_id": "9ccce82c330af6e5ec5ea4cf118cb94d27047627",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "cacrowley",
        "id": 80238672,
        "node_id": "MDQ6VXNlcjgwMjM4Njcy",
        "avatar_url": "https://avatars.githubusercontent.com/u/80238672?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cacrowley",
        "html_url": "https://github.com/cacrowley",
        "followers_url": "https://api.github.com/users/cacrowley/followers",
        "following_url": "https://api.github.com/users/cacrowley/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cacrowley/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cacrowley/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cacrowley/subscriptions",
        "organizations_url": "https://api.github.com/users/cacrowley/orgs",
        "repos_url": "https://api.github.com/users/cacrowley/repos",
        "events_url": "https://api.github.com/users/cacrowley/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cacrowley/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1663063154",
      "submitted_at": "2023-10-07T14:44:03Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10582265497,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAJ2wI6Z",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10582265497",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c3c61020c07465495b564b05a087220cc3cb1b3b",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/c3c61020c07465495b564b05a087220cc3cb1b3b",
      "created_at": "2023-10-07T16:40:27Z"
    },
    {
      "event": "reviewed",
      "id": 1663408774,
      "node_id": "PRR_kwDOABII585jJZqG",
      "url": null,
      "actor": null,
      "commit_id": "c3c61020c07465495b564b05a087220cc3cb1b3b",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\njust started reviewing, some initial comments",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1663408774",
      "submitted_at": "2023-10-09T04:10:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10591835180,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAJ3UpQs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10591835180",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "created_at": "2023-10-09T14:09:29Z"
    },
    {
      "event": "unlabeled",
      "id": 10598820952,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAJ3vSxY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10598820952",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-10-10T04:57:23Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1665480038,
      "node_id": "PRR_kwDOABII585jRTVm",
      "url": null,
      "actor": null,
      "commit_id": "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "halfway through with the review, these are my comments so far.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1665480038",
      "submitted_at": "2023-10-10T22:27:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "reviewed",
      "id": 1671747731,
      "node_id": "PRR_kwDOABII585jpNiT",
      "url": null,
      "actor": null,
      "commit_id": "5f851714cf5fa7a31bb423c20035f7b44deed25d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1671747731",
      "submitted_at": "2023-10-11T16:03:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "referenced",
      "id": 10627958806,
      "node_id": "REFE_lADOABII585G_btJzwAAAAJ5ecgW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10627958806",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4a5aae9330780c3740e27cc511f7cba1fab745b9",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4a5aae9330780c3740e27cc511f7cba1fab745b9",
      "created_at": "2023-10-12T07:35:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10629188602,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAJ5jIv6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10629188602",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "32836c6fec4cbb2624176daf7fd769856025c426",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/32836c6fec4cbb2624176daf7fd769856025c426",
      "created_at": "2023-10-12T09:25:55Z"
    },
    {
      "event": "labeled",
      "id": 10630593736,
      "node_id": "LE_lADOABII585G_btJzwAAAAJ5ofzI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10630593736",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-10-12T11:49:13Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "referenced",
      "id": 10646525637,
      "node_id": "REFE_lADOABII585G_btJzwAAAAJ6lRbF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10646525637",
      "actor": {
        "login": "Frank-GER",
        "id": 87550788,
        "node_id": "MDQ6VXNlcjg3NTUwNzg4",
        "avatar_url": "https://avatars.githubusercontent.com/u/87550788?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Frank-GER",
        "html_url": "https://github.com/Frank-GER",
        "followers_url": "https://api.github.com/users/Frank-GER/followers",
        "following_url": "https://api.github.com/users/Frank-GER/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Frank-GER/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Frank-GER/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Frank-GER/subscriptions",
        "organizations_url": "https://api.github.com/users/Frank-GER/orgs",
        "repos_url": "https://api.github.com/users/Frank-GER/repos",
        "events_url": "https://api.github.com/users/Frank-GER/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Frank-GER/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "0a38a7b9bc765088d3900a4bf1d517a7dea13983",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/0a38a7b9bc765088d3900a4bf1d517a7dea13983",
      "created_at": "2023-10-13T17:03:42Z"
    },
    {
      "event": "labeled",
      "id": 10831538465,
      "node_id": "LE_lADOABII585G_btJzwAAAAKFnCkh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10831538465",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-01T11:56:55Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10853997889,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKG8t1B",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10853997889",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f94bc366fa56dbc7cd4aa701727bf80411a82527",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/f94bc366fa56dbc7cd4aa701727bf80411a82527",
      "created_at": "2023-11-03T10:29:27Z"
    },
    {
      "event": "commented",
      "id": 1792201473,
      "node_id": "IC_kwDOABII585q0tMB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1792201473",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-03T10:32:33Z",
      "updated_at": "2023-11-03T10:32:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased on master.",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1792201473",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "unlabeled",
      "id": 10854651497,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAKG_NZp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10854651497",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-03T11:27:33Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 10855017004,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAKHAmos",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10855017004",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-03T12:03:08Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 10862710838,
      "node_id": "LE_lADOABII585G_btJzwAAAAKHd9A2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10862710838",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-04T13:03:04Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 10862772587,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAKHeMFr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10862772587",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-04T13:29:43Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "referenced",
      "id": 10892653322,
      "node_id": "REFE_lADOABII585G_btJzwAAAAKJQLMK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10892653322",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "962ea5c525028391bb4c6546db0c2c3dec9cb4a0",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/962ea5c525028391bb4c6546db0c2c3dec9cb4a0",
      "created_at": "2023-11-07T21:49:08Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10895435658,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKJayeK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10895435658",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "aa275a6a4d9d4a1340b0be9ec0b65512a8164779",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/aa275a6a4d9d4a1340b0be9ec0b65512a8164779",
      "created_at": "2023-11-08T04:32:34Z"
    },
    {
      "event": "commented",
      "id": 1801073913,
      "node_id": "IC_kwDOABII585rWjT5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1801073913",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-08T04:39:10Z",
      "updated_at": "2023-11-08T04:39:10Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated since #28374 is merged.",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1801073913",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "ready_for_review",
      "id": 10895480216,
      "node_id": "RFRE_lADOABII585G_btJzwAAAAKJa9WY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10895480216",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-08T04:39:27Z"
    },
    {
      "event": "labeled",
      "id": 10897053792,
      "node_id": "LE_lADOABII585G_btJzwAAAAKJg9hg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10897053792",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-08T08:08:54Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1801417208,
      "node_id": "IC_kwDOABII585rX3H4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1801417208",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-08T09:35:27Z",
      "updated_at": "2023-11-08T09:35:27Z",
      "author_association": "MEMBER",
      "body": "CI:\r\n\r\n```\r\nï¿½[0mï¿½[0;31mp2p_v2_earlykeyresponse.py                             | âœ– Failed  | 1 s",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1801417208",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "labeled",
      "id": 10899304212,
      "node_id": "LE_lADOABII585G_btJzwAAAAKJpi8U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10899304212",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-08T11:15:38Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1723019604,
      "node_id": "PRR_kwDOABII585mszFU",
      "url": null,
      "actor": null,
      "commit_id": "aa275a6a4d9d4a1340b0be9ec0b65512a8164779",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nDid only a rough first review round so far, left some comments on the way, mostly nits. \r\n\r\nIt seems like the newly introduced functional test `p2p_v2_encrypted.py` could be merged with the already existing `p2p_v2_transport.py` (here or in a follow-up), or is it fundamentally different? ",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1723019604",
      "submitted_at": "2023-11-09T17:39:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10931513032,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKLkabI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10931513032",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "50a30f6394335b7c8ed32ade1c86a69502857012",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/50a30f6394335b7c8ed32ade1c86a69502857012",
      "created_at": "2023-11-11T05:57:46Z"
    },
    {
      "event": "unlabeled",
      "id": 10931517549,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAKLkbht",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10931517549",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-11T05:59:59Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1806715075,
      "node_id": "IC_kwDOABII585rsEjD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1806715075",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-11T06:32:40Z",
      "updated_at": "2023-11-11T06:34:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "@theStack, @mzumsande thank you for the reviews! I've rebased and addressed your comments.\r\n\r\n> It seems like the newly introduced functional test p2p_v2_encrypted.py could be merged with the already existing p2p_v2_transport.py (here or in a follow-up), or is it fundamentally different?\r\n\r\nyes! can be done in a follow up. only difference is `p2p_v2_encrypted.py` tests `TestNode` <--> `P2PInterface` behaviour and `p2p_v2_transport.py` tests `TestNode` <--> `TestNode` behaviour. So maybe in separate functions within `p2p_v2_transport.py`?\r\n\r\n@maflcko, I still need to address the CI failure. https://api.cirrus-ci.com/v1/task/6171895557521408/logs/ci.log",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1806715075",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "mentioned",
      "id": 10931596926,
      "node_id": "MEE_lADOABII585G_btJzwAAAAKLku5-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10931596926",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-11T06:32:40Z"
    },
    {
      "event": "subscribed",
      "id": 10931596928,
      "node_id": "SE_lADOABII585G_btJzwAAAAKLku6A",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10931596928",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-11T06:32:40Z"
    },
    {
      "event": "mentioned",
      "id": 10931596931,
      "node_id": "MEE_lADOABII585G_btJzwAAAAKLku6D",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10931596931",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-11T06:32:40Z"
    },
    {
      "event": "subscribed",
      "id": 10931596936,
      "node_id": "SE_lADOABII585G_btJzwAAAAKLku6I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10931596936",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-11T06:32:40Z"
    },
    {
      "event": "mentioned",
      "id": 10931596941,
      "node_id": "MEE_lADOABII585G_btJzwAAAAKLku6N",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10931596941",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-11T06:32:41Z"
    },
    {
      "event": "subscribed",
      "id": 10931596947,
      "node_id": "SE_lADOABII585G_btJzwAAAAKLku6T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10931596947",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-11T06:32:41Z"
    },
    {
      "event": "reviewed",
      "id": 1730319269,
      "node_id": "PRR_kwDOABII585nIpOl",
      "url": null,
      "actor": null,
      "commit_id": "50a30f6394335b7c8ed32ade1c86a69502857012",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "I've noticed that the test `p2p_v2_encrypted.py` fails if the node under test sends a small amount of garbage (in the range of 0-19 bytes). Can be reproduced by applying the following simple patch:\r\n```diff\r\ndiff --git a/src/net.cpp b/src/net.cpp\r\nindex 2682035912..09af15a9b7 100644\r\n--- a/src/net.cpp\r\n+++ b/src/net.cpp\r\n@@ -951,7 +951,7 @@ std::vector<uint8_t> GenerateRandomGarbage() noexcept\r\n {\r\n     std::vector<uint8_t> ret;\r\n     FastRandomContext rng;\r\n-    ret.resize(rng.randrange(V2Transport::MAX_GARBAGE_LEN + 1));\r\n+    ret.resize(19); // fails in range 0-19, works with 20+\r\n     rng.fillrand(MakeWritableByteSpan(ret));\r\n     return ret;\r\n }\r\n```\r\nApparently the expected VERACK is not received from the node. Didn't dig deeper yet. For finding the cause, I think some `logger.debug(...)` messages in `v2_p2p.py` might be helpful.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1730319269",
      "submitted_at": "2023-11-14T17:29:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10964139490,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKNg33i",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10964139490",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b3c0a54085703932e57369f5b1315b516c172dc4",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/b3c0a54085703932e57369f5b1315b516c172dc4",
      "created_at": "2023-11-15T08:03:09Z"
    },
    {
      "event": "commented",
      "id": 1811980868,
      "node_id": "IC_kwDOABII585sAKJE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1811980868",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-15T08:07:58Z",
      "updated_at": "2023-11-15T08:07:58Z",
      "author_association": "CONTRIBUTOR",
      "body": "> I've noticed that the test p2p_v2_encrypted.py fails if the node under test sends a small amount of garbage (in the range of 0-19 bytes).\r\n\r\nthanks for catching that @theStack! before the drop garbage authentication packet change in #28525, `recvbuf` needed 16+20+20 bytes to authenticate the handshake. now it only needs 16+20 bytes. i've fixed it now.",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1811980868",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "mentioned",
      "id": 10964183855,
      "node_id": "MEE_lADOABII585G_btJzwAAAAKNhCsv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10964183855",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-15T08:07:59Z"
    },
    {
      "event": "subscribed",
      "id": 10964183874,
      "node_id": "SE_lADOABII585G_btJzwAAAAKNhCtC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10964183874",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-15T08:07:59Z"
    },
    {
      "event": "commented",
      "id": 1812003580,
      "node_id": "IC_kwDOABII585sAPr8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1812003580",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-15T08:26:19Z",
      "updated_at": "2023-11-15T08:26:50Z",
      "author_association": "CONTRIBUTOR",
      "body": ">  https://api.cirrus-ci.com/v1/task/6171895557521408/logs/ci.log\r\n\r\ni wasn't able to reproduce this error - tried it locally on the docker container, setting randomseed and running it in loop. also confused how it could have happened.\r\n\r\nthis is what happens inside `p2p_v2_earlykeyresponse.py` test\r\n- we start an inbound connection to the TestNode (`TestNode` <---- `P2PInterface`). \r\n- v2 connection starts by sending 64 bytes ellswift (`TestNode` <--64 bytes-- `P2PInterface`). this is sent in 2 parts:\r\n\t- `TestNode` <--4 bytes magic bytes-- `P2PInterface` - `TestNode` doesn't send us a response\r\n\t- `TestNode` <--remaining 60 bytes-- `P2PInterface` - `TestNode` responds back since there's a mismatch from V1_PREFIX. \r\n\r\nWhat usually happens:\r\n1. During inbound connection creation, `TestNode::add_p2p_connection()` calls `P2PConnection::peer_connect()` where an object of `EncryptedP2PState` class is created - this object `v2_state` contains the function `EncryptedP2PState::initiate_v2_handshake()` to send ellswift bytes\r\n2. then the asyncio code to create a connection happens and `connection_made()` is called when the connection is opened\r\n\t- inside `connection_made()`, 64 bytes ellswift is sent using `EncryptedP2PState::initiate_v2_handshake()`\r\n3. When the `TestNode` sends a response, `P2PConnection::data_received()` callback will detect it\r\n\r\n\r\nWhat happens in test:\r\n- there are 2 variables:\r\n1. `send_net_magic` - initially true. after we send magic bytes, `send_net_magic_bytes` is set to false (basically just a switch to send 64 bytes in 2 parts)\r\n2. `can_data_be_received` - initally false - data can't be received until mismatch from V1_PREFIX occurs. after we send remaining mismatched 60 bytes, `can_data_be_received` is set to true.\r\n- since response will be detected on `TestNode`, we add an assertion to make sure `send_net_magic` = false (meaning magic bytes already sent) and `can_data_be_received` = true (meaning mismatched 60 bytes also sent). `TestNode` wouldn't send a response in the intermediate states.\r\n- so the possible states are:\r\n1. initially\r\n\t`send_net_magic` = true, `can_data_be_received` = false (Assertion would fail in `data_received()` but shouldn't happen)\r\n2. after `connection_made()`'s `custom EncryptedP2PState::initiate_v2_handshake()` (TestNode <--4 bytes magic bytes-- P2PInterface)\r\n\t`send_net_magic` = false, `can_data_be_received` = false (Assertion would fail in `data_received()` but shouldn't happen)\r\n3. after `p2p_v2_earlykeyresponse.py` test when we call `custom EncryptedP2PState::initiate_v2_handshake()` explicitly (TestNode <--remaining 60 bytes-- P2PInterface)\r\n\t`send_net_magic` = false, `can_data_be_received` = true (Assertion passes in `data_received()`)",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1812003580",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "unlabeled",
      "id": 10964641008,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAKNiyTw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10964641008",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-15T08:55:30Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1733127844,
      "node_id": "PRR_kwDOABII585nTW6k",
      "url": null,
      "actor": null,
      "commit_id": "b3c0a54085703932e57369f5b1315b516c172dc4",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "I had a look at `p2p_v2_earlykeyresponse.py` and it would fail the handshake rarely (but the test still passes because the error is thrown in the p2p thread!).\r\nI could reproduce it by changing `GenerateRandomGarbage()` similar to TheStack above, but this time to large values:\r\n`ret.resize(V2Transport::MAX_GARBAGE_LEN-19);` or larger. I haven't analyzed any further so far.\r\n\r\n[Edit]: Well, it is expected that the handshake fails, because we manipulated our key we'll never find the expected garbage terminator. But it seems confusing to fail with a stack trace / uncaught exception in this case (\"`Fatal error: protocol.data_received() call failed.`\") when this is actually expected to happen.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1733127844",
      "submitted_at": "2023-11-15T23:38:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "commented",
      "id": 1813782523,
      "node_id": "IC_kwDOABII585sHB_7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1813782523",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-16T04:44:56Z",
      "updated_at": "2023-11-16T04:44:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "Ah, I think if we have an unhandled exception like in my previous post, running the test directly (`python3 p2p_v2_earlykeyresponse.py`) will show success, but if we use the test_runner (`python3 test_runner.py p2p_v2_earlykeyresponse.py`) it will show failure, probably because things were written to stderr. So we need to do something about the case I mentioned above.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1813782523",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11006259238,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKQBjAm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11006259238",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3cfdced3e9ce66de59557972da98e5a2cae809ed",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/3cfdced3e9ce66de59557972da98e5a2cae809ed",
      "created_at": "2023-11-20T04:25:37Z"
    },
    {
      "event": "commented",
      "id": 1818210163,
      "node_id": "IC_kwDOABII585sX69z",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1818210163",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-20T04:29:22Z",
      "updated_at": "2023-11-20T04:29:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "> But it seems confusing to fail with a stack trace / uncaught exception in this case (\"Fatal error: protocol.data_received() call failed.\") when this is actually expected to happen.\r\n\r\n\r\n<details>\r\n<summary> is this the test log you observed? </summary>\r\n<br>\r\n\r\n```\r\n2023-11-18T13:52:32.976000Z TestFramework (INFO): PRNG seed is: 8699047777059301467\r\n2023-11-18T13:52:32.977000Z TestFramework (INFO): Initializing test directory /tmp/bitcoin_func_test_70zlmcgr\r\n2023-11-18T13:52:33.535000Z TestFramework (INFO): Sending ellswift bytes in parts to ensure that response from responder is received only when\r\n2023-11-18T13:52:33.536000Z TestFramework (INFO): ellswift bytes have a mismatch from the 16 bytes(network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\")\r\n2023-11-18T13:52:33.536000Z TestFramework (INFO): Sending first 4 bytes of ellswift which match network magic\r\n2023-11-18T13:52:33.536000Z TestFramework (INFO): If a response is received, assertion failure would happen in our custom data_received() function\r\n2023-11-18T13:52:33.587000Z TestFramework (INFO): Sending remaining ellswift and garbage which are different from V1_PREFIX. Since a response is\r\n2023-11-18T13:52:33.587000Z TestFramework (INFO): expected now, our custom data_received() function wouldn't result in assertion failure\r\nFatal error: protocol.data_received() call failed.\r\nprotocol: <__main__.PeerEarlyKey object at 0x7f0d6f6c1060>\r\ntransport: <_SelectorSocketTransport fd=10 read=polling write=<idle, bufsize=0>>\r\nTraceback (most recent call last):\r\n  File \"/usr/lib/python3.10/asyncio/selector_events.py\", line 876, in _read_ready__data_received\r\n    self._protocol.data_received(data)\r\n  File \"/home/stratospher/code/bitcoin/test/functional/p2p_v2_earlykeyresponse.py\", line 60, in data_received\r\n    super(PeerEarlyKey, self).data_received(t)\r\n  File \"/home/stratospher/code/bitcoin/test/functional/test_framework/p2p.py\", line 297, in data_received\r\n    self.v2_handshake()\r\n  File \"/home/stratospher/code/bitcoin/test/functional/test_framework/p2p.py\", line 284, in v2_handshake\r\n    raise ValueError(\"invalid v2 mac tag in handshake authentication\")\r\nValueError: invalid v2 mac tag in handshake authentication\r\n2023-11-18T13:52:33.673000Z TestFramework.p2p (WARNING): Connection lost to 127.0.0.1:13882 due to invalid v2 mac tag in handshake authentication\r\n2023-11-18T13:52:33.693000Z TestFramework (INFO): successful disconnection when MITM happens in the key exchange phase\r\n2023-11-18T13:52:33.744000Z TestFramework (INFO): Stopping nodes\r\n2023-11-18T13:52:33.948000Z TestFramework (INFO): Cleaning up /tmp/bitcoin_func_test_70zlmcgr on exit\r\n2023-11-18T13:52:33.948000Z TestFramework (INFO): Tests successful\r\n```\r\n</details>\r\n\r\n\r\nthis happened because of the mac tag mismatch in the v2 handshake's authentication. it only got displayed sometimes because the test would finish before the v2 handshake authentication happened.  since we don't need to do v2 handshake authentication/v2 handshake for this test, and just be able to detect when data is received, i've removed the `P2PInterface::data_received()` call which performs the handshake. whenever data is received, `PeerEarlyKey::data_received()` would detect it and do nothing with the received bytes.\r\n\r\n\r\n> I could reproduce it by changing GenerateRandomGarbage() similar to TheStack above, but this time to large values:\r\nret.resize(V2Transport::MAX_GARBAGE_LEN-19); or larger.\r\n\r\noh! i'm not able to reproduce this by changing to large values. Could this be related to the above test log?",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1818210163",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "commented",
      "id": 1819618919,
      "node_id": "IC_kwDOABII585sdS5n",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1819618919",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-20T18:46:45Z",
      "updated_at": "2023-11-20T18:46:45Z",
      "author_association": "CONTRIBUTOR",
      "body": "> is this the test log you observed?\r\n\r\nYes. Only in ~1% of runs with the previous version, but after changing the garbage size in `net.cpp` to the max I would get it consistently.\r\nI think the reason is that usually bitcoind would terminate the connection (because the python side would wait for more bytes that wouldn't come), but when the garbage was close to the max, the python side would terminate it and throwing the exception.\r\n\r\n> i've removed the P2PInterface::data_received() call which performs the handshake\r\n\r\nThanks, that should fix this issue.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1819618919",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "reviewed",
      "id": 1740854829,
      "node_id": "PRR_kwDOABII585nw1Yt",
      "url": null,
      "actor": null,
      "commit_id": "3cfdced3e9ce66de59557972da98e5a2cae809ed",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1740854829",
      "submitted_at": "2023-11-20T23:17:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11058887465,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKTKTsp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11058887465",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b0965e4d1f1b1f7f585a2a2bf78f116f241d5735",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/b0965e4d1f1b1f7f585a2a2bf78f116f241d5735",
      "created_at": "2023-11-24T19:03:34Z"
    },
    {
      "event": "referenced",
      "id": 11087755977,
      "node_id": "REFE_lADOABII585G_btJzwAAAAKU4brJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11087755977",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "30a055782908702c012bdd5f6a6d41458bf22dfa",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/30a055782908702c012bdd5f6a6d41458bf22dfa",
      "created_at": "2023-11-28T19:17:42Z"
    },
    {
      "event": "reviewed",
      "id": 1753471883,
      "node_id": "PRR_kwDOABII585og9uL",
      "url": null,
      "actor": null,
      "commit_id": "b0965e4d1f1b1f7f585a2a2bf78f116f241d5735",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Another round of review - looking good!",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1753471883",
      "submitted_at": "2023-11-28T21:18:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11098627968,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKVh5-A",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11098627968",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at": "2023-11-29T16:16:44Z"
    },
    {
      "event": "commented",
      "id": 1832239855,
      "node_id": "IC_kwDOABII585tNcLv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1832239855",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-29T16:20:40Z",
      "updated_at": "2023-11-29T16:20:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "thanks @mzumsande for the really great feedback! Iâ€™ve rebased on master since #28805 is merged and updated the PR to address your comments.",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1832239855",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "mentioned",
      "id": 11098678934,
      "node_id": "MEE_lADOABII585G_btJzwAAAAKViGaW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11098678934",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-29T16:20:40Z"
    },
    {
      "event": "subscribed",
      "id": 11098678979,
      "node_id": "SE_lADOABII585G_btJzwAAAAKViGbD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11098678979",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-29T16:20:40Z"
    },
    {
      "event": "labeled",
      "id": 11099615923,
      "node_id": "LE_lADOABII585G_btJzwAAAAKVlrKz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11099615923",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-29T17:42:32Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1755780494,
      "node_id": "PRR_kwDOABII585opxWO",
      "url": null,
      "actor": null,
      "commit_id": "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Left some comments below from the latest review round, mostly nits. I think another small check to add in the newly introduced functional test could be to verify that a `P2PConnection`'s session id matches the one from the node, as returned via `getpeerinfo()`.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1755780494",
      "submitted_at": "2023-11-29T18:22:36Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "reviewed",
      "id": 1755965923,
      "node_id": "PRR_kwDOABII585oqenj",
      "url": null,
      "actor": null,
      "commit_id": "47e72daf656ea6dc6766f71e5c8bda5717dc5362",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1755965923",
      "submitted_at": "2023-11-29T18:37:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11104246665,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKV3VuJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11104246665",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4fe043e6050ca7a8bb3b2553980e3366abbb4004",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/4fe043e6050ca7a8bb3b2553980e3366abbb4004",
      "created_at": "2023-11-30T05:06:14Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11104257891,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKV3Ydj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11104257891",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "6567fe2aafa43b99e8298018b0665222eec4daff",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/6567fe2aafa43b99e8298018b0665222eec4daff",
      "created_at": "2023-11-30T05:08:21Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11104413857,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKV3-ih",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11104413857",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f479a99cc92c7966266804e8c33338cebbc44fbc",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/f479a99cc92c7966266804e8c33338cebbc44fbc",
      "created_at": "2023-11-30T05:37:15Z"
    },
    {
      "event": "unlabeled",
      "id": 11104653890,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAKV45JC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11104653890",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-30T06:16:37Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1833222343,
      "node_id": "IC_kwDOABII585tRMDH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1833222343",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-30T07:11:24Z",
      "updated_at": "2023-11-30T07:11:24Z",
      "author_association": "CONTRIBUTOR",
      "body": "thanks @theStack, @mzumsande! I've updated the PR to address your comments.\r\nAlso made this change to `MSGTYPE_TO_SHORTID` construction because of `lint-python.py` failure in the CI\r\n\r\n```diff\r\ndiff --git a/test/functional/test_framework/v2_p2p.py b/test/functional/test_framework/v2_p2p.py\r\nindex fe44351a13..b4efd1ac58 100644\r\n--- a/test/functional/test_framework/v2_p2p.py\r\n+++ b/test/functional/test_framework/v2_p2p.py\r\n@@ -55,7 +55,7 @@ SHORTID = {\r\n }\r\n \r\n # Dictionary which contains short message type ID for the P2P message\r\n-MSGTYPE_TO_SHORTID = dict(map(reversed, SHORTID.items()))\r\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\r\n \r\n \r\n class EncryptedP2PState:\r\n```",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1833222343",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "mentioned",
      "id": 11105027120,
      "node_id": "MEE_lADOABII585G_btJzwAAAAKV6UQw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11105027120",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-30T07:11:24Z"
    },
    {
      "event": "subscribed",
      "id": 11105027139,
      "node_id": "SE_lADOABII585G_btJzwAAAAKV6URD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11105027139",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-30T07:11:25Z"
    },
    {
      "event": "mentioned",
      "id": 11105027156,
      "node_id": "MEE_lADOABII585G_btJzwAAAAKV6URU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11105027156",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-30T07:11:25Z"
    },
    {
      "event": "subscribed",
      "id": 11105027170,
      "node_id": "SE_lADOABII585G_btJzwAAAAKV6URi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11105027170",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-30T07:11:25Z"
    },
    {
      "event": "reviewed",
      "id": 1768762854,
      "node_id": "PRR_kwDOABII585pbS3m",
      "url": null,
      "actor": null,
      "commit_id": "f479a99cc92c7966266804e8c33338cebbc44fbc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK f479a99cc92c7966266804e8c33338cebbc44fbc\r\n\r\nI have reviewed the code. I did some testing / gained more confidence that it works well by having a [branch](https://github.com/mzumsande/bitcoin/tree/tmp_bip324_fixalltests) where, with some adjustments, the python v2 p2p module is used for the entire functional test suite.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1768762854",
      "submitted_at": "2023-12-06T22:47:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "review_requested",
      "id": 11174464196,
      "node_id": "RRE_lADOABII585G_btJzwAAAAKaDMrE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11174464196",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-06T22:47:56Z",
      "requested_reviewer": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 11174464388,
      "node_id": "RRE_lADOABII585G_btJzwAAAAKaDMuE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11174464388",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-06T22:47:56Z",
      "requested_reviewer": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 11174464566,
      "node_id": "RRE_lADOABII585G_btJzwAAAAKaDMw2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11174464566",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-06T22:47:57Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 1770812972,
      "node_id": "PRR_kwDOABII585pjHYs",
      "url": null,
      "actor": null,
      "commit_id": "f479a99cc92c7966266804e8c33338cebbc44fbc",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Halfway through.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1770812972",
      "submitted_at": "2023-12-07T19:37:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "reviewed",
      "id": 1771245412,
      "node_id": "PRR_kwDOABII585pkw9k",
      "url": null,
      "actor": null,
      "commit_id": "f479a99cc92c7966266804e8c33338cebbc44fbc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1771245412",
      "submitted_at": "2023-12-08T00:01:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "review_requested",
      "id": 11188086065,
      "node_id": "RRE_lADOABII585G_btJzwAAAAKa3KUx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11188086065",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-08T00:01:32Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11255127513,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKe253Z",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11255127513",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ad0ae3d2128d04ff4f62a4bf612286d153dc314b",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/ad0ae3d2128d04ff4f62a4bf612286d153dc314b",
      "created_at": "2023-12-15T03:53:16Z"
    },
    {
      "event": "commented",
      "id": 1857250302,
      "node_id": "IC_kwDOABII585us2P-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1857250302",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-15T04:17:02Z",
      "updated_at": "2023-12-15T04:17:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "thanks for the reviews @mzumsande, @sipa, @theStack! i've updated the PR to address your comments. sorry for the delay since i was away.",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1857250302",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "mentioned",
      "id": 11255235075,
      "node_id": "MEE_lADOABII585G_btJzwAAAAKe3UID",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11255235075",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-15T04:17:02Z"
    },
    {
      "event": "subscribed",
      "id": 11255235087,
      "node_id": "SE_lADOABII585G_btJzwAAAAKe3UIP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11255235087",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-15T04:17:02Z"
    },
    {
      "event": "mentioned",
      "id": 11255235096,
      "node_id": "MEE_lADOABII585G_btJzwAAAAKe3UIY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11255235096",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-15T04:17:03Z"
    },
    {
      "event": "subscribed",
      "id": 11255235105,
      "node_id": "SE_lADOABII585G_btJzwAAAAKe3UIh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11255235105",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-15T04:17:03Z"
    },
    {
      "event": "mentioned",
      "id": 11255235123,
      "node_id": "MEE_lADOABII585G_btJzwAAAAKe3UIz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11255235123",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-15T04:17:03Z"
    },
    {
      "event": "subscribed",
      "id": 11255235134,
      "node_id": "SE_lADOABII585G_btJzwAAAAKe3UI-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11255235134",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-15T04:17:03Z"
    },
    {
      "event": "reviewed",
      "id": 1795584001,
      "node_id": "PRR_kwDOABII585rBnAB",
      "url": null,
      "actor": null,
      "commit_id": "ad0ae3d2128d04ff4f62a4bf612286d153dc314b",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK ad0ae3d2128d04ff4f62a4bf612286d153dc314b",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1795584001",
      "submitted_at": "2023-12-24T15:04:11Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "review_requested",
      "id": 11332658608,
      "node_id": "RRE_lADOABII585G_btJzwAAAAKjeqWw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11332658608",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-24T15:04:16Z",
      "requested_reviewer": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11372041214,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKl05P-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11372041214",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at": "2024-01-02T16:49:49Z"
    },
    {
      "event": "commented",
      "id": 1885174610,
      "node_id": "IC_kwDOABII585wXXtS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1885174610",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-10T16:21:40Z",
      "updated_at": "2024-01-10T16:29:19Z",
      "author_association": "MEMBER",
      "body": "~~Since the merge of #29058 I think the first commit here should be dropped.~~\r\n\r\nEDIT: nevermind, I confused `addconnection` with `addnode` (and the latter already has a `v2transport` argument).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1885174610",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "reviewed",
      "id": 1810107436,
      "node_id": "PRR_kwDOABII585r5Aws",
      "url": null,
      "actor": null,
      "commit_id": "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1810107436",
      "submitted_at": "2024-01-10T21:23:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "milestoned",
      "id": 11457495695,
      "node_id": "MIE_lADOABII585G_btJzwAAAAKq64KP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11457495695",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-11T14:35:08Z",
      "milestone": {
        "title": "27.0"
      }
    },
    {
      "event": "reviewed",
      "id": 1814350455,
      "node_id": "PRR_kwDOABII585sJMp3",
      "url": null,
      "actor": null,
      "commit_id": "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1814350455",
      "submitted_at": "2024-01-12T16:32:06Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "reviewed",
      "id": 1816369526,
      "node_id": "PRR_kwDOABII585sQ5l2",
      "url": null,
      "actor": null,
      "commit_id": "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "First pass, untested, will do a more thorough review next week",
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1816369526",
      "submitted_at": "2024-01-12T20:52:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "labeled",
      "id": 11480114263,
      "node_id": "LE_lADOABII585G_btJzwAAAAKsRKRX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11480114263",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-14T06:03:06Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 11523899010,
      "node_id": "LE_lADOABII585G_btJzwAAAAKu4L6C",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11523899010",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-18T11:20:01Z",
      "label": {
        "name": "Tests",
        "color": "d4c5f9"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11546137478,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKwNBOG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11546137478",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "eb8a870603357d12a181d1e9845c561d80e9bded",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at": "2024-01-20T14:19:51Z"
    },
    {
      "event": "unlabeled",
      "id": 11546268331,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAKwNhKr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11546268331",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-20T15:06:59Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11548183506,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKwU0vS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11548183506",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3970fb1c785f3f540e3c71517f2f62625a24ff53",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/3970fb1c785f3f540e3c71517f2f62625a24ff53",
      "created_at": "2024-01-21T04:02:25Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11548262419,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKwVIAT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11548262419",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e8d8124bade589ac489377118650f4085890b51d",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/e8d8124bade589ac489377118650f4085890b51d",
      "created_at": "2024-01-21T05:24:50Z"
    },
    {
      "event": "labeled",
      "id": 11548322977,
      "node_id": "LE_lADOABII585G_btJzwAAAAKwVWyh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11548322977",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-21T06:09:54Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 11551765720,
      "node_id": "UNLE_lADOABII585G_btJzwAAAAKwifTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11551765720",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-22T05:19:41Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11553257709,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKwoLjt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11553257709",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at": "2024-01-22T08:23:52Z"
    },
    {
      "event": "reviewed",
      "id": 1837243116,
      "node_id": "PRR_kwDOABII585tghrs",
      "url": null,
      "actor": null,
      "commit_id": "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1837243116",
      "submitted_at": "2024-01-22T20:32:10Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "reviewed",
      "id": 1838102663,
      "node_id": "PRR_kwDOABII585tjziH",
      "url": null,
      "actor": null,
      "commit_id": "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Some low-level feedback for now, mostly nits. I will do high-level review against the BIP shortly.",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1838102663",
      "submitted_at": "2024-01-23T10:40:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "reviewed",
      "id": 1829978188,
      "node_id": "PRR_kwDOABII585tE0BM",
      "url": null,
      "actor": null,
      "commit_id": "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Approach ACK\r\n\r\nI think this looks good overall, I left some potential improvements/questions but feel free to disregard them given this is just for testing",
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1829978188",
      "submitted_at": "2024-01-23T16:09:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ0ODdiODA1MTc5NzE3M2M3YWI0MzJlNzVlZmEzNzBhZmIwM2I1Mjk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4487b8051797173c7ab432e75efa370afb03b529",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4487b8051797173c7ab432e75efa370afb03b529",
      "tree": {
        "sha": "0ddab3eb06d55c64ce8979b0806c78130399e963",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0ddab3eb06d55c64ce8979b0806c78130399e963"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/16b5b4b674414c41f34b0d37e15a16521fb08013",
          "sha": "16b5b4b674414c41f34b0d37e15a16521fb08013",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/16b5b4b674414c41f34b0d37e15a16521fb08013"
        }
      ],
      "message": "[rpc/net] Allow v2 p2p support in addconnection\n\nThis test-only RPC is required when a TestNode initiates\nan outbound v2 p2p connection. Add a new arg `v2transport`\nso that the node can attempt v2 connections.",
      "committer": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2024-01-23T16:34:48Z"
      },
      "author": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2022-02-04T05:35:23Z"
      },
      "sha": "4487b8051797173c7ab432e75efa370afb03b529"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU5NWFkNGIxNjg4MGFlMWYyMzQ2M2NhOTk4NTM4MWM4ZWFlOTQ1ZDg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/595ad4b16880ae1f23463ca9985381c8eae945d8",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/595ad4b16880ae1f23463ca9985381c8eae945d8",
      "tree": {
        "sha": "a217ee801b514c9d7f3b9bd72406e625de59a15c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a217ee801b514c9d7f3b9bd72406e625de59a15c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4487b8051797173c7ab432e75efa370afb03b529",
          "sha": "4487b8051797173c7ab432e75efa370afb03b529",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4487b8051797173c7ab432e75efa370afb03b529"
        }
      ],
      "message": "[test/crypto] Add ECDH\n\nCo-authored-by: Pieter Wuille <pieter.wuille@gmail.com>",
      "committer": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2024-01-23T16:34:55Z"
      },
      "author": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2022-10-06T16:41:46Z"
      },
      "sha": "595ad4b16880ae1f23463ca9985381c8eae945d8"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDhkNmM4NDhhNDg1MzA4OTNjYTQwYmU1YzEyODU1NDFiM2U3YTk0ZjM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8d6c848a48530893ca40be5c1285541b3e7a94f3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8d6c848a48530893ca40be5c1285541b3e7a94f3",
      "tree": {
        "sha": "9623f102edea8d3791757bc8a1ab1dcf4babe1c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9623f102edea8d3791757bc8a1ab1dcf4babe1c5"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/595ad4b16880ae1f23463ca9985381c8eae945d8",
          "sha": "595ad4b16880ae1f23463ca9985381c8eae945d8",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/595ad4b16880ae1f23463ca9985381c8eae945d8"
        }
      ],
      "message": "[test] Move MAGIC_BYTES to messages.py\n\nThis avoids circular dependency happening when importing MAGIC_BYTES.\nBefore,\n\tp2p.py <--import for EncryptedP2PState-- v2_p2p.py\n\t  |\t\t\t\t\t    ^\n\t  |\t\t\t\t            |\n\t  â””---------import for MAGIC_BYTES----------â”˜\nNow, MAGIC_BYTES are kept separately in messages.py\n\nCo-authored-by: Martin Zumsande <mzumsande@gmail.com>",
      "committer": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2024-01-23T16:34:55Z"
      },
      "author": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2023-11-15T05:08:40Z"
      },
      "sha": "8d6c848a48530893ca40be5c1285541b3e7a94f3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGI4OWZhNTllNzE1YTE4NWQ5ZmE3ZmNlMDg5ZGFkNDI3M2QzYjE1MzI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b89fa59e715a185d9fa7fce089dad4273d3b1532",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b89fa59e715a185d9fa7fce089dad4273d3b1532",
      "tree": {
        "sha": "37da744c16a3bee4caf6d584abbe28db5b826df9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/37da744c16a3bee4caf6d584abbe28db5b826df9"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8d6c848a48530893ca40be5c1285541b3e7a94f3",
          "sha": "8d6c848a48530893ca40be5c1285541b3e7a94f3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8d6c848a48530893ca40be5c1285541b3e7a94f3"
        }
      ],
      "message": "[test] Construct class to handle v2 P2P protocol functions\n\nThe class `EncryptedP2PState` stores the 4 32-byte keys, session id,\ngarbage terminators, whether it's an initiator/responder, whether the\ninitial handshake has been completed etc.. It also contains functions\nto perform the v2 handshake and to encrypt/decrypt p2p v2 messages.\n\n- In an inbound connection to TestNode, P2PConnection is the initiator\nand `initiate_v2_handshake()`, `complete_handshake()`, `authenticate_handshake()`\nare called on it. [ TestNode <----------------- P2PConnection ]\n\n- In an outbound connection from TestNode, P2PConnection is the responder\nand `respond_v2_handshake()`, `complete_handshake()`, `authenticate_handshake()`\nare called on it. [ TestNode -----------------> P2PConnection ]",
      "committer": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2024-01-24T06:21:47Z"
      },
      "author": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2022-10-11T13:38:47Z"
      },
      "sha": "b89fa59e715a185d9fa7fce089dad4273d3b1532"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11579722500,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKyNIsE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11579722500",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "created_at": "2024-01-24T06:34:05Z"
    },
    {
      "event": "reviewed",
      "id": 1840754152,
      "node_id": "PRR_kwDOABII585tt63o",
      "url": null,
      "actor": null,
      "commit_id": "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1840754152",
      "submitted_at": "2024-01-24T08:36:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "commented",
      "id": 1907670816,
      "node_id": "IC_kwDOABII585xtL8g",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1907670816",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-24T08:55:27Z",
      "updated_at": "2024-01-24T08:55:27Z",
      "author_association": "MEMBER",
      "body": "ACK fa4d9d5b39d5652de1d83564f19b1a0749863b16\r\n\r\nThere are many more tests possible, right? E.g. sending more than 4095 bytes of garbage.\r\nI assume the goal here wasn't to cover everything?",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1907670816",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "review_requested",
      "id": 11581236320,
      "node_id": "RRE_lADOABII585G_btJzwAAAAKyS6Rg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11581236320",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-24T08:55:34Z",
      "requested_reviewer": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 11581236499,
      "node_id": "RRE_lADOABII585G_btJzwAAAAKyS6UT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11581236499",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-24T08:55:35Z",
      "requested_reviewer": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 11581236808,
      "node_id": "RRE_lADOABII585G_btJzwAAAAKyS6ZI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11581236808",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-24T08:55:36Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGEwNDlkMWJkMDhjOGNkYjNiNjkzNTIwZjI0ZjhhODI1NzJkY2FhYjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a049d1bd08c8cdb3b693520f24f8a82572dcaab1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a049d1bd08c8cdb3b693520f24f8a82572dcaab1",
      "tree": {
        "sha": "b04732021ed5c2c73d8851ae16797763ceb981f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b04732021ed5c2c73d8851ae16797763ceb981f0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b89fa59e715a185d9fa7fce089dad4273d3b1532",
          "sha": "b89fa59e715a185d9fa7fce089dad4273d3b1532",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b89fa59e715a185d9fa7fce089dad4273d3b1532"
        }
      ],
      "message": "[test] Introduce EncryptedP2PState object in P2PConnection\n\nInstantiate this object when the connection supports v2 P2P transport\nprotocol.\n\n- When a P2PConnection is opened, perform initiate_v2_handshake() if the\nconnection is an initiator. application layer messages are only sent after\nthe initial v2 handshake is over (for both initiator and responder).",
      "committer": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2024-01-25T05:39:50Z"
      },
      "author": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2022-02-05T16:41:02Z"
      },
      "sha": "a049d1bd08c8cdb3b693520f24f8a82572dcaab1"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA1YmRkYjIwZjVjYzkwMzZmZDY4MDUwMGJkZThlY2U3MGRiZjA2NDY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/05bddb20f5cc9036fd680500bde8ece70dbf0646",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/05bddb20f5cc9036fd680500bde8ece70dbf0646",
      "tree": {
        "sha": "78356190c1fd4e7a89dfb8eb6c8379c734e249ff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/78356190c1fd4e7a89dfb8eb6c8379c734e249ff"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a049d1bd08c8cdb3b693520f24f8a82572dcaab1",
          "sha": "a049d1bd08c8cdb3b693520f24f8a82572dcaab1",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a049d1bd08c8cdb3b693520f24f8a82572dcaab1"
        }
      ],
      "message": "[test] Perform initial v2 handshake",
      "committer": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2024-01-25T05:39:52Z"
      },
      "author": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2022-02-05T17:38:49Z"
      },
      "sha": "05bddb20f5cc9036fd680500bde8ece70dbf0646"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDViOTFmYjE0YWJhN2Q3ZmU0NWM5YWMzNjQ1MjY4MTViZWM3NDIzNTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5b91fb14aba7d7fe45c9ac364526815bec742356",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5b91fb14aba7d7fe45c9ac364526815bec742356",
      "tree": {
        "sha": "5e40a46f022bd1d52677d408e88cceae30fe5068",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5e40a46f022bd1d52677d408e88cceae30fe5068"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/05bddb20f5cc9036fd680500bde8ece70dbf0646",
          "sha": "05bddb20f5cc9036fd680500bde8ece70dbf0646",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/05bddb20f5cc9036fd680500bde8ece70dbf0646"
        }
      ],
      "message": "[test] Read v2 P2P messages",
      "committer": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2024-01-25T05:39:52Z"
      },
      "author": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2022-12-10T18:52:20Z"
      },
      "sha": "5b91fb14aba7d7fe45c9ac364526815bec742356"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGJiN2JmZmVkNzk5ZGM1YWQ4YjYwNjc2ODE2NGZjZTQ2ZDRjYmY5ZDA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bb7bffed799dc5ad8b606768164fce46d4cbf9d0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/bb7bffed799dc5ad8b606768164fce46d4cbf9d0",
      "tree": {
        "sha": "8d54fc60710c543049c2c6877916f89b2a2743ef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8d54fc60710c543049c2c6877916f89b2a2743ef"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5b91fb14aba7d7fe45c9ac364526815bec742356",
          "sha": "5b91fb14aba7d7fe45c9ac364526815bec742356",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5b91fb14aba7d7fe45c9ac364526815bec742356"
        }
      ],
      "message": "[test] Use lock for sending P2P messages in test framework\n\nMessages are built, encrypted and sent over the socket in v2\nconnections. If a race condition happens between python's main\nthread and p2p thread with both of them trying to send a message,\nit's possible that the messages get encrypted with wrong keystream.\n\nMessages are built and sent over the socket in v1 connections.\nSo there's no problem if messages are sent in the wrong order.\n\nCo-authored-by: Martin Zumsande <mzumsande@gmail.com>\nCo-authored-by: theStack <sebastian.falbesoner@gmail.com>",
      "committer": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2024-01-25T05:39:52Z"
      },
      "author": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2023-11-24T18:25:44Z"
      },
      "sha": "bb7bffed799dc5ad8b606768164fce46d4cbf9d0"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGE5NGUzNTBhYzBlNWI2NWVmMjNhODRiMDVmYjEwZDEyMDRjOThjOTc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a94e350ac0e5b65ef23a84b05fb10d1204c98c97",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a94e350ac0e5b65ef23a84b05fb10d1204c98c97",
      "tree": {
        "sha": "851ca8d114b78bc1a64e19e33add3c48fa11a731",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/851ca8d114b78bc1a64e19e33add3c48fa11a731"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bb7bffed799dc5ad8b606768164fce46d4cbf9d0",
          "sha": "bb7bffed799dc5ad8b606768164fce46d4cbf9d0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/bb7bffed799dc5ad8b606768164fce46d4cbf9d0"
        }
      ],
      "message": "[test] Build v2 P2P messages",
      "committer": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2024-01-25T05:39:52Z"
      },
      "author": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2022-02-05T17:58:02Z"
      },
      "sha": "a94e350ac0e5b65ef23a84b05fb10d1204c98c97"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDM4Mjg5NGMzYWNkMmRiZjNlNDE5ODgxNGY1NDdjNzViNmZiMTc3MDY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/382894c3acd2dbf3e4198814f547c75b6fb17706",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/382894c3acd2dbf3e4198814f547c75b6fb17706",
      "tree": {
        "sha": "a76ccef93a18fdc35a596a5b477b545f15f9a5e0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a76ccef93a18fdc35a596a5b477b545f15f9a5e0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a94e350ac0e5b65ef23a84b05fb10d1204c98c97",
          "sha": "a94e350ac0e5b65ef23a84b05fb10d1204c98c97",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a94e350ac0e5b65ef23a84b05fb10d1204c98c97"
        }
      ],
      "message": " [test] Reconnect using v1 P2P when v2 P2P terminates due to magic byte mismatch\n\n- When a v2 TestNode makes an outbound connection to a P2PInterface node\nwhich doesn't support v2 but is advertised as v2 by some malicious\nintermediary, the TestNode sends 64 bytes ellswift. The v1 node doesn't\nunderstand this and disconnects. Then the v2 TestNode reconnects by\nsending a v1/version message.",
      "committer": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2024-01-25T05:40:48Z"
      },
      "author": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2022-12-10T06:42:37Z"
      },
      "sha": "382894c3acd2dbf3e4198814f547c75b6fb17706"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDhjMDU0YWEwNGQzM2IyNDc3NDRiMzc0N2NkNWJmMzAwNWEwMTNlOTA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8c054aa04d33b247744b3747cd5bf3005a013e90",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8c054aa04d33b247744b3747cd5bf3005a013e90",
      "tree": {
        "sha": "27655d7f06922f403c5c3b34b149e7882b046e5c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/27655d7f06922f403c5c3b34b149e7882b046e5c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/382894c3acd2dbf3e4198814f547c75b6fb17706",
          "sha": "382894c3acd2dbf3e4198814f547c75b6fb17706",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/382894c3acd2dbf3e4198814f547c75b6fb17706"
        }
      ],
      "message": "[test] Allow inbound and outbound connections supporting v2 P2P protocol\n\n- Add an optional `supports_v2_p2p` parameter to specify if the inbound\nand outbound connections support v2 P2P protocol.\n- In the `addconnection_callback` which gets called when creating\noutbound connections, call the `addconnection` RPC with v2 P2P protocol\nsupport enabled.",
      "committer": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2024-01-25T05:40:50Z"
      },
      "author": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2022-02-05T18:19:47Z"
      },
      "sha": "8c054aa04d33b247744b3747cd5bf3005a013e90"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQxMTVjZjk5NTY0N2QxYTUxM2NhZWNiNTRhNGZmM2Y1MTkyN2FhOGU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4115cf995647d1a513caecb54a4ff3f51927aa8e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4115cf995647d1a513caecb54a4ff3f51927aa8e",
      "tree": {
        "sha": "5bde335930337e137daac46b4d22c7e9e602f0a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5bde335930337e137daac46b4d22c7e9e602f0a2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8c054aa04d33b247744b3747cd5bf3005a013e90",
          "sha": "8c054aa04d33b247744b3747cd5bf3005a013e90",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8c054aa04d33b247744b3747cd5bf3005a013e90"
        }
      ],
      "message": "[test] Ignore BIP324 decoy messages\n\nAlso allow P2PConnection::send_message() to send decoy messages for\nwriting tests.",
      "committer": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2024-01-25T05:40:50Z"
      },
      "author": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2022-12-10T14:42:51Z"
      },
      "sha": "4115cf995647d1a513caecb54a4ff3f51927aa8e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGJhNzM3MzU4YTM3NDM4YzE4ZjBmYmE3MjNlYWIxMGNjZmQ5YWFlOWI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ba737358a37438c18f0fba723eab10ccfd9aae9b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ba737358a37438c18f0fba723eab10ccfd9aae9b",
      "tree": {
        "sha": "fa46be45422bca161d9b8641dac359b189ed7cc7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fa46be45422bca161d9b8641dac359b189ed7cc7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4115cf995647d1a513caecb54a4ff3f51927aa8e",
          "sha": "4115cf995647d1a513caecb54a4ff3f51927aa8e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4115cf995647d1a513caecb54a4ff3f51927aa8e"
        }
      ],
      "message": "[test] Add functional tests to test v2 P2P behaviour",
      "committer": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2024-01-25T05:40:50Z"
      },
      "author": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2022-12-10T05:07:51Z"
      },
      "sha": "ba737358a37438c18f0fba723eab10ccfd9aae9b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGZmZTZhNTZkNzVjMGI0N2QwNzI5ZTRlMGI3MjI1YTgyN2I0M2FkODk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ffe6a56d75c0b47d0729e4e0b7225a827b43ad89",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ffe6a56d75c0b47d0729e4e0b7225a827b43ad89",
      "tree": {
        "sha": "0a8a05b8d7277bce0ce881432023a9242b04444d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0a8a05b8d7277bce0ce881432023a9242b04444d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ba737358a37438c18f0fba723eab10ccfd9aae9b",
          "sha": "ba737358a37438c18f0fba723eab10ccfd9aae9b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ba737358a37438c18f0fba723eab10ccfd9aae9b"
        }
      ],
      "message": "[test] Check whether v2 TestNode performs downgrading",
      "committer": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2024-01-25T05:40:50Z"
      },
      "author": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2023-09-08T13:44:22Z"
      },
      "sha": "ffe6a56d75c0b47d0729e4e0b7225a827b43ad89"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGJjOTI4M2M0NDE1YTkzMmVjMWVlYjcwY2EyYWE0Mzk5YzgwNDM3YjM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "tree": {
        "sha": "47946b5de64c0a64e95deb467bfea0a9017243ee",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/47946b5de64c0a64e95deb467bfea0a9017243ee"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ffe6a56d75c0b47d0729e4e0b7225a827b43ad89",
          "sha": "ffe6a56d75c0b47d0729e4e0b7225a827b43ad89",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ffe6a56d75c0b47d0729e4e0b7225a827b43ad89"
        }
      ],
      "message": "[test] Add functional test to test early key response behaviour in BIP 324\n\n- A node initiates a v2 connection by sending 64 bytes ellswift\n- In BIP 324 \"The responder waits until one byte is received which does not match the\n  V1_PREFIX (16 bytes consisting of the network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\".)\"\n- It's possible that the 64 bytes ellswift sent by an initiator starts with a prefix of V1_PREFIX\n- Example form of 64 bytes ellswift could be:\n\t4 bytes network magic + 60 bytes which aren't prefixed with remaining V1_PREFIX\n- We test this behaviour:\n\t- when responder receives 4 byte network magic -> no response received by initiator\n\t- when first mismatch happens -> response received by initiator",
      "committer": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2024-01-25T05:42:15Z"
      },
      "author": {
        "name": "stratospher",
        "email": "44024636+stratospher@users.noreply.github.com",
        "date": "2022-12-10T05:08:31Z"
      },
      "sha": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11592736025,
      "node_id": "HRFPE_lADOABII585G_btJzwAAAAKy-x0Z",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11592736025",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "commit_url": "https://api.github.com/repos/stratospher/bitcoin/commits/bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "created_at": "2024-01-25T05:46:36Z"
    },
    {
      "event": "commented",
      "id": 1909407947,
      "node_id": "IC_kwDOABII585xz0DL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1909407947",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-25T05:59:27Z",
      "updated_at": "2024-01-25T05:59:27Z",
      "author_association": "CONTRIBUTOR",
      "body": "> There are many more tests possible, right? E.g. sending more than 4095 bytes of garbage.\r\nI assume the goal here wasn't to cover everything?\r\n\r\nyes! goal here was to just introduce support for v2 in the test framework. we need more tests after this.",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1909407947",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "reviewed",
      "id": 1844567036,
      "node_id": "PRR_kwDOABII585t8dv8",
      "url": null,
      "actor": null,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Code Review ACK bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1844567036",
      "submitted_at": "2024-01-25T19:50:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "review_requested",
      "id": 11601706130,
      "node_id": "RRE_lADOABII585G_btJzwAAAAKzg_yS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11601706130",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-25T19:50:10Z",
      "requested_reviewer": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 1844474487,
      "node_id": "PRR_kwDOABII585t8HJ3",
      "url": null,
      "actor": null,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Code-review ACK bc9283c4415a932ec1eeb70ca2aa4399c80437b3\r\n\r\nWent through another review round and only found some minor nits, mostly naming suggestions. If you retouch (or follow-up material):\r\n* should use multi-line imports (see style guidelines in `test/functional/README.md`)\r\n* commit 382894c3acd2dbf3e4198814f547c75b6fb17706 has a leading space in the commit subject",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1844474487",
      "submitted_at": "2024-01-25T21:34:30Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "commented",
      "id": 1914329134,
      "node_id": "IC_kwDOABII585yGlgu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1914329134",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-29T09:49:20Z",
      "updated_at": "2024-01-29T09:49:20Z",
      "author_association": "MEMBER",
      "body": "ACK bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1914329134",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "review_request_removed",
      "id": 11625177314,
      "node_id": "RRRE_lADOABII585G_btJzwAAAAK06iDi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11625177314",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-29T09:49:28Z",
      "requested_reviewer": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 1840768056,
      "node_id": "PRR_kwDOABII585tt-Q4",
      "url": null,
      "actor": null,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1840768056",
      "submitted_at": "2024-01-29T09:49:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "reviewed",
      "id": 1848564888,
      "node_id": "PRR_kwDOABII585uLtyY",
      "url": null,
      "actor": null,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK bc9283c4415a932ec1eeb70ca2aa4399c80437b3\r\n\r\nDid some light code review of the `P2PConnection` functions, mutation testing of `EncryptedP2PState`, and manually changing other functional tests to use v2 connections.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1848564888",
      "submitted_at": "2024-01-29T12:33:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "merged",
      "id": 11631114232,
      "node_id": "ME_lADOABII585G_btJzwAAAAK1RLf4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11631114232",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "411ba32af21a56efa0a570b6aa8bf8f035410230",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/411ba32af21a56efa0a570b6aa8bf8f035410230",
      "created_at": "2024-01-29T17:31:51Z"
    },
    {
      "event": "closed",
      "id": 11631114291,
      "node_id": "CE_lADOABII585G_btJzwAAAAK1RLgz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11631114291",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-29T17:31:51Z"
    },
    {
      "event": "reviewed",
      "id": 1850458767,
      "node_id": "PRR_kwDOABII585uS8KP",
      "url": null,
      "actor": null,
      "commit_id": "4487b8051797173c7ab432e75efa370afb03b529",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1850458767",
      "submitted_at": "2024-01-30T08:06:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
    },
    {
      "event": "commented",
      "id": 1916996716,
      "node_id": "IC_kwDOABII585yQwxs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1916996716",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-30T14:29:36Z",
      "updated_at": "2024-01-30T14:29:36Z",
      "author_association": "MEMBER",
      "body": "The test fails for me:\r\n\r\n```\r\n146/294 - p2p_v2_earlykeyresponse.py failed, Duration: 1 s\r\n\r\nstdout:\r\n2024-01-30T13:33:10.051000Z TestFramework (INFO): PRNG seed is: 5518845862592986813\r\n2024-01-30T13:33:10.052000Z TestFramework (INFO): Initializing test directory /tmp/test_runner_â‚¿_ðŸƒ_20240130_142948/p2p_v2_earlykeyresponse_133\r\n2024-01-30T13:33:10.370000Z TestFramework (INFO): Sending ellswift bytes in parts to ensure that response from responder is received only when\r\n2024-01-30T13:33:10.370000Z TestFramework (INFO): ellswift bytes have a mismatch from the 16 bytes(network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\")\r\n2024-01-30T13:33:10.371000Z TestFramework (INFO): Sending first 4 bytes of ellswift which match network magic\r\n2024-01-30T13:33:10.371000Z TestFramework (INFO): If a response is received, assertion failure would happen in our custom data_received() function\r\n2024-01-30T13:33:10.429000Z TestFramework (INFO): Sending remaining ellswift and garbage which are different from V1_PREFIX. Since a response is\r\n2024-01-30T13:33:10.429000Z TestFramework (INFO): expected now, our custom data_received() function wouldn't result in assertion failure\r\n2024-01-30T13:33:10.480000Z TestFramework.p2p (WARNING): Connection lost to 127.0.0.1:12596 due to \r\n2024-01-30T13:33:10.518000Z TestFramework (INFO): successful disconnection when MITM happens in the key exchange phase\r\n2024-01-30T13:33:10.519000Z TestFramework (INFO): Stopping nodes\r\n2024-01-30T13:33:10.625000Z TestFramework (INFO): Cleaning up /tmp/test_runner_â‚¿_ðŸƒ_20240130_142948/p2p_v2_earlykeyresponse_133 on exit\r\n2024-01-30T13:33:10.625000Z TestFramework (INFO): Tests successful\r\n\r\n\r\nstderr:\r\nFatal error: protocol.data_received() call failed.\r\nprotocol: <__main__.PeerEarlyKey object at 0x7fe7925dccb0>\r\ntransport: <_SelectorSocketTransport fd=10 read=polling write=<idle, bufsize=0>>\r\nTraceback (most recent call last):\r\n  File \"python3.12/asyncio/selector_events.py\", line 1023, in _read_ready__data_received\r\n    self._protocol.data_received(data)\r\n  File \"test/functional/p2p_v2_earlykeyresponse.py\", line 60, in data_received\r\n    assert self.v2_state.can_data_be_received and not self.v2_state.send_net_magic\r\nAssertionError\r\n\r\n\r\n",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1916996716",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "commented",
      "id": 1917230742,
      "node_id": "IC_kwDOABII585yRp6W",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1917230742",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-30T15:32:03Z",
      "updated_at": "2024-01-30T15:32:03Z",
      "author_association": "CONTRIBUTOR",
      "body": "hmm weird, looking into it.\r\n\r\ni also have a [WIP branch](https://github.com/stratospher/bitcoin/commits/more-v2-tests/) which uses this test file and adds more v2 tests for sending excess garbage bytes, wrong garbage terminator, incorrect ellswift and non-empty version packet.",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1917230742",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "commented",
      "id": 1917933292,
      "node_id": "IC_kwDOABII585yUVbs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1917933292",
      "actor": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-30T21:34:47Z",
      "updated_at": "2024-01-30T21:37:42Z",
      "author_association": "MEMBER",
      "body": "> WIP branch\r\n\r\nIs this consistently failing for you (or can you at least reproduce it)? I can see it also failing on some of the current open PRs but I can not get my head around why (nor can I reproduce it). \r\n\r\nThis should only happen if `PeerEarlyKey` receives any data from the node before sending anything at all, or after sending the network magic but before sending the remaining initial bytes + garbage.\r\n\r\nTo my understanding, the node should not have been able to parse enough data to be replying (with either v1 or v2) ðŸ˜• \r\n\r\nIn case you can reproduce it, it may be useful to log what `data_received` is receiving",
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1917933292",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "commented",
      "id": 1918064080,
      "node_id": "IC_kwDOABII585yU1XQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1918064080",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-30T23:06:32Z",
      "updated_at": "2024-01-30T23:07:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "> The test fails for me:\r\n\r\nsee #29352 for a fix (and a way to reproduce it).",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1918064080",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748"
    },
    {
      "event": "referenced",
      "id": 11661599445,
      "node_id": "REFE_lADOABII585G_btJzwAAAAK3FeLV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11661599445",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4b6687719768b6fd0812edc4cc4b6f9f91622dbc",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4b6687719768b6fd0812edc4cc4b6f9f91622dbc",
      "created_at": "2024-01-31T21:36:39Z"
    },
    {
      "event": "referenced",
      "id": 11716427429,
      "node_id": "REFE_lADOABII585G_btJzwAAAAK6Wn6l",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11716427429",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4de84557d6d1f53255ab19f27c8b6ea0a712934a",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4de84557d6d1f53255ab19f27c8b6ea0a712934a",
      "created_at": "2024-02-06T11:03:04Z"
    },
    {
      "event": "referenced",
      "id": 11933679721,
      "node_id": "REFE_lADOABII585G_btJzwAAAALHTYBp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11933679721",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5c6d900a27076aee95b046c1a7352e832215e88d",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5c6d900a27076aee95b046c1a7352e832215e88d",
      "created_at": "2024-02-27T09:51:49Z"
    },
    {
      "event": "referenced",
      "id": 12092432327,
      "node_id": "REFE_lADOABII585G_btJzwAAAALQw9_H",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12092432327",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "bef99176e638688360020152579b92008c857688",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bef99176e638688360020152579b92008c857688",
      "created_at": "2024-03-12T16:59:16Z"
    },
    {
      "event": "head_ref_deleted",
      "id": 12850084598,
      "node_id": "HRDE_lADOABII585G_btJzwAAAAL97Lr2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12850084598",
      "actor": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T15:21:05Z"
    },
    {
      "event": "referenced",
      "id": 14657329717,
      "node_id": "REFE_lADOABII585G_btJzwAAAANppRo1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14657329717",
      "actor": {
        "login": "kwvg",
        "id": 63189531,
        "node_id": "MDQ6VXNlcjYzMTg5NTMx",
        "avatar_url": "https://avatars.githubusercontent.com/u/63189531?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kwvg",
        "html_url": "https://github.com/kwvg",
        "followers_url": "https://api.github.com/users/kwvg/followers",
        "following_url": "https://api.github.com/users/kwvg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kwvg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kwvg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kwvg/subscriptions",
        "organizations_url": "https://api.github.com/users/kwvg/orgs",
        "repos_url": "https://api.github.com/users/kwvg/repos",
        "events_url": "https://api.github.com/users/kwvg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kwvg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3f04b29e5f9e1c1e9b8ae929d83dd2f215103fd7",
      "commit_url": "https://api.github.com/repos/kwvg/dash/commits/3f04b29e5f9e1c1e9b8ae929d83dd2f215103fd7",
      "created_at": "2024-10-15T13:09:19Z"
    },
    {
      "event": "referenced",
      "id": 14806076691,
      "node_id": "REFE_lADOABII585G_btJzwAAAANygs0T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14806076691",
      "actor": {
        "login": "kwvg",
        "id": 63189531,
        "node_id": "MDQ6VXNlcjYzMTg5NTMx",
        "avatar_url": "https://avatars.githubusercontent.com/u/63189531?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kwvg",
        "html_url": "https://github.com/kwvg",
        "followers_url": "https://api.github.com/users/kwvg/followers",
        "following_url": "https://api.github.com/users/kwvg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kwvg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kwvg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kwvg/subscriptions",
        "organizations_url": "https://api.github.com/users/kwvg/orgs",
        "repos_url": "https://api.github.com/users/kwvg/repos",
        "events_url": "https://api.github.com/users/kwvg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kwvg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f05925a937338784af674227b49eaf143bfa8479",
      "commit_url": "https://api.github.com/repos/kwvg/dash/commits/f05925a937338784af674227b49eaf143bfa8479",
      "created_at": "2024-10-23T08:55:55Z"
    },
    {
      "event": "referenced",
      "id": 14817243599,
      "node_id": "REFE_lADOABII585G_btJzwAAAANzLTHP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14817243599",
      "actor": {
        "login": "kwvg",
        "id": 63189531,
        "node_id": "MDQ6VXNlcjYzMTg5NTMx",
        "avatar_url": "https://avatars.githubusercontent.com/u/63189531?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kwvg",
        "html_url": "https://github.com/kwvg",
        "followers_url": "https://api.github.com/users/kwvg/followers",
        "following_url": "https://api.github.com/users/kwvg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kwvg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kwvg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kwvg/subscriptions",
        "organizations_url": "https://api.github.com/users/kwvg/orgs",
        "repos_url": "https://api.github.com/users/kwvg/repos",
        "events_url": "https://api.github.com/users/kwvg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kwvg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a0cc1fb36f896cfdb348a79e86d2e90eecf4324c",
      "commit_url": "https://api.github.com/repos/kwvg/dash/commits/a0cc1fb36f896cfdb348a79e86d2e90eecf4324c",
      "created_at": "2024-10-23T13:55:17Z"
    },
    {
      "event": "referenced",
      "id": 14818250125,
      "node_id": "REFE_lADOABII585G_btJzwAAAANzPI2N",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14818250125",
      "actor": {
        "login": "kwvg",
        "id": 63189531,
        "node_id": "MDQ6VXNlcjYzMTg5NTMx",
        "avatar_url": "https://avatars.githubusercontent.com/u/63189531?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kwvg",
        "html_url": "https://github.com/kwvg",
        "followers_url": "https://api.github.com/users/kwvg/followers",
        "following_url": "https://api.github.com/users/kwvg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kwvg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kwvg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kwvg/subscriptions",
        "organizations_url": "https://api.github.com/users/kwvg/orgs",
        "repos_url": "https://api.github.com/users/kwvg/repos",
        "events_url": "https://api.github.com/users/kwvg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kwvg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7bcc28d5a524c0d3036d898b7e17f1ea8cb27e4c",
      "commit_url": "https://api.github.com/repos/kwvg/dash/commits/7bcc28d5a524c0d3036d898b7e17f1ea8cb27e4c",
      "created_at": "2024-10-23T14:26:31Z"
    },
    {
      "event": "referenced",
      "id": 14852791674,
      "node_id": "REFE_lADOABII585G_btJzwAAAAN1S516",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14852791674",
      "actor": {
        "login": "kwvg",
        "id": 63189531,
        "node_id": "MDQ6VXNlcjYzMTg5NTMx",
        "avatar_url": "https://avatars.githubusercontent.com/u/63189531?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kwvg",
        "html_url": "https://github.com/kwvg",
        "followers_url": "https://api.github.com/users/kwvg/followers",
        "following_url": "https://api.github.com/users/kwvg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kwvg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kwvg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kwvg/subscriptions",
        "organizations_url": "https://api.github.com/users/kwvg/orgs",
        "repos_url": "https://api.github.com/users/kwvg/repos",
        "events_url": "https://api.github.com/users/kwvg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kwvg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5c01be1851c4a3ddda8557ad0f2160d3f86d8156",
      "commit_url": "https://api.github.com/repos/kwvg/dash/commits/5c01be1851c4a3ddda8557ad0f2160d3f86d8156",
      "created_at": "2024-10-24T14:29:25Z"
    },
    {
      "event": "referenced",
      "id": 14853256564,
      "node_id": "REFE_lADOABII585G_btJzwAAAAN1UrV0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14853256564",
      "actor": {
        "login": "kwvg",
        "id": 63189531,
        "node_id": "MDQ6VXNlcjYzMTg5NTMx",
        "avatar_url": "https://avatars.githubusercontent.com/u/63189531?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kwvg",
        "html_url": "https://github.com/kwvg",
        "followers_url": "https://api.github.com/users/kwvg/followers",
        "following_url": "https://api.github.com/users/kwvg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kwvg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kwvg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kwvg/subscriptions",
        "organizations_url": "https://api.github.com/users/kwvg/orgs",
        "repos_url": "https://api.github.com/users/kwvg/repos",
        "events_url": "https://api.github.com/users/kwvg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kwvg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "6b2a8b5988ce4cdd78ba48ce835fb77b8eecc233",
      "commit_url": "https://api.github.com/repos/kwvg/dash/commits/6b2a8b5988ce4cdd78ba48ce835fb77b8eecc233",
      "created_at": "2024-10-24T14:51:58Z"
    },
    {
      "event": "referenced",
      "id": 14854787821,
      "node_id": "REFE_lADOABII585G_btJzwAAAAN1ahLt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14854787821",
      "actor": {
        "login": "PastaPastaPasta",
        "id": 6443210,
        "node_id": "MDQ6VXNlcjY0NDMyMTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6443210?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/PastaPastaPasta",
        "html_url": "https://github.com/PastaPastaPasta",
        "followers_url": "https://api.github.com/users/PastaPastaPasta/followers",
        "following_url": "https://api.github.com/users/PastaPastaPasta/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/PastaPastaPasta/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/PastaPastaPasta/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/PastaPastaPasta/subscriptions",
        "organizations_url": "https://api.github.com/users/PastaPastaPasta/orgs",
        "repos_url": "https://api.github.com/users/PastaPastaPasta/repos",
        "events_url": "https://api.github.com/users/PastaPastaPasta/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/PastaPastaPasta/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2e162da06f9aa4388444b55bff51505036798db3",
      "commit_url": "https://api.github.com/repos/dashpay/dash/commits/2e162da06f9aa4388444b55bff51505036798db3",
      "created_at": "2024-10-24T16:15:02Z"
    },
    {
      "event": "locked",
      "id": 17697523146,
      "node_id": "LOE_lADOABII585G_btJzwAAAAQe2sXK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17697523146",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-17T06:08:12Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320700971",
      "pull_request_review_id": 1618745079,
      "id": 1320700971,
      "node_id": "PRRC_kwDOABII585OuEwr",
      "diff_hunk": "@@ -598,6 +598,11 @@ def wait_for_disconnect(self, timeout=60):\n         test_function = lambda: not self.is_connected\n         self.wait_until(test_function, timeout=timeout, check_connected=False)\n \n+    def wait_for_reconnect(self, timeout=60):",
      "path": "test/functional/test_framework/p2p.py",
      "position": 321,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "e18b22d: in an outbound connection, `TestNode` -----> `P2PConnection` where `P2PConnection` doesn't actually support v2 P2P but is advertised to support v2 P2P (false advertisement), we need to wait for the `TestNode` to reconnect using v1 P2P.\r\n\r\nThis `wait_for_reconnect()` function won't work always since race conditions are possible. Anyone has a better idea on how this can be done? ",
      "created_at": "2023-09-10T06:13:21Z",
      "updated_at": "2023-09-10T06:13:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1320700971",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320700971"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 593,
      "original_line": 593,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320788959",
      "pull_request_review_id": 1618844751,
      "id": 1320788959,
      "node_id": "PRRC_kwDOABII585OuaPf",
      "diff_hunk": "@@ -598,6 +598,11 @@ def wait_for_disconnect(self, timeout=60):\n         test_function = lambda: not self.is_connected\n         self.wait_until(test_function, timeout=timeout, check_connected=False)\n \n+    def wait_for_reconnect(self, timeout=60):",
      "path": "test/functional/test_framework/p2p.py",
      "position": 321,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "in_reply_to_id": 1320700971,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What is the race condition? I expect you should always still observe a v2 connection, a v2 disconnect, and a v1 connect.\r\n\r\nFWIW, the reason why the reconnect is done asynchronously is to avoid making a P2P connection (which can take seconds, or up to a minute) inside the normal network thread (as that'd prevent us from receiving anything from any other peer at the same time).",
      "created_at": "2023-09-10T15:26:39Z",
      "updated_at": "2023-09-10T15:26:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1320788959",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320788959"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 593,
      "original_line": 593,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320795432",
      "pull_request_review_id": 1618850256,
      "id": 1320795432,
      "node_id": "PRRC_kwDOABII585Oub0o",
      "diff_hunk": "@@ -598,6 +598,11 @@ def wait_for_disconnect(self, timeout=60):\n         test_function = lambda: not self.is_connected\n         self.wait_until(test_function, timeout=timeout, check_connected=False)\n \n+    def wait_for_reconnect(self, timeout=60):",
      "path": "test/functional/test_framework/p2p.py",
      "position": 321,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "in_reply_to_id": 1320700971,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "ideally, first `wait_for_connect` waits on v2 connection and the `wait_for_connect` a few lines below waits for v1 connection.\r\n\r\nit's possible that the v2 reconnection happens quickly and the first `wait_for_connect` detects a v2 connection directly. Then we'd be stuck waiting for disconnect and connect (in the lines below) to happen (even though it has already happened).",
      "created_at": "2023-09-10T16:13:14Z",
      "updated_at": "2023-09-10T16:13:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1320795432",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320795432"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 593,
      "original_line": 593,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1349750146",
      "pull_request_review_id": 1663408774,
      "id": 1349750146,
      "node_id": "PRRC_kwDOABII585Qc42C",
      "diff_hunk": "@@ -1913,7 +1913,11 @@ bool CConnman::AddConnection(const std::string& address, ConnectionType conn_typ\n     CSemaphoreGrant grant(*semOutbound, true);\n     if (!grant) return false;\n \n-    OpenNetworkConnection(CAddress(), false, std::move(grant), address.c_str(), conn_type, /*use_v2transport=*/false);\n+    CAddress addr(CService(), NODE_NONE);\n+    if (use_v2transport) {",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 15,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "4084fe0c4c95aa4385e91512291ea756cec73c71",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updating the address is no longer necessary with the latest `net` code, just passing the bool should be enough.",
      "created_at": "2023-10-08T17:29:06Z",
      "updated_at": "2023-10-09T04:10:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1349750146",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1349750146"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1917,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1349828896",
      "pull_request_review_id": 1663408774,
      "id": 1349828896,
      "node_id": "PRRC_kwDOABII585QdMEg",
      "diff_hunk": "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 96,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "a7478eab51c156519885673aff9efeaa95504bd3",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Here, and in `respond_v2_handshake`: This should probably be something like\r\n\r\n```\r\ndef initiate_v2_handshake(self, garbage_len=None):\r\n    if garbage_len is None:\r\n        garbage_len = random.randrange(4096)\r\n```\r\nBecause default args are determined when the function is defined (and not when it's called), otherwise \r\n1) the provided `--randomseed` isn't used, making runs non-deterministic.\r\n2) multiple calls to `initiate_v2_handshake` within one program run will all use the same `garbage_len`.",
      "created_at": "2023-10-09T02:50:41Z",
      "updated_at": "2023-10-09T04:10:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1349828896",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1349828896"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1349847429",
      "pull_request_review_id": 1663408774,
      "id": 1349847429,
      "node_id": "PRRC_kwDOABII585QdQmF",
      "diff_hunk": "@@ -598,6 +598,11 @@ def wait_for_disconnect(self, timeout=60):\n         test_function = lambda: not self.is_connected\n         self.wait_until(test_function, timeout=timeout, check_connected=False)\n \n+    def wait_for_reconnect(self, timeout=60):",
      "path": "test/functional/test_framework/p2p.py",
      "position": 321,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "in_reply_to_id": 1320700971,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe it would work just not checking for the racy intermediate states, but instead waiting until we have received the \"version\" message via v1? Something like\r\n\r\n ```\r\ndef test_function():\r\n     if not (self.is_connected and self.last_message.get('version') and self.v2_state is None):\r\n         return False\r\n     return True\r\nself.wait_until(test_function, timeout=timeout, check_connected=False  )\r\n```",
      "created_at": "2023-10-09T04:05:43Z",
      "updated_at": "2023-10-09T04:10:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1349847429",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1349847429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 593,
      "original_line": 593,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350368094",
      "pull_request_review_id": 1664551055,
      "id": 1350368094,
      "node_id": "PRRC_kwDOABII585QfPte",
      "diff_hunk": "@@ -1913,7 +1913,11 @@ bool CConnman::AddConnection(const std::string& address, ConnectionType conn_typ\n     CSemaphoreGrant grant(*semOutbound, true);\n     if (!grant) return false;\n \n-    OpenNetworkConnection(CAddress(), false, std::move(grant), address.c_str(), conn_type, /*use_v2transport=*/false);\n+    CAddress addr(CService(), NODE_NONE);\n+    if (use_v2transport) {",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 15,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "4084fe0c4c95aa4385e91512291ea756cec73c71",
      "in_reply_to_id": 1349750146,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "thanks! done.",
      "created_at": "2023-10-09T14:15:20Z",
      "updated_at": "2023-10-09T14:15:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1350368094",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350368094"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1917,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350368582",
      "pull_request_review_id": 1664551886,
      "id": 1350368582,
      "node_id": "PRRC_kwDOABII585QfP1G",
      "diff_hunk": "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 96,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "a7478eab51c156519885673aff9efeaa95504bd3",
      "in_reply_to_id": 1349828896,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "interesting, done. i've removed `garbage_len` from the function parameter list since the call sites wouldn't need to set `garbage_len` value.",
      "created_at": "2023-10-09T14:15:46Z",
      "updated_at": "2023-10-09T14:15:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1350368582",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350368582"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350370031",
      "pull_request_review_id": 1664554329,
      "id": 1350370031,
      "node_id": "PRRC_kwDOABII585QfQLv",
      "diff_hunk": "@@ -598,6 +598,11 @@ def wait_for_disconnect(self, timeout=60):\n         test_function = lambda: not self.is_connected\n         self.wait_until(test_function, timeout=timeout, check_connected=False)\n \n+    def wait_for_reconnect(self, timeout=60):",
      "path": "test/functional/test_framework/p2p.py",
      "position": 321,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "in_reply_to_id": 1320700971,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "good idea! that should work.",
      "created_at": "2023-10-09T14:17:00Z",
      "updated_at": "2023-10-09T14:17:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1350370031",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350370031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 593,
      "original_line": 593,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350924659",
      "pull_request_review_id": 1665480038,
      "id": 1350924659,
      "node_id": "PRRC_kwDOABII585QhXlz",
      "diff_hunk": "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response, garbage_len=random.randrange(4096)):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad)",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 133,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "5f851714cf5fa7a31bb423c20035f7b44deed25d",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think that all the decoy packets should pass `ignore=True` as an arg to `v2_enc_packet`.",
      "created_at": "2023-10-09T22:40:31Z",
      "updated_at": "2023-10-10T22:27:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1350924659",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350924659"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 138,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353141062",
      "pull_request_review_id": 1665480038,
      "id": 1353141062,
      "node_id": "PRRC_kwDOABII585Qp0tG",
      "diff_hunk": "@@ -1209,13 +1209,14 @@ class CConnman\n      * @param[in]   address     Address of node to try connecting to\n      * @param[in]   conn_type   ConnectionType::OUTBOUND, ConnectionType::BLOCK_RELAY,\n      *                          ConnectionType::ADDR_FETCH or ConnectionType::FEELER\n+     * @param[in]   use_v2transport  Set to true if node supports BIP324 v2 transport protocol",
      "path": "src/net.h",
      "position": null,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9810e96c74380a3087b2b576508581380019872f",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'd prefer to explain what it actually does - (attempt to) connect using the v2 transport protocol.",
      "created_at": "2023-10-10T18:46:50Z",
      "updated_at": "2023-10-10T22:27:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353141062",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353141062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353143252",
      "pull_request_review_id": 1665480038,
      "id": 1353143252,
      "node_id": "PRRC_kwDOABII585Qp1PU",
      "diff_hunk": "@@ -357,6 +357,7 @@ static RPCHelpMan addconnection()\n         {\n             {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The IP address and port to attempt connecting to.\"},\n             {\"connection_type\", RPCArg::Type::STR, RPCArg::Optional::NO, \"Type of connection to open (\\\"outbound-full-relay\\\", \\\"block-relay-only\\\", \\\"addr-fetch\\\" or \\\"feeler\\\").\"},\n+            {\"v2transport\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Node supports BIP324 v2 transport protocol\"},",
      "path": "src/rpc/net.cpp",
      "position": null,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9810e96c74380a3087b2b576508581380019872f",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "same here: connect with v2 transport protocol; we might choose to not pass `v2transport=True` with this rpc even if the node supports v2 transport.",
      "created_at": "2023-10-10T18:47:26Z",
      "updated_at": "2023-10-10T22:27:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353143252",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353143252"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 360,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353156113",
      "pull_request_review_id": 1665480038,
      "id": 1353156113,
      "node_id": "PRRC_kwDOABII585Qp4YR",
      "diff_hunk": "@@ -388,11 +389,12 @@ static RPCHelpMan addconnection()\n     } else {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, self.ToString());\n     }\n+    bool use_v2transport = !request.params[2].isNull() && request.params[2].get_bool();",
      "path": "src/rpc/net.cpp",
      "position": 23,
      "original_position": 23,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9810e96c74380a3087b2b576508581380019872f",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "could return an error if `-v2transport` for the node is not enabled but `use_v2transport` is chosen (similar to the way it's done in `addnode`).",
      "created_at": "2023-10-10T18:50:31Z",
      "updated_at": "2023-10-10T22:27:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353156113",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353156113"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 405,
      "original_line": 405,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353183494",
      "pull_request_review_id": 1665480038,
      "id": 1353183494,
      "node_id": "PRRC_kwDOABII585Qp_EG",
      "diff_hunk": "@@ -1880,7 +1880,7 @@ void CConnman::CreateNodeFromAcceptedSocket(std::unique_ptr<Sock>&& sock,\n     RandAddEvent((uint32_t)id);\n }\n \n-bool CConnman::AddConnection(const std::string& address, ConnectionType conn_type)\n+bool CConnman::AddConnection(const std::string& address, ConnectionType conn_type, bool use_v2transport = false)",
      "path": "src/net.cpp",
      "position": 5,
      "original_position": 5,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9810e96c74380a3087b2b576508581380019872f",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9810e96c74380a3087b2b576508581380019872f:\r\nCommit message needs an update (remove the service bit flags part)",
      "created_at": "2023-10-10T18:59:49Z",
      "updated_at": "2023-10-10T22:27:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353183494",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353183494"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1836,
      "original_line": 1836,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353263820",
      "pull_request_review_id": 1665480038,
      "id": 1353263820,
      "node_id": "PRRC_kwDOABII585QqSrM",
      "diff_hunk": "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 96,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "a7478eab51c156519885673aff9efeaa95504bd3",
      "in_reply_to_id": 1349828896,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks! The fix made it into the wrong commit (should be in \"Construct class to handle v2 P2P protocol functions\", it's one commit later).",
      "created_at": "2023-10-10T20:03:42Z",
      "updated_at": "2023-10-10T22:27:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353263820",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353263820"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353384798",
      "pull_request_review_id": 1665480038,
      "id": 1353384798,
      "node_id": "PRRC_kwDOABII585QqwNe",
      "diff_hunk": "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response, garbage_len=random.randrange(4096)):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(4096):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't\n+                    if length == LENGTH_FIELD_LEN + HEADER_LEN + CHACHA20POLY1305_EXPANSION:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Return a peer object with various BIP324 derived keys and ciphers.\"\"\"",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 178,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "5f851714cf5fa7a31bb423c20035f7b44deed25d",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: this function doesn't return anything, it sets the `peer` class member.",
      "created_at": "2023-10-10T20:56:28Z",
      "updated_at": "2023-10-10T22:27:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353384798",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353384798"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1355307964",
      "pull_request_review_id": 1671747731,
      "id": 1355307964,
      "node_id": "PRRC_kwDOABII585QyFu8",
      "diff_hunk": "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response, garbage_len=random.randrange(4096)):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(4096):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't\n+                    if length == LENGTH_FIELD_LEN + HEADER_LEN + CHACHA20POLY1305_EXPANSION:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Return a peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[\"regtest\"]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+        Returns:\n+            1. length - length of packet processed in order to update recvbuf.\n+                      - return 0 if only part of packet is received. (recvbuf not updated since decryption not done yet)\n+                      - return -1 if there's a MAC tag mismatch and disconnect.\n+            2. decrypted packet contents\n+                     - return b\"\" if only part of packet is received/MAC tag mismatch.\n+        \"\"\"\n+        if len(response) < LENGTH_FIELD_LEN:\n+            return 0, b\"\"\n+        enc_contents_len = response[:LENGTH_FIELD_LEN]\n+        response = response[LENGTH_FIELD_LEN:]\n+        contents_len = int.from_bytes(self.peer['recv_L'].crypt(enc_contents_len), 'little')",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 225,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "5f851714cf5fa7a31bb423c20035f7b44deed25d",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I have little knowledge of cryptography, but I think that something is wrong here.\r\nDoesn't `crypt` change the internal state of the stream cipher, so if we abort below because we haven't received the message in full, but then call `crypt` again on the same first 3 bytes of the now larger response, we will get an incorrect result?",
      "created_at": "2023-10-11T16:03:53Z",
      "updated_at": "2023-10-11T16:03:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1355307964",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1355307964"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 230,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549582",
      "pull_request_review_id": 1673715969,
      "id": 1356549582,
      "node_id": "PRRC_kwDOABII585Q203O",
      "diff_hunk": "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response, garbage_len=random.randrange(4096)):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad)",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 133,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "5f851714cf5fa7a31bb423c20035f7b44deed25d",
      "in_reply_to_id": 1350924659,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done. true! logs had lines like these: `[net] non-version message before version handshake. Message \"\" from peer=0`.",
      "created_at": "2023-10-12T09:27:27Z",
      "updated_at": "2023-10-12T09:27:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356549582",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549582"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 138,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549683",
      "pull_request_review_id": 1673716109,
      "id": 1356549683,
      "node_id": "PRRC_kwDOABII585Q204z",
      "diff_hunk": "@@ -1209,13 +1209,14 @@ class CConnman\n      * @param[in]   address     Address of node to try connecting to\n      * @param[in]   conn_type   ConnectionType::OUTBOUND, ConnectionType::BLOCK_RELAY,\n      *                          ConnectionType::ADDR_FETCH or ConnectionType::FEELER\n+     * @param[in]   use_v2transport  Set to true if node supports BIP324 v2 transport protocol",
      "path": "src/net.h",
      "position": null,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9810e96c74380a3087b2b576508581380019872f",
      "in_reply_to_id": 1353141062,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2023-10-12T09:27:31Z",
      "updated_at": "2023-10-12T09:27:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356549683",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549683"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549798",
      "pull_request_review_id": 1673716273,
      "id": 1356549798,
      "node_id": "PRRC_kwDOABII585Q206m",
      "diff_hunk": "@@ -357,6 +357,7 @@ static RPCHelpMan addconnection()\n         {\n             {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The IP address and port to attempt connecting to.\"},\n             {\"connection_type\", RPCArg::Type::STR, RPCArg::Optional::NO, \"Type of connection to open (\\\"outbound-full-relay\\\", \\\"block-relay-only\\\", \\\"addr-fetch\\\" or \\\"feeler\\\").\"},\n+            {\"v2transport\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Node supports BIP324 v2 transport protocol\"},",
      "path": "src/rpc/net.cpp",
      "position": null,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9810e96c74380a3087b2b576508581380019872f",
      "in_reply_to_id": 1353143252,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2023-10-12T09:27:36Z",
      "updated_at": "2023-10-12T09:27:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356549798",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549798"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 360,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549916",
      "pull_request_review_id": 1673716458,
      "id": 1356549916,
      "node_id": "PRRC_kwDOABII585Q208c",
      "diff_hunk": "@@ -388,11 +389,12 @@ static RPCHelpMan addconnection()\n     } else {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, self.ToString());\n     }\n+    bool use_v2transport = !request.params[2].isNull() && request.params[2].get_bool();",
      "path": "src/rpc/net.cpp",
      "position": 23,
      "original_position": 23,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9810e96c74380a3087b2b576508581380019872f",
      "in_reply_to_id": 1353156113,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2023-10-12T09:27:41Z",
      "updated_at": "2023-10-12T09:27:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356549916",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549916"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 405,
      "original_line": 405,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356550097",
      "pull_request_review_id": 1673716731,
      "id": 1356550097,
      "node_id": "PRRC_kwDOABII585Q20_R",
      "diff_hunk": "@@ -1880,7 +1880,7 @@ void CConnman::CreateNodeFromAcceptedSocket(std::unique_ptr<Sock>&& sock,\n     RandAddEvent((uint32_t)id);\n }\n \n-bool CConnman::AddConnection(const std::string& address, ConnectionType conn_type)\n+bool CConnman::AddConnection(const std::string& address, ConnectionType conn_type, bool use_v2transport = false)",
      "path": "src/net.cpp",
      "position": 5,
      "original_position": 5,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9810e96c74380a3087b2b576508581380019872f",
      "in_reply_to_id": 1353183494,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2023-10-12T09:27:46Z",
      "updated_at": "2023-10-12T09:27:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356550097",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356550097"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1836,
      "original_line": 1836,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356550296",
      "pull_request_review_id": 1673717025,
      "id": 1356550296,
      "node_id": "PRRC_kwDOABII585Q21CY",
      "diff_hunk": "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 96,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "a7478eab51c156519885673aff9efeaa95504bd3",
      "in_reply_to_id": 1349828896,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "oops, fixed.",
      "created_at": "2023-10-12T09:27:52Z",
      "updated_at": "2023-10-12T09:27:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356550296",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356550296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356550774",
      "pull_request_review_id": 1673717719,
      "id": 1356550774,
      "node_id": "PRRC_kwDOABII585Q21J2",
      "diff_hunk": "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response, garbage_len=random.randrange(4096)):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(4096):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't\n+                    if length == LENGTH_FIELD_LEN + HEADER_LEN + CHACHA20POLY1305_EXPANSION:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Return a peer object with various BIP324 derived keys and ciphers.\"\"\"",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 178,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "5f851714cf5fa7a31bb423c20035f7b44deed25d",
      "in_reply_to_id": 1353384798,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2023-10-12T09:28:16Z",
      "updated_at": "2023-10-12T09:28:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356550774",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356550774"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356583257",
      "pull_request_review_id": 1673768690,
      "id": 1356583257,
      "node_id": "PRRC_kwDOABII585Q29FZ",
      "diff_hunk": "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response, garbage_len=random.randrange(4096)):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(4096):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't\n+                    if length == LENGTH_FIELD_LEN + HEADER_LEN + CHACHA20POLY1305_EXPANSION:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Return a peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[\"regtest\"]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+        Returns:\n+            1. length - length of packet processed in order to update recvbuf.\n+                      - return 0 if only part of packet is received. (recvbuf not updated since decryption not done yet)\n+                      - return -1 if there's a MAC tag mismatch and disconnect.\n+            2. decrypted packet contents\n+                     - return b\"\" if only part of packet is received/MAC tag mismatch.\n+        \"\"\"\n+        if len(response) < LENGTH_FIELD_LEN:\n+            return 0, b\"\"\n+        enc_contents_len = response[:LENGTH_FIELD_LEN]\n+        response = response[LENGTH_FIELD_LEN:]\n+        contents_len = int.from_bytes(self.peer['recv_L'].crypt(enc_contents_len), 'little')",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 225,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "5f851714cf5fa7a31bb423c20035f7b44deed25d",
      "in_reply_to_id": 1355307964,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nice catch. you're right!\r\n\r\ni've stored `contents_len` in a class variable so as to not perform the decryption of 3 bytes length again. initially, `contents_len` is -1, after the 3 bytes length gets processed - `contents_len` is updated, when the whole packet is processed `contents_len` is reset to -1 again.\r\n\r\ni'm open to other solutions.\r\n\r\ni wish there was a cleaner way for writing this function with reads like [this](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki?plain=1#L500-L513) but we're working with `P2PConnection`(subclass of `asyncio.Protocol`) where no read is possible(no \"waiting\" for data to be ready) and we just have a [`data_received()`](https://docs.python.org/3/library/asyncio-protocol.html#asyncio.Protocol.data_received) callback when data is received.",
      "created_at": "2023-10-12T09:56:00Z",
      "updated_at": "2023-10-12T09:56:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356583257",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356583257"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 230,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388268045",
      "pull_request_review_id": 1723019604,
      "id": 1388268045,
      "node_id": "PRRC_kwDOABII585Sv0oN",
      "diff_hunk": "@@ -4,10 +4,92 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import os\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n \n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+MAGIC_BYTES = {\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\"   # regtest\n+}\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+TRANSPORT_VERSION = b''\n+V1_PREFIX = MAGIC_BYTES[\"regtest\"] + b'version\\x00\\x00\\x00\\x00\\x00'\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+\n+def GetShortIDFromMessageType(msgtype):\n+    \"\"\"Returns 1-byte short message type ID for the P2P message\"\"\"\n+    msgtype_to_shortid = dict(map(reversed, SHORTID.items()))\n+    return msgtype_to_shortid[msgtype].to_bytes(1, 'big') if msgtype in msgtype_to_shortid else b\"\\x00\"\n+\n+\n class EncryptedP2PState:\n+    \"\"\"A class for performing v2 P2P protocol functions on P2PConnection:\n+    - `initiating` defines whether the P2PConnection is an initiator or responder.\n+        - `initiating` = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+        - `initiating` = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+    - perform initial v2 handshake to instantiate the encrypted transport.\n+        - initial v2 handshakes is performed by:\n+            1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+        - see section #overall-handshake-pseudocode in BIP 324\n+    - encrypt/decrypt v2 P2P messages.\n+        - see section #overall_packet_encryption_and_decryption_pseudocode in BIP 324\n+    \"\"\"\n+    def __init__(self, **kwargs):\n+        self.initiating = kwargs['initiating']  # True if initiator",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 79,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "63463aa9be20fbb93a73be3638a61041b792decd",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could avoid `kwargs` here (unless there is a good reason to also allow other keyword arguments)\r\n```suggestion\r\n    def __init__(self, *, initiating):\r\n        self.initiating = initiating  # True if initiator\r\n```",
      "created_at": "2023-11-09T16:37:53Z",
      "updated_at": "2023-11-09T17:39:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388268045",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388268045"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 80,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388276157",
      "pull_request_review_id": 1723019604,
      "id": 1388276157,
      "node_id": "PRRC_kwDOABII585Sv2m9",
      "diff_hunk": "@@ -4,10 +4,92 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import os\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n \n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+MAGIC_BYTES = {\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\"   # regtest\n+}",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 19,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "63463aa9be20fbb93a73be3638a61041b792decd",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: there's already a `MAGIC_BYTES` dictionary in p2p.py, could use that? (though it seems there's some circular inclusion going on, not sure how to properly resolve that....)",
      "created_at": "2023-11-09T16:44:19Z",
      "updated_at": "2023-11-09T17:39:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388276157",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388276157"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 19,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 21,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388279451",
      "pull_request_review_id": 1723019604,
      "id": 1388279451,
      "node_id": "PRRC_kwDOABII585Sv3ab",
      "diff_hunk": "@@ -18,3 +100,147 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(4096)\n+        self.sent_garbage = os.urandom(garbage_len)",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 103,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "63463aa9be20fbb93a73be3638a61041b792decd",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could deduplicate code by using a helper method like `generate_garbage` (or even `generate_keypair_and_garbage`) that is used both in `initiate_v2_handshake` and `respond_v2_handshake`? Could also put the magic number in a `MAX_GARBAGE_LEN` constant (that's the naming we use in the C++ codebase), though that's one less than the number passed to randrange here.",
      "created_at": "2023-11-09T16:46:41Z",
      "updated_at": "2023-11-09T17:39:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388279451",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388279451"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 107,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 108,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388285003",
      "pull_request_review_id": 1723019604,
      "id": 1388285003,
      "node_id": "PRRC_kwDOABII585Sv4xL",
      "diff_hunk": "@@ -18,3 +100,147 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(4096)\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                garbage_len = random.randrange(4096)\n+                self.sent_garbage = os.urandom(garbage_len)",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 119,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "63463aa9be20fbb93a73be3638a61041b792decd",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Since we are only in test land here, it's probably fine to also use seed-determined randomness for garbage as well (i.e. `random.randrange`)? (I've used `os.urandom` in the past for a PR and got critical feedback about that: https://github.com/bitcoin/bitcoin/pull/25625#discussion_r924540431, which I agree with)\r\n```suggestion\r\n                self.sent_garbage = random.randrange(garbage_len)\r\n```",
      "created_at": "2023-11-09T16:51:05Z",
      "updated_at": "2023-11-09T17:39:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388285003",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388285003"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388307652",
      "pull_request_review_id": 1723019604,
      "id": 1388307652,
      "node_id": "PRRC_kwDOABII585Sv-TE",
      "diff_hunk": "@@ -18,3 +100,147 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(4096)\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                garbage_len = random.randrange(4096)\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(4096):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 158,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "63463aa9be20fbb93a73be3638a61041b792decd",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: as `received_garbage` is ensured to have a maximum size of 16 bytes a few lines above, the slicing isn't needed here.\r\n```suggestion\r\n            if received_garbage == self.peer['recv_garbage_terminator']:\r\n                # Receive, decode, and ignore version packet.\r\n                # This includes skipping decoys and authenticating the received garbage.\r\n                aad = received_garbage\r\n```",
      "created_at": "2023-11-09T17:05:41Z",
      "updated_at": "2023-11-09T17:39:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388307652",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388307652"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 160,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388337105",
      "pull_request_review_id": 1723019604,
      "id": 1388337105,
      "node_id": "PRRC_kwDOABII585SwFfR",
      "diff_hunk": "@@ -689,14 +700,34 @@ def add_outbound_p2p_connection(self, p2p_conn, *, wait_for_verack=True, p2p_idx\n         p2p_idx must be different for simultaneously connected peers. When reusing it for the next peer\n         after disconnecting the previous one, it is necessary to wait for the disconnect to finish to avoid\n         a race condition.\n+\n+        Parameters:\n+            supports_v2_p2p: whether p2p_conn supports v2 P2P or not\n+            advertise_v2_p2p: whether p2p_conn is advertised to support v2 P2P or not\n+\n+        An outbound connection is made from TestNode -------> P2PConnection\n+            - if P2PConnection doesn't advertise_v2_p2p, TestNode sends version message and v1 P2P is followed\n+            - if P2PConnection both supports_v2_p2p and advertise_v2_p2p, TestNode sends ellswift bytes and v2 P2P is followed\n+            - if P2PConnection doesn't supports_v2_p2p but advertise_v2_p2p,\n+                TestNode sends ellswift bytes and P2PConnection disconnects,\n+                TestNode reconnects by sending version message and v1 P2P is followed\n         \"\"\"\n \n         def addconnection_callback(address, port):\n             self.log.debug(\"Connecting to %s:%d %s\" % (address, port, connection_type))\n-            self.addconnection('%s:%d' % (address, port), connection_type)\n+            self.addconnection('%s:%d' % (address, port), connection_type, advertise_v2_p2p)\n \n         p2p_conn.p2p_connected_to_node = False\n-        p2p_conn.peer_accept_connection(connect_cb=addconnection_callback, connect_id=p2p_idx + 1, net=self.chain, timeout_factor=self.timeout_factor, **kwargs)()\n+        if advertise_v2_p2p:\n+            kwargs['services'] = kwargs['services']|NODE_P2P_V2 if 'services' in kwargs else P2P_SERVICES|NODE_P2P_V2",
      "path": "test/functional/test_framework/test_node.py",
      "position": null,
      "original_position": 76,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "1b656a1cf69ff573a23437431c8650729d9fa95a",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "readability nit:\r\n```suggestion\r\n            kwargs['services'] = (kwargs['services']|NODE_P2P_V2) if 'services' in kwargs else (P2P_SERVICES|NODE_P2P_V2)\r\n```",
      "created_at": "2023-11-09T17:25:54Z",
      "updated_at": "2023-11-09T17:39:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388337105",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388337105"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 722,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388344334",
      "pull_request_review_id": 1723019604,
      "id": 1388344334,
      "node_id": "PRRC_kwDOABII585SwHQO",
      "diff_hunk": "@@ -853,9 +855,11 @@ def send_blocks_and_test(self, blocks, node, *, success=True, force_send=False,\n \n         reject_reason = [reject_reason] if reject_reason else []\n         with node.assert_debug_log(expected_msgs=reject_reason):\n+            if is_decoy:  # since decoy messages don't get sent - no need to wait for response",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 55,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "09638be021c6d928002f0a7fe1ff4fc3d4dbb89a",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit:\r\n```suggestion\r\n            if is_decoy:  # since decoy messages are ignored by the recipient - no need to wait for response\r\n```\r\n(or \"don't get processed\" or something like that?)",
      "created_at": "2023-11-09T17:30:55Z",
      "updated_at": "2023-11-09T17:39:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388344334",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388344334"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 858,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388353134",
      "pull_request_review_id": 1723019604,
      "id": 1388353134,
      "node_id": "PRRC_kwDOABII585SwJZu",
      "diff_hunk": "@@ -0,0 +1,116 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+\n+REKEY_INTERVAL = 224",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 23,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "f9a34e333592fc37151f9d5867ced762910e3730",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could import this constant from test_framework.crypto",
      "created_at": "2023-11-09T17:36:20Z",
      "updated_at": "2023-11-09T17:39:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388353134",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388353134"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1389838929",
      "pull_request_review_id": 1725507560,
      "id": 1389838929,
      "node_id": "PRRC_kwDOABII585S10JR",
      "diff_hunk": "@@ -4,10 +4,92 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import os\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n \n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+MAGIC_BYTES = {\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\"   # regtest\n+}",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 19,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "63463aa9be20fbb93a73be3638a61041b792decd",
      "in_reply_to_id": 1388276157,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I agree that would be nice, in particular so that we can enable `p2p_dos_header_tree.py` (which uses testnet instead of regtest) in combination with v2 transport. One possibility would be to move the `MAGIC_BYTES` constants from `p2p.py` into another file (e.g. `test_framework/messages.py`), change all includes, pass `net` to `EncryptedP2PState`, and change `V1_PREFIX` into a local variable using it)",
      "created_at": "2023-11-10T19:45:16Z",
      "updated_at": "2023-11-10T19:45:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1389838929",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1389838929"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 19,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 21,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149591",
      "pull_request_review_id": 1725972058,
      "id": 1390149591,
      "node_id": "PRRC_kwDOABII585S2__X",
      "diff_hunk": "@@ -4,10 +4,92 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import os\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n \n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+MAGIC_BYTES = {\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\"   # regtest\n+}\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+TRANSPORT_VERSION = b''\n+V1_PREFIX = MAGIC_BYTES[\"regtest\"] + b'version\\x00\\x00\\x00\\x00\\x00'\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+\n+def GetShortIDFromMessageType(msgtype):\n+    \"\"\"Returns 1-byte short message type ID for the P2P message\"\"\"\n+    msgtype_to_shortid = dict(map(reversed, SHORTID.items()))\n+    return msgtype_to_shortid[msgtype].to_bytes(1, 'big') if msgtype in msgtype_to_shortid else b\"\\x00\"\n+\n+\n class EncryptedP2PState:\n+    \"\"\"A class for performing v2 P2P protocol functions on P2PConnection:\n+    - `initiating` defines whether the P2PConnection is an initiator or responder.\n+        - `initiating` = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+        - `initiating` = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+    - perform initial v2 handshake to instantiate the encrypted transport.\n+        - initial v2 handshakes is performed by:\n+            1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+        - see section #overall-handshake-pseudocode in BIP 324\n+    - encrypt/decrypt v2 P2P messages.\n+        - see section #overall_packet_encryption_and_decryption_pseudocode in BIP 324\n+    \"\"\"\n+    def __init__(self, **kwargs):\n+        self.initiating = kwargs['initiating']  # True if initiator",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 79,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "63463aa9be20fbb93a73be3638a61041b792decd",
      "in_reply_to_id": 1388268045,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2023-11-11T06:27:19Z",
      "updated_at": "2023-11-11T06:27:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149591",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149591"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 80,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149597",
      "pull_request_review_id": 1725972065,
      "id": 1390149597,
      "node_id": "PRRC_kwDOABII585S2__d",
      "diff_hunk": "@@ -4,10 +4,92 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import os\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n \n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+MAGIC_BYTES = {\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\"   # regtest\n+}",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 19,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "63463aa9be20fbb93a73be3638a61041b792decd",
      "in_reply_to_id": 1388276157,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nice! included `MAGIC_BYTES` in messages.py",
      "created_at": "2023-11-11T06:27:28Z",
      "updated_at": "2023-11-11T06:27:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149597",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149597"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 19,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 21,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149601",
      "pull_request_review_id": 1725972070,
      "id": 1390149601,
      "node_id": "PRRC_kwDOABII585S2__h",
      "diff_hunk": "@@ -18,3 +100,147 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(4096)\n+        self.sent_garbage = os.urandom(garbage_len)",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 103,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "63463aa9be20fbb93a73be3638a61041b792decd",
      "in_reply_to_id": 1388279451,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "true! done.",
      "created_at": "2023-11-11T06:27:32Z",
      "updated_at": "2023-11-11T06:27:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149601",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149601"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 107,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 108,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149609",
      "pull_request_review_id": 1725972078,
      "id": 1390149609,
      "node_id": "PRRC_kwDOABII585S2__p",
      "diff_hunk": "@@ -18,3 +100,147 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(4096)\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                garbage_len = random.randrange(4096)\n+                self.sent_garbage = os.urandom(garbage_len)",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 119,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "63463aa9be20fbb93a73be3638a61041b792decd",
      "in_reply_to_id": 1388285003,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "makes sense. done.",
      "created_at": "2023-11-11T06:27:37Z",
      "updated_at": "2023-11-11T06:27:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149609",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149609"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149630",
      "pull_request_review_id": 1725972107,
      "id": 1390149630,
      "node_id": "PRRC_kwDOABII585S2__-",
      "diff_hunk": "@@ -18,3 +100,147 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(4096)\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                garbage_len = random.randrange(4096)\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(4096):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 158,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "63463aa9be20fbb93a73be3638a61041b792decd",
      "in_reply_to_id": 1388307652,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "but there's also an else condition below where if the `received_garbage` doesn't match the garbage terminator, we keep appending 1 byte to `received_garbage` until there's a match with garbage terminator/we've exceed max garbage limit. so even though initially `received_garbage` length is 16 bytes, it can take values from 17 bytes, ..., 17 + 4095 bytes.  ",
      "created_at": "2023-11-11T06:27:52Z",
      "updated_at": "2023-11-11T06:27:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149630",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149630"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 160,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149640",
      "pull_request_review_id": 1725972133,
      "id": 1390149640,
      "node_id": "PRRC_kwDOABII585S3AAI",
      "diff_hunk": "@@ -689,14 +700,34 @@ def add_outbound_p2p_connection(self, p2p_conn, *, wait_for_verack=True, p2p_idx\n         p2p_idx must be different for simultaneously connected peers. When reusing it for the next peer\n         after disconnecting the previous one, it is necessary to wait for the disconnect to finish to avoid\n         a race condition.\n+\n+        Parameters:\n+            supports_v2_p2p: whether p2p_conn supports v2 P2P or not\n+            advertise_v2_p2p: whether p2p_conn is advertised to support v2 P2P or not\n+\n+        An outbound connection is made from TestNode -------> P2PConnection\n+            - if P2PConnection doesn't advertise_v2_p2p, TestNode sends version message and v1 P2P is followed\n+            - if P2PConnection both supports_v2_p2p and advertise_v2_p2p, TestNode sends ellswift bytes and v2 P2P is followed\n+            - if P2PConnection doesn't supports_v2_p2p but advertise_v2_p2p,\n+                TestNode sends ellswift bytes and P2PConnection disconnects,\n+                TestNode reconnects by sending version message and v1 P2P is followed\n         \"\"\"\n \n         def addconnection_callback(address, port):\n             self.log.debug(\"Connecting to %s:%d %s\" % (address, port, connection_type))\n-            self.addconnection('%s:%d' % (address, port), connection_type)\n+            self.addconnection('%s:%d' % (address, port), connection_type, advertise_v2_p2p)\n \n         p2p_conn.p2p_connected_to_node = False\n-        p2p_conn.peer_accept_connection(connect_cb=addconnection_callback, connect_id=p2p_idx + 1, net=self.chain, timeout_factor=self.timeout_factor, **kwargs)()\n+        if advertise_v2_p2p:\n+            kwargs['services'] = kwargs['services']|NODE_P2P_V2 if 'services' in kwargs else P2P_SERVICES|NODE_P2P_V2",
      "path": "test/functional/test_framework/test_node.py",
      "position": null,
      "original_position": 76,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "1b656a1cf69ff573a23437431c8650729d9fa95a",
      "in_reply_to_id": 1388337105,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2023-11-11T06:28:06Z",
      "updated_at": "2023-11-11T06:28:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149640",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149640"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 722,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149641",
      "pull_request_review_id": 1725972136,
      "id": 1390149641,
      "node_id": "PRRC_kwDOABII585S3AAJ",
      "diff_hunk": "@@ -853,9 +855,11 @@ def send_blocks_and_test(self, blocks, node, *, success=True, force_send=False,\n \n         reject_reason = [reject_reason] if reject_reason else []\n         with node.assert_debug_log(expected_msgs=reject_reason):\n+            if is_decoy:  # since decoy messages don't get sent - no need to wait for response",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 55,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "09638be021c6d928002f0a7fe1ff4fc3d4dbb89a",
      "in_reply_to_id": 1388344334,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2023-11-11T06:28:11Z",
      "updated_at": "2023-11-11T06:28:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149641",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149641"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 858,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149646",
      "pull_request_review_id": 1725972145,
      "id": 1390149646,
      "node_id": "PRRC_kwDOABII585S3AAO",
      "diff_hunk": "@@ -0,0 +1,116 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+\n+REKEY_INTERVAL = 224",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 23,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "f9a34e333592fc37151f9d5867ced762910e3730",
      "in_reply_to_id": 1388353134,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2023-11-11T06:28:15Z",
      "updated_at": "2023-11-11T06:28:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149646",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149646"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390234612",
      "pull_request_review_id": 1726071399,
      "id": 1390234612,
      "node_id": "PRRC_kwDOABII585S3Uv0",
      "diff_hunk": "@@ -18,3 +100,147 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(4096)\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                garbage_len = random.randrange(4096)\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(4096):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 158,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "63463aa9be20fbb93a73be3638a61041b792decd",
      "in_reply_to_id": 1388307652,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Oh right, I missed the else-branch and assumed `received_garbage` wouldn't change in the loop (which wouldn't make much sense), nevermind.",
      "created_at": "2023-11-11T14:23:50Z",
      "updated_at": "2023-11-11T14:23:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390234612",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390234612"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 160,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390623656",
      "pull_request_review_id": 1726545195,
      "id": 1390623656,
      "node_id": "PRRC_kwDOABII585S4zuo",
      "diff_hunk": "@@ -4,10 +4,92 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import os\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n \n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+MAGIC_BYTES = {\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\"   # regtest\n+}",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 19,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "63463aa9be20fbb93a73be3638a61041b792decd",
      "in_reply_to_id": 1388276157,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks! \r\nI think you should actually use `net` by making both callers from `p2p.py`  pass it to `EncryptedP2PState`, the default value of 'regtest' should be dropped in my opinion. \r\nCould also change all existing imports for MAGIC_BYTES (there are a few in other tests) to avoid indirect imports.",
      "created_at": "2023-11-13T04:52:32Z",
      "updated_at": "2023-11-13T06:56:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390623656",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390623656"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 19,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 21,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1393801774",
      "pull_request_review_id": 1731446070,
      "id": 1393801774,
      "node_id": "PRRC_kwDOABII585TE7ou",
      "diff_hunk": "@@ -4,10 +4,92 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import os\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n \n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+MAGIC_BYTES = {\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\"   # regtest\n+}",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 19,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "63463aa9be20fbb93a73be3638a61041b792decd",
      "in_reply_to_id": 1388276157,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "sounds much better! added a [new commit](https://github.com/bitcoin/bitcoin/pull/24748/commits/7f0e797dc9524c03f650f60a028cb46852877284).",
      "created_at": "2023-11-15T08:06:44Z",
      "updated_at": "2023-11-15T08:06:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1393801774",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1393801774"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 19,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 21,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1394911231",
      "pull_request_review_id": 1733127844,
      "id": 1394911231,
      "node_id": "PRRC_kwDOABII585TJKf_",
      "diff_hunk": "@@ -0,0 +1,86 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+import random\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.v2_p2p import EncryptedP2PState\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Custom implementation of class EncryptedP2PState for testing purposes:\n+\n+    - if `send_net_magic` is True, send first 4 bytes of ellswift(match network magic) else send remaining 60 bytes\n+    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+              This state is represented using `can_data_be_received` = False.\n+            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+              This state is represented using `can_data_be_received` = True.\n+    \"\"\"\n+\n+    def __init__(self):\n+        super().__init__(initiating=True, net='regtest')\n+        self.send_net_magic = True\n+        self.can_data_be_received = False\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage.\n+        Here, the 64 bytes ellswift is assumed to have it's 4 bytes match network magic bytes. It is sent in 2 phases:\n+            1. when `send_network_magic` = True, send first 4 bytes of ellswift (matches network magic bytes)\n+            2. when `send_network_magic` = False, send remaining 60 bytes of ellswift\n+        \"\"\"\n+        if self.send_net_magic:\n+            self.privkey_ours, self.ellswift_ours = ellswift_create()\n+            self.sent_garbage = os.urandom(garbage_len)\n+            self.send_net_magic = False\n+            return b\"\\xfa\\xbf\\xb5\\xda\"\n+        else:\n+            self.can_data_be_received = True\n+            return self.ellswift_ours[4:] + self.sent_garbage\n+\n+\n+class PeerEarlyKey(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.v2_state = None\n+\n+    def connection_made(self, *args, **kwargs):\n+        \"\"\"Custom implementation so that 64 bytes ellswift is sent in 2 parts during `initial_v2_handshake()`\"\"\"\n+        self.v2_state = TestEncryptedP2PState()\n+        super(PeerEarlyKey, self).connection_made(*args, **kwargs)",
      "path": "test/functional/p2p_v2_earlykeyresponse.py",
      "position": null,
      "original_position": 55,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "b3c0a54085703932e57369f5b1315b516c172dc4",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is it on purpose to use `super()` above and provide args here and below? Not an expert on this kind of stuff, but [this](https://stackoverflow.com/questions/59538746/when-do-you-need-to-pass-arguments-to-python-super) suggests that providing args is not necessary in python3.",
      "created_at": "2023-11-15T22:30:14Z",
      "updated_at": "2023-11-15T23:38:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1394911231",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1394911231"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1394961498",
      "pull_request_review_id": 1733127844,
      "id": 1394961498,
      "node_id": "PRRC_kwDOABII585TJWxa",
      "diff_hunk": "@@ -0,0 +1,86 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+import random\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.v2_p2p import EncryptedP2PState\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Custom implementation of class EncryptedP2PState for testing purposes:\n+\n+    - if `send_net_magic` is True, send first 4 bytes of ellswift(match network magic) else send remaining 60 bytes\n+    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+              This state is represented using `can_data_be_received` = False.\n+            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+              This state is represented using `can_data_be_received` = True.\n+    \"\"\"\n+\n+    def __init__(self):\n+        super().__init__(initiating=True, net='regtest')\n+        self.send_net_magic = True\n+        self.can_data_be_received = False\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage.\n+        Here, the 64 bytes ellswift is assumed to have it's 4 bytes match network magic bytes. It is sent in 2 phases:\n+            1. when `send_network_magic` = True, send first 4 bytes of ellswift (matches network magic bytes)\n+            2. when `send_network_magic` = False, send remaining 60 bytes of ellswift\n+        \"\"\"\n+        if self.send_net_magic:\n+            self.privkey_ours, self.ellswift_ours = ellswift_create()\n+            self.sent_garbage = os.urandom(garbage_len)",
      "path": "test/functional/p2p_v2_earlykeyresponse.py",
      "position": null,
      "original_position": 39,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "b3c0a54085703932e57369f5b1315b516c172dc4",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "one more instance of os.urandom (`random.randbytes(garbage_len)` should work)\r\n",
      "created_at": "2023-11-15T23:04:32Z",
      "updated_at": "2023-11-15T23:38:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1394961498",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1394961498"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398651836",
      "pull_request_review_id": 1738944298,
      "id": 1398651836,
      "node_id": "PRRC_kwDOABII585TXbu8",
      "diff_hunk": "@@ -0,0 +1,86 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+import random\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.v2_p2p import EncryptedP2PState\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Custom implementation of class EncryptedP2PState for testing purposes:\n+\n+    - if `send_net_magic` is True, send first 4 bytes of ellswift(match network magic) else send remaining 60 bytes\n+    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+              This state is represented using `can_data_be_received` = False.\n+            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+              This state is represented using `can_data_be_received` = True.\n+    \"\"\"\n+\n+    def __init__(self):\n+        super().__init__(initiating=True, net='regtest')\n+        self.send_net_magic = True\n+        self.can_data_be_received = False\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage.\n+        Here, the 64 bytes ellswift is assumed to have it's 4 bytes match network magic bytes. It is sent in 2 phases:\n+            1. when `send_network_magic` = True, send first 4 bytes of ellswift (matches network magic bytes)\n+            2. when `send_network_magic` = False, send remaining 60 bytes of ellswift\n+        \"\"\"\n+        if self.send_net_magic:\n+            self.privkey_ours, self.ellswift_ours = ellswift_create()\n+            self.sent_garbage = os.urandom(garbage_len)\n+            self.send_net_magic = False\n+            return b\"\\xfa\\xbf\\xb5\\xda\"\n+        else:\n+            self.can_data_be_received = True\n+            return self.ellswift_ours[4:] + self.sent_garbage\n+\n+\n+class PeerEarlyKey(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.v2_state = None\n+\n+    def connection_made(self, *args, **kwargs):\n+        \"\"\"Custom implementation so that 64 bytes ellswift is sent in 2 parts during `initial_v2_handshake()`\"\"\"\n+        self.v2_state = TestEncryptedP2PState()\n+        super(PeerEarlyKey, self).connection_made(*args, **kwargs)",
      "path": "test/functional/p2p_v2_earlykeyresponse.py",
      "position": null,
      "original_position": 55,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "b3c0a54085703932e57369f5b1315b516c172dc4",
      "in_reply_to_id": 1394911231,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "you're right! done.",
      "created_at": "2023-11-20T04:29:57Z",
      "updated_at": "2023-11-20T04:29:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1398651836",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398651836"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398651878",
      "pull_request_review_id": 1738944376,
      "id": 1398651878,
      "node_id": "PRRC_kwDOABII585TXbvm",
      "diff_hunk": "@@ -0,0 +1,86 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+import random\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.v2_p2p import EncryptedP2PState\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Custom implementation of class EncryptedP2PState for testing purposes:\n+\n+    - if `send_net_magic` is True, send first 4 bytes of ellswift(match network magic) else send remaining 60 bytes\n+    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+              This state is represented using `can_data_be_received` = False.\n+            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+              This state is represented using `can_data_be_received` = True.\n+    \"\"\"\n+\n+    def __init__(self):\n+        super().__init__(initiating=True, net='regtest')\n+        self.send_net_magic = True\n+        self.can_data_be_received = False\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage.\n+        Here, the 64 bytes ellswift is assumed to have it's 4 bytes match network magic bytes. It is sent in 2 phases:\n+            1. when `send_network_magic` = True, send first 4 bytes of ellswift (matches network magic bytes)\n+            2. when `send_network_magic` = False, send remaining 60 bytes of ellswift\n+        \"\"\"\n+        if self.send_net_magic:\n+            self.privkey_ours, self.ellswift_ours = ellswift_create()\n+            self.sent_garbage = os.urandom(garbage_len)",
      "path": "test/functional/p2p_v2_earlykeyresponse.py",
      "position": null,
      "original_position": 39,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "b3c0a54085703932e57369f5b1315b516c172dc4",
      "in_reply_to_id": 1394961498,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2023-11-20T04:30:06Z",
      "updated_at": "2023-11-20T04:30:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1398651878",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398651878"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1399855267",
      "pull_request_review_id": 1740854829,
      "id": 1399855267,
      "node_id": "PRRC_kwDOABII585TcBij",
      "diff_hunk": "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 91,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "7eac63705b376d5d8d7f3f1a2d86452412b4e371",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "One possible problem I encountered when running the `p2p_invalid_messages.py` `test_resource_exhaustion` subtest with v2 that but could affect many tests intermittently, also this spot:\r\n\r\nI think that there could be a race between the python main thread of functional tests and the p2p thread:\r\nFor example, this command 1) builds messages, 2) encrypts them and 3) sends them, all within the main thread.\r\nIf during step 2) the bitcoind node would decide to send out a ping, the p2p thread will also encrypt a message (the pong answer) and send it. It doesn't wait for the other thread. This isn't a problem with v1 (if the messages are sent in different orders, nothing may break),  but with v2 I think the connection would break down because the ChaCha stream cipher is stateful.\r\n\r\nSo I think that maybe we need some kind of synchronization / locking mechanism?\r\n\r\nI haven't though much about a solution yet, just wanted to share this problem.",
      "created_at": "2023-11-20T23:13:40Z",
      "updated_at": "2023-11-20T23:17:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1399855267",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1399855267"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404207499",
      "pull_request_review_id": 1747722826,
      "id": 1404207499,
      "node_id": "PRRC_kwDOABII585TsoGL",
      "diff_hunk": "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 91,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "7eac63705b376d5d8d7f3f1a2d86452412b4e371",
      "in_reply_to_id": 1399855267,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good point indeed. To execute the steps build/encrypt/send-message atomically, I think introducing a new lock and acquiring it in the `send_message` method should do the trick? I.e.\r\n```diff\r\ndiff --git a/test/functional/test_framework/p2p.py b/test/functional/test_framework/p2p.py\r\nindex a70682a768..59707471a6 100755\r\n--- a/test/functional/test_framework/p2p.py\r\n+++ b/test/functional/test_framework/p2p.py\r\n@@ -164,6 +164,7 @@ class P2PConnection(asyncio.Protocol):\r\n         # The underlying transport of the connection.\r\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\r\n         self._transport = None\r\n+        self._send_lock = threading.Lock()\r\n         self.v2_state = None  # EncryptedP2PState object needed for v2 p2p connections\r\n         self.supports_v2_p2p = False  # set if the connection supports v2 p2p\r\n         self.reconnect = False  # set if reconnection needs to happen\r\n@@ -371,9 +372,10 @@ class P2PConnection(asyncio.Protocol):\r\n \r\n         This method takes a P2P payload, builds the P2P header and adds\r\n         the message to the send buffer to be sent over the socket.\"\"\"\r\n-        tmsg = self.build_message(message, is_decoy)\r\n-        self._log_message(\"send\", message)\r\n-        return self.send_raw_message(tmsg)\r\n+        with self._send_lock:\r\n+            tmsg = self.build_message(message, is_decoy)\r\n+            self._log_message(\"send\", message)\r\n+            return self.send_raw_message(tmsg)\r\n \r\n     def send_raw_message(self, raw_message_bytes):\r\n         if not self.is_connected:\r\n```\r\nIt might be also good to classify the methods `build_message` and `send_raw_message` as private then (that is, prefixing them with an underscore) to express that they shouldn't be called from the outside anymore, as this would cause problems for v2 connections after handshake completion. Currently only `p2p_invalid_messages.py` is calling those methods, so that test needs to be reworked for v2 support (didn't look deeper yet though, can maybe also done in a follow-up).",
      "created_at": "2023-11-24T10:41:06Z",
      "updated_at": "2023-11-24T10:41:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1404207499",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404207499"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404234919",
      "pull_request_review_id": 1747764579,
      "id": 1404234919,
      "node_id": "PRRC_kwDOABII585Tsuyn",
      "diff_hunk": "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 91,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "7eac63705b376d5d8d7f3f1a2d86452412b4e371",
      "in_reply_to_id": 1399855267,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "+1, good catch! when i tried this, just running `self.test_resource_exhaustion()` in `p2p_invalid messages.py` took too much time. \r\n1. in v1, without locks - 0m22.265s\r\n2. in v2, without locks - won't work\r\n3. in v1, with locks - 0m22.101s\r\n4. in v2, with locks - 8m45.916s",
      "created_at": "2023-11-24T11:09:16Z",
      "updated_at": "2023-11-24T11:09:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1404234919",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404234919"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404392341",
      "pull_request_review_id": 1748012511,
      "id": 1404392341,
      "node_id": "PRRC_kwDOABII585TtVOV",
      "diff_hunk": "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 91,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "7eac63705b376d5d8d7f3f1a2d86452412b4e371",
      "in_reply_to_id": 1399855267,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "@stratospher: Seems like the long run-time in case 4. is primarily caused by the slow ChaCha20 implementation in Python. On my machine, encrypting 4MB of data (as done in `test_resource_exhaustion`, but repeated 80 times) takes already more than half a minute:\r\n```\r\n$ ipython \r\nPython 3.10.13 (main, Oct  5 2023, 16:21:31) [Clang 13.0.0 ]\r\nType 'copyright', 'credits' or 'license' for more information\r\nIPython 8.13.2 -- An enhanced Interactive Python. Type '?' for help.\r\n\r\nIn [1]: from test.functional.test_framework.crypto.bip324_cipher import aead_chacha20_poly1305_encrypt\r\n\r\nIn [2]: %time _ = aead_chacha20_poly1305_encrypt(key=bytes([1]*32), nonce=bytes([2]*12), aad=bytes(), plaintext=bytes([0xcc]*4000000))\r\nCPU times: user 35.9 s, sys: 40 ms, total: 36 s\r\nWall time: 35.8 s\r\n```\r\nI guess we can't do that much about that (unless someone sees a way to optimize our python cryptography, without introducing new dependencies like `numpy` or calling an external library?), other than reducing the number of loops in `test_resource_exhaustion` if p2p-v2 is used.",
      "created_at": "2023-11-24T14:08:55Z",
      "updated_at": "2023-11-24T14:08:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1404392341",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404392341"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404533791",
      "pull_request_review_id": 1748231287,
      "id": 1404533791,
      "node_id": "PRRC_kwDOABII585Tt3wf",
      "diff_hunk": "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 91,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "7eac63705b376d5d8d7f3f1a2d86452412b4e371",
      "in_reply_to_id": 1399855267,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> so that test needs to be reworked for v2 support (didn't look deeper yet though, can maybe also done in a follow-up)\r\n\r\nYes, multiple tests need an adjustment for running with python v2 P2P. I have a WIP branch at \r\nhttps://github.com/mzumsande/bitcoin/tree/tmp_bip324_fixalltests for that which has helped me find this concurrency issue and other issues I mentioned above, but will only open a PR after this PR is merged.\r\n\r\n> Seems like the long run-time in case 4. is primarily caused by the slow ChaCha20 implementation in Python.\r\n\r\nI agree. I think that his particular subtest maybe could be skipped with v2 because its goal is to stress the node by bombarding it with lots of messages in a short time, not the test framework. But also,  `feature_block.py` and `feature_maxuploadtarget.py`, become very slow on my computer for the same reason and we might have to only run them with v1 transport.",
      "created_at": "2023-11-24T16:48:29Z",
      "updated_at": "2023-11-24T16:48:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1404533791",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404533791"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404599389",
      "pull_request_review_id": 1748347506,
      "id": 1404599389,
      "node_id": "PRRC_kwDOABII585TuHxd",
      "diff_hunk": "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 91,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "7eac63705b376d5d8d7f3f1a2d86452412b4e371",
      "in_reply_to_id": 1399855267,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I guess we can't do that much about that (unless someone sees a way to optimize our python cryptography, without introducing new dependencies like numpy or calling an external library?), other than reducing the number of loops in test_resource_exhaustion if p2p-v2 is used.\r\n\r\nmakes sense.\r\n\r\ni've introduced a new lock in [this commit](https://github.com/bitcoin/bitcoin/pull/24748/commits/99f162f3abfe5f76f914a20169743cd151d6c14e).",
      "created_at": "2023-11-24T19:10:24Z",
      "updated_at": "2023-11-24T19:10:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1404599389",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404599389"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408124460",
      "pull_request_review_id": 1753471883,
      "id": 1408124460,
      "node_id": "PRRC_kwDOABII585T7kYs",
      "diff_hunk": "@@ -197,6 +198,10 @@ def start(self, extra_args=None, *, cwd=None, stdout=None, stderr=None, env=None\n         \"\"\"Start the node.\"\"\"\n         if extra_args is None:\n             extra_args = self.extra_args\n+        if \"-v2transport=1\" in extra_args:\n+            self.advertise_v2_p2p = True",
      "path": "test/functional/test_framework/test_node.py",
      "position": null,
      "original_position": 13,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "b9538c706742444a41c9e9d906baedc40f5aa91e",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Now that #28805 is merged, `self.use_v2transport` from test_node could be used instead of introducing `self.advertise_v2_p2p`.",
      "created_at": "2023-11-28T17:21:41Z",
      "updated_at": "2023-11-28T21:18:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1408124460",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408124460"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408222484",
      "pull_request_review_id": 1753471883,
      "id": 1408222484,
      "node_id": "PRRC_kwDOABII585T78UU",
      "diff_hunk": "@@ -231,12 +231,65 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged(see BIP 324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                ellswift_and_garbage_data = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if ellswift_and_garbage_data == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif ellswift_and_garbage_data:\n+                    self.send_raw_message(ellswift_and_garbage_data)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64 - length:",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 32,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9a6b684becbffd02f24a686b965ada257fa7bfd9",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why `64 - length` here instead of `64`? I realize that we have already read some bytes in `respond_v2_handshake` but I think we haven't removed these from `self.recvbuf` yet, so wouldn't this need to be at least 64 bytes to proceed?",
      "created_at": "2023-11-28T18:32:06Z",
      "updated_at": "2023-11-28T21:18:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1408222484",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408222484"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 262,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408245400",
      "pull_request_review_id": 1753471883,
      "id": 1408245400,
      "node_id": "PRRC_kwDOABII585T8B6Y",
      "diff_hunk": "@@ -231,12 +231,65 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged(see BIP 324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                ellswift_and_garbage_data = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if ellswift_and_garbage_data == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif ellswift_and_garbage_data:\n+                    self.send_raw_message(ellswift_and_garbage_data)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64 - length:\n+                return\n+            # `complete_handshake()` computes garbage terminator + authentication packet + version packet to be sent as\n+            # response after deriving shared ECDH secret using received ellswift bytes\n+            response = self.v2_state.complete_handshake(BytesIO(self.recvbuf[length:]))\n+            self.send_raw_message(response)\n+            self.recvbuf = self.recvbuf[64:]\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        if self.v2_state.peer:",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 43,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9a6b684becbffd02f24a686b965ada257fa7bfd9",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is there a way we could get to this spot without `self.v2_state.peer`? I think not (it should have been present from the beginning or created in `complete_handshake`), so this line could be dropped or changed to an assert?",
      "created_at": "2023-11-28T18:52:15Z",
      "updated_at": "2023-11-28T21:18:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1408245400",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408245400"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408269092",
      "pull_request_review_id": 1753471883,
      "id": 1408269092,
      "node_id": "PRRC_kwDOABII585T8Hsk",
      "diff_hunk": "@@ -231,12 +231,65 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged(see BIP 324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                ellswift_and_garbage_data = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if ellswift_and_garbage_data == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif ellswift_and_garbage_data:\n+                    self.send_raw_message(ellswift_and_garbage_data)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64 - length:\n+                return\n+            # `complete_handshake()` computes garbage terminator + authentication packet + version packet to be sent as\n+            # response after deriving shared ECDH secret using received ellswift bytes\n+            response = self.v2_state.complete_handshake(BytesIO(self.recvbuf[length:]))\n+            self.send_raw_message(response)\n+            self.recvbuf = self.recvbuf[64:]\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        if self.v2_state.peer:\n+            # authenticate v2 handshake\n+            if len(self.recvbuf) < 16 + 20:",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 45,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9a6b684becbffd02f24a686b965ada257fa7bfd9",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "could add a comment about the meaning of the magic numbers",
      "created_at": "2023-11-28T19:10:53Z",
      "updated_at": "2023-11-28T21:18:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1408269092",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408269092"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408382994",
      "pull_request_review_id": 1753471883,
      "id": 1408382994,
      "node_id": "PRRC_kwDOABII585T8jgS",
      "diff_hunk": "@@ -553,6 +560,11 @@ def on_verack(self, message):\n \n     def on_version(self, message):\n         assert message.nVersion >= MIN_P2P_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_P2P_VERSION_SUPPORTED)\n+        # reconnection using v1 P2P has happened since version message can be processed, previously queued messages are sent using v1 P2P here\n+        if self.reconnect:\n+            while self.queue_messages:\n+                message = self.queue_messages.pop(0)\n+                self.send_message(message)",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 59,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "ae8070c58f628a76d25d15eece1f9ffdd5002e26",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should we at some point set `self.reconnect` to `False` again (maybe here?), so that future possible disconnections that would be unrelated will be handled correctly?",
      "created_at": "2023-11-28T20:29:23Z",
      "updated_at": "2023-11-28T21:18:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1408382994",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408382994"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 572,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409537266",
      "pull_request_review_id": 1755680506,
      "id": 1409537266,
      "node_id": "PRRC_kwDOABII585UA9Ty",
      "diff_hunk": "@@ -197,6 +198,10 @@ def start(self, extra_args=None, *, cwd=None, stdout=None, stderr=None, env=None\n         \"\"\"Start the node.\"\"\"\n         if extra_args is None:\n             extra_args = self.extra_args\n+        if \"-v2transport=1\" in extra_args:\n+            self.advertise_v2_p2p = True",
      "path": "test/functional/test_framework/test_node.py",
      "position": null,
      "original_position": 13,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "b9538c706742444a41c9e9d906baedc40f5aa91e",
      "in_reply_to_id": 1408124460,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yay! done.",
      "created_at": "2023-11-29T16:18:41Z",
      "updated_at": "2023-11-29T16:18:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409537266",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409537266"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409538169",
      "pull_request_review_id": 1755682114,
      "id": 1409538169,
      "node_id": "PRRC_kwDOABII585UA9h5",
      "diff_hunk": "@@ -231,12 +231,65 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged(see BIP 324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                ellswift_and_garbage_data = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if ellswift_and_garbage_data == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif ellswift_and_garbage_data:\n+                    self.send_raw_message(ellswift_and_garbage_data)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64 - length:",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 32,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9a6b684becbffd02f24a686b965ada257fa7bfd9",
      "in_reply_to_id": 1408222484,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "good catch! done.",
      "created_at": "2023-11-29T16:19:00Z",
      "updated_at": "2023-11-29T16:19:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409538169",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409538169"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 262,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409539941",
      "pull_request_review_id": 1755685348,
      "id": 1409539941,
      "node_id": "PRRC_kwDOABII585UA99l",
      "diff_hunk": "@@ -231,12 +231,65 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged(see BIP 324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                ellswift_and_garbage_data = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if ellswift_and_garbage_data == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif ellswift_and_garbage_data:\n+                    self.send_raw_message(ellswift_and_garbage_data)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64 - length:\n+                return\n+            # `complete_handshake()` computes garbage terminator + authentication packet + version packet to be sent as\n+            # response after deriving shared ECDH secret using received ellswift bytes\n+            response = self.v2_state.complete_handshake(BytesIO(self.recvbuf[length:]))\n+            self.send_raw_message(response)\n+            self.recvbuf = self.recvbuf[64:]\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        if self.v2_state.peer:",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 43,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9a6b684becbffd02f24a686b965ada257fa7bfd9",
      "in_reply_to_id": 1408245400,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "you're right! i've made it an assert.\r\n\r\ni vaguely remember adding this in some older version of the branch because when `TestNode` sends transport layer packets(64 bytes ellswift, x bytes garbage, 16 bytes garbage terminator, optional decoy packets, 20 bytes transport version packet) to our python `P2PInterface`, it's not necessary that we receive all these bytes at once on the wire/have access to these bytes at once on `self.recvbuf`. Looking at this again - even without the \"`if self.v2_state.peer`\", the code paths for when 64 + 16 + 20 bytes is received or when 64 bytes, delay, 16 + 20 bytes is received works fine!\r\n\r\nEDIT: the code path in `complete_handshake` returning 0, b\"\" to receive rest of (64-x) bytes doesn't work currently because it would result in an assertion failure here in case 64 bytes ellswift were received in smaller chunks. added an [else condition](https://github.com/bitcoin/bitcoin/compare/e8d8124bade589ac489377118650f4085890b51d..a5e0d0b3abc70b7f8501743a0787880a32eb5b93) in case that happens.",
      "created_at": "2023-11-29T16:19:35Z",
      "updated_at": "2024-01-29T06:39:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409539941",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409539941"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409540454",
      "pull_request_review_id": 1755686399,
      "id": 1409540454,
      "node_id": "PRRC_kwDOABII585UA-Fm",
      "diff_hunk": "@@ -231,12 +231,65 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged(see BIP 324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                ellswift_and_garbage_data = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if ellswift_and_garbage_data == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif ellswift_and_garbage_data:\n+                    self.send_raw_message(ellswift_and_garbage_data)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64 - length:\n+                return\n+            # `complete_handshake()` computes garbage terminator + authentication packet + version packet to be sent as\n+            # response after deriving shared ECDH secret using received ellswift bytes\n+            response = self.v2_state.complete_handshake(BytesIO(self.recvbuf[length:]))\n+            self.send_raw_message(response)\n+            self.recvbuf = self.recvbuf[64:]\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        if self.v2_state.peer:\n+            # authenticate v2 handshake\n+            if len(self.recvbuf) < 16 + 20:",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 45,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9a6b684becbffd02f24a686b965ada257fa7bfd9",
      "in_reply_to_id": 1408269092,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "added!",
      "created_at": "2023-11-29T16:19:47Z",
      "updated_at": "2023-11-29T16:19:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409540454",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409540454"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409540710",
      "pull_request_review_id": 1755686870,
      "id": 1409540710,
      "node_id": "PRRC_kwDOABII585UA-Jm",
      "diff_hunk": "@@ -553,6 +560,11 @@ def on_verack(self, message):\n \n     def on_version(self, message):\n         assert message.nVersion >= MIN_P2P_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_P2P_VERSION_SUPPORTED)\n+        # reconnection using v1 P2P has happened since version message can be processed, previously queued messages are sent using v1 P2P here\n+        if self.reconnect:\n+            while self.queue_messages:\n+                message = self.queue_messages.pop(0)\n+                self.send_message(message)",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 59,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "ae8070c58f628a76d25d15eece1f9ffdd5002e26",
      "in_reply_to_id": 1408382994,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "good point! done.",
      "created_at": "2023-11-29T16:19:52Z",
      "updated_at": "2023-11-29T16:19:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409540710",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409540710"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 572,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409600332",
      "pull_request_review_id": 1755780494,
      "id": 1409600332,
      "node_id": "PRRC_kwDOABII585UBMtM",
      "diff_hunk": "@@ -4,10 +4,90 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+\n+def GetShortIDFromMessageType(msgtype):\n+    \"\"\"Returns 1-byte short message type ID for the P2P message\"\"\"\n+    msgtype_to_shortid = dict(map(reversed, SHORTID.items()))",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 58,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "95d57de31f6e1fd251ffb1db4dd6959cf4f90a36",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: as this dictionary is only dependent on the constant `SHORTID` dict, could place it in the global namespace (e.g. as `MSGTYPE_TO_SHORTID` directly below `SHORTID`), so it only has to be calculated once if the module is loaded, and not on each `GetShortIDFromMessageType` call again",
      "created_at": "2023-11-29T16:55:09Z",
      "updated_at": "2023-11-29T18:22:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409600332",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409600332"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409605417",
      "pull_request_review_id": 1755780494,
      "id": 1409605417,
      "node_id": "PRRC_kwDOABII585UBN8p",
      "diff_hunk": "@@ -4,10 +4,90 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+\n+def GetShortIDFromMessageType(msgtype):\n+    \"\"\"Returns 1-byte short message type ID for the P2P message\"\"\"\n+    msgtype_to_shortid = dict(map(reversed, SHORTID.items()))\n+    return msgtype_to_shortid[msgtype].to_bytes(1, 'big') if msgtype in msgtype_to_shortid else b\"\\x00\"",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 59,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "95d57de31f6e1fd251ffb1db4dd6959cf4f90a36",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "a little more pythonic (see https://docs.python.org/3/library/stdtypes.html#dict.get):\r\n```suggestion\r\n    return msgtype_to_shortid.get(msgtype, 0).to_bytes(1, 'big')\r\n```",
      "created_at": "2023-11-29T16:58:55Z",
      "updated_at": "2023-11-29T18:22:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409605417",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409605417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409620992",
      "pull_request_review_id": 1755780494,
      "id": 1409620992,
      "node_id": "PRRC_kwDOABII585UBRwA",
      "diff_hunk": "@@ -18,3 +98,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 102,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "95d57de31f6e1fd251ffb1db4dd6959cf4f90a36",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit:\r\n```suggestion\r\n        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\r\n```",
      "created_at": "2023-11-29T17:11:19Z",
      "updated_at": "2023-11-29T18:22:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409620992",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409620992"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409649019",
      "pull_request_review_id": 1755780494,
      "id": 1409649019,
      "node_id": "PRRC_kwDOABII585UBYl7",
      "diff_hunk": "@@ -301,23 +302,47 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+                    # v2 P2P messages are read\n+                    if len(self.recvbuf) < 3 + 1 + 16:\n+                        return\n+                    msglen, msg = self.v2_state.v2_receive_packet(self.recvbuf)\n+                    if msglen == -1:\n+                        raise ValueError(\"invalid v2 mac tag \" + repr(self.recvbuf))\n+                    self.recvbuf = self.recvbuf[msglen:]\n+                    shortid = msg[0]\n+                    if shortid == 0:\n+                        # a string command\n+                        msgtype = msg[1:13].rstrip(b'\\x00')\n+                        msg = msg[13:] # msg is set to be payload\n+                    else:\n+                        # a short id\n+                        if shortid in SHORTID:\n+                            msgtype = SHORTID[shortid]\n+                        else:\n+                            msgtype = \"unknown-\" + str(shortid)",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 49,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "07be9af55860b447edbb7069114881abdd1d85a4",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: shorter, using dict's `.get` method again:\r\n```suggestion\r\n                        msgtype = SHORTID.get(shortid, f\"unknown-{shortid}\")\r\n```",
      "created_at": "2023-11-29T17:35:08Z",
      "updated_at": "2023-11-29T18:22:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409649019",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409649019"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 322,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 325,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409654837",
      "pull_request_review_id": 1755780494,
      "id": 1409654837,
      "node_id": "PRRC_kwDOABII585UBaA1",
      "diff_hunk": "@@ -387,17 +388,29 @@ def maybe_write():\n \n     def build_message(self, message):\n         \"\"\"Build a serialized P2P message\"\"\"\n-        msgtype = message.msgtype\n-        data = message.serialize()\n-        tmsg = self.magic_bytes\n-        tmsg += msgtype\n-        tmsg += b\"\\x00\" * (12 - len(msgtype))\n-        tmsg += struct.pack(\"<I\", len(data))\n-        th = sha256(data)\n-        h = sha256(th)\n-        tmsg += h[:4]\n-        tmsg += data\n-        return tmsg\n+        if self.supports_v2_p2p:\n+            msgtype = message.msgtype\n+            data = message.serialize()",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 25,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "985791c38ff90c09dfd4fa727e326e395ebc1406",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: to deduplicate, could move these two assignments above the `if`, as they are identical in both branches",
      "created_at": "2023-11-29T17:40:40Z",
      "updated_at": "2023-11-29T18:22:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409654837",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409654837"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 392,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 393,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409687151",
      "pull_request_review_id": 1755780494,
      "id": 1409687151,
      "node_id": "PRRC_kwDOABII585UBh5v",
      "diff_hunk": "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 58,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "a1109bfc250263d629070bcb0763b76e9ebc1689",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "to verify each connection's transport protocol version, could additionally take the node's perspective into account via `getpeerinfo()`, e.g.:\r\n<details>\r\n<summary>diff</summary>\r\n\r\n```diff\r\ndiff --git a/test/functional/p2p_v2_encrypted.py b/test/functional/p2p_v2_encrypted.py\r\nindex 177c3ed42f..8f5c4bb925 100755\r\n--- a/test/functional/p2p_v2_encrypted.py\r\n+++ b/test/functional/p2p_v2_encrypted.py\r\n@@ -56,23 +56,28 @@ class P2PEncrypted(BitcoinTestFramework):\r\n         self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\r\n         peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\r\n         assert peer1.supports_v2_p2p\r\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\r\n \r\n         self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\r\n         peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\r\n         assert not peer2.supports_v2_p2p\r\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\r\n \r\n         self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\r\n         peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\r\n         assert not peer3.supports_v2_p2p\r\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\r\n \r\n         # v2 TestNode performs downgrading here\r\n         self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v2 is v1\")\r\n         peer4 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, supports_v2_p2p=False, advertise_v2_p2p=True)\r\n         assert not peer4.supports_v2_p2p\r\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\r\n \r\n         self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\r\n         peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\r\n         assert peer5.supports_v2_p2p\r\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\r\n \r\n         self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\r\n         assert_equal(len(node0.getpeerinfo()), 5)  # check if above 5 connections are present in node0's getpeerinfo()\r\n@@ -88,6 +93,7 @@ class P2PEncrypted(BitcoinTestFramework):\r\n             # Add v2 P2P connection to node0\r\n             peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\r\n             assert peer6.supports_v2_p2p\r\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\r\n \r\n             if i:\r\n                 # check if node1 connected to node0 (but not to node0's p2p connection directly)\r\n@@ -115,6 +121,7 @@ class P2PEncrypted(BitcoinTestFramework):\r\n         self.restart_node(0, [\"-v2transport=0\"])\r\n         peer7 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\r\n         assert not peer7.supports_v2_p2p\r\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\r\n         check_node_connections(node=node0, num_in=1, num_out=0)\r\n```\r\n</details>\r\n(same for the downgrading check commit after)",
      "created_at": "2023-11-29T18:09:34Z",
      "updated_at": "2023-11-29T18:22:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409687151",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409687151"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 56,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409717469",
      "pull_request_review_id": 1755965923,
      "id": 1409717469,
      "node_id": "PRRC_kwDOABII585UBpTd",
      "diff_hunk": "@@ -642,18 +643,30 @@ def assert_start_raises_init_error(self, extra_args=None, expected_msg=None, mat\n                     assert_msg += \"with expected error \" + expected_msg\n                 self._raise_assertion_error(assert_msg)\n \n-    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, **kwargs):\n+    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, supports_v2_p2p=False, **kwargs):\n         \"\"\"Add an inbound p2p connection to the node.\n \n         This method adds the p2p connection to the self.p2ps list and also\n-        returns the connection to the caller.\"\"\"\n+        returns the connection to the caller.\n+\n+        When self.use_v2transport is True, TestNode advertises NODE_P2P_V2 service flag\n+\n+        An inbound connection is made from TestNode <------ P2PConnection\n+        - if TestNode doesn't advertise NODE_P2P_V2 service, P2PConnection sends version message and v1 P2P is followed\n+        - if TestNode advertises NODE_P2P_V2 service, (and if P2PConnections supports v2 P2P)\n+                P2PConnection sends ellswift bytes and v2 P2P is followed\n+        \"\"\"\n         if 'dstport' not in kwargs:\n             kwargs['dstport'] = p2p_port(self.index)\n         if 'dstaddr' not in kwargs:\n             kwargs['dstaddr'] = '127.0.0.1'\n \n         p2p_conn.p2p_connected_to_node = True\n-        p2p_conn.peer_connect(**kwargs, send_version=send_version, net=self.chain, timeout_factor=self.timeout_factor)()\n+        if self.use_v2transport:\n+            kwargs['services'] = kwargs['services']|NODE_P2P_V2 if 'services' in kwargs else P2P_SERVICES|NODE_P2P_V2",
      "path": "test/functional/test_framework/test_node.py",
      "position": null,
      "original_position": 37,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "47e72daf656ea6dc6766f71e5c8bda5717dc5362",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, now that `use_v2transport` with the correct restart behavior is used, CI fails because it is necessary to fix the `test_service_flags` subtest from rpc_net.py already in this PR, to something like\r\n```\r\nif self.options.v2transport:\r\n    assert_equal(['UNKNOWN[2^4]', 'P2P_V2', 'UNKNOWN[2^63]'], self.nodes[0].getpeerinfo()[-1]['servicesnames'])\r\nelse:\r\n    assert_equal(['UNKNOWN[2^4]', 'UNKNOWN[2^63]'], self.nodes[0].getpeerinfo()[-1]['servicesnames'])\r\n```",
      "created_at": "2023-11-29T18:37:35Z",
      "updated_at": "2023-11-29T18:37:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409717469",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409717469"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 666,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410160755",
      "pull_request_review_id": 1756640775,
      "id": 1410160755,
      "node_id": "PRRC_kwDOABII585UDVhz",
      "diff_hunk": "@@ -4,10 +4,90 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+\n+def GetShortIDFromMessageType(msgtype):\n+    \"\"\"Returns 1-byte short message type ID for the P2P message\"\"\"\n+    msgtype_to_shortid = dict(map(reversed, SHORTID.items()))",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 58,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "95d57de31f6e1fd251ffb1db4dd6959cf4f90a36",
      "in_reply_to_id": 1409600332,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "great idea! done.",
      "created_at": "2023-11-30T05:08:49Z",
      "updated_at": "2023-11-30T05:08:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410160755",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410160755"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161591",
      "pull_request_review_id": 1756641992,
      "id": 1410161591,
      "node_id": "PRRC_kwDOABII585UDVu3",
      "diff_hunk": "@@ -4,10 +4,90 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+\n+def GetShortIDFromMessageType(msgtype):\n+    \"\"\"Returns 1-byte short message type ID for the P2P message\"\"\"\n+    msgtype_to_shortid = dict(map(reversed, SHORTID.items()))\n+    return msgtype_to_shortid[msgtype].to_bytes(1, 'big') if msgtype in msgtype_to_shortid else b\"\\x00\"",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 59,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "95d57de31f6e1fd251ffb1db4dd6959cf4f90a36",
      "in_reply_to_id": 1409605417,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "interesting! i've kept a `MSGTYPE_TO_SHORTID` dictionary and used this construct in [`build_message`](https://github.com/bitcoin/bitcoin/blob/6567fe2aafa43b99e8298018b0665222eec4daff/test/functional/test_framework/p2p.py#L398).",
      "created_at": "2023-11-30T05:10:27Z",
      "updated_at": "2023-11-30T05:10:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410161591",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161591"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161655",
      "pull_request_review_id": 1756642068,
      "id": 1410161655,
      "node_id": "PRRC_kwDOABII585UDVv3",
      "diff_hunk": "@@ -18,3 +98,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 102,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "95d57de31f6e1fd251ffb1db4dd6959cf4f90a36",
      "in_reply_to_id": 1409620992,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2023-11-30T05:10:32Z",
      "updated_at": "2023-11-30T05:10:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410161655",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161655"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161736",
      "pull_request_review_id": 1756642205,
      "id": 1410161736,
      "node_id": "PRRC_kwDOABII585UDVxI",
      "diff_hunk": "@@ -301,23 +302,47 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+                    # v2 P2P messages are read\n+                    if len(self.recvbuf) < 3 + 1 + 16:\n+                        return\n+                    msglen, msg = self.v2_state.v2_receive_packet(self.recvbuf)\n+                    if msglen == -1:\n+                        raise ValueError(\"invalid v2 mac tag \" + repr(self.recvbuf))\n+                    self.recvbuf = self.recvbuf[msglen:]\n+                    shortid = msg[0]\n+                    if shortid == 0:\n+                        # a string command\n+                        msgtype = msg[1:13].rstrip(b'\\x00')\n+                        msg = msg[13:] # msg is set to be payload\n+                    else:\n+                        # a short id\n+                        if shortid in SHORTID:\n+                            msgtype = SHORTID[shortid]\n+                        else:\n+                            msgtype = \"unknown-\" + str(shortid)",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 49,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "07be9af55860b447edbb7069114881abdd1d85a4",
      "in_reply_to_id": 1409649019,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yay! looks pythonic! done.",
      "created_at": "2023-11-30T05:10:42Z",
      "updated_at": "2023-11-30T05:10:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410161736",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161736"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 322,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 325,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161807",
      "pull_request_review_id": 1756642260,
      "id": 1410161807,
      "node_id": "PRRC_kwDOABII585UDVyP",
      "diff_hunk": "@@ -387,17 +388,29 @@ def maybe_write():\n \n     def build_message(self, message):\n         \"\"\"Build a serialized P2P message\"\"\"\n-        msgtype = message.msgtype\n-        data = message.serialize()\n-        tmsg = self.magic_bytes\n-        tmsg += msgtype\n-        tmsg += b\"\\x00\" * (12 - len(msgtype))\n-        tmsg += struct.pack(\"<I\", len(data))\n-        th = sha256(data)\n-        h = sha256(th)\n-        tmsg += h[:4]\n-        tmsg += data\n-        return tmsg\n+        if self.supports_v2_p2p:\n+            msgtype = message.msgtype\n+            data = message.serialize()",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 25,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "985791c38ff90c09dfd4fa727e326e395ebc1406",
      "in_reply_to_id": 1409654837,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2023-11-30T05:10:47Z",
      "updated_at": "2023-11-30T05:10:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410161807",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161807"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 392,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 393,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161873",
      "pull_request_review_id": 1756642336,
      "id": 1410161873,
      "node_id": "PRRC_kwDOABII585UDVzR",
      "diff_hunk": "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 58,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "a1109bfc250263d629070bcb0763b76e9ebc1689",
      "in_reply_to_id": 1409687151,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "good suggestion! done.",
      "created_at": "2023-11-30T05:10:53Z",
      "updated_at": "2023-11-30T05:10:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410161873",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161873"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 56,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410162030",
      "pull_request_review_id": 1756642573,
      "id": 1410162030,
      "node_id": "PRRC_kwDOABII585UDV1u",
      "diff_hunk": "@@ -642,18 +643,30 @@ def assert_start_raises_init_error(self, extra_args=None, expected_msg=None, mat\n                     assert_msg += \"with expected error \" + expected_msg\n                 self._raise_assertion_error(assert_msg)\n \n-    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, **kwargs):\n+    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, supports_v2_p2p=False, **kwargs):\n         \"\"\"Add an inbound p2p connection to the node.\n \n         This method adds the p2p connection to the self.p2ps list and also\n-        returns the connection to the caller.\"\"\"\n+        returns the connection to the caller.\n+\n+        When self.use_v2transport is True, TestNode advertises NODE_P2P_V2 service flag\n+\n+        An inbound connection is made from TestNode <------ P2PConnection\n+        - if TestNode doesn't advertise NODE_P2P_V2 service, P2PConnection sends version message and v1 P2P is followed\n+        - if TestNode advertises NODE_P2P_V2 service, (and if P2PConnections supports v2 P2P)\n+                P2PConnection sends ellswift bytes and v2 P2P is followed\n+        \"\"\"\n         if 'dstport' not in kwargs:\n             kwargs['dstport'] = p2p_port(self.index)\n         if 'dstaddr' not in kwargs:\n             kwargs['dstaddr'] = '127.0.0.1'\n \n         p2p_conn.p2p_connected_to_node = True\n-        p2p_conn.peer_connect(**kwargs, send_version=send_version, net=self.chain, timeout_factor=self.timeout_factor)()\n+        if self.use_v2transport:\n+            kwargs['services'] = kwargs['services']|NODE_P2P_V2 if 'services' in kwargs else P2P_SERVICES|NODE_P2P_V2",
      "path": "test/functional/test_framework/test_node.py",
      "position": null,
      "original_position": 37,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "47e72daf656ea6dc6766f71e5c8bda5717dc5362",
      "in_reply_to_id": 1409717469,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "missed that! i've updated the subtest in `rpc_net.py`.",
      "created_at": "2023-11-30T05:11:12Z",
      "updated_at": "2023-11-30T05:11:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410162030",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410162030"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 666,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1418061039",
      "pull_request_review_id": 1768762854,
      "id": 1418061039,
      "node_id": "PRRC_kwDOABII585UheTv",
      "diff_hunk": "@@ -163,6 +163,7 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self._send_lock = threading.Lock()",
      "path": "test/functional/test_framework/p2p.py",
      "position": 40,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "bc26a862b06257ce922b586ac5a7751e61e45e4b",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "One thing to consider is that now we have two locks for p2p, we need to worry about deadlocks.\r\nThere is an implied lock order, `on_message` locks `p2p_lock`, and can call messages (e.g. `on_inv`) that will call `send_message` and lock `_send_lock`. So we must make sure never to take `p2p_lock` after `_send_lock`. I don't think that this is currently possible, but maybe we should add a comment about this.",
      "created_at": "2023-12-06T22:43:13Z",
      "updated_at": "2023-12-06T22:47:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1418061039",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1418061039"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 169,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419447076",
      "pull_request_review_id": 1770812972,
      "id": 1419447076,
      "node_id": "PRRC_kwDOABII585Umwsk",
      "diff_hunk": "@@ -4,10 +4,87 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for performing v2 P2P protocol functions on P2PConnection:",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 60,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "1e070587145a307477328bd313b2eebf72d3a208",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"[test] Construct class to handle v2 P2P protocol functions\"\r\n\r\nIt would be helpful to explain what the return value of the various functions in this class means. In several cases the return value seems to be bytes-that-should-be-sent-to-the-peer, but there are exceptions (-1 meaning downgrade for `respond_v2_handshake`, and `v2_ecdh` returning the shared secret).",
      "created_at": "2023-12-07T18:32:41Z",
      "updated_at": "2023-12-07T19:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419447076",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419447076"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419473256",
      "pull_request_review_id": 1770812972,
      "id": 1419473256,
      "node_id": "PRRC_kwDOABII585Um3Fo",
      "diff_hunk": "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 133,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "1e070587145a307477328bd313b2eebf72d3a208",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"[test] Construct class to handle v2 P2P protocol functions\"\r\n\r\nIt seems a bit strange to always send exactly 10 decoy packets before the version packet. Maybe randomize that too?",
      "created_at": "2023-12-07T18:55:33Z",
      "updated_at": "2023-12-07T19:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419473256",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419473256"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 138,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419502857",
      "pull_request_review_id": 1770812972,
      "id": 1419502857,
      "node_id": "PRRC_kwDOABII585Um-UJ",
      "diff_hunk": "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't\n+                    if length == LENGTH_FIELD_LEN + HEADER_LEN + CHACHA20POLY1305_EXPANSION:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+        Returns:\n+            1. length - length of packet processed in order to update recvbuf.\n+                      - return 0 if only part of packet is received. (recvbuf not updated since decryption not done yet)\n+                      - return -1 if there's a MAC tag mismatch and disconnect.\n+            2. decrypted packet contents\n+                     - return b\"\" if only part of packet is received/MAC tag mismatch.",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 220,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "1e070587145a307477328bd313b2eebf72d3a208",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"[test] Construct class to handle v2 P2P protocol functions\"\r\n\r\nAs I understand it, this function does not distinguish between \"valid packet with 0-byte contents\" and \"decoy packet\", which I believe is incorrect (the version packet can have 0-byte contents, but if it's a decoy, we should still listen for more packets). This isn't caught because Bitcoin Core's V2Transport implementation never sends decoys, but if it did, I believe the tests would break.\r\n\r\nMy suggestion would be to return `None` instead of `b\"\"` for decoys.",
      "created_at": "2023-12-07T19:22:31Z",
      "updated_at": "2023-12-07T19:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419502857",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419502857"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419509492",
      "pull_request_review_id": 1770812972,
      "id": 1419509492,
      "node_id": "PRRC_kwDOABII585Um_70",
      "diff_hunk": "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 163,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "1e070587145a307477328bd313b2eebf72d3a208",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"[test] Construct class to handle v2 P2P protocol functions\"\r\n\r\nI don't think we should be hardcoding this assumption. Decoy packets with 0-byte contents are very much correct and possibly useful. See my other comment on `v2_receive_packet` about distinguishing decoys from 0-byte content packets.",
      "created_at": "2023-12-07T19:28:15Z",
      "updated_at": "2023-12-07T19:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419509492",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419509492"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419512254",
      "pull_request_review_id": 1770812972,
      "id": 1419512254,
      "node_id": "PRRC_kwDOABII585UnAm-",
      "diff_hunk": "@@ -199,8 +211,13 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n+        # in an inbound connection to the TestNode, P2PConnection is the initiator. [TestNode <---- P2PConnection]\n+        # ellswift is generated and sent immediately to begin the initial v2 handshake.\n+        if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n+            ellswift_and_garbage_data = self.v2_state.initiate_v2_handshake()",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 52,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "e378d8af14e302fb34900c403d698445ade5f582",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"[test] Introduce EncryptedP2PState object in P2PConnection\"\r\n\r\nNit: I'd find it a bit cleaner to *not* give this variable such an accurate name for reasons of abstractions. The code here shouldn't care about *what* it is that the `EncryptedP2PState` tells us to send; it should just be sent. Maybe call it \"send_handshake_bytes\" ?",
      "created_at": "2023-12-07T19:30:17Z",
      "updated_at": "2023-12-07T19:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419512254",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419512254"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419733098",
      "pull_request_review_id": 1771245412,
      "id": 1419733098,
      "node_id": "PRRC_kwDOABII585Un2hq",
      "diff_hunk": "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 157,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "1e070587145a307477328bd313b2eebf72d3a208",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If the length returned by `v2_receive_packet(...)` is -1 due to a MAC tag mismatch, `processed_length` is decreased by one here, which is very likely unintended. Currently this is not a problem (the call-site in the later introduced method `P2PConnection.v2_handshake` throws an exception then anyways and doesn't do anything with the returned length), but it's probably better if the `processed_length` increase happens after the length-checks and returns a few lines below.",
      "created_at": "2023-12-07T22:37:31Z",
      "updated_at": "2023-12-08T00:01:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419733098",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419733098"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 161,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 162,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419736521",
      "pull_request_review_id": 1771245412,
      "id": 1419736521,
      "node_id": "PRRC_kwDOABII585Un3XJ",
      "diff_hunk": "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 115,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "1e070587145a307477328bd313b2eebf72d3a208",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: as the `v1_prefix` only depends on `self.net` and never changes, could set it once before the loop (or even in the constructor and store it as member, if we'd ever need it somewhere else), rather than repeatedly on each iteration.",
      "created_at": "2023-12-07T22:41:55Z",
      "updated_at": "2023-12-08T00:01:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419736521",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419736521"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 120,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419777979",
      "pull_request_review_id": 1771245412,
      "id": 1419777979,
      "node_id": "PRRC_kwDOABII585UoBe7",
      "diff_hunk": "@@ -301,23 +302,44 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+                    # v2 P2P messages are read\n+                    if len(self.recvbuf) < 3 + 1 + 16:\n+                        return\n+                    msglen, msg = self.v2_state.v2_receive_packet(self.recvbuf)\n+                    if msglen == -1:\n+                        raise ValueError(\"invalid v2 mac tag \" + repr(self.recvbuf))\n+                    self.recvbuf = self.recvbuf[msglen:]\n+                    shortid = msg[0]\n+                    if shortid == 0:\n+                        # a string command\n+                        msgtype = msg[1:13].rstrip(b'\\x00')\n+                        msg = msg[13:]  # msg is set to be payload",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 43,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "74187afea19284f1ccf576321a57ff18b6e2b1d0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could check that `msg` has the required minimum length (13) and raise an error if it doesn't, to avoid a potential index out-of-bounds exception (even though this is more theoretical now, as bitcoind wouldn't send such an invalid message).",
      "created_at": "2023-12-07T23:53:04Z",
      "updated_at": "2023-12-08T00:01:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419777979",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419777979"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 317,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419779955",
      "pull_request_review_id": 1771245412,
      "id": 1419779955,
      "node_id": "PRRC_kwDOABII585UoB9z",
      "diff_hunk": "@@ -301,23 +302,44 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+                    # v2 P2P messages are read\n+                    if len(self.recvbuf) < 3 + 1 + 16:\n+                        return",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 34,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "74187afea19284f1ccf576321a57ff18b6e2b1d0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is this early check needed? I think `v2_receive_packet` already takes care of these \"only part of packet is received\" cases and indicates this with a corresponding return code.",
      "created_at": "2023-12-07T23:56:54Z",
      "updated_at": "2023-12-08T00:01:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419779955",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419779955"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 309,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 310,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525133",
      "pull_request_review_id": 1783087789,
      "id": 1427525133,
      "node_id": "PRRC_kwDOABII585VFk4N",
      "diff_hunk": "@@ -163,6 +163,7 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self._send_lock = threading.Lock()",
      "path": "test/functional/test_framework/p2p.py",
      "position": 40,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "bc26a862b06257ce922b586ac5a7751e61e45e4b",
      "in_reply_to_id": 1418061039,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "good find! i've added a comment.",
      "created_at": "2023-12-15T04:01:17Z",
      "updated_at": "2023-12-15T04:01:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525133",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525133"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 169,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525183",
      "pull_request_review_id": 1783087850,
      "id": 1427525183,
      "node_id": "PRRC_kwDOABII585VFk4_",
      "diff_hunk": "@@ -4,10 +4,87 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for performing v2 P2P protocol functions on P2PConnection:",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 60,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "1e070587145a307477328bd313b2eebf72d3a208",
      "in_reply_to_id": 1419447076,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "definitely useful to have. done.",
      "created_at": "2023-12-15T04:01:24Z",
      "updated_at": "2023-12-15T04:01:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525183",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525183"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525201",
      "pull_request_review_id": 1783087889,
      "id": 1427525201,
      "node_id": "PRRC_kwDOABII585VFk5R",
      "diff_hunk": "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 133,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "1e070587145a307477328bd313b2eebf72d3a208",
      "in_reply_to_id": 1419473256,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "changed it to send 0-9 number of decoy packets randomly.",
      "created_at": "2023-12-15T04:01:28Z",
      "updated_at": "2023-12-15T04:01:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525201",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525201"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 138,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525236",
      "pull_request_review_id": 1783087939,
      "id": 1427525236,
      "node_id": "PRRC_kwDOABII585VFk50",
      "diff_hunk": "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't\n+                    if length == LENGTH_FIELD_LEN + HEADER_LEN + CHACHA20POLY1305_EXPANSION:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+        Returns:\n+            1. length - length of packet processed in order to update recvbuf.\n+                      - return 0 if only part of packet is received. (recvbuf not updated since decryption not done yet)\n+                      - return -1 if there's a MAC tag mismatch and disconnect.\n+            2. decrypted packet contents\n+                     - return b\"\" if only part of packet is received/MAC tag mismatch.",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 220,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "1e070587145a307477328bd313b2eebf72d3a208",
      "in_reply_to_id": 1419502857,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "good catch! changed it to `None`.",
      "created_at": "2023-12-15T04:01:33Z",
      "updated_at": "2023-12-15T04:01:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525236",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525236"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525256",
      "pull_request_review_id": 1783087968,
      "id": 1427525256,
      "node_id": "PRRC_kwDOABII585VFk6I",
      "diff_hunk": "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 163,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "1e070587145a307477328bd313b2eebf72d3a208",
      "in_reply_to_id": 1419509492,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "right! done.",
      "created_at": "2023-12-15T04:01:36Z",
      "updated_at": "2023-12-15T04:01:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525256",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525256"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525305",
      "pull_request_review_id": 1783088067,
      "id": 1427525305,
      "node_id": "PRRC_kwDOABII585VFk65",
      "diff_hunk": "@@ -199,8 +211,13 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n+        # in an inbound connection to the TestNode, P2PConnection is the initiator. [TestNode <---- P2PConnection]\n+        # ellswift is generated and sent immediately to begin the initial v2 handshake.\n+        if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n+            ellswift_and_garbage_data = self.v2_state.initiate_v2_handshake()",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 52,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "e378d8af14e302fb34900c403d698445ade5f582",
      "in_reply_to_id": 1419512254,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "oh makes sense to `s/ellswift_and_garbage_data/send_handshake_bytes` in `p2p.py`. didn't change the name in a test where we [send ellswift in parts](https://github.com/bitcoin/bitcoin/blob/ad0ae3d2128d04ff4f62a4bf612286d153dc314b/test/functional/p2p_v2_earlykeyresponse.py#L78). ",
      "created_at": "2023-12-15T04:01:46Z",
      "updated_at": "2023-12-15T04:01:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525305",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525305"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525326",
      "pull_request_review_id": 1783088100,
      "id": 1427525326,
      "node_id": "PRRC_kwDOABII585VFk7O",
      "diff_hunk": "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 157,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "1e070587145a307477328bd313b2eebf72d3a208",
      "in_reply_to_id": 1419733098,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2023-12-15T04:01:50Z",
      "updated_at": "2023-12-15T04:01:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525326",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525326"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 161,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 162,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525347",
      "pull_request_review_id": 1783088132,
      "id": 1427525347,
      "node_id": "PRRC_kwDOABII585VFk7j",
      "diff_hunk": "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 115,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "1e070587145a307477328bd313b2eebf72d3a208",
      "in_reply_to_id": 1419736521,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nice, i've kept it outside the loop since we don't need it anywhere else for now.",
      "created_at": "2023-12-15T04:01:53Z",
      "updated_at": "2023-12-15T04:01:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525347",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525347"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 120,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525364",
      "pull_request_review_id": 1783088159,
      "id": 1427525364,
      "node_id": "PRRC_kwDOABII585VFk70",
      "diff_hunk": "@@ -301,23 +302,44 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+                    # v2 P2P messages are read\n+                    if len(self.recvbuf) < 3 + 1 + 16:\n+                        return\n+                    msglen, msg = self.v2_state.v2_receive_packet(self.recvbuf)\n+                    if msglen == -1:\n+                        raise ValueError(\"invalid v2 mac tag \" + repr(self.recvbuf))\n+                    self.recvbuf = self.recvbuf[msglen:]\n+                    shortid = msg[0]\n+                    if shortid == 0:\n+                        # a string command\n+                        msgtype = msg[1:13].rstrip(b'\\x00')\n+                        msg = msg[13:]  # msg is set to be payload",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 43,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "74187afea19284f1ccf576321a57ff18b6e2b1d0",
      "in_reply_to_id": 1419777979,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2023-12-15T04:01:57Z",
      "updated_at": "2023-12-15T04:01:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525364",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525364"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 317,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525400",
      "pull_request_review_id": 1783088186,
      "id": 1427525400,
      "node_id": "PRRC_kwDOABII585VFk8Y",
      "diff_hunk": "@@ -301,23 +302,44 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+                    # v2 P2P messages are read\n+                    if len(self.recvbuf) < 3 + 1 + 16:\n+                        return",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 34,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "74187afea19284f1ccf576321a57ff18b6e2b1d0",
      "in_reply_to_id": 1419779955,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "true, replaced it with a check using `v2_receive_packet` return values which are anyways computed.",
      "created_at": "2023-12-15T04:02:00Z",
      "updated_at": "2023-12-15T04:02:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525400",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525400"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 309,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 310,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1435835891",
      "pull_request_review_id": 1795584001,
      "id": 1435835891,
      "node_id": "PRRC_kwDOABII585VlR3z",
      "diff_hunk": "@@ -642,18 +643,30 @@ def assert_start_raises_init_error(self, extra_args=None, expected_msg=None, mat\n                     assert_msg += \"with expected error \" + expected_msg\n                 self._raise_assertion_error(assert_msg)\n \n-    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, **kwargs):\n+    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, supports_v2_p2p=False, **kwargs):\n         \"\"\"Add an inbound p2p connection to the node.\n \n         This method adds the p2p connection to the self.p2ps list and also\n-        returns the connection to the caller.\"\"\"\n+        returns the connection to the caller.\n+\n+        When self.use_v2transport is True, TestNode advertises NODE_P2P_V2 service flag\n+\n+        An inbound connection is made from TestNode <------ P2PConnection\n+        - if TestNode doesn't advertise NODE_P2P_V2 service, P2PConnection sends version message and v1 P2P is followed\n+        - if TestNode advertises NODE_P2P_V2 service, (and if P2PConnections supports v2 P2P)\n+                P2PConnection sends ellswift bytes and v2 P2P is followed\n+        \"\"\"\n         if 'dstport' not in kwargs:\n             kwargs['dstport'] = p2p_port(self.index)\n         if 'dstaddr' not in kwargs:\n             kwargs['dstaddr'] = '127.0.0.1'\n \n         p2p_conn.p2p_connected_to_node = True\n-        p2p_conn.peer_connect(**kwargs, send_version=send_version, net=self.chain, timeout_factor=self.timeout_factor)()\n+        if self.use_v2transport:\n+            kwargs['services'] = kwargs['services']|NODE_P2P_V2 if 'services' in kwargs else P2P_SERVICES|NODE_P2P_V2",
      "path": "test/functional/test_framework/test_node.py",
      "position": null,
      "original_position": 37,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "52a1719d604befeb799588cd43d7e241772de38a",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "more-pythonic-nit:\r\n```suggestion\r\n            kwargs['services'] = kwargs.get('services', P2P_SERVICES) | NODE_P2P_V2\r\n```\r\n(also in the `add_outbound_p2p_connection` method below)",
      "created_at": "2023-12-24T14:35:41Z",
      "updated_at": "2023-12-24T15:04:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1435835891",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1435835891"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 666,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1435840695",
      "pull_request_review_id": 1795584001,
      "id": 1435840695,
      "node_id": "PRRC_kwDOABII585VlTC3",
      "diff_hunk": "@@ -4,17 +4,275 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\n+\n+        Returns:\n+        bytes - encrypted packet contents\n+        \"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+\n+        Returns:\n+        1. int - length of packet processed in order to update recvbuf.\n+               - return 0 if only part of packet is received. (recvbuf not updated since decryption not done yet)\n+               - return -1 if there's a MAC tag mismatch and disconnect.\n+        2. bytes - decrypted packet contents\n+                 - return b\"\" if only part of packet is received/MAC tag mismatch.",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 259,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "d4d9f673046c05ca1eb638c9c763dc5d90947fe0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: IIUC, `b\"\"` is also returned if the decrypted package content is empty. As call-sites currently use\r\nthe length integer return value (0) to check for the \"only part of packet is received\" condition, this isn't a problem, but maybe the description can be improved to avoid confusion.",
      "created_at": "2023-12-24T14:58:45Z",
      "updated_at": "2023-12-24T15:04:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1435840695",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1435840695"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 259,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439634994",
      "pull_request_review_id": 1800723563,
      "id": 1439634994,
      "node_id": "PRRC_kwDOABII585VzxYy",
      "diff_hunk": "@@ -642,18 +643,30 @@ def assert_start_raises_init_error(self, extra_args=None, expected_msg=None, mat\n                     assert_msg += \"with expected error \" + expected_msg\n                 self._raise_assertion_error(assert_msg)\n \n-    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, **kwargs):\n+    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, supports_v2_p2p=False, **kwargs):\n         \"\"\"Add an inbound p2p connection to the node.\n \n         This method adds the p2p connection to the self.p2ps list and also\n-        returns the connection to the caller.\"\"\"\n+        returns the connection to the caller.\n+\n+        When self.use_v2transport is True, TestNode advertises NODE_P2P_V2 service flag\n+\n+        An inbound connection is made from TestNode <------ P2PConnection\n+        - if TestNode doesn't advertise NODE_P2P_V2 service, P2PConnection sends version message and v1 P2P is followed\n+        - if TestNode advertises NODE_P2P_V2 service, (and if P2PConnections supports v2 P2P)\n+                P2PConnection sends ellswift bytes and v2 P2P is followed\n+        \"\"\"\n         if 'dstport' not in kwargs:\n             kwargs['dstport'] = p2p_port(self.index)\n         if 'dstaddr' not in kwargs:\n             kwargs['dstaddr'] = '127.0.0.1'\n \n         p2p_conn.p2p_connected_to_node = True\n-        p2p_conn.peer_connect(**kwargs, send_version=send_version, net=self.chain, timeout_factor=self.timeout_factor)()\n+        if self.use_v2transport:\n+            kwargs['services'] = kwargs['services']|NODE_P2P_V2 if 'services' in kwargs else P2P_SERVICES|NODE_P2P_V2",
      "path": "test/functional/test_framework/test_node.py",
      "position": null,
      "original_position": 37,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "52a1719d604befeb799588cd43d7e241772de38a",
      "in_reply_to_id": 1435835891,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nice! done.",
      "created_at": "2024-01-02T16:53:56Z",
      "updated_at": "2024-01-02T16:53:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1439634994",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439634994"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 666,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439635162",
      "pull_request_review_id": 1800723770,
      "id": 1439635162,
      "node_id": "PRRC_kwDOABII585Vzxba",
      "diff_hunk": "@@ -4,17 +4,275 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\n+\n+        Returns:\n+        bytes - encrypted packet contents\n+        \"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+\n+        Returns:\n+        1. int - length of packet processed in order to update recvbuf.\n+               - return 0 if only part of packet is received. (recvbuf not updated since decryption not done yet)\n+               - return -1 if there's a MAC tag mismatch and disconnect.\n+        2. bytes - decrypted packet contents\n+                 - return b\"\" if only part of packet is received/MAC tag mismatch.",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 259,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "d4d9f673046c05ca1eb638c9c763dc5d90947fe0",
      "in_reply_to_id": 1435840695,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "added a [description](https://github.com/bitcoin/bitcoin/blob/42203f84bba7e4ba206c9f951c3f4b6922a44f81/test/functional/test_framework/v2_p2p.py#L260-L265) and also an [extra assert](https://github.com/bitcoin/bitcoin/blob/42203f84bba7e4ba206c9f951c3f4b6922a44f81/test/functional/test_framework/p2p.py#L326) to make sure we don't receive b\"\" as an application layer message.",
      "created_at": "2024-01-02T16:54:07Z",
      "updated_at": "2024-01-02T16:54:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1439635162",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439635162"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 259,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1445399806",
      "pull_request_review_id": 1810107436,
      "id": 1445399806,
      "node_id": "PRRC_kwDOABII585WJwz-",
      "diff_hunk": "@@ -174,16 +180,22 @@ def peer_connect_helper(self, dstaddr, dstport, net, timeout_factor):\n         self.recvbuf = b\"\"\n         self.magic_bytes = MAGIC_BYTES[net]\n \n-    def peer_connect(self, dstaddr, dstport, *, net, timeout_factor):\n+    def peer_connect(self, dstaddr, dstport, *, net, timeout_factor, supports_v2_p2p=False):",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 25,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "here, and in `peer_accept_connection`: I think the default values aren't necessary and could be dropped. They are not used right now, and it seems better if future callers are forced make a decision on whether to use v2 or not!",
      "created_at": "2024-01-08T22:09:17Z",
      "updated_at": "2024-01-10T21:23:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1445399806",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1445399806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447657783",
      "pull_request_review_id": 1810107436,
      "id": 1447657783,
      "node_id": "PRRC_kwDOABII585WSYE3",
      "diff_hunk": "@@ -4,17 +4,280 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 201,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "76abc719f20243eb352633082421f33e9a2f66e4",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Trying to wrap my head around this: \r\nLet's say we receive the garbage and then receive one or more decoy packages. Then we cut the response here, but if no version package has been received so far, we can still return `0, True` earlier in the while loop and try again later.\r\nBut then the next time this function is called, wouldn't authentication fail because we've already removed the garbage terminator from the response?\r\n\r\nNot a big deal though - because bitcoind doesn't send any decoy messages currently, this cannot be triggered.",
      "created_at": "2024-01-10T16:52:10Z",
      "updated_at": "2024-01-10T21:23:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1447657783",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447657783"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447884179",
      "pull_request_review_id": 1810107436,
      "id": 1447884179,
      "node_id": "PRRC_kwDOABII585WTPWT",
      "diff_hunk": "@@ -321,6 +321,8 @@ def _on_data(self):\n                         return\n                     self.recvbuf = self.recvbuf[msglen:]\n \n+                    if msg is None:  # reject decoy messages",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "7da31532af882dabbd5d9d6e89634513a24189ea",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: `reject` sounds like we actively do something, `ignore` seems better.",
      "created_at": "2024-01-10T19:50:23Z",
      "updated_at": "2024-01-10T21:23:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1447884179",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447884179"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 324,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447962448",
      "pull_request_review_id": 1810107436,
      "id": 1447962448,
      "node_id": "PRRC_kwDOABII585WTidQ",
      "diff_hunk": "@@ -741,7 +741,10 @@ def addconnection_callback(address, port):\n             p2p_conn.wait_until(lambda: p2p_conn.message_count[\"version\"] == 1, check_connected=False)\n             p2p_conn.wait_until(lambda: not p2p_conn.is_connected, check_connected=False)\n         else:\n-            p2p_conn.wait_for_connect()\n+            if reconnect:\n+                p2p_conn.wait_for_reconnect()",
      "path": "test/functional/test_framework/test_node.py",
      "position": null,
      "original_position": 6,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "689318cd83ca5b17b73e56a0c1544072973718c5",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think that this should be moved outside of the `if connection_type == \"feeler\":` clause and be done before:\r\nAfter all the v2 reconnection stuff logically comes first, and then all the existing v1 logic still applies to the downgraded v1 connection - for example, the reconnection logic should also work if `add_outbound_p2p_connection` specified a feeler connection - in which case we currently wouldn't call `wait_for_reconnect`.",
      "created_at": "2024-01-10T21:00:13Z",
      "updated_at": "2024-01-10T21:25:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1447962448",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447962448"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 745,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1448895458",
      "pull_request_review_id": 1814350455,
      "id": 1448895458,
      "node_id": "PRRC_kwDOABII585WXGPi",
      "diff_hunk": "@@ -4,17 +4,280 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 203,
      "original_position": 194,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "76abc719f20243eb352633082421f33e9a2f66e4",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"[test] Construct class to handle v2 P2P protocol functions\"\r\n\r\nThis needs to be `return processed_length, True`, as there may be been decoys before (I can trigger a failure in p2p_v2_encrypted.py by making Bitcoin Core send large decoys before the version packet). <details><summary>Code to trigger it:</summary>\r\n```diff\r\n--- a/src/net.cpp\r\n+++ b/src/net.cpp\r\n@@ -1130,6 +1130,15 @@ bool V2Transport::ProcessReceivedKeyBytes() noexcept\r\n                   m_cipher.GetSendGarbageTerminator().end(),\r\n                   MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\r\n \r\n+        unsigned decoys = GetRand<unsigned>(10);\r\n+        while (decoys--) {\r\n+            unsigned decoysize = GetRand<unsigned>(4000000);\r\n+            m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + decoysize);\r\n+            std::vector<std::byte> decoy_data(decoysize);\r\n+            m_cipher.Encrypt(decoy_data, MakeByteSpan(m_send_garbage), true, MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + decoysize));\r\n+            ClearShrink(m_send_garbage);\r\n+        }\r\n+\r\n         // Construct version packet in the send buffer, with the sent garbage data as AAD.\r\n```\r\n</details>\r\n\r\nI think it would be even cleaner to change `v2_receive_packet` to also return `contents = None` in case no complete packet was received. In that case, the whole `elif length == 0:` branch can go away.",
      "created_at": "2024-01-11T13:49:48Z",
      "updated_at": "2024-01-12T16:40:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1448895458",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1448895458"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 203,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1448904297",
      "pull_request_review_id": 1814350455,
      "id": 1448904297,
      "node_id": "PRRC_kwDOABII585WXIZp",
      "diff_hunk": "@@ -4,17 +4,280 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\n+\n+        Returns:\n+        bytes - encrypted packet contents\n+        \"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+\n+        Returns:",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 265,
      "original_position": 254,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "76abc719f20243eb352633082421f33e9a2f66e4",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In \"In commit \"[test] Construct class to handle v2 P2P protocol functions\"\r\n\r\nNit: see above, I think it would be cleaner to return `(0, None)` in case no complete packet is present, and `(-1, None)` in case of error. That would make the description:\r\n* int: number of bytes consumed (or -1 if error)\r\n* bytes: contents of decrypted non-decoy packet if any (or None otherwise)\r\n\r\nSince the callers don't care about the distinction between \"no packet processed\" or \"decoy packet processed\" for what to do with the returned contents, I think this would let you remove some branches.",
      "created_at": "2024-01-11T13:56:39Z",
      "updated_at": "2024-01-12T16:32:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1448904297",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1448904297"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 265,
      "original_line": 265,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1448911572",
      "pull_request_review_id": 1814350455,
      "id": 1448911572,
      "node_id": "PRRC_kwDOABII585WXKLU",
      "diff_hunk": "@@ -199,8 +211,13 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n+        # in an inbound connection to the TestNode, P2PConnection is the initiator. [TestNode <---- P2PConnection]\n+        # ellswift is generated and sent immediately to begin the initial v2 handshake.",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 50,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"[test] Introduce EncryptedP2PState object in P2PConnection\":\r\n\r\nNit: probably unnecessary to go into the detail of what gets sent, as that's the responsibility of `v2_p2p`. Maybe just say \"The initial handshake is sent immediately\".",
      "created_at": "2024-01-11T14:02:23Z",
      "updated_at": "2024-01-12T16:32:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1448911572",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1448911572"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449286884",
      "pull_request_review_id": 1816369526,
      "id": 1449286884,
      "node_id": "PRRC_kwDOABII585WYlzk",
      "diff_hunk": "@@ -159,6 +162,9 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self.v2_state = None  # EncryptedP2PState object needed for v2 p2p connections\n+        self.supports_v2_p2p = False  # set if the connection supports v2 p2p\n+        self.queue_messages = []  # queue messages to send after initial v2 handshake",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 16,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: queued / queue of messages / messages queued",
      "created_at": "2024-01-11T19:10:45Z",
      "updated_at": "2024-01-12T20:52:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449286884",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449286884"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449289058",
      "pull_request_review_id": 1816369526,
      "id": 1449289058,
      "node_id": "PRRC_kwDOABII585WYmVi",
      "diff_hunk": "@@ -159,6 +162,9 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self.v2_state = None  # EncryptedP2PState object needed for v2 p2p connections\n+        self.supports_v2_p2p = False  # set if the connection supports v2 p2p",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 15,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think this field is redundant. This will always be `True` if `v2_state` is set, and `False` otherwise, so we could drop it and just check against whether v2_state is `None`.\r\n\r\nIf you think that's too verbose, you could also create a helper method:\r\n\r\n```python\r\ndef supports_v2_p2p(self):\r\n    return self.v2_state is not None\r\n```",
      "created_at": "2024-01-11T19:13:30Z",
      "updated_at": "2024-01-12T20:52:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449289058",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449289058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 166,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449320797",
      "pull_request_review_id": 1816369526,
      "id": 1449320797,
      "node_id": "PRRC_kwDOABII585WYuFd",
      "diff_hunk": "@@ -199,8 +211,13 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n+        # in an inbound connection to the TestNode, P2PConnection is the initiator. [TestNode <---- P2PConnection]\n+        # ellswift is generated and sent immediately to begin the initial v2 handshake.\n+        if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n+            send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n+            self.send_raw_message(send_handshake_bytes)\n         if self.on_connection_send_msg:\n-            self.send_message(self.on_connection_send_msg)\n+            self.queue_messages.append(self.on_connection_send_msg) if self.supports_v2_p2p else self.send_message(self.on_connection_send_msg)",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 56,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: feels like this is something that you could do on `__init__()` instead of creating an empty array. It's not a big deal though, so feel free to disregard  ",
      "created_at": "2024-01-11T19:46:55Z",
      "updated_at": "2024-01-12T20:52:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449320797",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449320797"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 220,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449336950",
      "pull_request_review_id": 1816369526,
      "id": 1449336950,
      "node_id": "PRRC_kwDOABII585WYyB2",
      "diff_hunk": "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 7,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: space missing after responder, also I guess add \"the\" before to match the previous suggestion if you happen to take it",
      "created_at": "2024-01-11T20:02:01Z",
      "updated_at": "2024-01-12T20:52:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449336950",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449336950"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 237,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449337692",
      "pull_request_review_id": 1816369526,
      "id": 1449337692,
      "node_id": "PRRC_kwDOABII585WYyNc",
      "diff_hunk": "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 6,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: P2PConnection is \"the\" initiator?",
      "created_at": "2024-01-11T20:02:51Z",
      "updated_at": "2024-01-12T20:52:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449337692",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449337692"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449340059",
      "pull_request_review_id": 1816369526,
      "id": 1449340059,
      "node_id": "PRRC_kwDOABII585WYyyb",
      "diff_hunk": "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 13,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: caps in \"the\"",
      "created_at": "2024-01-11T20:05:12Z",
      "updated_at": "2024-01-12T20:52:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449340059",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449340059"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449352220",
      "pull_request_review_id": 1816369526,
      "id": 1449352220,
      "node_id": "PRRC_kwDOABII585WY1wc",
      "diff_hunk": "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 16,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is this necessary? \r\n\r\n`self.v2_state.received_prefix` is initialized to `b\"\"`, whose length is zero. Therefore, and given you are only using this as offset for `self.recvbuf`, I think you could just dump the variable and do (in line 266):\r\n\r\n```\r\nresponse = self.v2_state.complete_handshake(BytesIO(self.recvbuf[len(self.v2_state.received_prefix):]))\r\n```\r\n\r\nOr define the variable if you want a shorter call but just right before using it, without having to set it to zero first.",
      "created_at": "2024-01-11T20:17:11Z",
      "updated_at": "2024-01-12T20:52:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449352220",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449352220"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 246,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450623741",
      "pull_request_review_id": 1814350455,
      "id": 1450623741,
      "node_id": "PRRC_kwDOABII585WdsL9",
      "diff_hunk": "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 20,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"[test] Perform initial v2 handshake\":\r\n\r\nI think it's not very clean to reach into `self.v2_state`'s internals to figure out how much `respond_v2_handshake` has consumed. It would be better if the function just returned how much was consumed (if anything).",
      "created_at": "2024-01-12T15:44:51Z",
      "updated_at": "2024-01-12T16:32:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450623741",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450623741"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 250,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450663849",
      "pull_request_review_id": 1814350455,
      "id": 1450663849,
      "node_id": "PRRC_kwDOABII585Wd1-p",
      "diff_hunk": "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if send_handshake_bytes == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif send_handshake_bytes:\n+                    self.send_raw_message(send_handshake_bytes)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64:\n+                return\n+            # `complete_handshake()` computes garbage terminator + optional decoy packets + transport version packet\n+            # to be sent as response after deriving shared ECDH secret using received ellswift bytes\n+            response = self.v2_state.complete_handshake(BytesIO(self.recvbuf[length:]))\n+            self.send_raw_message(response)\n+            self.recvbuf = self.recvbuf[64:]\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        assert self.v2_state.peer\n+        # at least 16 bytes garbage terminator and 20 bytes empty transport version packet\n+        # is required to authenticate v2 handshake\n+        if len(self.recvbuf) < 16 + 20:",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 46,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"[test] Perform initial v2 handshake\":\r\n\r\nI don't think this conditional is necessary. `authenticate_handshake` itself can figure out what it needs.",
      "created_at": "2024-01-12T16:17:47Z",
      "updated_at": "2024-01-12T16:32:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450663849",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450663849"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 276,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450676078",
      "pull_request_review_id": 1818631409,
      "id": 1450676078,
      "node_id": "PRRC_kwDOABII585Wd49u",
      "diff_hunk": "@@ -4,17 +4,280 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 201,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "76abc719f20243eb352633082421f33e9a2f66e4",
      "in_reply_to_id": 1447657783,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "just want to add that if this turned out annoying to fix (I didn't see an immediate trivial fix but haven't looked hard), I'd be fine with just throwing an assert / error if decoy packages are received in this PR (since bitcoind shouldn't send those anyway).",
      "created_at": "2024-01-12T16:29:07Z",
      "updated_at": "2024-01-12T16:29:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450676078",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450676078"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450804849",
      "pull_request_review_id": 1816369526,
      "id": 1450804849,
      "node_id": "PRRC_kwDOABII585WeYZx",
      "diff_hunk": "@@ -163,6 +163,7 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self._send_lock = threading.Lock()",
      "path": "test/functional/test_framework/p2p.py",
      "position": 40,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "bc26a862b06257ce922b586ac5a7751e61e45e4b",
      "in_reply_to_id": 1418061039,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Would it be worth changing how `p2p_lock` is acquired to prevent this? Instead of just grabbing it we could have a helper method being part of the `P2PConnection` that returns it as long as `_send_lock` is not being held, and fails otherwise. Something along the lines of:\r\n\r\n```python\r\ndef p2p_lock(self):\r\n    assert not self._send_lock.locked()\r\n    return p2p_lock\r\n```\r\n\r\nIf you make this change it may also be worth renaming `p2p_lock` to `_p2p_lock` to discourage it from being imported straightaway (and even comment that it shouldn't).\r\n\r\nGiven this will affect several parts of the tests suite it may be worth doing it as a followup",
      "created_at": "2024-01-12T18:41:15Z",
      "updated_at": "2024-01-12T20:52:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450804849",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450804849"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 169,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450825617",
      "pull_request_review_id": 1816369526,
      "id": 1450825617,
      "node_id": "PRRC_kwDOABII585WedeR",
      "diff_hunk": "@@ -199,8 +211,13 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n+        # in an inbound connection to the TestNode, P2PConnection is the initiator. [TestNode <---- P2PConnection]\n+        # ellswift is generated and sent immediately to begin the initial v2 handshake.\n+        if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n+            send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n+            self.send_raw_message(send_handshake_bytes)\n         if self.on_connection_send_msg:\n-            self.send_message(self.on_connection_send_msg)\n+            self.queue_messages.append(self.on_connection_send_msg) if self.supports_v2_p2p else self.send_message(self.on_connection_send_msg)",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 56,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "in_reply_to_id": 1449320797,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Giving this a second look, is this queue necessary? The current use of it is adding the `on_connection_send_msg` and setting that to `None`, meaning that the queue will have at most a single message. Not sure if this is intended to be used in the future, but I don't this it is used atm ",
      "created_at": "2024-01-12T19:06:55Z",
      "updated_at": "2024-01-12T20:52:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450825617",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450825617"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 220,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450866270",
      "pull_request_review_id": 1816369526,
      "id": 1450866270,
      "node_id": "PRRC_kwDOABII585WenZe",
      "diff_hunk": "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 94,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm really struggling to understand what is going on here based on these comments (and the ones bellow at L98-99).\r\n\r\nTo my understanding, what we are trying to test here is: given a peer of `node0` (`peer6`) that provides some blocks to it (decoy on the first iteration and regular on the second) check if after connecting `node0` and `node1` they do end up sharing the same tip. However, I feel the comments are hard to understand",
      "created_at": "2024-01-12T19:48:25Z",
      "updated_at": "2024-01-16T15:09:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450866270",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450866270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 93,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450888252",
      "pull_request_review_id": 1816369526,
      "id": 1450888252,
      "node_id": "PRRC_kwDOABII585Wesw8",
      "diff_hunk": "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 56,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: connection (for consistency with the rest)",
      "created_at": "2024-01-12T20:15:55Z",
      "updated_at": "2024-01-12T20:52:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450888252",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450888252"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450888980",
      "pull_request_review_id": 1816369526,
      "id": 1450888980,
      "node_id": "PRRC_kwDOABII585Wes8U",
      "diff_hunk": "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances\n+            else:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly) and node0 - both\n+                # do not get blocks produced by node0's p2p connection if the messages sent are decoys\n+                self.log.info(\"Check if blocks produced by node0's p2p connection sent as decoys aren't received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=False, is_decoy=True) # node0's tip doesn't advance\n+            # Connect node0 and node1 using v2\n+            self.connect_nodes(0, 1, peer_advertises_v2=True)\n+            self.log.info(\"Wait for node1 to receive all the blocks from node0\")\n+            self.sync_all()\n+            self.log.info(\"Make sure node0 and node1 have same block tips\")\n+            assert_equal(node0.getbestblockhash(), node1.getbestblockhash())\n+\n+            self.disconnect_nodes(0, 1)\n+\n+        self.log.info(\"Check the connections opened as expected\")\n+        check_node_connections(node=node0, num_in=4, num_out=2)\n+\n+        self.log.info(\"Check inbound connections to v1 TestNode from v2 P2PConnection is v1\")",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 114,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: connection (for consistency with the rest).\r\n\r\nAlso, it may be worth moving this right `peer2` so inbounds and outbounds are grouped",
      "created_at": "2024-01-12T20:16:58Z",
      "updated_at": "2024-01-12T20:52:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450888980",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450888980"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457621863",
      "pull_request_review_id": 1829978188,
      "id": 1457621863,
      "node_id": "PRRC_kwDOABII585W4Ytn",
      "diff_hunk": "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n+    @staticmethod\n+    def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n+        ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+        if initiating:\n+            # Initiating, place our public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+        else:\n+            # Responding, place their public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 218,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why is 32 here being passed in every tuple if it really is used as a constant?",
      "created_at": "2024-01-18T15:38:26Z",
      "updated_at": "2024-01-23T16:09:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1457621863",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457621863"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 217,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457652467",
      "pull_request_review_id": 1829978188,
      "id": 1457652467,
      "node_id": "PRRC_kwDOABII585W4gLz",
      "diff_hunk": "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n+    @staticmethod\n+    def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n+        ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+        if initiating:\n+            # Initiating, place our public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+        else:\n+            # Responding, place their public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 222,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why is `garbage_terminators` being actively deleted here instead of letting the deletion be managed by the interpreter once we go out of context (and `peer` is deleted as a whole)?",
      "created_at": "2024-01-18T15:55:05Z",
      "updated_at": "2024-01-23T16:09:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1457652467",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457652467"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457654033",
      "pull_request_review_id": 1829978188,
      "id": 1457654033,
      "node_id": "PRRC_kwDOABII585W4gkR",
      "diff_hunk": "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n+    @staticmethod\n+    def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n+        ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+        if initiating:\n+            # Initiating, place our public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+        else:\n+            # Responding, place their public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 222,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "in_reply_to_id": 1457652467,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I initially thought this had to do with:\r\n\r\n> \\# To achieve forward secrecy we must wipe the key material used to initialize the ciphers\r\n\r\nBut turns out we are not doing it for the key material.",
      "created_at": "2024-01-18T15:56:06Z",
      "updated_at": "2024-01-23T16:09:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1457654033",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457654033"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457665569",
      "pull_request_review_id": 1829978188,
      "id": 1457665569,
      "node_id": "PRRC_kwDOABII585W4jYh",
      "diff_hunk": "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n+    @staticmethod\n+    def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n+        ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+        if initiating:\n+            # Initiating, place our public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+        else:\n+            # Responding, place their public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 222,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "in_reply_to_id": 1457652467,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We could even get rid of this whole re-assignment and just set it in the latter if/else:\r\n\r\n```\r\nself.peer['send_garbage_terminator'] = peer['garbage_terminators'][:16]\r\nself.peer['recv_garbage_terminator'] = peer['garbage_terminators'][16:]\r\n```",
      "created_at": "2024-01-18T16:04:25Z",
      "updated_at": "2024-01-23T16:09:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1457665569",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457665569"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457677043",
      "pull_request_review_id": 1829978188,
      "id": 1457677043,
      "node_id": "PRRC_kwDOABII585W4mLz",
      "diff_hunk": "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 87,
      "original_position": 87,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I wonder whether it may be worth defining a `Peer` class for this and move the peer-building logic of `initialize_v2_transport` here. I don't think this would make a huge difference, but it would make accessing the elements of peer cleaner for the callers. e.g. `self.peer.send_L` instead of `self.peer[\"send_L\"]`",
      "created_at": "2024-01-18T16:13:06Z",
      "updated_at": "2024-01-23T16:09:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1457677043",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457677043"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 87,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466364",
      "pull_request_review_id": 1834681957,
      "id": 1460466364,
      "node_id": "PRRC_kwDOABII585XDPK8",
      "diff_hunk": "@@ -174,16 +180,22 @@ def peer_connect_helper(self, dstaddr, dstport, net, timeout_factor):\n         self.recvbuf = b\"\"\n         self.magic_bytes = MAGIC_BYTES[net]\n \n-    def peer_connect(self, dstaddr, dstport, *, net, timeout_factor):\n+    def peer_connect(self, dstaddr, dstport, *, net, timeout_factor, supports_v2_p2p=False):",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 25,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "in_reply_to_id": 1445399806,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nice! done. removed default value for `reconnect` in `peer_accept_connection` too since that is also always passed from `add_outbound_p2p_connection`  ",
      "created_at": "2024-01-20T14:22:26Z",
      "updated_at": "2024-01-20T14:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460466364",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466364"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466533",
      "pull_request_review_id": 1834681995,
      "id": 1460466533,
      "node_id": "PRRC_kwDOABII585XDPNl",
      "diff_hunk": "@@ -4,17 +4,280 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 201,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "76abc719f20243eb352633082421f33e9a2f66e4",
      "in_reply_to_id": 1447657783,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "great catch! i've changed the `authenticate_handshake` function to first deal with garbage terminator detection before processing decoy packets and version packet. hopefully this is not a concern now?",
      "created_at": "2024-01-20T14:22:47Z",
      "updated_at": "2024-01-20T14:22:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460466533",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466533"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466611",
      "pull_request_review_id": 1834682014,
      "id": 1460466611,
      "node_id": "PRRC_kwDOABII585XDPOz",
      "diff_hunk": "@@ -321,6 +321,8 @@ def _on_data(self):\n                         return\n                     self.recvbuf = self.recvbuf[msglen:]\n \n+                    if msg is None:  # reject decoy messages",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "7da31532af882dabbd5d9d6e89634513a24189ea",
      "in_reply_to_id": 1447884179,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2024-01-20T14:22:54Z",
      "updated_at": "2024-01-20T14:22:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460466611",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466611"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 324,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466749",
      "pull_request_review_id": 1834682043,
      "id": 1460466749,
      "node_id": "PRRC_kwDOABII585XDPQ9",
      "diff_hunk": "@@ -741,7 +741,10 @@ def addconnection_callback(address, port):\n             p2p_conn.wait_until(lambda: p2p_conn.message_count[\"version\"] == 1, check_connected=False)\n             p2p_conn.wait_until(lambda: not p2p_conn.is_connected, check_connected=False)\n         else:\n-            p2p_conn.wait_for_connect()\n+            if reconnect:\n+                p2p_conn.wait_for_reconnect()",
      "path": "test/functional/test_framework/test_node.py",
      "position": null,
      "original_position": 6,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "689318cd83ca5b17b73e56a0c1544072973718c5",
      "in_reply_to_id": 1447962448,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "true! done.",
      "created_at": "2024-01-20T14:23:09Z",
      "updated_at": "2024-01-20T14:23:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460466749",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466749"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 745,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467080",
      "pull_request_review_id": 1834682138,
      "id": 1460467080,
      "node_id": "PRRC_kwDOABII585XDPWI",
      "diff_hunk": "@@ -4,17 +4,280 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 203,
      "original_position": 194,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "76abc719f20243eb352633082421f33e9a2f66e4",
      "in_reply_to_id": 1448895458,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nice catch! done. i've changed `authenticate_handshake` function a bit as discussed in https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1447657783.\r\n\r\n> I think it would be even cleaner to change v2_receive_packet to also return contents = None in case no complete packet was received. In that case, the whole elif length == 0: branch can go away.\r\n\r\ni think we need the `elif length == 0:` now so that we can exit out of the `while not self.tried_v2_handshake:` loop in case we don't have sufficient bytes and need more bytes to be received on `recvbuf`? \r\n",
      "created_at": "2024-01-20T14:23:55Z",
      "updated_at": "2024-01-20T14:23:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467080",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467080"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 203,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467126",
      "pull_request_review_id": 1834682149,
      "id": 1460467126,
      "node_id": "PRRC_kwDOABII585XDPW2",
      "diff_hunk": "@@ -4,17 +4,280 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\n+\n+        Returns:\n+        bytes - encrypted packet contents\n+        \"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+\n+        Returns:",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 265,
      "original_position": 254,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "76abc719f20243eb352633082421f33e9a2f66e4",
      "in_reply_to_id": 1448904297,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "much simpler! done.",
      "created_at": "2024-01-20T14:24:03Z",
      "updated_at": "2024-01-20T14:24:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467126",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467126"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 265,
      "original_line": 265,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467188",
      "pull_request_review_id": 1834682166,
      "id": 1460467188,
      "node_id": "PRRC_kwDOABII585XDPX0",
      "diff_hunk": "@@ -199,8 +211,13 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n+        # in an inbound connection to the TestNode, P2PConnection is the initiator. [TestNode <---- P2PConnection]\n+        # ellswift is generated and sent immediately to begin the initial v2 handshake.",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 50,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "in_reply_to_id": 1448911572,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2024-01-20T14:24:12Z",
      "updated_at": "2024-01-20T14:24:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467188",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467188"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467324",
      "pull_request_review_id": 1834682199,
      "id": 1460467324,
      "node_id": "PRRC_kwDOABII585XDPZ8",
      "diff_hunk": "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 20,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "in_reply_to_id": 1450623741,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "makes sense! I've changed `respond_v2_handshake` and `complete_v2_handshake` to return the bytes consumed info too.",
      "created_at": "2024-01-20T14:24:30Z",
      "updated_at": "2024-01-20T14:24:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467324",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467324"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 250,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467380",
      "pull_request_review_id": 1834682211,
      "id": 1460467380,
      "node_id": "PRRC_kwDOABII585XDPa0",
      "diff_hunk": "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if send_handshake_bytes == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif send_handshake_bytes:\n+                    self.send_raw_message(send_handshake_bytes)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64:\n+                return\n+            # `complete_handshake()` computes garbage terminator + optional decoy packets + transport version packet\n+            # to be sent as response after deriving shared ECDH secret using received ellswift bytes\n+            response = self.v2_state.complete_handshake(BytesIO(self.recvbuf[length:]))\n+            self.send_raw_message(response)\n+            self.recvbuf = self.recvbuf[64:]\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        assert self.v2_state.peer\n+        # at least 16 bytes garbage terminator and 20 bytes empty transport version packet\n+        # is required to authenticate v2 handshake\n+        if len(self.recvbuf) < 16 + 20:",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 46,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "in_reply_to_id": 1450663849,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "true! done.",
      "created_at": "2024-01-20T14:24:37Z",
      "updated_at": "2024-01-20T14:24:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467380",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467380"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 276,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467496",
      "pull_request_review_id": 1834682228,
      "id": 1460467496,
      "node_id": "PRRC_kwDOABII585XDPco",
      "diff_hunk": "@@ -159,6 +162,9 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self.v2_state = None  # EncryptedP2PState object needed for v2 p2p connections\n+        self.supports_v2_p2p = False  # set if the connection supports v2 p2p",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 15,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "in_reply_to_id": 1449289058,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "oh i like this! done.",
      "created_at": "2024-01-20T14:24:46Z",
      "updated_at": "2024-01-20T14:24:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467496",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467496"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 166,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467897",
      "pull_request_review_id": 1834682270,
      "id": 1460467897,
      "node_id": "PRRC_kwDOABII585XDPi5",
      "diff_hunk": "@@ -199,8 +211,13 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n+        # in an inbound connection to the TestNode, P2PConnection is the initiator. [TestNode <---- P2PConnection]\n+        # ellswift is generated and sent immediately to begin the initial v2 handshake.\n+        if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n+            send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n+            self.send_raw_message(send_handshake_bytes)\n         if self.on_connection_send_msg:\n-            self.send_message(self.on_connection_send_msg)\n+            self.queue_messages.append(self.on_connection_send_msg) if self.supports_v2_p2p else self.send_message(self.on_connection_send_msg)",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 56,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "in_reply_to_id": 1449320797,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "hmm you're right. i used the idea of a queue initially because i liked the abstraction implied by queuing unsent messages to be sent after v2 handshake/reconnection.\r\n\r\nsince `on_connection_send_msg` is always the version message, i've changed the code to work with not clearing `on_connection_send_msg` before v2 handshake/reconnection is complete.",
      "created_at": "2024-01-20T14:25:14Z",
      "updated_at": "2024-01-20T14:25:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467897",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467897"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 220,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468062",
      "pull_request_review_id": 1834682296,
      "id": 1460468062,
      "node_id": "PRRC_kwDOABII585XDPle",
      "diff_hunk": "@@ -159,6 +162,9 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self.v2_state = None  # EncryptedP2PState object needed for v2 p2p connections\n+        self.supports_v2_p2p = False  # set if the connection supports v2 p2p\n+        self.queue_messages = []  # queue messages to send after initial v2 handshake",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 16,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "in_reply_to_id": 1449286884,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "removed this variable as discussed in https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467897.",
      "created_at": "2024-01-20T14:25:34Z",
      "updated_at": "2024-01-20T14:25:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468062",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468098",
      "pull_request_review_id": 1834682305,
      "id": 1460468098,
      "node_id": "PRRC_kwDOABII585XDPmC",
      "diff_hunk": "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 7,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "in_reply_to_id": 1449336950,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2024-01-20T14:25:41Z",
      "updated_at": "2024-01-20T14:25:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468098",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468098"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 237,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468173",
      "pull_request_review_id": 1834682330,
      "id": 1460468173,
      "node_id": "PRRC_kwDOABII585XDPnN",
      "diff_hunk": "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 6,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "in_reply_to_id": 1449337692,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2024-01-20T14:25:52Z",
      "updated_at": "2024-01-20T14:25:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468173",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468173"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468220",
      "pull_request_review_id": 1834682344,
      "id": 1460468220,
      "node_id": "PRRC_kwDOABII585XDPn8",
      "diff_hunk": "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 13,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "in_reply_to_id": 1449340059,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2024-01-20T14:25:58Z",
      "updated_at": "2024-01-20T14:25:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468220",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468220"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468278",
      "pull_request_review_id": 1834682354,
      "id": 1460468278,
      "node_id": "PRRC_kwDOABII585XDPo2",
      "diff_hunk": "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 16,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "in_reply_to_id": 1449352220,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "makes sense! i've changed `respond_handshake` and `complete_handshake` to return length consumed too.",
      "created_at": "2024-01-20T14:26:05Z",
      "updated_at": "2024-01-20T14:26:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468278",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468278"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 246,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468407",
      "pull_request_review_id": 1834682376,
      "id": 1460468407,
      "node_id": "PRRC_kwDOABII585XDPq3",
      "diff_hunk": "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 94,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "in_reply_to_id": 1450866270,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yes! i've simplified the comments. hopefully it's better now?",
      "created_at": "2024-01-20T14:26:14Z",
      "updated_at": "2024-01-20T14:26:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468407",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468407"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 93,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468434",
      "pull_request_review_id": 1834682383,
      "id": 1460468434,
      "node_id": "PRRC_kwDOABII585XDPrS",
      "diff_hunk": "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 56,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "in_reply_to_id": 1450888252,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2024-01-20T14:26:19Z",
      "updated_at": "2024-01-20T14:26:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468434",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468434"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468510",
      "pull_request_review_id": 1834682400,
      "id": 1460468510,
      "node_id": "PRRC_kwDOABII585XDPse",
      "diff_hunk": "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances\n+            else:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly) and node0 - both\n+                # do not get blocks produced by node0's p2p connection if the messages sent are decoys\n+                self.log.info(\"Check if blocks produced by node0's p2p connection sent as decoys aren't received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=False, is_decoy=True) # node0's tip doesn't advance\n+            # Connect node0 and node1 using v2\n+            self.connect_nodes(0, 1, peer_advertises_v2=True)\n+            self.log.info(\"Wait for node1 to receive all the blocks from node0\")\n+            self.sync_all()\n+            self.log.info(\"Make sure node0 and node1 have same block tips\")\n+            assert_equal(node0.getbestblockhash(), node1.getbestblockhash())\n+\n+            self.disconnect_nodes(0, 1)\n+\n+        self.log.info(\"Check the connections opened as expected\")\n+        check_node_connections(node=node0, num_in=4, num_out=2)\n+\n+        self.log.info(\"Check inbound connections to v1 TestNode from v2 P2PConnection is v1\")",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 114,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "in_reply_to_id": 1450888980,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.\r\n\r\n> Also, it may be worth moving this right peer2 so inbounds and outbounds are grouped\r\n\r\ndidn't follow. i've renamed `peer7` to `peer1` since this is first peer in restarted node. is that what you meant?",
      "created_at": "2024-01-20T14:26:27Z",
      "updated_at": "2024-01-20T14:26:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468510",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468510"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462241588",
      "pull_request_review_id": 1829978188,
      "id": 1462241588,
      "node_id": "PRRC_kwDOABII585XKAk0",
      "diff_hunk": "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances\n+            else:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly) and node0 - both\n+                # do not get blocks produced by node0's p2p connection if the messages sent are decoys\n+                self.log.info(\"Check if blocks produced by node0's p2p connection sent as decoys aren't received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=False, is_decoy=True) # node0's tip doesn't advance\n+            # Connect node0 and node1 using v2\n+            self.connect_nodes(0, 1, peer_advertises_v2=True)\n+            self.log.info(\"Wait for node1 to receive all the blocks from node0\")\n+            self.sync_all()\n+            self.log.info(\"Make sure node0 and node1 have same block tips\")\n+            assert_equal(node0.getbestblockhash(), node1.getbestblockhash())\n+\n+            self.disconnect_nodes(0, 1)\n+\n+        self.log.info(\"Check the connections opened as expected\")\n+        check_node_connections(node=node0, num_in=4, num_out=2)\n+\n+        self.log.info(\"Check inbound connections to v1 TestNode from v2 P2PConnection is v1\")",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 114,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "in_reply_to_id": 1450888980,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Sorry, I meant right after peer2, referring to grouping the connections in the test by either inbound or outbound.\r\n\r\npeer1 does v2 **from** v2\r\npeer2 does v2 **from** v1\r\npeer3 does  v2 **to** v1\r\n[...] the rest are all x **to** y\r\nand then peer7 goes back to peer1 does v1 **from** v2\r\n\r\nCertainly not a big deal though\r\n",
      "created_at": "2024-01-22T18:21:01Z",
      "updated_at": "2024-01-23T16:09:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462241588",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462241588"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462341834",
      "pull_request_review_id": 1837243116,
      "id": 1462341834,
      "node_id": "PRRC_kwDOABII585XKZDK",
      "diff_hunk": "@@ -231,12 +231,61 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is the initiator\n+        (in inbound connections to TestNode) and the responder (in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. The rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                # reads ellswift bytes till the first mismatch from 12 bytes V1_PREFIX\n+                length, send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                self.recvbuf = self.recvbuf[length:]\n+                if send_handshake_bytes == -1:\n+                    self.supports_v2_p2p = False",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 22,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "885fac3a13786d873b033c03e51d15e158eff3a7",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "line should be removed now that `supports_v2_p2p` is a property, it would probably throw an AttributeError if it was hit (which it isn't)",
      "created_at": "2024-01-22T19:49:10Z",
      "updated_at": "2024-01-22T20:32:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462341834",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462341834"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462877634",
      "pull_request_review_id": 1838102663,
      "id": 1462877634,
      "node_id": "PRRC_kwDOABII585XMb3C",
      "diff_hunk": "@@ -401,11 +402,16 @@ static RPCHelpMan addconnection()\n     } else {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, self.ToString());\n     }\n+    bool use_v2transport = !request.params[2].isNull() && request.params[2].get_bool();\n \n     NodeContext& node = EnsureAnyNodeContext(request.context);\n     CConnman& connman = EnsureConnman(node);\n \n-    const bool success = connman.AddConnection(address, conn_type);\n+    if (use_v2transport && !(connman.GetLocalServices() & NODE_P2P_V2)) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Error: v2transport requested but not enabled (see -v2transport)\");",
      "path": "src/rpc/net.cpp",
      "position": null,
      "original_position": 30,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "c950386eaaf41ec096606de81a3a60b278b156f0",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c950386eaaf41ec096606de81a3a60b278b156f0\r\nnit: since `v2transport` is named exactly the same in addconnection and as an init flag, perhaps either specify where exactly to see, or have extended description in both places (\"adding v2transport connections requires v2transport init flag to be set.\"). Current version is kinda confusing.",
      "created_at": "2024-01-23T08:20:31Z",
      "updated_at": "2024-01-23T10:40:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462877634",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462877634"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 411,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462899288",
      "pull_request_review_id": 1838102663,
      "id": 1462899288,
      "node_id": "PRRC_kwDOABII585XMhJY",
      "diff_hunk": "@@ -4,17 +4,285 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+        self.found_garbage_terminator = False\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 132,
      "original_position": 131,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9b6425ce0fb74b40e12f92b704a41feec23cd754",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9b6425ce0fb74b40e12f92b704a41feec23cd754\r\nnit: \"at least one byte\" is confusing... what if it's half-a-byte? Sounds like that would be ignored, but i assume it won't be.",
      "created_at": "2024-01-23T08:29:46Z",
      "updated_at": "2024-01-23T10:40:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462899288",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462899288"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 132,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462920200",
      "pull_request_review_id": 1838102663,
      "id": 1462920200,
      "node_id": "PRRC_kwDOABII585XMmQI",
      "diff_hunk": "@@ -4,17 +4,285 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+        self.found_garbage_terminator = False\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        1. int - length of bytes that were consumed so that recvbuf can be updated\n+        2. bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+                 - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+                 - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return len(self.received_prefix), b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 147,
      "original_position": 146,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9b6425ce0fb74b40e12f92b704a41feec23cd754",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9b6425ce0fb74b40e12f92b704a41feec23cd754\r\n\r\nnit: might be cleaner this way\r\n```\r\n        received_prefix_len = 0\r\n        while received_prefix_len < 16:\r\n            byte = response.read(1)\r\n            # return b\"\" if we need to receive more bytes\r\n            if not byte:\r\n                return received_prefix_len, b\"\"\r\n            received_prefix_len += len(byte)\r\n            if byte != v1_prefix[received_prefix_len - 1]:\r\n                return received_prefix_len, self.generate_keypair_and_garbage()\r\n        # return -1 to decide v1 only after all 16 bytes processed\r\n        return received_prefix_len, -1\r\n```",
      "created_at": "2024-01-23T08:47:04Z",
      "updated_at": "2024-01-23T10:40:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462920200",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462920200"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462949568",
      "pull_request_review_id": 1838102663,
      "id": 1462949568,
      "node_id": "PRRC_kwDOABII585XMtbA",
      "diff_hunk": "@@ -296,23 +297,49 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 30,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9a2050275573eae31c5dc14fefedb612e951d0b8",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9a2050275573eae31c5dc14fefedb612e951d0b8\r\n\r\ndo you mind adding a comment for what happened here?",
      "created_at": "2024-01-23T09:10:36Z",
      "updated_at": "2024-01-23T10:40:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462949568",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462949568"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 301,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462953624",
      "pull_request_review_id": 1838102663,
      "id": 1462953624,
      "node_id": "PRRC_kwDOABII585XMuaY",
      "diff_hunk": "@@ -296,23 +297,49 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+\n+                    # v2 P2P messages are read\n+                    msglen, msg = self.v2_state.v2_receive_packet(self.recvbuf)\n+                    if msglen == -1:\n+                        raise ValueError(\"invalid v2 mac tag \" + repr(self.recvbuf))\n+                    elif msglen == 0:  # need to receive more bytes in recvbuf\n+                        return\n+                    self.recvbuf = self.recvbuf[msglen:]\n+\n+                    assert msg  # application layer messages(which aren't decoy messages) are non-empty\n+                    shortid = msg[0]\n+                    if shortid == 0:\n+                        # a string command",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 44,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9a2050275573eae31c5dc14fefedb612e951d0b8",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "what does this mean?",
      "created_at": "2024-01-23T09:13:37Z",
      "updated_at": "2024-01-23T10:40:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462953624",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462953624"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 315,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462964155",
      "pull_request_review_id": 1838102663,
      "id": 1462964155,
      "node_id": "PRRC_kwDOABII585XMw-7",
      "diff_hunk": "@@ -221,14 +223,15 @@ def connection_made(self, transport):\n         if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n             send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n             self.send_raw_message(send_handshake_bytes)\n-        if self.on_connection_send_msg and not self.supports_v2_p2p:\n+        if self.on_connection_send_msg and not self.supports_v2_p2p and not self.reconnect:",
      "path": "test/functional/test_framework/p2p.py",
      "position": 91,
      "original_position": 24,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "125e24a9402950c395fad11ef800be49e6a37589",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "why `on_connection_send_msg` is not sent here on reconnect (the new condition)?",
      "created_at": "2024-01-23T09:21:31Z",
      "updated_at": "2024-01-23T10:40:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462964155",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462964155"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 228,
      "original_line": 228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463495866",
      "pull_request_review_id": 1829978188,
      "id": 1463495866,
      "node_id": "PRRC_kwDOABII585XOyy6",
      "diff_hunk": "@@ -205,27 +218,82 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n-        if self.on_connection_send_msg:\n+        # in an inbound connection to the TestNode with P2PConnection as the initiator, [TestNode <---- P2PConnection]\n+        # the initial handshake is sent immediately\n+        if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n+            send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n+            self.send_raw_message(send_handshake_bytes)\n+        if self.on_connection_send_msg and not self.supports_v2_p2p and not self.reconnect:\n             self.send_message(self.on_connection_send_msg)\n             self.on_connection_send_msg = None  # Never used again\n         self.on_open()\n \n     def connection_lost(self, exc):\n         \"\"\"asyncio callback when a connection is closed.\"\"\"\n-        if exc:\n+        # don't display warning if reconnection needs to be attempted using v1 P2P\n+        if exc and not self.reconnect:\n             logger.warning(\"Connection lost to {}:{} due to {}\".format(self.dstaddr, self.dstport, exc))\n         else:\n             logger.debug(\"Closed connection to: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = None\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is the initiator\n+        (in inbound connections to TestNode) and the responder (in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. The rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                # reads ellswift bytes till the first mismatch from 12 bytes V1_PREFIX\n+                length, send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                self.recvbuf = self.recvbuf[length:]\n+                if send_handshake_bytes == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif send_handshake_bytes:\n+                    self.send_raw_message(send_handshake_bytes)\n+                elif send_handshake_bytes == b\"\":\n+                    return  # only after send_handshake_bytes are sent can `complete_handshake()` be done\n+\n+            # `complete_handshake()` reads the remaining ellswift bytes from recvbuf\n+            # and sends response after deriving shared ECDH secret using received ellswift bytes\n+            length, response = self.v2_state.complete_handshake(BytesIO(self.recvbuf))\n+            self.recvbuf = self.recvbuf[length:]\n+            if response:\n+                self.send_raw_message(response)\n+            else:\n+                return  # only after response is sent can `authenticate_handshake()` be done\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        assert self.v2_state.peer\n+        length, is_mac_auth = self.v2_state.authenticate_handshake(self.recvbuf)\n+        if not is_mac_auth:\n+            raise ValueError(\"invalid v2 mac tag in handshake authentication\")\n+        self.recvbuf = self.recvbuf[length:]\n+        if self.v2_state.tried_v2_handshake and self.on_connection_send_msg:\n+            self.send_message(self.on_connection_send_msg)\n+            self.on_connection_send_msg = None\n+\n     # Socket read methods\n \n     def data_received(self, t):\n         \"\"\"asyncio callback when data is read from the socket.\"\"\"\n         if len(t) > 0:\n             self.recvbuf += t\n+            if self.supports_v2_p2p and not self.v2_state.tried_v2_handshake:",
      "path": "test/functional/test_framework/p2p.py",
      "position": 161,
      "original_position": 159,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I wonder if it'd be worth also checking that `len(self.recvbuf) > 15` to avoid calling `v2_handshake` when we potentially don't have enough data to decide whether this a v1 or v2 connection. This potentially will call `v2_handshake` 16 times, and process byte arrays of length from 1..16.\r\n\r\nIn practice I don't think this matters, given the logic never triggers: this happens when the python node is the responder, and the Core node will never send a half-baked `magic_bytes + version` (it may partially happen randomly, but its rather unlikely).\r\n\r\nStill, it feels a small enough change in case this ends up being reused.\r\n",
      "created_at": "2024-01-23T15:46:30Z",
      "updated_at": "2024-01-23T16:20:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1463495866",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463495866"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 296,
      "original_line": 296,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463533897",
      "pull_request_review_id": 1839218378,
      "id": 1463533897,
      "node_id": "PRRC_kwDOABII585XO8FJ",
      "diff_hunk": "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 94,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "in_reply_to_id": 1450866270,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes! This reads much clearer now :)",
      "created_at": "2024-01-23T16:11:35Z",
      "updated_at": "2024-01-23T16:11:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1463533897",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463533897"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 93,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463600444",
      "pull_request_review_id": 1839322405,
      "id": 1463600444,
      "node_id": "PRRC_kwDOABII585XPMU8",
      "diff_hunk": "@@ -4,17 +4,285 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+        self.found_garbage_terminator = False\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 132,
      "original_position": 131,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9b6425ce0fb74b40e12f92b704a41feec23cd754",
      "in_reply_to_id": 1462899288,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i took the [text from the BIP](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#cite_note-handshake_progress_19) here. On the python side, [`data_received()` asyncio function](https://docs.python.org/3/library/asyncio-protocol.html#asyncio.Protocol.data_received) only gets called when a bytes object is received.\r\n\r\n(thinking about the c++ side)",
      "created_at": "2024-01-23T16:43:44Z",
      "updated_at": "2024-01-23T16:43:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1463600444",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463600444"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 132,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463620264",
      "pull_request_review_id": 1839354213,
      "id": 1463620264,
      "node_id": "PRRC_kwDOABII585XPRKo",
      "diff_hunk": "@@ -4,17 +4,285 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+        self.found_garbage_terminator = False\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        1. int - length of bytes that were consumed so that recvbuf can be updated\n+        2. bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+                 - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+                 - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return len(self.received_prefix), b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 147,
      "original_position": 146,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9b6425ce0fb74b40e12f92b704a41feec23cd754",
      "in_reply_to_id": 1462920200,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`respond_v2_handshake()` is supposed keep reading bytes from `bitcoind` and shoot out ellswift bytes when first mismatch from 16 bytes `V1_PREFIX` happens. Let's say the mismatch happens after reading 3 bytes - we still need to store the 3 bytes read somewhere (currently stored in `self.received_prefix`) since it's actually the first 3 bytes of ellswift which `bitcoind` was sending us.\r\n\r\nwe need this 3 bytes later in `complete_handshake()` to read the remaining 64-3 bytes and to compute ellswift which bitcoind sent us. ",
      "created_at": "2024-01-23T16:55:01Z",
      "updated_at": "2024-01-23T16:55:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1463620264",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463620264"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464318846",
      "pull_request_review_id": 1840432934,
      "id": 1464318846,
      "node_id": "PRRC_kwDOABII585XR7t-",
      "diff_hunk": "@@ -221,14 +223,15 @@ def connection_made(self, transport):\n         if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n             send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n             self.send_raw_message(send_handshake_bytes)\n-        if self.on_connection_send_msg and not self.supports_v2_p2p:\n+        if self.on_connection_send_msg and not self.supports_v2_p2p and not self.reconnect:",
      "path": "test/functional/test_framework/p2p.py",
      "position": 91,
      "original_position": 24,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "125e24a9402950c395fad11ef800be49e6a37589",
      "in_reply_to_id": 1462964155,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "(originally because `on_connection_send_msg` would be end up being unused in v2 connection anyways and wanted to keep the `on_connection_send_msg` send during the v1 reconnection phase.)\r\n\r\ninteresting question! you're talking about a less common scenario where initiator node is preparing for v2 connection thinking responder node is v2 but v1 version message from responder node gets sent before v2 ellswift bytes from initiator node. if this happens the initiator node wouldn't attempt a reconnection using v1 since it's [receive buffer is not empty](https://github.com/bitcoin/bitcoin/blob/e69796c79c0aa202087a13ba62d9fbcc1c8754d4/src/net.cpp#L1525).",
      "created_at": "2024-01-24T05:17:01Z",
      "updated_at": "2024-01-24T05:17:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464318846",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464318846"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 228,
      "original_line": 228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464356180",
      "pull_request_review_id": 1840489048,
      "id": 1464356180,
      "node_id": "PRRC_kwDOABII585XSE1U",
      "diff_hunk": "@@ -205,27 +218,82 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n-        if self.on_connection_send_msg:\n+        # in an inbound connection to the TestNode with P2PConnection as the initiator, [TestNode <---- P2PConnection]\n+        # the initial handshake is sent immediately\n+        if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n+            send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n+            self.send_raw_message(send_handshake_bytes)\n+        if self.on_connection_send_msg and not self.supports_v2_p2p and not self.reconnect:\n             self.send_message(self.on_connection_send_msg)\n             self.on_connection_send_msg = None  # Never used again\n         self.on_open()\n \n     def connection_lost(self, exc):\n         \"\"\"asyncio callback when a connection is closed.\"\"\"\n-        if exc:\n+        # don't display warning if reconnection needs to be attempted using v1 P2P\n+        if exc and not self.reconnect:\n             logger.warning(\"Connection lost to {}:{} due to {}\".format(self.dstaddr, self.dstport, exc))\n         else:\n             logger.debug(\"Closed connection to: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = None\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is the initiator\n+        (in inbound connections to TestNode) and the responder (in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. The rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                # reads ellswift bytes till the first mismatch from 12 bytes V1_PREFIX\n+                length, send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                self.recvbuf = self.recvbuf[length:]\n+                if send_handshake_bytes == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif send_handshake_bytes:\n+                    self.send_raw_message(send_handshake_bytes)\n+                elif send_handshake_bytes == b\"\":\n+                    return  # only after send_handshake_bytes are sent can `complete_handshake()` be done\n+\n+            # `complete_handshake()` reads the remaining ellswift bytes from recvbuf\n+            # and sends response after deriving shared ECDH secret using received ellswift bytes\n+            length, response = self.v2_state.complete_handshake(BytesIO(self.recvbuf))\n+            self.recvbuf = self.recvbuf[length:]\n+            if response:\n+                self.send_raw_message(response)\n+            else:\n+                return  # only after response is sent can `authenticate_handshake()` be done\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        assert self.v2_state.peer\n+        length, is_mac_auth = self.v2_state.authenticate_handshake(self.recvbuf)\n+        if not is_mac_auth:\n+            raise ValueError(\"invalid v2 mac tag in handshake authentication\")\n+        self.recvbuf = self.recvbuf[length:]\n+        if self.v2_state.tried_v2_handshake and self.on_connection_send_msg:\n+            self.send_message(self.on_connection_send_msg)\n+            self.on_connection_send_msg = None\n+\n     # Socket read methods\n \n     def data_received(self, t):\n         \"\"\"asyncio callback when data is read from the socket.\"\"\"\n         if len(t) > 0:\n             self.recvbuf += t\n+            if self.supports_v2_p2p and not self.v2_state.tried_v2_handshake:",
      "path": "test/functional/test_framework/p2p.py",
      "position": 161,
      "original_position": 159,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "in_reply_to_id": 1463495866,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "hmm other than the ellswift bytes, `v2_handshake()` also needs to read garbage bytes (could be received as separate chunks with size < 16 bytes) and other things like garbage terminator, decoy messages and version packet. i'm leaning towards keeping the interface generic and processing as we receive bytes.",
      "created_at": "2024-01-24T06:19:46Z",
      "updated_at": "2024-01-24T06:19:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464356180",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464356180"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 296,
      "original_line": 296,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464363550",
      "pull_request_review_id": 1840500869,
      "id": 1464363550,
      "node_id": "PRRC_kwDOABII585XSGoe",
      "diff_hunk": "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances\n+            else:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly) and node0 - both\n+                # do not get blocks produced by node0's p2p connection if the messages sent are decoys\n+                self.log.info(\"Check if blocks produced by node0's p2p connection sent as decoys aren't received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=False, is_decoy=True) # node0's tip doesn't advance\n+            # Connect node0 and node1 using v2\n+            self.connect_nodes(0, 1, peer_advertises_v2=True)\n+            self.log.info(\"Wait for node1 to receive all the blocks from node0\")\n+            self.sync_all()\n+            self.log.info(\"Make sure node0 and node1 have same block tips\")\n+            assert_equal(node0.getbestblockhash(), node1.getbestblockhash())\n+\n+            self.disconnect_nodes(0, 1)\n+\n+        self.log.info(\"Check the connections opened as expected\")\n+        check_node_connections(node=node0, num_in=4, num_out=2)\n+\n+        self.log.info(\"Check inbound connections to v1 TestNode from v2 P2PConnection is v1\")",
      "path": "test/functional/p2p_v2_encrypted.py",
      "position": null,
      "original_position": 114,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "in_reply_to_id": 1450888980,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "oh that way! the last test was for v1 behaviour and peer7 needed a v1 `TestNode` while all the others needed a v2 `TestNode` which is why it was kept separately in the end.",
      "created_at": "2024-01-24T06:30:41Z",
      "updated_at": "2024-01-24T06:30:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464363550",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464363550"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464367456",
      "pull_request_review_id": 1840508287,
      "id": 1464367456,
      "node_id": "PRRC_kwDOABII585XSHlg",
      "diff_hunk": "@@ -231,12 +231,61 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is the initiator\n+        (in inbound connections to TestNode) and the responder (in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. The rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                # reads ellswift bytes till the first mismatch from 12 bytes V1_PREFIX\n+                length, send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                self.recvbuf = self.recvbuf[length:]\n+                if send_handshake_bytes == -1:\n+                    self.supports_v2_p2p = False",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 22,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "885fac3a13786d873b033c03e51d15e158eff3a7",
      "in_reply_to_id": 1462341834,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "good catch! done.",
      "created_at": "2024-01-24T06:35:35Z",
      "updated_at": "2024-01-24T06:35:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464367456",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464367456"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464367790",
      "pull_request_review_id": 1840508851,
      "id": 1464367790,
      "node_id": "PRRC_kwDOABII585XSHqu",
      "diff_hunk": "@@ -401,11 +402,16 @@ static RPCHelpMan addconnection()\n     } else {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, self.ToString());\n     }\n+    bool use_v2transport = !request.params[2].isNull() && request.params[2].get_bool();\n \n     NodeContext& node = EnsureAnyNodeContext(request.context);\n     CConnman& connman = EnsureConnman(node);\n \n-    const bool success = connman.AddConnection(address, conn_type);\n+    if (use_v2transport && !(connman.GetLocalServices() & NODE_P2P_V2)) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Error: v2transport requested but not enabled (see -v2transport)\");",
      "path": "src/rpc/net.cpp",
      "position": null,
      "original_position": 30,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "c950386eaaf41ec096606de81a3a60b278b156f0",
      "in_reply_to_id": 1462877634,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done. liked the simpler language.",
      "created_at": "2024-01-24T06:36:07Z",
      "updated_at": "2024-01-24T06:36:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464367790",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464367790"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 411,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464368898",
      "pull_request_review_id": 1840510614,
      "id": 1464368898,
      "node_id": "PRRC_kwDOABII585XSH8C",
      "diff_hunk": "@@ -296,23 +297,49 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 30,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9a2050275573eae31c5dc14fefedb612e951d0b8",
      "in_reply_to_id": 1462949568,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "good find! replaced it with an `else` pathway in `data_received()`. this was kept to not perform parsing/deserialising of P2P messages inside `_on_data()` in case `v2_handshake()` wasn't over.\r\n\r\ndone.",
      "created_at": "2024-01-24T06:37:42Z",
      "updated_at": "2024-01-24T06:37:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464368898",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464368898"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 301,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464371637",
      "pull_request_review_id": 1840515494,
      "id": 1464371637,
      "node_id": "PRRC_kwDOABII585XSIm1",
      "diff_hunk": "@@ -296,23 +297,49 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+\n+                    # v2 P2P messages are read\n+                    msglen, msg = self.v2_state.v2_receive_packet(self.recvbuf)\n+                    if msglen == -1:\n+                        raise ValueError(\"invalid v2 mac tag \" + repr(self.recvbuf))\n+                    elif msglen == 0:  # need to receive more bytes in recvbuf\n+                        return\n+                    self.recvbuf = self.recvbuf[msglen:]\n+\n+                    assert msg  # application layer messages(which aren't decoy messages) are non-empty\n+                    shortid = msg[0]\n+                    if shortid == 0:\n+                        # a string command",
      "path": "test/functional/test_framework/p2p.py",
      "position": null,
      "original_position": 44,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9a2050275573eae31c5dc14fefedb612e951d0b8",
      "in_reply_to_id": 1462953624,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "added more comments. meant it as the [ASCII message type](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#v2-bitcoin-p2p-message-structure) like in v1.",
      "created_at": "2024-01-24T06:40:40Z",
      "updated_at": "2024-01-24T06:40:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464371637",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464371637"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 315,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464372562",
      "pull_request_review_id": 1840517253,
      "id": 1464372562,
      "node_id": "PRRC_kwDOABII585XSI1S",
      "diff_hunk": "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n+    @staticmethod\n+    def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n+        ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+        if initiating:\n+            # Initiating, place our public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+        else:\n+            # Responding, place their public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 218,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "in_reply_to_id": 1457621863,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "true! removed.",
      "created_at": "2024-01-24T06:41:26Z",
      "updated_at": "2024-01-24T06:41:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464372562",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464372562"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": 217,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464372887",
      "pull_request_review_id": 1840517782,
      "id": 1464372887,
      "node_id": "PRRC_kwDOABII585XSI6X",
      "diff_hunk": "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n+    @staticmethod\n+    def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n+        ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+        if initiating:\n+            # Initiating, place our public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+        else:\n+            # Responding, place their public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": null,
      "original_position": 222,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "in_reply_to_id": 1457652467,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nice! done.",
      "created_at": "2024-01-24T06:41:56Z",
      "updated_at": "2024-01-24T06:41:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464372887",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464372887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464375410",
      "pull_request_review_id": 1840522719,
      "id": 1464375410,
      "node_id": "PRRC_kwDOABII585XSJhy",
      "diff_hunk": "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 87,
      "original_position": 87,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "in_reply_to_id": 1457677043,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "right, not much of a difference - leaving it as a follow up if desired.",
      "created_at": "2024-01-24T06:45:25Z",
      "updated_at": "2024-01-24T06:45:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464375410",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464375410"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 87,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464497339",
      "pull_request_review_id": 1840726898,
      "id": 1464497339,
      "node_id": "PRRC_kwDOABII585XSnS7",
      "diff_hunk": "@@ -221,14 +223,15 @@ def connection_made(self, transport):\n         if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n             send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n             self.send_raw_message(send_handshake_bytes)\n-        if self.on_connection_send_msg and not self.supports_v2_p2p:\n+        if self.on_connection_send_msg and not self.supports_v2_p2p and not self.reconnect:",
      "path": "test/functional/test_framework/p2p.py",
      "position": 91,
      "original_position": 24,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "125e24a9402950c395fad11ef800be49e6a37589",
      "in_reply_to_id": 1462964155,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think it deserves a comment :)",
      "created_at": "2024-01-24T08:20:50Z",
      "updated_at": "2024-01-24T08:20:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464497339",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464497339"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 228,
      "original_line": 228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464515415",
      "pull_request_review_id": 1840754152,
      "id": 1464515415,
      "node_id": "PRRC_kwDOABII585XSrtX",
      "diff_hunk": "@@ -0,0 +1,85 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import random\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.v2_p2p import EncryptedP2PState\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):",
      "path": "test/functional/p2p_v2_earlykeyresponse.py",
      "position": 14,
      "original_position": 14,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The goal of this class is mostly to test the tests, right? Commenting that more clearly could help.",
      "created_at": "2024-01-24T08:36:25Z",
      "updated_at": "2024-01-24T08:36:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464515415",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464515415"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 14,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464523738",
      "pull_request_review_id": 1840768056,
      "id": 1464523738,
      "node_id": "PRRC_kwDOABII585XStva",
      "diff_hunk": "@@ -0,0 +1,85 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import random\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.v2_p2p import EncryptedP2PState\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Custom implementation of class EncryptedP2PState for testing purposes:\n+\n+    - if `send_net_magic` is True, send first 4 bytes of ellswift(match network magic) else send remaining 60 bytes\n+    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+              This state is represented using `can_data_be_received` = False.\n+            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+              This state is represented using `can_data_be_received` = True.\n+    \"\"\"\n+\n+    def __init__(self):\n+        super().__init__(initiating=True, net='regtest')\n+        self.send_net_magic = True\n+        self.can_data_be_received = False\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage.\n+        Here, the 64 bytes ellswift is assumed to have it's 4 bytes match network magic bytes. It is sent in 2 phases:\n+            1. when `send_network_magic` = True, send first 4 bytes of ellswift (matches network magic bytes)\n+            2. when `send_network_magic` = False, send remaining 60 bytes of ellswift\n+        \"\"\"\n+        if self.send_net_magic:\n+            self.privkey_ours, self.ellswift_ours = ellswift_create()\n+            self.sent_garbage = random.randbytes(garbage_len)\n+            self.send_net_magic = False\n+            return b\"\\xfa\\xbf\\xb5\\xda\"\n+        else:\n+            self.can_data_be_received = True\n+            return self.ellswift_ours[4:] + self.sent_garbage\n+\n+\n+class PeerEarlyKey(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.v2_state = None\n+\n+    def connection_made(self, transport):\n+        \"\"\"Custom implementation so that 64 bytes ellswift is sent in 2 parts during `initial_v2_handshake()`\"\"\"\n+        self.v2_state = TestEncryptedP2PState()\n+        super().connection_made(transport)\n+\n+    def data_received(self, t):\n+        # check that data can be received on recvbuf only when mismatch from V1_PREFIX happens (send_net_magic = False)\n+        assert self.v2_state.can_data_be_received and not self.v2_state.send_net_magic\n+\n+\n+class P2PEarlyKey(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[\"-v2transport=1\", \"-peertimeout=3\"]]\n+\n+    def run_test(self):\n+        # testing BIP 324 \"The responder waits until one byte is received which does not match the 16 bytes\n+        # consisting of the network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\".\"\n+        self.log.info('Sending ellswift bytes in parts to ensure that response from responder is received only when')\n+        self.log.info('ellswift bytes have a mismatch from the 16 bytes(network magic followed by \"version\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\")')\n+        node0 = self.nodes[0]\n+        self.log.info('Sending first 4 bytes of ellswift which match network magic')\n+        self.log.info('If a response is received, assertion failure would happen in our custom data_received() function')\n+        # send happens in `initiate_v2_handshake()` in `connection_made()`\n+        peer1 = node0.add_p2p_connection(PeerEarlyKey(), wait_for_verack=False, send_version=False, supports_v2_p2p=True)\n+        self.log.info('Sending remaining ellswift and garbage which are different from V1_PREFIX. Since a response is')\n+        self.log.info('expected now, our custom data_received() function wouldn\\'t result in assertion failure')\n+        ellswift_and_garbage_data = peer1.v2_state.initiate_v2_handshake()\n+        peer1.send_raw_message(ellswift_and_garbage_data)\n+        peer1.wait_for_disconnect(timeout=5)\n+        self.log.info('successful disconnection when MITM happens in the key exchange phase')",
      "path": "test/functional/p2p_v2_earlykeyresponse.py",
      "position": 81,
      "original_position": 81,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This comes unexpectedly. This is merely an unintentional side-effect of saving LOC in this test, right?",
      "created_at": "2024-01-24T08:41:23Z",
      "updated_at": "2024-01-29T09:49:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464523738",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464523738"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 81,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464954826",
      "pull_request_review_id": 1841443007,
      "id": 1464954826,
      "node_id": "PRRC_kwDOABII585XUW_K",
      "diff_hunk": "@@ -4,17 +4,285 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+        self.found_garbage_terminator = False\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 132,
      "original_position": 131,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "9b6425ce0fb74b40e12f92b704a41feec23cd754",
      "in_reply_to_id": 1462899288,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "TCP/IP presents a stream interface that sends/receives bytes. You can only receive multiples of bytes.",
      "created_at": "2024-01-24T13:58:43Z",
      "updated_at": "2024-01-24T13:58:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464954826",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464954826"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 132,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1465420112",
      "pull_request_review_id": 1842169651,
      "id": 1465420112,
      "node_id": "PRRC_kwDOABII585XWIlQ",
      "diff_hunk": "@@ -221,14 +223,15 @@ def connection_made(self, transport):\n         if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n             send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n             self.send_raw_message(send_handshake_bytes)\n-        if self.on_connection_send_msg and not self.supports_v2_p2p:\n+        if self.on_connection_send_msg and not self.supports_v2_p2p and not self.reconnect:",
      "path": "test/functional/test_framework/p2p.py",
      "position": 91,
      "original_position": 24,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "125e24a9402950c395fad11ef800be49e6a37589",
      "in_reply_to_id": 1462964155,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The python code only supports the \"reconnection\" use case in one direction: TestNode connects to the P2PConnection with v2, and reconnects with v1 without anything breaking (e.g. timeouts) on the python side. The reverse direction (P2PConnection actively does reconnections itself for outgoing connections) is not supported and I don't think it needs to be. So P2PConnection is receiving an inbound connection, and here it must wait to send `on_connection_send_msg` with sending until the version is received so it doesn't send it out in the v2 attempt. Maybe a comment could just point that in the reconnection case, `on_connection_send_msg` is sent in `on_version`, not here.\r\n\r\nI don't understand why in the existing v1 master code, the test framework, when receiving an inbound connection, sends out the version message in `connection_made` instead of doing it in `on_version` (similar to the way it is done in bitcoind, see [here](https://github.com/bitcoin/bitcoin/blob/207220ce8b767d8efdb5abf042ecf23d846ded73/src/net_processing.cpp#L3429-L3432)). After all, the usual protocol is that the initiator sends its version, and the responder processes it and responds. But that is unrelated to this PR.",
      "created_at": "2024-01-24T19:07:24Z",
      "updated_at": "2024-01-24T19:07:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1465420112",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1465420112"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 228,
      "original_line": 228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1465595068",
      "pull_request_review_id": 1842470647,
      "id": 1465595068,
      "node_id": "PRRC_kwDOABII585XWzS8",
      "diff_hunk": "@@ -205,27 +218,82 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n-        if self.on_connection_send_msg:\n+        # in an inbound connection to the TestNode with P2PConnection as the initiator, [TestNode <---- P2PConnection]\n+        # the initial handshake is sent immediately\n+        if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n+            send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n+            self.send_raw_message(send_handshake_bytes)\n+        if self.on_connection_send_msg and not self.supports_v2_p2p and not self.reconnect:\n             self.send_message(self.on_connection_send_msg)\n             self.on_connection_send_msg = None  # Never used again\n         self.on_open()\n \n     def connection_lost(self, exc):\n         \"\"\"asyncio callback when a connection is closed.\"\"\"\n-        if exc:\n+        # don't display warning if reconnection needs to be attempted using v1 P2P\n+        if exc and not self.reconnect:\n             logger.warning(\"Connection lost to {}:{} due to {}\".format(self.dstaddr, self.dstport, exc))\n         else:\n             logger.debug(\"Closed connection to: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = None\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is the initiator\n+        (in inbound connections to TestNode) and the responder (in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. The rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                # reads ellswift bytes till the first mismatch from 12 bytes V1_PREFIX\n+                length, send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                self.recvbuf = self.recvbuf[length:]\n+                if send_handshake_bytes == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif send_handshake_bytes:\n+                    self.send_raw_message(send_handshake_bytes)\n+                elif send_handshake_bytes == b\"\":\n+                    return  # only after send_handshake_bytes are sent can `complete_handshake()` be done\n+\n+            # `complete_handshake()` reads the remaining ellswift bytes from recvbuf\n+            # and sends response after deriving shared ECDH secret using received ellswift bytes\n+            length, response = self.v2_state.complete_handshake(BytesIO(self.recvbuf))\n+            self.recvbuf = self.recvbuf[length:]\n+            if response:\n+                self.send_raw_message(response)\n+            else:\n+                return  # only after response is sent can `authenticate_handshake()` be done\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        assert self.v2_state.peer\n+        length, is_mac_auth = self.v2_state.authenticate_handshake(self.recvbuf)\n+        if not is_mac_auth:\n+            raise ValueError(\"invalid v2 mac tag in handshake authentication\")\n+        self.recvbuf = self.recvbuf[length:]\n+        if self.v2_state.tried_v2_handshake and self.on_connection_send_msg:\n+            self.send_message(self.on_connection_send_msg)\n+            self.on_connection_send_msg = None\n+\n     # Socket read methods\n \n     def data_received(self, t):\n         \"\"\"asyncio callback when data is read from the socket.\"\"\"\n         if len(t) > 0:\n             self.recvbuf += t\n+            if self.supports_v2_p2p and not self.v2_state.tried_v2_handshake:",
      "path": "test/functional/test_framework/p2p.py",
      "position": 161,
      "original_position": 159,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "in_reply_to_id": 1463495866,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Oh, I thought the `recvbuf` was a growing-only buffer that was not cleared until the handshake was over.",
      "created_at": "2024-01-24T22:04:01Z",
      "updated_at": "2024-01-24T22:04:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1465595068",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1465595068"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 296,
      "original_line": 296,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1465874369",
      "pull_request_review_id": 1842886929,
      "id": 1465874369,
      "node_id": "PRRC_kwDOABII585XX3fB",
      "diff_hunk": "@@ -221,14 +223,15 @@ def connection_made(self, transport):\n         if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n             send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n             self.send_raw_message(send_handshake_bytes)\n-        if self.on_connection_send_msg and not self.supports_v2_p2p:\n+        if self.on_connection_send_msg and not self.supports_v2_p2p and not self.reconnect:",
      "path": "test/functional/test_framework/p2p.py",
      "position": 91,
      "original_position": 24,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "125e24a9402950c395fad11ef800be49e6a37589",
      "in_reply_to_id": 1462964155,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> The reverse direction (P2PConnection actively does reconnections itself for outgoing connections) is not supported and I don't think it needs to be.\r\n\r\n+1 since we only really care if TestNode/bitcoind (and not P2PConnection) does reconnection logic.\r\n\r\n> I don't understand why in the existing v1 master code, the test framework, when receiving an inbound connection, sends out the version message in connection_made instead of doing it in on_version (similar to the way it is done in bitcoind, see [here](https://github.com/bitcoin/bitcoin/blob/207220ce8b767d8efdb5abf042ecf23d846ded73/src/net_processing.cpp#L3429-L3432)). After all, the usual protocol is that the initiator sends its version, and the responder processes it and responds. But that is unrelated to this PR.\r\n\r\ni guess support for P2PConnection receiving an inbound connection/TestNode initiating outbound connections was only added later in the test framework when `addconnection` RPC was introduced. Also the concept of who's initiating wasn't relevant until now and we don't have access to that information in the inside functions.\r\n\r\nmaybe we can move [`initiating`](https://github.com/bitcoin/bitcoin/blob/fa4d9d5b39d5652de1d83564f19b1a0749863b16/test/functional/test_framework/v2_p2p.py#L67) from `class EncryptedP2PState` to `class P2PConnection` instead.\r\n\r\n(EDIT: added a comment [here](https://github.com/bitcoin/bitcoin/compare/fa4d9d5b39d5652de1d83564f19b1a0749863b16..bc9283c4415a932ec1eeb70ca2aa4399c80437b3))",
      "created_at": "2024-01-25T05:53:31Z",
      "updated_at": "2024-01-25T05:55:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1465874369",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1465874369"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 228,
      "original_line": 228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1465875760",
      "pull_request_review_id": 1842889063,
      "id": 1465875760,
      "node_id": "PRRC_kwDOABII585XX30w",
      "diff_hunk": "@@ -0,0 +1,85 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import random\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.v2_p2p import EncryptedP2PState\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):",
      "path": "test/functional/p2p_v2_earlykeyresponse.py",
      "position": 14,
      "original_position": 14,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "in_reply_to_id": 1464515415,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2024-01-25T05:55:57Z",
      "updated_at": "2024-01-25T05:55:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1465875760",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1465875760"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 14,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1466826427",
      "pull_request_review_id": 1844474487,
      "id": 1466826427,
      "node_id": "PRRC_kwDOABII585Xbf67",
      "diff_hunk": "@@ -4,17 +4,281 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+        self.found_garbage_terminator = False\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 119,
      "original_position": 118,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "b89fa59e715a185d9fa7fce089dad4273d3b1532",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: not a big deal, but I feel this message would fit more to the call-site, when the garbage is actually passed to the transport layer (before `.send_raw_message()`).",
      "created_at": "2024-01-25T19:25:49Z",
      "updated_at": "2024-01-25T21:34:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1466826427",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1466826427"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 119,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1466950294",
      "pull_request_review_id": 1844474487,
      "id": 1466950294,
      "node_id": "PRRC_kwDOABII585Xb-KW",
      "diff_hunk": "@@ -4,17 +4,281 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 87,
      "original_position": 85,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "b89fa59e715a185d9fa7fce089dad4273d3b1532",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: the name `self.peer` doesn't say a lot, maybe something like `self.key_material` would be more descriptive? (though it's strictly speaking more than that, as it contains also stuff derived from the keys like garbage terminators and session id)",
      "created_at": "2024-01-25T20:54:13Z",
      "updated_at": "2024-01-25T21:34:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1466950294",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1466950294"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 87,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1466958424",
      "pull_request_review_id": 1844474487,
      "id": 1466958424,
      "node_id": "PRRC_kwDOABII585XcAJY",
      "diff_hunk": "@@ -232,13 +232,62 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):",
      "path": "test/functional/test_framework/p2p.py",
      "position": 109,
      "original_position": 5,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "05bddb20f5cc9036fd680500bde8ece70dbf0646",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could name this method in a way that it's more obvious that this is called in the asyncio callback context, e.g. `_on_data_v2_handshake`.",
      "created_at": "2024-01-25T21:03:54Z",
      "updated_at": "2024-01-25T21:34:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1466958424",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1466958424"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 245,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1466979708",
      "pull_request_review_id": 1844474487,
      "id": 1466979708,
      "node_id": "PRRC_kwDOABII585XcFV8",
      "diff_hunk": "@@ -590,6 +590,13 @@ def wait_for_disconnect(self, timeout=60):\n         test_function = lambda: not self.is_connected\n         self.wait_until(test_function, timeout=timeout, check_connected=False)\n \n+    def wait_for_reconnect(self, timeout=60):\n+        def test_function():\n+            if not (self.is_connected and self.last_message.get('version') and self.v2_state is None):\n+                return False\n+            return True",
      "path": "test/functional/test_framework/p2p.py",
      "position": 325,
      "original_position": 8,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "ffe6a56d75c0b47d0729e4e0b7225a827b43ad89",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: a bit shorter\r\n```suggestion\r\n            return self.is_connected and self.last_message.get('version') and not self.supports_v2_p2p\r\n```",
      "created_at": "2024-01-25T21:27:33Z",
      "updated_at": "2024-01-25T21:34:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1466979708",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1466979708"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": 595,
      "original_start_line": 595,
      "start_side": "RIGHT",
      "line": 597,
      "original_line": 597,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1467027522",
      "pull_request_review_id": 1844785543,
      "id": 1467027522,
      "node_id": "PRRC_kwDOABII585XcRBC",
      "diff_hunk": "@@ -4,17 +4,281 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 87,
      "original_position": 85,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "b89fa59e715a185d9fa7fce089dad4273d3b1532",
      "in_reply_to_id": 1466950294,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think this comes straight from BIP324 pseudocode: https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#keys-and-session-id-derivation",
      "created_at": "2024-01-25T22:25:49Z",
      "updated_at": "2024-01-25T22:25:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1467027522",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1467027522"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 87,
      "original_line": 87,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1468498323",
      "pull_request_review_id": 1847099240,
      "id": 1468498323,
      "node_id": "PRRC_kwDOABII585Xh4GT",
      "diff_hunk": "@@ -163,6 +163,7 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self._send_lock = threading.Lock()",
      "path": "test/functional/test_framework/p2p.py",
      "position": 40,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "bc26a862b06257ce922b586ac5a7751e61e45e4b",
      "in_reply_to_id": 1418061039,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "@mzumsande, @sr-gi, I played with @sr-gi's idea on [this branch](https://github.com/stratospher/bitcoin/commit/276b95d766cd11d65d563805d52beace8dd32744) and wondering about 2 things:\r\n\r\n1. can deadlocks happen? i noticed places in the test where `_send_lock` was acquired and then `p2p_lock` (and deadlocks didn't happen). am i missing something?\r\n\t1. MainThread acquires `_send_lock`\r\n\t2. NetworkThread acquires `p2p_lock`\r\n\t3. NetworkThread would wait for MainThread to release `_send_lock`\r\n\t4. MainThread would release `_send_lock` at some point of time right? (since it doesn't need to wait for `p2p_lock`)\r\n2. do we need a separate `_send_lock` for every P2PConnection? benchmarks look slightly faster with a global `_send_lock` (like `p2p_lock`).\r\n\r\n> Given this will affect several parts of the tests suite it may be worth doing it as a followup\r\n\r\n+1, but supposing deadlocks are possible - in the follow up:\r\n1. `_send_lock` acquired because of `send_message()` and then `p2p_lock` acquired because of `wait_until()` is harmless for us\r\n2. `_send_lock` acquired because of `send_message()` and then `p2p_lock` acquired because of `on_message()` is the situation we need to be concerned about",
      "created_at": "2024-01-27T14:55:57Z",
      "updated_at": "2024-01-27T14:55:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1468498323",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1468498323"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 169,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1470021935",
      "pull_request_review_id": 1849488387,
      "id": 1470021935,
      "node_id": "PRRC_kwDOABII585XnsEv",
      "diff_hunk": "@@ -163,6 +163,7 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self._send_lock = threading.Lock()",
      "path": "test/functional/test_framework/p2p.py",
      "position": 40,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "bc26a862b06257ce922b586ac5a7751e61e45e4b",
      "in_reply_to_id": 1418061039,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> do we need a separate `_send_lock` for every P2PConnection? benchmarks look slightly faster with a global `_send_lock` (like `p2p_lock`).\r\n\r\nUmm, that sounds a bit strange to me. My intuition would be that having a global lock should be slower, especially if multiple connections are run at the same time, given they would be racing to acquire that lock every time a message needs to be sent (?)\r\n\r\nw.r.t wether or not a deadlock is possible, I think @mzumsande may be able to tell you better given he was the one pointing them out initially, but if we want to enforce a certain ordering of acquiring them I think my suggestion (or something on those lines) may be worth adding. I'm even happy to open a PR for that ",
      "created_at": "2024-01-29T18:24:17Z",
      "updated_at": "2024-01-29T18:24:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1470021935",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1470021935"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 169,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1470738750",
      "pull_request_review_id": 1850458767,
      "id": 1470738750,
      "node_id": "PRRC_kwDOABII585XqbE-",
      "diff_hunk": "@@ -401,11 +402,16 @@ static RPCHelpMan addconnection()\n     } else {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, self.ToString());\n     }\n+    bool use_v2transport = !request.params[2].isNull() && request.params[2].get_bool();",
      "path": "src/rpc/net.cpp",
      "position": 23,
      "original_position": 23,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "4487b8051797173c7ab432e75efa370afb03b529",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Please don't encode the default value in the syntax of the source code. Otherwise, it is hard to change the default value. Also, it is confusing to have to change two places to change one value. You could just use `self.Arg<bool>(2)`.",
      "created_at": "2024-01-30T08:06:40Z",
      "updated_at": "2024-01-30T08:06:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1470738750",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1470738750"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 405,
      "original_line": 405,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1471455135",
      "pull_request_review_id": 1851630547,
      "id": 1471455135,
      "node_id": "PRRC_kwDOABII585XtJ-f",
      "diff_hunk": "@@ -0,0 +1,85 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import random\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.v2_p2p import EncryptedP2PState\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Custom implementation of class EncryptedP2PState for testing purposes:\n+\n+    - if `send_net_magic` is True, send first 4 bytes of ellswift(match network magic) else send remaining 60 bytes\n+    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+              This state is represented using `can_data_be_received` = False.\n+            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+              This state is represented using `can_data_be_received` = True.\n+    \"\"\"\n+\n+    def __init__(self):\n+        super().__init__(initiating=True, net='regtest')\n+        self.send_net_magic = True\n+        self.can_data_be_received = False\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage.\n+        Here, the 64 bytes ellswift is assumed to have it's 4 bytes match network magic bytes. It is sent in 2 phases:\n+            1. when `send_network_magic` = True, send first 4 bytes of ellswift (matches network magic bytes)\n+            2. when `send_network_magic` = False, send remaining 60 bytes of ellswift\n+        \"\"\"\n+        if self.send_net_magic:\n+            self.privkey_ours, self.ellswift_ours = ellswift_create()\n+            self.sent_garbage = random.randbytes(garbage_len)\n+            self.send_net_magic = False\n+            return b\"\\xfa\\xbf\\xb5\\xda\"\n+        else:\n+            self.can_data_be_received = True\n+            return self.ellswift_ours[4:] + self.sent_garbage\n+\n+\n+class PeerEarlyKey(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.v2_state = None\n+\n+    def connection_made(self, transport):\n+        \"\"\"Custom implementation so that 64 bytes ellswift is sent in 2 parts during `initial_v2_handshake()`\"\"\"\n+        self.v2_state = TestEncryptedP2PState()\n+        super().connection_made(transport)\n+\n+    def data_received(self, t):\n+        # check that data can be received on recvbuf only when mismatch from V1_PREFIX happens (send_net_magic = False)\n+        assert self.v2_state.can_data_be_received and not self.v2_state.send_net_magic\n+\n+\n+class P2PEarlyKey(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[\"-v2transport=1\", \"-peertimeout=3\"]]\n+\n+    def run_test(self):\n+        # testing BIP 324 \"The responder waits until one byte is received which does not match the 16 bytes\n+        # consisting of the network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\".\"\n+        self.log.info('Sending ellswift bytes in parts to ensure that response from responder is received only when')\n+        self.log.info('ellswift bytes have a mismatch from the 16 bytes(network magic followed by \"version\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\")')\n+        node0 = self.nodes[0]\n+        self.log.info('Sending first 4 bytes of ellswift which match network magic')\n+        self.log.info('If a response is received, assertion failure would happen in our custom data_received() function')\n+        # send happens in `initiate_v2_handshake()` in `connection_made()`\n+        peer1 = node0.add_p2p_connection(PeerEarlyKey(), wait_for_verack=False, send_version=False, supports_v2_p2p=True)\n+        self.log.info('Sending remaining ellswift and garbage which are different from V1_PREFIX. Since a response is')\n+        self.log.info('expected now, our custom data_received() function wouldn\\'t result in assertion failure')\n+        ellswift_and_garbage_data = peer1.v2_state.initiate_v2_handshake()\n+        peer1.send_raw_message(ellswift_and_garbage_data)\n+        peer1.wait_for_disconnect(timeout=5)\n+        self.log.info('successful disconnection when MITM happens in the key exchange phase')",
      "path": "test/functional/p2p_v2_earlykeyresponse.py",
      "position": 81,
      "original_position": 81,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "in_reply_to_id": 1464523738,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "true, will clean it up in [this branch](https://github.com/stratospher/bitcoin/commits/more-v2-tests/).",
      "created_at": "2024-01-30T15:33:59Z",
      "updated_at": "2024-01-30T15:34:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1471455135",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1471455135"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 81,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1472938508",
      "pull_request_review_id": 1853930479,
      "id": 1472938508,
      "node_id": "PRRC_kwDOABII585Xy0IM",
      "diff_hunk": "@@ -401,11 +402,16 @@ static RPCHelpMan addconnection()\n     } else {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, self.ToString());\n     }\n+    bool use_v2transport = !request.params[2].isNull() && request.params[2].get_bool();",
      "path": "src/rpc/net.cpp",
      "position": 23,
      "original_position": 23,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "4487b8051797173c7ab432e75efa370afb03b529",
      "in_reply_to_id": 1470738750,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done in #29356",
      "created_at": "2024-01-31T14:49:42Z",
      "updated_at": "2024-01-31T14:49:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1472938508",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1472938508"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 405,
      "original_line": 405,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1472939091",
      "pull_request_review_id": 1853931396,
      "id": 1472939091,
      "node_id": "PRRC_kwDOABII585Xy0RT",
      "diff_hunk": "@@ -590,6 +590,13 @@ def wait_for_disconnect(self, timeout=60):\n         test_function = lambda: not self.is_connected\n         self.wait_until(test_function, timeout=timeout, check_connected=False)\n \n+    def wait_for_reconnect(self, timeout=60):\n+        def test_function():\n+            if not (self.is_connected and self.last_message.get('version') and self.v2_state is None):\n+                return False\n+            return True",
      "path": "test/functional/test_framework/p2p.py",
      "position": 325,
      "original_position": 8,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "ffe6a56d75c0b47d0729e4e0b7225a827b43ad89",
      "in_reply_to_id": 1466979708,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done in #29356",
      "created_at": "2024-01-31T14:50:05Z",
      "updated_at": "2024-01-31T14:50:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1472939091",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1472939091"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": 595,
      "original_start_line": 595,
      "start_side": "RIGHT",
      "line": 597,
      "original_line": 597,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1472939751",
      "pull_request_review_id": 1853932532,
      "id": 1472939751,
      "node_id": "PRRC_kwDOABII585Xy0bn",
      "diff_hunk": "@@ -232,13 +232,62 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):",
      "path": "test/functional/test_framework/p2p.py",
      "position": 109,
      "original_position": 5,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "05bddb20f5cc9036fd680500bde8ece70dbf0646",
      "in_reply_to_id": 1466958424,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done in #29356",
      "created_at": "2024-01-31T14:50:35Z",
      "updated_at": "2024-01-31T14:50:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1472939751",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1472939751"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 245,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1472944545",
      "pull_request_review_id": 1853941710,
      "id": 1472944545,
      "node_id": "PRRC_kwDOABII585Xy1mh",
      "diff_hunk": "@@ -4,17 +4,281 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+        self.found_garbage_terminator = False\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 119,
      "original_position": 118,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "b89fa59e715a185d9fa7fce089dad4273d3b1532",
      "in_reply_to_id": 1466826427,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "didn't include this in #29356 because we'd need to call it in 2 places (before `initiate_v2_handshake`, `respond_v2_handshake`) and also calculate `garbage_len` there again.",
      "created_at": "2024-01-31T14:53:49Z",
      "updated_at": "2024-01-31T14:53:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1472944545",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1472944545"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 119,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1492983890",
      "pull_request_review_id": 1886003998,
      "id": 1492983890,
      "node_id": "PRRC_kwDOABII585Y_SBS",
      "diff_hunk": "@@ -163,6 +163,7 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self._send_lock = threading.Lock()",
      "path": "test/functional/test_framework/p2p.py",
      "position": 40,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "bc26a862b06257ce922b586ac5a7751e61e45e4b",
      "in_reply_to_id": 1418061039,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Something along the lines of:\r\n> \r\n> ```python\r\n> def p2p_lock(self):\r\n>     assert not self._send_lock.locked()\r\n>     return p2p_lock\r\n> ```\r\n\r\nI think that this is not right (I tried it out, and it asserts everywhere :sweat_smile:):\r\nTo prevent deadlocks, the lock order must be preserved only within each thread:\r\n- It's possible that a given thread first takes `p2p_lock`, and then `send_lock`. See for example: `on_message` -> `p2p_lock` taken -> call `on_inv` -> call `send_message` -> `_send_lock` taken\r\n- What must be disallowed is that any thread can do the reverse: First take `_send_lock`, and then take `p2p_lock`, because it would lead to a deadlock\r\n- I don't think that this is possible because I looked at the one spot where `send_lock` is taken (it calls `self.build_message` and `self.send_raw_message`, neither of which take `p2p_lock`) \r\n- But it is perfectly allowed that Thread 1 take `_send_lock`, and immediately after Thread 2 takes `p2p_lock` (which would trigger the assert).",
      "created_at": "2024-02-16T21:03:23Z",
      "updated_at": "2024-02-16T21:08:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1492983890",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1492983890"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 169,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1493011255",
      "pull_request_review_id": 1886091038,
      "id": 1493011255,
      "node_id": "PRRC_kwDOABII585Y_Ys3",
      "diff_hunk": "@@ -163,6 +163,7 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self._send_lock = threading.Lock()",
      "path": "test/functional/test_framework/p2p.py",
      "position": 40,
      "original_position": 4,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "bc26a862b06257ce922b586ac5a7751e61e45e4b",
      "in_reply_to_id": 1418061039,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "You're right. I don't think there is any easy way of keeping track of who's thread is holding what lock in Python though, so I don't think there a straightforward way of addressing this :(",
      "created_at": "2024-02-16T21:42:52Z",
      "updated_at": "2024-02-16T21:42:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1493011255",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1493011255"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 169,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1605180790",
      "pull_request_review_id": 2063723443,
      "id": 1605180790,
      "node_id": "PRRC_kwDOABII585frR12",
      "diff_hunk": "@@ -4,17 +4,281 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+        self.found_garbage_terminator = False\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")",
      "path": "test/functional/test_framework/v2_p2p.py",
      "position": 119,
      "original_position": 118,
      "commit_id": "bc9283c4415a932ec1eeb70ca2aa4399c80437b3",
      "original_commit_id": "b89fa59e715a185d9fa7fce089dad4273d3b1532",
      "in_reply_to_id": 1466826427,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done in #29431 actually",
      "created_at": "2024-05-17T15:20:44Z",
      "updated_at": "2024-05-17T15:20:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1605180790",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1605180790"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 119,
      "original_line": 119,
      "side": "RIGHT"
    }
  ]
}