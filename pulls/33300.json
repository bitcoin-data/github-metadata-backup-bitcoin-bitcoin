{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300",
    "id": 2797425845,
    "node_id": "PR_kwDOABII586mvVS1",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/33300",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/33300.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/33300.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/ed813c48f826d083becf93c741b483774c850c86",
    "number": 33300,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "fuzz: compact block harness",
    "user": {
      "login": "Crypt-iQ",
      "id": 15145615,
      "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
      "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Crypt-iQ",
      "html_url": "https://github.com/Crypt-iQ",
      "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
      "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
      "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
      "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
      "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Posting up to get feedback, there are some design flaws with the approach in this PR. Coverage is [here](https://crypt-iq.github.io/fuzz_coverage_reports/cmpctblock-aflpp-inputs-09182025/) (look in `src/blockencodings.cpp`, relevant compact block bits in `src/net_processing.cpp`).\r\n\r\nThis harness can make (in)valid blocks, reconstruct blocks with in-mempool txns, mark peers as HB, and has high stability in AFL++ (~98-99%).\r\n\r\nThe main downside is that there are filesystem operations. In the `.init` function `initialize_cmpctblock`, a chain of 200 blocks is created. Each fuzzing iteration then copies this statically-named, \"cached\" data directory to a temporary directory that gets deleted at the end of the iteration. If each fuzzing iteration instead mines its own chain, the execs/s slows down to a crawl (~0.5/s or less, which would also make CI runs really slow).",
    "labels": [
      {
        "id": 62963516,
        "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
        "name": "Tests",
        "color": "d4c5f9",
        "default": false
      }
    ],
    "created_at": "2025-09-03T22:33:44Z",
    "updated_at": "2025-10-24T23:46:42Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "31b5fb1ac4ada3deca2c8bd2832824e4c3f2356b",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "Crypt-iQ:cmpctblock-fuzz-0807-fs",
      "ref": "cmpctblock-fuzz-0807-fs",
      "sha": "ed813c48f826d083becf93c741b483774c850c86",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 79155174,
        "node_id": "MDEwOlJlcG9zaXRvcnk3OTE1NTE3NA==",
        "name": "bitcoin",
        "full_name": "Crypt-iQ/bitcoin",
        "owner": {
          "login": "Crypt-iQ",
          "id": 15145615,
          "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
          "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/Crypt-iQ",
          "html_url": "https://github.com/Crypt-iQ",
          "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
          "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
          "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
          "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
          "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/Crypt-iQ/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/Crypt-iQ/bitcoin",
        "archive_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/events",
        "forks_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/Crypt-iQ/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:Crypt-iQ/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/Crypt-iQ/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/hooks",
        "svn_url": "https://github.com/Crypt-iQ/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 0,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 264932,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-10-24T19:10:18Z",
        "created_at": "2017-01-16T20:09:01Z",
        "updated_at": "2025-07-28T14:17:58Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "1ed00a0d39d5190d8ad88a0dd705a09b56d987aa",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 38074,
        "stargazers_count": 86390,
        "watchers_count": 86390,
        "size": 295240,
        "default_branch": "master",
        "open_issues_count": 740,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-10-24T20:25:13Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-10-24T21:44:31Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 492,
    "deletions": 18,
    "changed_files": 11,
    "commits": 7,
    "review_comments": 26,
    "comments": 8
  },
  "events": [
    {
      "event": "labeled",
      "id": 19491980050,
      "node_id": "LE_lADOABII587JjYsgzwAAAASJ0AMS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19491980050",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-03T22:33:47Z",
      "label": {
        "name": "Tests",
        "color": "d4c5f9"
      }
    },
    {
      "event": "commented",
      "id": 3251019621,
      "node_id": "IC_kwDOABII587Bxp9l",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3251019621",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-03T22:33:49Z",
      "updated_at": "2025-10-24T23:46:42Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33300.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#33637](https://github.com/bitcoin/bitcoin/pull/33637) (refactor: optimize block index comparisons (1.4-6.8x faster) by l0rinc)\n* [#33191](https://github.com/bitcoin/bitcoin/pull/33191) (net: Provide block templates to peers on request by ajtowns)\n* [#31260](https://github.com/bitcoin/bitcoin/pull/31260) (scripted-diff: Type-safe settings retrieval by ryanofsky)\n* [#29415](https://github.com/bitcoin/bitcoin/pull/29415) (Broadcast own transactions only via short-lived Tor or I2P connections by vasild)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3251019621",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19492052899,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASJ0R-j",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19492052899",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ea293e34d63163c26227c4f4a2438613e8d97ce6",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/ea293e34d63163c26227c4f4a2438613e8d97ce6",
      "created_at": "2025-09-03T22:39:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19492123839,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASJ0jS_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19492123839",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c426b8066347594d975d612626add067652207e5",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/c426b8066347594d975d612626add067652207e5",
      "created_at": "2025-09-03T22:45:49Z"
    },
    {
      "event": "commented",
      "id": 3252163887,
      "node_id": "IC_kwDOABII587B2BUv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3252163887",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T06:45:28Z",
      "updated_at": "2025-09-04T06:45:28Z",
      "author_association": "MEMBER",
      "body": "> There does not seem to be a way without signal handlers to delete the static, cached datadir when fuzzing is complete. Another issue is that multi-core fuzzing via AFL++ does not work because each worker will try to wipe the cached datadir (created via `-testdatadir` which wipes if the directory exists) which will cause other workers to crash if they are trying to copy it. I could not figure out a way for each worker to have their own cached datadir.\r\n\r\nIs my understanding correct that AFL will run init (create the static dir), then fork into several fuzz processes, which run for N iterations and then shut down and delete the static dir? (On the next re-fork, it will fail to find the static dir)?\r\n\r\nIf yes, a solution could be to lazy-init the static dir after init, after the fork. Also, you may have to use the pid (or os-rand) to name the static folder to avoid collisions.\r\n\r\nAs for deleting the dirs, maybe it is possible to spin up several testing setups at the same time:\r\n\r\n* One dummy testing setup to create a root dir, which is cleaned up\r\n* One testing setup living inside that root dir for the static folder (in a subfolder)\r\n* One testing setup living inside the root dir with a copy of the static folder\r\n\r\n(Not sure if this is possible, though)",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3252163887",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "commented",
      "id": 3252595782,
      "node_id": "IC_kwDOABII587B3qxG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3252595782",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T08:59:35Z",
      "updated_at": "2025-09-04T08:59:35Z",
      "author_association": "MEMBER",
      "body": "> Is my understanding correct that AFL will run init (create the static dir), then fork into several fuzz processes, which run for N iterations and then shut down and delete the static dir? (On the next re-fork, it will fail to find the static dir)?\r\n\r\nWe removed the `__AFL_INIT` call, so it will actually fork prior to `init`, so I think all that's needed is to randomize the static dir name as you suggested as well.",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3252595782",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "commented",
      "id": 3253868966,
      "node_id": "IC_kwDOABII587B8hmm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3253868966",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T13:58:27Z",
      "updated_at": "2025-09-04T13:59:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Is my understanding correct that AFL will run init (create the static dir), then fork into several fuzz processes, which run for N iterations and then shut down and delete the static dir? (On the next re-fork, it will fail to find the static dir)?\r\n\r\nMy description was a bit vague. Since the harness uses `-testdatadir` in init to create the static datadir, it does not get deleted in the TestingSetup destructor (by design of `-testdatadir`). Any time init is called, it will wipe the static datadir if it already exists. This can happen after N iterations (100,000 currently) or with a newly spawned worker after forking since the fork point is prior to init like @dergoegge mentioned. If the datadir is deleted while a fuzz iteration tries to copy the non-existent directory, it will crash.\r\n\r\n> a solution could be to lazy-init the static dir after init, after the fork\r\n\r\nI considered this, but I think this introduces some (slight) non-determinism as the directory may/may not exist?\r\n\r\n> Also, you may have to use the pid (or os-rand) to name the static folder to avoid collisions.\r\n\r\nYup, I agree. I think this randomization can only be done if the static datadir can be deleted at the end of fuzzing, otherwise there will be lots of these lying around?\r\n\r\n> As for deleting the dirs, maybe it is possible to spin up several testing setups at the same time:\r\n\r\nWhy is the dummy testing setup needed in this example? Could it instead just be two testing setups (one for the static datadir, one for the copied datadir)? I considered something similar to this as well where there is a `static TestingSetup` that gets destructed at the end of fuzzing (and wipes the static datadir) and one for each fuzz iteration (that gets destructed at the end of the iteration), but I was worried that the `static TestingSetup` would introduce more non-determinism? For example, what if this `static TestingSetup` has scheduling going on or is using the static datadir while we try to copy from it?",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3253868966",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "mentioned",
      "id": 19505729443,
      "node_id": "MEE_lADOABII587JjYsgzwAAAASKoc-j",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19505729443",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T13:58:29Z"
    },
    {
      "event": "subscribed",
      "id": 19505729484,
      "node_id": "SE_lADOABII587JjYsgzwAAAASKoc_M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19505729484",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T13:58:29Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19536531291,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASMd89b",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19536531291",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c76f47547683afd305b091d955b44935f4be840a",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/c76f47547683afd305b091d955b44935f4be840a",
      "created_at": "2025-09-05T21:36:08Z"
    },
    {
      "event": "commented",
      "id": 3259826186,
      "node_id": "IC_kwDOABII587CTQAK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3259826186",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-05T21:41:11Z",
      "updated_at": "2025-09-05T21:42:03Z",
      "author_association": "CONTRIBUTOR",
      "body": "I was able to get AFL++ multi-core fuzzing to work by adding a static `FuzzedDirectoryWrapper` instance that deletes the passed path in its destructor as well as using a random element to each statically named datadir. Each instance is in the high 98-99% stability and does not crash after hitting 100,000 iterations (yay). I was not able to use multiple `TestingSetup`s at the same time without causing several panics due to assertions about globals. I will fix the lint, tidy jobs and also see if the deterministic-fuzz-coverage issues still pop up.",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3259826186",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19592095844,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASPx6hk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19592095844",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/0de9143aa06f19d9074fb8b651b5daa398922c46",
      "created_at": "2025-09-09T14:49:56Z"
    },
    {
      "event": "commented",
      "id": 3271483113,
      "node_id": "IC_kwDOABII587C_t7p",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3271483113",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-09T16:39:30Z",
      "updated_at": "2025-09-11T16:12:58Z",
      "author_association": "CONTRIBUTOR",
      "body": "There is non-determinism [here](https://github.com/bitcoin/bitcoin/blob/c0894a0a2be032cd9a5d5945643689230ab10255/src/node/blockstorage.cpp#L490-L493) because `m_dirty_blockindex` is `std::set<CBlockIndex*>` and sorts based on the pointer. This can be fixed by adding a function object that compares the block hashes. However, I did not know if this should be added just for fuzz code and I have not run benchmarks.\r\n\r\nAfter patching the above non-determinism locally, there is also non-determinism in the scheduler ~~because this fuzz test uses the scheduler. I am guessing this is due to the `RegisterValidationInterface` call in the fuzz test notifying when transactions are being added or removed, and blocks being mined.~~",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3271483113",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "ready_for_review",
      "id": 19594317030,
      "node_id": "RFRE_lADOABII587JjYsgzwAAAASP6Yzm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19594317030",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-09T16:40:39Z"
    },
    {
      "event": "reviewed",
      "id": 3212403908,
      "node_id": "PRR_kwDOABII586_eWTE",
      "url": null,
      "actor": null,
      "commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-12T15:29:56Z",
      "author_association": "MEMBER",
      "body": "Did a first pass, overall approach looks good to me",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#pullrequestreview-3212403908",
      "submitted_at": "2025-09-12T15:29:56Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19777388764,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASa0wDc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19777388764",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "19ca89b57704f6ca8fa52dd3b03f0ae4305ce70b",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/19ca89b57704f6ca8fa52dd3b03f0ae4305ce70b",
      "created_at": "2025-09-18T14:34:09Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19777887460,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASa2pzk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19777887460",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d7e402c37ee2287eaa31c17a34c609b5b1c40a6d",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/d7e402c37ee2287eaa31c17a34c609b5b1c40a6d",
      "created_at": "2025-09-18T14:53:18Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19778339306,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASa4YHq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19778339306",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "dbc911fe07fb3d07468cd76ed3155163f10b3d19",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/dbc911fe07fb3d07468cd76ed3155163f10b3d19",
      "created_at": "2025-09-18T15:09:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19779756007,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASa9x_n",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19779756007",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "created_at": "2025-09-18T16:08:37Z"
    },
    {
      "event": "commented",
      "id": 3308381089,
      "node_id": "IC_kwDOABII587FMeOh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3308381089",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-18T16:18:17Z",
      "updated_at": "2025-09-18T16:31:48Z",
      "author_association": "CONTRIBUTOR",
      "body": "The latest push adds two commits:\r\n- a5619ea631bd8b93b4ef02a20abb8c1c0705d8e4 \"test: add setup_validation_interface_no_scheduler to TestOpts\"\r\n  - Disables the scheduler completely if set. This is needed because this harness creates a `TestingSetup` inside `FUZZ_TARGET` and scheduling a [promise](https://github.com/bitcoin/bitcoin/blob/74fa028da1ea38c5348f988464074899684cebcf/src/test/util/setup_common.cpp#L249) can be non-deterministic as the scheduler's `serviceQueue` may start with a non-empty `taskQueue`. This is not an issue in the other fuzz tests because their `TestingSetup` is created in .init and `ResetCoverageCounters` is called after.\r\n- e2f921458913bcbbe74115cdb2174b0ab31784f2 \"node: sort m_dirty_blockindex by block hash\"\r\n  - I am ok with this commit being removed and want to know what others think. This sorts by block hash rather than memory address and does introduce a slow-down in production code for no production benefit (I think because memory addresses are ~generally going to be increasing while inserting into `m_dirty_blockindex`, whereas sorting by block hash won't). I added it to show the change needed to make this harness fully non-deterministic. It is also possible to add an #ifdef so that it doesn't negatively affect production code, but I also don't want to set a precedent and litter the codebase with fuzz-specific macros. The sorting is needed as otherwise leveldb's MemTable will be non-deterministic across runs. I tried some alternatives, but this is the best I could come up with that made the `determinstic-fuzz-coverage` script happy.",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3308381089",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "reviewed",
      "id": 3291568683,
      "node_id": "PRR_kwDOABII587EMVor",
      "url": null,
      "actor": null,
      "commit_id": "a473ec650987c267328ccbb9b472e7db8e361a54",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-01T23:26:52Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#pullrequestreview-3291568683",
      "submitted_at": "2025-10-01T23:26:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDc5ZWE5NTc4ZDZkNGEyMzM0YTlhOWQzMTIxODcyM2MzZGIzYzYwYjQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/79ea9578d6d4a2334a9a9d31218723c3db3c60b4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/79ea9578d6d4a2334a9a9d31218723c3db3c60b4",
      "tree": {
        "sha": "633587f88d5b2bf5f521b2356b3179c7bac97677",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/633587f88d5b2bf5f521b2356b3179c7bac97677"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1ed00a0d39d5190d8ad88a0dd705a09b56d987aa",
          "sha": "1ed00a0d39d5190d8ad88a0dd705a09b56d987aa",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/1ed00a0d39d5190d8ad88a0dd705a09b56d987aa"
        }
      ],
      "message": "net: move CMPCTBLOCK_VERSION to header",
      "committer": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2025-10-02T16:13:50Z"
      },
      "author": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2025-08-26T14:23:30Z"
      },
      "sha": "79ea9578d6d4a2334a9a9d31218723c3db3c60b4"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI1NGUxM2NkNDQyYTdhMGZiYjMyZWQ2ZDlkMjAyMDJkN2VhY2ZmZjk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/254e13cd442a7a0fbb32ed6d9d20202d7eacfff9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/254e13cd442a7a0fbb32ed6d9d20202d7eacfff9",
      "tree": {
        "sha": "559b13c3d896ad7674b7f4f7ab43e7cc8ae29315",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/559b13c3d896ad7674b7f4f7ab43e7cc8ae29315"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/79ea9578d6d4a2334a9a9d31218723c3db3c60b4",
          "sha": "79ea9578d6d4a2334a9a9d31218723c3db3c60b4",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/79ea9578d6d4a2334a9a9d31218723c3db3c60b4"
        }
      ],
      "message": "fuzz: move FinalizeHeader from p2p_headers_presync.cpp to util.h\n\nThis allows other fuzz tests to use the function to create valid block headers.",
      "committer": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2025-10-02T16:13:50Z"
      },
      "author": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2025-04-22T01:58:47Z"
      },
      "sha": "254e13cd442a7a0fbb32ed6d9d20202d7eacfff9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGViOTJhZDc1OWQ4N2YwMTkwMjU4NTU3ZmI2YTY3OTNhMDE4NjZiZjI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eb92ad759d87f0190258557fb6a6793a01866bf2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/eb92ad759d87f0190258557fb6a6793a01866bf2",
      "tree": {
        "sha": "28281153b66cdf2edd9d9dbdeb7a8091ba46a096",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/28281153b66cdf2edd9d9dbdeb7a8091ba46a096"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/254e13cd442a7a0fbb32ed6d9d20202d7eacfff9",
          "sha": "254e13cd442a7a0fbb32ed6d9d20202d7eacfff9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/254e13cd442a7a0fbb32ed6d9d20202d7eacfff9"
        }
      ],
      "message": "fs: add std::filesystem::copy wrapper\n\nDisable implicit string conversion.",
      "committer": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2025-10-02T16:13:50Z"
      },
      "author": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2025-09-09T14:37:37Z"
      },
      "sha": "eb92ad759d87f0190258557fb6a6793a01866bf2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGY5NWNmYmE4OTA2Y2YzNzMwMGQ0MDRkNzY1OGFhMmIzODUzNmEzNzE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f95cfba8906cf37300d404d7658aa2b38536a371",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f95cfba8906cf37300d404d7658aa2b38536a371",
      "tree": {
        "sha": "2afa66f17b036fc4d2987dc3c9ed9a476c12c630",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2afa66f17b036fc4d2987dc3c9ed9a476c12c630"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eb92ad759d87f0190258557fb6a6793a01866bf2",
          "sha": "eb92ad759d87f0190258557fb6a6793a01866bf2",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/eb92ad759d87f0190258557fb6a6793a01866bf2"
        }
      ],
      "message": "test: add -fuzzcopydatadir, modify -testdatadir semantics during fuzzing\n\nThe -fuzzcopydatadir argument accepts a path to a cached data directory.\nIt then copies everything in this data directory over to a new directory\nthat will be deleted in ~BasicTestingSetup.\n\nThe -testdatadir argument is modified to not add a random path element\nif EnableFuzzDeterminism() is true. This is necessary so the path of\nthe data directory created via -testdatadir can be passed into\n-fuzzcopydatadir. Since the caller is BasicTestingSetup() is not aware of\nthe random path element, finding it would be more complex than just\nnot adding it.",
      "committer": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2025-10-02T16:20:28Z"
      },
      "author": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2025-08-25T20:34:58Z"
      },
      "sha": "f95cfba8906cf37300d404d7658aa2b38536a371"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDc5Nzg4NmFhYTI3NmQ4OTRmYmYxNzU5ZjBmNWM5NWUzMDE4NGVhMzI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/797886aaa276d894fbf1759f0f5c95e30184ea32",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/797886aaa276d894fbf1759f0f5c95e30184ea32",
      "tree": {
        "sha": "79bd45dc49a27e7e5ce4aa50e42fd8902d9cabe4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/79bd45dc49a27e7e5ce4aa50e42fd8902d9cabe4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f95cfba8906cf37300d404d7658aa2b38536a371",
          "sha": "f95cfba8906cf37300d404d7658aa2b38536a371",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f95cfba8906cf37300d404d7658aa2b38536a371"
        }
      ],
      "message": "test: add setup_validation_interface_no_scheduler to TestOpts\n\nThis option is mutually exclusive with setup_validation_interface\nand ensures that a scheduler is not created.",
      "committer": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2025-10-02T16:32:15Z"
      },
      "author": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2025-09-17T15:36:18Z"
      },
      "sha": "797886aaa276d894fbf1759f0f5c95e30184ea32"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGJhODljZGQ5M2VlMzllODg0YzkyNGFlMTI3MzdkZDA2NjM5Y2VlOGY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ba89cdd93ee39e884c924ae12737dd06639cee8f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ba89cdd93ee39e884c924ae12737dd06639cee8f",
      "tree": {
        "sha": "87dca48a52e2f2878701b0a4eb105fefdd7cf3fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/87dca48a52e2f2878701b0a4eb105fefdd7cf3fb"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/797886aaa276d894fbf1759f0f5c95e30184ea32",
          "sha": "797886aaa276d894fbf1759f0f5c95e30184ea32",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/797886aaa276d894fbf1759f0f5c95e30184ea32"
        }
      ],
      "message": "fuzz: add harness for the compact blocks protocol\n\nThis harness does one of the following operations in a loop:\n- send a cmpctblock message to the test node\n- send a blocktxn message to the test node\n- send a headers message to the test node\n- send a sendcmpct message to the test node\n- send a tx message to the test node\n- mine a block\n- set mock time\n\nThe initialize function creates a TestingSetup and mines 200 blocks. Each fuzz\niteration will then create a TestingSetup and copy the cached data directory via\n-fuzzcopydatadir.",
      "committer": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2025-10-02T16:32:15Z"
      },
      "author": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2025-04-22T02:14:51Z"
      },
      "sha": "ba89cdd93ee39e884c924ae12737dd06639cee8f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGVkODEzYzQ4ZjgyNmQwODNiZWNmOTNjNzQxYjQ4Mzc3NGM4NTBjODY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ed813c48f826d083becf93c741b483774c850c86",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ed813c48f826d083becf93c741b483774c850c86",
      "tree": {
        "sha": "7723673d04e0f40cf044ad60652d91b39a4c2be2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7723673d04e0f40cf044ad60652d91b39a4c2be2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ba89cdd93ee39e884c924ae12737dd06639cee8f",
          "sha": "ba89cdd93ee39e884c924ae12737dd06639cee8f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ba89cdd93ee39e884c924ae12737dd06639cee8f"
        }
      ],
      "message": "node: sort m_dirty_blockindex by block hash\n\nThis avoids non-determinism since memory addresses change between\nruns for a single input.",
      "committer": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2025-10-02T16:32:15Z"
      },
      "author": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2025-09-17T15:17:05Z"
      },
      "sha": "ed813c48f826d083becf93c741b483774c850c86"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20063857987,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASr5i1D",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20063857987",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/ed813c48f826d083becf93c741b483774c850c86",
      "created_at": "2025-10-02T16:33:59Z"
    },
    {
      "event": "commented",
      "id": 3362128175,
      "node_id": "IC_kwDOABII587IZgEv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3362128175",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-02T16:43:25Z",
      "updated_at": "2025-10-02T16:43:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "e2f921458913bcbbe74115cdb2174b0ab31784f2 -> ed813c48f826d083becf93c741b483774c850c86:\r\n- Fixes an issue pointed out by @marcofleon with the PoW checks failing\r\n- Adds more descriptive commit messages ",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3362128175",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "mentioned",
      "id": 20064013191,
      "node_id": "MEE_lADOABII587JjYsgzwAAAASr6IuH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20064013191",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-02T16:43:26Z"
    },
    {
      "event": "subscribed",
      "id": 20064013229,
      "node_id": "SE_lADOABII587JjYsgzwAAAASr6Iut",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20064013229",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-02T16:43:26Z"
    },
    {
      "event": "reviewed",
      "id": 3310414827,
      "node_id": "PRR_kwDOABII587FUOvr",
      "url": null,
      "actor": null,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-07T14:29:40Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#pullrequestreview-3310414827",
      "submitted_at": "2025-10-07T14:29:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
    },
    {
      "event": "reviewed",
      "id": 3315685387,
      "node_id": "PRR_kwDOABII587FoVgL",
      "url": null,
      "actor": null,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-08T16:57:20Z",
      "author_association": "CONTRIBUTOR",
      "body": "Some possible discussion about ed813c48f826d083becf93c741b483774c850c86 for review club.",
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#pullrequestreview-3315685387",
      "submitted_at": "2025-10-08T16:57:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2341477921",
      "pull_request_review_id": 3212403908,
      "id": 2341477921,
      "node_id": "PRRC_kwDOABII586LkB4h",
      "diff_hunk": "@@ -0,0 +1,421 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount amount_fee = 1000;",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 40,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit\r\n\r\n```suggestion\r\nconst CAmount AMOUNT_FEE{1000};\r\n```",
      "created_at": "2025-09-11T15:35:20Z",
      "updated_at": "2025-09-12T15:29:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2341477921",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2341477921"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2341484545",
      "pull_request_review_id": 3212403908,
      "id": 2341484545,
      "node_id": "PRRC_kwDOABII586LkDgB",
      "diff_hunk": "@@ -0,0 +1,421 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount amount_fee = 1000;\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - amount_fee;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbaseTx;\n+        coinbaseTx.vin.resize(1);\n+        coinbaseTx.vin[0].prevout.SetNull();\n+        coinbaseTx.vout.resize(1);\n+        coinbaseTx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbaseTx.vout[0].nValue = COIN;\n+        coinbaseTx.vin[0].scriptSig = CScript() << height << OP_0;\n+        block->vtx.push_back(MakeTransactionRef(coinbaseTx));\n+\n+        // Add a tx from mempool. Since we do not include parents, it may be an invalid block.\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            LOCK(setup->m_node.mempool->cs);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx();\n+            block->vtx.push_back(mempool_tx);\n+        }\n+\n+        // Create and add a (possibly invalid) tx that is not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            CTransactionRef non_mempool_tx = create_tx();\n+            if (non_mempool_tx != nullptr) {\n+                block->vtx.push_back(non_mempool_tx);\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+        FinalizeHeader(header, *setup->m_node.chainman);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+\n+        BlockInfo blockinfo;\n+        blockinfo.block = block;\n+        blockinfo.hash = block->GetHash();\n+        blockinfo.height = height;\n+\n+        return blockinfo;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo blockinfo = create_block();\n+                    cblock = blockinfo.block;\n+                    info.push_back(blockinfo);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctBlock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, baseCmpctBlock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctBlock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctBlock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;\n+                net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, baseCmpctBlock);\n+            },\n+            [&]() {\n+                // Send a blocktxn message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Fetch an existing block and randomly choose transactions to send over.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                const BlockInfo& block_info = info[index];\n+                BlockTransactions block_txn;\n+                block_txn.blockhash = block_info.hash;\n+                std::shared_ptr<CBlock> cblock = block_info.block;\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (num_txs > 1) {\n+                    for (size_t i = 1; i < num_txs; i++) {\n+                        if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                        block_txn.txn.push_back(cblock->vtx[i]);\n+                    }\n+                }\n+\n+                net_msg = NetMsg::Make(NetMsgType::BLOCKTXN, block_txn);\n+            },\n+            [&]() {\n+                // Send a headers message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Choose an existing block and send a HEADERS message for it.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                CBlock block = *info[index].block;",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 359,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n                CBlock block = *info[index].block;\r\n                block.vtx.clear();\r\n```\r\n\r\nThe headers message is a vector of blocks without transactions, so I think you should clear the copy of the block here? Although, technically this doesn't matter because there's only one header in the vector being sent, so the following txs are just ignored.",
      "created_at": "2025-09-11T15:37:06Z",
      "updated_at": "2025-09-12T15:29:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2341484545",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2341484545"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 359,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2341516465",
      "pull_request_review_id": 3212403908,
      "id": 2341516465,
      "node_id": "PRRC_kwDOABII586LkLSx",
      "diff_hunk": "@@ -0,0 +1,421 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount amount_fee = 1000;\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - amount_fee;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbaseTx;\n+        coinbaseTx.vin.resize(1);\n+        coinbaseTx.vin[0].prevout.SetNull();\n+        coinbaseTx.vout.resize(1);\n+        coinbaseTx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbaseTx.vout[0].nValue = COIN;\n+        coinbaseTx.vin[0].scriptSig = CScript() << height << OP_0;\n+        block->vtx.push_back(MakeTransactionRef(coinbaseTx));\n+\n+        // Add a tx from mempool. Since we do not include parents, it may be an invalid block.\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            LOCK(setup->m_node.mempool->cs);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx();\n+            block->vtx.push_back(mempool_tx);\n+        }\n+\n+        // Create and add a (possibly invalid) tx that is not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            CTransactionRef non_mempool_tx = create_tx();\n+            if (non_mempool_tx != nullptr) {\n+                block->vtx.push_back(non_mempool_tx);\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+        FinalizeHeader(header, *setup->m_node.chainman);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+\n+        BlockInfo blockinfo;\n+        blockinfo.block = block;\n+        blockinfo.hash = block->GetHash();\n+        blockinfo.height = height;\n+\n+        return blockinfo;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo blockinfo = create_block();\n+                    cblock = blockinfo.block;\n+                    info.push_back(blockinfo);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctBlock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, baseCmpctBlock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctBlock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctBlock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 320,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n                CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;\r\n```\r\n\r\nnit: there are few instances of camel case usage here. Our convention is to use snake case (see dev notes).",
      "created_at": "2025-09-11T15:44:19Z",
      "updated_at": "2025-09-12T15:29:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2341516465",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2341516465"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 320,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2359949673",
      "pull_request_review_id": 3240553602,
      "id": 2359949673,
      "node_id": "PRRC_kwDOABII586Mqflp",
      "diff_hunk": "@@ -0,0 +1,421 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount amount_fee = 1000;",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 40,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "in_reply_to_id": 2341477921,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks, done.",
      "created_at": "2025-09-18T15:38:30Z",
      "updated_at": "2025-09-18T15:38:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2359949673",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2359949673"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2359951971",
      "pull_request_review_id": 3240556299,
      "id": 2359951971,
      "node_id": "PRRC_kwDOABII586MqgJj",
      "diff_hunk": "@@ -0,0 +1,421 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount amount_fee = 1000;\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - amount_fee;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbaseTx;\n+        coinbaseTx.vin.resize(1);\n+        coinbaseTx.vin[0].prevout.SetNull();\n+        coinbaseTx.vout.resize(1);\n+        coinbaseTx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbaseTx.vout[0].nValue = COIN;\n+        coinbaseTx.vin[0].scriptSig = CScript() << height << OP_0;\n+        block->vtx.push_back(MakeTransactionRef(coinbaseTx));\n+\n+        // Add a tx from mempool. Since we do not include parents, it may be an invalid block.\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            LOCK(setup->m_node.mempool->cs);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx();\n+            block->vtx.push_back(mempool_tx);\n+        }\n+\n+        // Create and add a (possibly invalid) tx that is not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            CTransactionRef non_mempool_tx = create_tx();\n+            if (non_mempool_tx != nullptr) {\n+                block->vtx.push_back(non_mempool_tx);\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+        FinalizeHeader(header, *setup->m_node.chainman);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+\n+        BlockInfo blockinfo;\n+        blockinfo.block = block;\n+        blockinfo.hash = block->GetHash();\n+        blockinfo.height = height;\n+\n+        return blockinfo;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo blockinfo = create_block();\n+                    cblock = blockinfo.block;\n+                    info.push_back(blockinfo);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctBlock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, baseCmpctBlock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctBlock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctBlock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;\n+                net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, baseCmpctBlock);\n+            },\n+            [&]() {\n+                // Send a blocktxn message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Fetch an existing block and randomly choose transactions to send over.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                const BlockInfo& block_info = info[index];\n+                BlockTransactions block_txn;\n+                block_txn.blockhash = block_info.hash;\n+                std::shared_ptr<CBlock> cblock = block_info.block;\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (num_txs > 1) {\n+                    for (size_t i = 1; i < num_txs; i++) {\n+                        if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                        block_txn.txn.push_back(cblock->vtx[i]);\n+                    }\n+                }\n+\n+                net_msg = NetMsg::Make(NetMsgType::BLOCKTXN, block_txn);\n+            },\n+            [&]() {\n+                // Send a headers message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Choose an existing block and send a HEADERS message for it.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                CBlock block = *info[index].block;",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 359,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "in_reply_to_id": 2341484545,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah nice catch, I completely missed this. Done.",
      "created_at": "2025-09-18T15:38:56Z",
      "updated_at": "2025-09-18T15:38:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2359951971",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2359951971"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 359,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2359953034",
      "pull_request_review_id": 3240557763,
      "id": 2359953034,
      "node_id": "PRRC_kwDOABII586MqgaK",
      "diff_hunk": "@@ -0,0 +1,421 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount amount_fee = 1000;\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - amount_fee;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbaseTx;\n+        coinbaseTx.vin.resize(1);\n+        coinbaseTx.vin[0].prevout.SetNull();\n+        coinbaseTx.vout.resize(1);\n+        coinbaseTx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbaseTx.vout[0].nValue = COIN;\n+        coinbaseTx.vin[0].scriptSig = CScript() << height << OP_0;\n+        block->vtx.push_back(MakeTransactionRef(coinbaseTx));\n+\n+        // Add a tx from mempool. Since we do not include parents, it may be an invalid block.\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            LOCK(setup->m_node.mempool->cs);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx();\n+            block->vtx.push_back(mempool_tx);\n+        }\n+\n+        // Create and add a (possibly invalid) tx that is not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            CTransactionRef non_mempool_tx = create_tx();\n+            if (non_mempool_tx != nullptr) {\n+                block->vtx.push_back(non_mempool_tx);\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+        FinalizeHeader(header, *setup->m_node.chainman);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+\n+        BlockInfo blockinfo;\n+        blockinfo.block = block;\n+        blockinfo.hash = block->GetHash();\n+        blockinfo.height = height;\n+\n+        return blockinfo;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo blockinfo = create_block();\n+                    cblock = blockinfo.block;\n+                    info.push_back(blockinfo);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctBlock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, baseCmpctBlock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctBlock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctBlock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 320,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "in_reply_to_id": 2341516465,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks, I believe I've fixed all of the camel case.",
      "created_at": "2025-09-18T15:39:13Z",
      "updated_at": "2025-09-18T15:39:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2359953034",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2359953034"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 320,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2396228628",
      "pull_request_review_id": 3291568683,
      "id": 2396228628,
      "node_id": "PRRC_kwDOABII586O04wU",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - AMOUNT_FEE;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbase_tx;\n+        coinbase_tx.vin.resize(1);\n+        coinbase_tx.vin[0].prevout.SetNull();\n+        coinbase_tx.vin[0].scriptSig = CScript() << height << OP_0;\n+        coinbase_tx.vout.resize(1);\n+        coinbase_tx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbase_tx.vout[0].nValue = COIN;\n+        block->vtx.push_back(MakeTransactionRef(coinbase_tx));\n+\n+        // Add a tx from mempool. Since we do not include parents, it may be an invalid block.\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            LOCK(setup->m_node.mempool->cs);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx();\n+            block->vtx.push_back(mempool_tx);\n+        }\n+\n+        // Create and add a (possibly invalid) tx that is not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            CTransactionRef non_mempool_tx = create_tx();\n+            if (non_mempool_tx != nullptr) {\n+                block->vtx.push_back(non_mempool_tx);\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+        FinalizeHeader(header, *setup->m_node.chainman);",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 261,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "a473ec650987c267328ccbb9b472e7db8e361a54",
      "in_reply_to_id": null,
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Shouldn't `*block` be passed in here instead of `header`? Right now, I think the block just ends up with the random nonce from when the header was created. Although this still works half the time with the simplifed PoW check. Also, calling `GetHash()` on the header includes the merkle root, so finalizing the header should be after we calculate the merkle root below.",
      "created_at": "2025-10-01T23:26:52Z",
      "updated_at": "2025-10-01T23:26:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2396228628",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2396228628"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2398415091",
      "pull_request_review_id": 3294089595,
      "id": 2398415091,
      "node_id": "PRRC_kwDOABII586O9Ojz",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - AMOUNT_FEE;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbase_tx;\n+        coinbase_tx.vin.resize(1);\n+        coinbase_tx.vin[0].prevout.SetNull();\n+        coinbase_tx.vin[0].scriptSig = CScript() << height << OP_0;\n+        coinbase_tx.vout.resize(1);\n+        coinbase_tx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbase_tx.vout[0].nValue = COIN;\n+        block->vtx.push_back(MakeTransactionRef(coinbase_tx));\n+\n+        // Add a tx from mempool. Since we do not include parents, it may be an invalid block.\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            LOCK(setup->m_node.mempool->cs);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx();\n+            block->vtx.push_back(mempool_tx);\n+        }\n+\n+        // Create and add a (possibly invalid) tx that is not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            CTransactionRef non_mempool_tx = create_tx();\n+            if (non_mempool_tx != nullptr) {\n+                block->vtx.push_back(non_mempool_tx);\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+        FinalizeHeader(header, *setup->m_node.chainman);",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 261,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "a473ec650987c267328ccbb9b472e7db8e361a54",
      "in_reply_to_id": 2396228628,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah yes, nice catch. I was wondering why the PoW check was still failing so many times in the coverage.",
      "created_at": "2025-10-02T11:24:39Z",
      "updated_at": "2025-10-02T11:24:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2398415091",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2398415091"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2399412490",
      "pull_request_review_id": 3295464134,
      "id": 2399412490,
      "node_id": "PRRC_kwDOABII586PBCEK",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - AMOUNT_FEE;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbase_tx;\n+        coinbase_tx.vin.resize(1);\n+        coinbase_tx.vin[0].prevout.SetNull();\n+        coinbase_tx.vin[0].scriptSig = CScript() << height << OP_0;\n+        coinbase_tx.vout.resize(1);\n+        coinbase_tx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbase_tx.vout[0].nValue = COIN;\n+        block->vtx.push_back(MakeTransactionRef(coinbase_tx));\n+\n+        // Add a tx from mempool. Since we do not include parents, it may be an invalid block.\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            LOCK(setup->m_node.mempool->cs);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx();\n+            block->vtx.push_back(mempool_tx);\n+        }\n+\n+        // Create and add a (possibly invalid) tx that is not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            CTransactionRef non_mempool_tx = create_tx();\n+            if (non_mempool_tx != nullptr) {\n+                block->vtx.push_back(non_mempool_tx);\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+        FinalizeHeader(header, *setup->m_node.chainman);",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 261,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "a473ec650987c267328ccbb9b472e7db8e361a54",
      "in_reply_to_id": 2396228628,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed in ba89cdd93ee39e884c924ae12737dd06639cee8f, verified that the `CheckBlockHeader` call in validation.cpp no longer fails.",
      "created_at": "2025-10-02T16:41:44Z",
      "updated_at": "2025-10-02T16:41:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2399412490",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2399412490"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2410849029",
      "pull_request_review_id": 3310414827,
      "id": 2410849029,
      "node_id": "PRRC_kwDOABII586PsqMF",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 75,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "When fuzzing on macOS (Apple Silicon), I ran into lots of crashes when copying the cached dir into the destination:\r\n\r\n```\r\nlibc++abi: terminating due to uncaught exception of type std::__1::__fs::filesystem::filesystem_error: filesystem error: in copy_file: File exists [\"/var/folders/wc/3l6l_0b92zzg54v6rmvqqn300000gn/T/test_common bitcoin/cmpctblock/6c5e38c6dcfbc2607321/regtest/blocks/xor.dat\"] [\"/var/folders/wc/3l6l_0b92zzg54v6rmvqqn300000gn/T/cmpctblock_cachedca12974312651650d6b0/datadir/regtest/blocks/xor.dat\"]\r\n```\r\n\r\nThe issue is that the destination dir may already exist before `TryCreateDirectories()`, and it happens when the AFL++ fork server is enabled (it does not happen when fuzzing with `AFL_NO_FORKSRV=1`). It appears that forked processes are running into collisions when generating the random path (`rand_path()`) for creating the destination dir, and when we switch to strong randomness (like how the static dir name is generated), the issue seems to be resolved:\r\n```diff\r\ndiff --git a/src/test/util/setup_common.cpp b/src/test/util/setup_common.cpp\r\nindex e9768d4c5c..ac477caa62 100644\r\n--- a/src/test/util/setup_common.cpp\r\n+++ b/src/test/util/setup_common.cpp\r\n@@ -164,8 +164,9 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\r\n         // tests, such as the fuzz tests to run in several processes at the\r\n         // same time, add a random element to the path. Keep it small enough to\r\n         // avoid a MAX_PATH violation on Windows.\r\n-        const auto rand{HexStr(g_rng_temp_path.randbytes(10))};\r\n-        return fs::temp_directory_path() / TEST_DIR_PATH_ELEMENT / test_name / rand;\r\n+        std::vector<unsigned char> random_path_suffix(10);\r\n+        GetStrongRandBytes(random_path_suffix);\r\n+        return fs::temp_directory_path() / TEST_DIR_PATH_ELEMENT / test_name / HexStr(random_path_suffix);\r\n     };\r\n \r\n     if (m_node.args->IsArgSet(\"-testdatadir\")) {\r\n```",
      "created_at": "2025-10-07T14:29:40Z",
      "updated_at": "2025-10-07T14:29:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2410849029",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2410849029"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": 210,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": 214,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2411373516",
      "pull_request_review_id": 3311161304,
      "id": 2411373516,
      "node_id": "PRRC_kwDOABII586PuqPM",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 75,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2410849029,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Are you fuzzing with persistent mode?",
      "created_at": "2025-10-07T17:29:08Z",
      "updated_at": "2025-10-07T17:29:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2411373516",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2411373516"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": 210,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": 214,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2411570436",
      "pull_request_review_id": 3311443359,
      "id": 2411570436,
      "node_id": "PRRC_kwDOABII586PvaUE",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 75,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2410849029,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes. I am compiling using `afl-clang-fast++` (it seems that other options are either unavailable or obsolete on macOS). However, I just added a `#undef __AFL_LOOP` at the top of `fuzz.cpp` to disable persistent mode (I made sure I no longer see the `[+] Persistent mode binary detected` log when running) and reverted the above change to `rand_path()`, but the same crash still occurs.",
      "created_at": "2025-10-07T18:43:57Z",
      "updated_at": "2025-10-07T18:43:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2411570436",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2411570436"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": 210,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": 214,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2413540219",
      "pull_request_review_id": 3314374913,
      "id": 2413540219,
      "node_id": "PRRC_kwDOABII586P27N7",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 75,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2410849029,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Think this is because the child processes have the same `g_rng_temp_path` so they create the same directory. Will need to see if `GetStrongRandBytes` introduces non-determinism. I'm confused why fuzzing on debian didn't bring this up.",
      "created_at": "2025-10-08T11:27:43Z",
      "updated_at": "2025-10-08T11:27:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2413540219",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2413540219"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": 210,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": 214,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414395854",
      "pull_request_review_id": 3315607374,
      "id": 2414395854,
      "node_id": "PRRC_kwDOABII586P6MHO",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 75,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2410849029,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for pointing this out, `GetStrongRandBytes` does not introduce non-determinism. I'll change the next time I push up by making `rand_path` accept a `bool strong` so that the original behavior when `-testdatadir` is set is unchanged. ",
      "created_at": "2025-10-08T16:17:00Z",
      "updated_at": "2025-10-08T16:17:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2414395854",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414395854"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": 210,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": 214,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414451232",
      "pull_request_review_id": 3315685387,
      "id": 2414451232,
      "node_id": "PRRC_kwDOABII586P6Zog",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 147,
      "original_position": 147,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ba89cdd93ee39e884c924ae12737dd06639cee8f",
      "in_reply_to_id": null,
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "As we discussed a bit offline, increasing the number of peers here to greater than 3 should be enough to hit some of the missing \"eviction\" logic in `MaybeSetPeerAsAnnouncingHeaderAndIDs`. Maybe increasing to 8 peers would be fine? Although not sure if that would test anything more (somewhere else) than if it were 4.",
      "created_at": "2025-10-08T16:40:44Z",
      "updated_at": "2025-10-08T16:57:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2414451232",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414451232"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414480315",
      "pull_request_review_id": 3315685387,
      "id": 2414480315,
      "node_id": "PRRC_kwDOABII586P6gu7",
      "diff_hunk": "@@ -487,7 +492,7 @@ bool BlockManager::WriteBlockIndexDB()\n     }\n     std::vector<const CBlockIndex*> vBlocks;\n     vBlocks.reserve(m_dirty_blockindex.size());\n-    for (std::set<CBlockIndex*>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {\n+    for (std::set<CBlockIndex*, CBlockIndexBlockHashComparator>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {",
      "path": "src/node/blockstorage.cpp",
      "position": 17,
      "original_position": 17,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": null,
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I feel like I might be overlooking something here, but could we keep `m_dirty_blockindex` the same and then if `EnableFuzzDeterminism()` just sort `vBlocks` by hash before calling `WriteBatchSync()`?\r\n\r\nI guess I'm asking is there a reason why `m_dirty_blockindex` needs to be sorted by hash from the beginning vs right before the write.",
      "created_at": "2025-10-08T16:53:40Z",
      "updated_at": "2025-10-08T16:57:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2414480315",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414480315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 495,
      "original_line": 495,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414740159",
      "pull_request_review_id": 3316104414,
      "id": 2414740159,
      "node_id": "PRRC_kwDOABII586P7gK_",
      "diff_hunk": "@@ -487,7 +492,7 @@ bool BlockManager::WriteBlockIndexDB()\n     }\n     std::vector<const CBlockIndex*> vBlocks;\n     vBlocks.reserve(m_dirty_blockindex.size());\n-    for (std::set<CBlockIndex*>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {\n+    for (std::set<CBlockIndex*, CBlockIndexBlockHashComparator>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {",
      "path": "src/node/blockstorage.cpp",
      "position": 17,
      "original_position": 17,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2414480315,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Answered in the review club, also posting here:\r\n\r\nWithout this commit, leveldb's `MemTable` is non-deterministic since it depends on insert order. If we sort `vBlocks` right before calling `WriteBatchSync`, then the leveldb non-determinism is solved, but the number of times we call the comparison function varies since the initial ordering before sorting varies across runs of the same input. That means we need to sort when we insert into `m_dirty_blockindex` as the order of `CBlockIndex*` we insert here _is_ deterministic (i.e. we'll always insert A then B, even if it may sort as {A, B} or {B, A}). This is definitely confusing, I used pencil and paper to work this out.\r\n\r\nI did a simple benchmark and it showed ~O(n log n) slowdown. I was not sure how to bench this in a production scenario or what a realistic load here would look like. I guess it's possible to bench two different IBDs, but there may be other non-IBD scenarios?",
      "created_at": "2025-10-08T18:49:32Z",
      "updated_at": "2025-10-08T18:53:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2414740159",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414740159"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 495,
      "original_line": 495,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414764467",
      "pull_request_review_id": 3316138578,
      "id": 2414764467,
      "node_id": "PRRC_kwDOABII586P7mGz",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 147,
      "original_position": 147,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ba89cdd93ee39e884c924ae12737dd06639cee8f",
      "in_reply_to_id": 2414451232,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Will compare the coverage from increasing to 4 vs increasing to 8.",
      "created_at": "2025-10-08T19:00:49Z",
      "updated_at": "2025-10-08T19:00:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2414764467",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414764467"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2417231848",
      "pull_request_review_id": 3319614699,
      "id": 2417231848,
      "node_id": "PRRC_kwDOABII586QFAfo",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 75,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2410849029,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Since the crash I explained wasn't observed by others, I doubted whether it was actually coming from multiple child processes running simultaneously or from missed data dir cleanup. So I added a bunch of logs (including pid and parent pid in each) to investigate this further and found this after reading the logs for multiple runs:\r\n\r\nI observed that AFL++ ran one worker process at a time, not multiple workers in parallel. Each worker created a static cached directory once, then ran multiple fuzz iterations sequentially; each iteration creating and destroying a temporary data directory. This worked fine until a worker died unexpectedly (not yet sure why), leaving behind both its last temp data directory and its static cached directory without cleanup.\r\n\r\nEach new worker had the same `g_rng_temp_path` as the previous worker, so it generated the same temp directory paths. When the next worker started, it faced the copy crash at exactly the same iteration where the previous worker died. For example, if process A died before completing iteration N, it left behind the temp data directory at that iteration. Process B then faced the `fs::copy()` crash at exactly iteration N, since the generated sequence of temp data directory paths was identical. This worker also died, leaving behind another orphaned static cached directory. This flow would repeat, eventually filling the disk with orphaned directories.",
      "created_at": "2025-10-09T15:54:49Z",
      "updated_at": "2025-10-09T15:54:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2417231848",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2417231848"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": 210,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": 214,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2417263019",
      "pull_request_review_id": 3319657981,
      "id": 2417263019,
      "node_id": "PRRC_kwDOABII586QFIGr",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 75,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2410849029,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": ">  I'm confused why fuzzing on debian didn't bring this up.\r\n\r\nYeah, I am also confused by this. While my case wasn't exactly a multi-process execution issue, it seems a true multi-process execution should observe the same crash because of the same `g_rng_temp_path` across processes.",
      "created_at": "2025-10-09T16:06:44Z",
      "updated_at": "2025-10-09T16:08:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2417263019",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2417263019"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": 210,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": 214,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2417331534",
      "pull_request_review_id": 3319756908,
      "id": 2417331534,
      "node_id": "PRRC_kwDOABII586QFY1O",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 75,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2410849029,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Some signals are not specifically handled by the fuzzer, so if it creates a datadir (i.e. `process_messages`) and you Ctrl-C, it will leave it around instead of deleting it in `~BasicTestingSetup`. In any case, not using `g_rng_temp_path` seems like the right choice.",
      "created_at": "2025-10-09T16:30:35Z",
      "updated_at": "2025-10-09T16:32:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2417331534",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2417331534"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": 210,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": 214,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2458728270",
      "pull_request_review_id": 3374344921,
      "id": 2458728270,
      "node_id": "PRRC_kwDOABII586SjTdO",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 147,
      "original_position": 147,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ba89cdd93ee39e884c924ae12737dd06639cee8f",
      "in_reply_to_id": 2414451232,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Neither 4 nor 8 helped hit the case, will look into it more.",
      "created_at": "2025-10-24T04:03:42Z",
      "updated_at": "2025-10-24T04:03:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2458728270",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2458728270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    }
  ]
}