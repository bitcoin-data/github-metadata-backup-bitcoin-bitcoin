{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300",
    "id": 2797425845,
    "node_id": "PR_kwDOABII586mvVS1",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/33300",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/33300.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/33300.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/3c515102f4e83b4117f52d7d0fd41aac59740b16",
    "number": 33300,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "fuzz: compact block harness",
    "user": {
      "login": "Crypt-iQ",
      "id": 15145615,
      "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
      "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Crypt-iQ",
      "html_url": "https://github.com/Crypt-iQ",
      "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
      "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
      "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
      "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
      "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
      "type": "User",
      "site_admin": false,
      "name": null,
      "patch_url": null
    },
    "body": "Posting up to get feedback, there are some design flaws with the approach in this PR. Coverage is [here](https://crypt-iq.github.io/fuzz_coverage_reports/cmpctblock-aflpp-inputs-09182025/) (look in `src/blockencodings.cpp`, relevant compact block bits in `src/net_processing.cpp`).\r\n\r\nThis harness can make (in)valid blocks, reconstruct blocks with in-mempool txns, mark peers as HB, and has high stability in AFL++ (~98-99%).\r\n\r\nThe main downside is that there are filesystem operations. In the `.init` function `initialize_cmpctblock`, a chain of 200 blocks is created. Each fuzzing iteration then copies this statically-named, \"cached\" data directory to a temporary directory that gets deleted at the end of the iteration. If each fuzzing iteration instead mines its own chain, the execs/s slows down to a crawl (~0.5/s or less, which would also make CI runs really slow).",
    "labels": [
      {
        "id": 62963516,
        "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
        "name": "Tests",
        "color": "d4c5f9",
        "default": false
      },
      {
        "id": 955867938,
        "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
        "name": "Needs rebase",
        "description": "",
        "color": "cccccc",
        "default": false
      },
      {
        "id": 9554944034,
        "node_id": "LA_kwDOABII588AAAACOYTgIg",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Fuzzing",
        "name": "Fuzzing",
        "description": "",
        "color": "0e8a16",
        "default": false
      }
    ],
    "created_at": "2025-09-03T22:33:44Z",
    "updated_at": "2026-02-04T23:21:55Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "0a2c74ffb178303581e1f903c53dadada8ddc5ca",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "Crypt-iQ:cmpctblock-fuzz-0807-fs",
      "ref": "cmpctblock-fuzz-0807-fs",
      "sha": "3c515102f4e83b4117f52d7d0fd41aac59740b16",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 79155174,
        "node_id": "MDEwOlJlcG9zaXRvcnk3OTE1NTE3NA==",
        "name": "bitcoin",
        "full_name": "Crypt-iQ/bitcoin",
        "owner": {
          "login": "Crypt-iQ",
          "id": 15145615,
          "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
          "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/Crypt-iQ",
          "html_url": "https://github.com/Crypt-iQ",
          "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
          "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
          "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
          "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
          "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
          "type": "User",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/Crypt-iQ/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/Crypt-iQ/bitcoin",
        "archive_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/events",
        "forks_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/Crypt-iQ/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:Crypt-iQ/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/Crypt-iQ/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/hooks",
        "svn_url": "https://github.com/Crypt-iQ/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 0,
        "stargazers_count": 2,
        "watchers_count": 2,
        "size": 272739,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-02-04T23:21:22Z",
        "created_at": "2017-01-16T20:09:01Z",
        "updated_at": "2025-11-07T03:51:20Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "4ae00e9a7183cb15877c3014bf46f2e36470c304",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 38845,
        "stargazers_count": 87939,
        "watchers_count": 87939,
        "size": 303092,
        "default_branch": "master",
        "open_issues_count": 745,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-02-04T19:06:59Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2026-02-04T23:13:55Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 459,
    "deletions": 10,
    "changed_files": 6,
    "commits": 6,
    "review_comments": 71,
    "comments": 12
  },
  "events": [
    {
      "event": "labeled",
      "id": 19491980050,
      "node_id": "LE_lADOABII587JjYsgzwAAAASJ0AMS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19491980050",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-03T22:33:47Z",
      "label": {
        "name": "Tests",
        "color": "d4c5f9"
      }
    },
    {
      "event": "commented",
      "id": 3251019621,
      "node_id": "IC_kwDOABII587Bxp9l",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3251019621",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-03T22:33:49Z",
      "updated_at": "2026-02-04T23:21:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33300.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [frankomosh](https://github.com/bitcoin/bitcoin/pull/33300#pullrequestreview-3586886869) |\n| Approach ACK | [l0rinc](https://github.com/bitcoin/bitcoin/pull/33300#pullrequestreview-3447750850) |\n\nIf your review is incorrectly listed, please copy-paste <code>&lt;!--meta-tag:bot-skip--&gt;</code> into the comment that the bot should ignore.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#33740](https://github.com/bitcoin/bitcoin/pull/33740) (RFC: bench: Add multi thread benchmarking by fjahr)\n* [#29415](https://github.com/bitcoin/bitcoin/pull/29415) (Broadcast own transactions only via short-lived Tor or I2P connections by vasild)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->\n### LLM Linter (âœ¨ experimental)\n\n\n\nPossible places where named args for integral literals may be used (e.g. `func(x, /*named_arg=*/0)` in C++, and `func(x, named_arg=0)` in Python):\n\n- AddrMan addrman{*setup->m_node.netgroupman, /*deterministic=*/true, /*consistency_check_ratio=*/0} in src/test/fuzz/cmpctblock.cpp\n\n\n\n<sup>2026-02-04 23:21:55</sup>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3251019621",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19492052899,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASJ0R-j",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19492052899",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "ea293e34d63163c26227c4f4a2438613e8d97ce6",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/ea293e34d63163c26227c4f4a2438613e8d97ce6",
      "created_at": "2025-09-03T22:39:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19492123839,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASJ0jS_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19492123839",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "c426b8066347594d975d612626add067652207e5",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/c426b8066347594d975d612626add067652207e5",
      "created_at": "2025-09-03T22:45:49Z"
    },
    {
      "event": "commented",
      "id": 3252163887,
      "node_id": "IC_kwDOABII587B2BUv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3252163887",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T06:45:28Z",
      "updated_at": "2025-09-04T06:45:28Z",
      "author_association": "MEMBER",
      "body": "> There does not seem to be a way without signal handlers to delete the static, cached datadir when fuzzing is complete. Another issue is that multi-core fuzzing via AFL++ does not work because each worker will try to wipe the cached datadir (created via `-testdatadir` which wipes if the directory exists) which will cause other workers to crash if they are trying to copy it. I could not figure out a way for each worker to have their own cached datadir.\r\n\r\nIs my understanding correct that AFL will run init (create the static dir), then fork into several fuzz processes, which run for N iterations and then shut down and delete the static dir? (On the next re-fork, it will fail to find the static dir)?\r\n\r\nIf yes, a solution could be to lazy-init the static dir after init, after the fork. Also, you may have to use the pid (or os-rand) to name the static folder to avoid collisions.\r\n\r\nAs for deleting the dirs, maybe it is possible to spin up several testing setups at the same time:\r\n\r\n* One dummy testing setup to create a root dir, which is cleaned up\r\n* One testing setup living inside that root dir for the static folder (in a subfolder)\r\n* One testing setup living inside the root dir with a copy of the static folder\r\n\r\n(Not sure if this is possible, though)",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3252163887",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "commented",
      "id": 3252595782,
      "node_id": "IC_kwDOABII587B3qxG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3252595782",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T08:59:35Z",
      "updated_at": "2025-09-04T08:59:35Z",
      "author_association": "MEMBER",
      "body": "> Is my understanding correct that AFL will run init (create the static dir), then fork into several fuzz processes, which run for N iterations and then shut down and delete the static dir? (On the next re-fork, it will fail to find the static dir)?\r\n\r\nWe removed the `__AFL_INIT` call, so it will actually fork prior to `init`, so I think all that's needed is to randomize the static dir name as you suggested as well.",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3252595782",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "commented",
      "id": 3253868966,
      "node_id": "IC_kwDOABII587B8hmm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3253868966",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T13:58:27Z",
      "updated_at": "2025-09-04T13:59:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Is my understanding correct that AFL will run init (create the static dir), then fork into several fuzz processes, which run for N iterations and then shut down and delete the static dir? (On the next re-fork, it will fail to find the static dir)?\r\n\r\nMy description was a bit vague. Since the harness uses `-testdatadir` in init to create the static datadir, it does not get deleted in the TestingSetup destructor (by design of `-testdatadir`). Any time init is called, it will wipe the static datadir if it already exists. This can happen after N iterations (100,000 currently) or with a newly spawned worker after forking since the fork point is prior to init like @dergoegge mentioned. If the datadir is deleted while a fuzz iteration tries to copy the non-existent directory, it will crash.\r\n\r\n> a solution could be to lazy-init the static dir after init, after the fork\r\n\r\nI considered this, but I think this introduces some (slight) non-determinism as the directory may/may not exist?\r\n\r\n> Also, you may have to use the pid (or os-rand) to name the static folder to avoid collisions.\r\n\r\nYup, I agree. I think this randomization can only be done if the static datadir can be deleted at the end of fuzzing, otherwise there will be lots of these lying around?\r\n\r\n> As for deleting the dirs, maybe it is possible to spin up several testing setups at the same time:\r\n\r\nWhy is the dummy testing setup needed in this example? Could it instead just be two testing setups (one for the static datadir, one for the copied datadir)? I considered something similar to this as well where there is a `static TestingSetup` that gets destructed at the end of fuzzing (and wipes the static datadir) and one for each fuzz iteration (that gets destructed at the end of the iteration), but I was worried that the `static TestingSetup` would introduce more non-determinism? For example, what if this `static TestingSetup` has scheduling going on or is using the static datadir while we try to copy from it?",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3253868966",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "mentioned",
      "id": 19505729443,
      "node_id": "MEE_lADOABII587JjYsgzwAAAASKoc-j",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19505729443",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T13:58:29Z"
    },
    {
      "event": "subscribed",
      "id": 19505729484,
      "node_id": "SE_lADOABII587JjYsgzwAAAASKoc_M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19505729484",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T13:58:29Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19536531291,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASMd89b",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19536531291",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "c76f47547683afd305b091d955b44935f4be840a",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/c76f47547683afd305b091d955b44935f4be840a",
      "created_at": "2025-09-05T21:36:08Z"
    },
    {
      "event": "commented",
      "id": 3259826186,
      "node_id": "IC_kwDOABII587CTQAK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3259826186",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-05T21:41:11Z",
      "updated_at": "2025-09-05T21:42:03Z",
      "author_association": "CONTRIBUTOR",
      "body": "I was able to get AFL++ multi-core fuzzing to work by adding a static `FuzzedDirectoryWrapper` instance that deletes the passed path in its destructor as well as using a random element to each statically named datadir. Each instance is in the high 98-99% stability and does not crash after hitting 100,000 iterations (yay). I was not able to use multiple `TestingSetup`s at the same time without causing several panics due to assertions about globals. I will fix the lint, tidy jobs and also see if the deterministic-fuzz-coverage issues still pop up.",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3259826186",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19592095844,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASPx6hk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19592095844",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/0de9143aa06f19d9074fb8b651b5daa398922c46",
      "created_at": "2025-09-09T14:49:56Z"
    },
    {
      "event": "commented",
      "id": 3271483113,
      "node_id": "IC_kwDOABII587C_t7p",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3271483113",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-09T16:39:30Z",
      "updated_at": "2025-09-11T16:12:58Z",
      "author_association": "CONTRIBUTOR",
      "body": "There is non-determinism [here](https://github.com/bitcoin/bitcoin/blob/c0894a0a2be032cd9a5d5945643689230ab10255/src/node/blockstorage.cpp#L490-L493) because `m_dirty_blockindex` is `std::set<CBlockIndex*>` and sorts based on the pointer. This can be fixed by adding a function object that compares the block hashes. However, I did not know if this should be added just for fuzz code and I have not run benchmarks.\r\n\r\nAfter patching the above non-determinism locally, there is also non-determinism in the scheduler ~~because this fuzz test uses the scheduler. I am guessing this is due to the `RegisterValidationInterface` call in the fuzz test notifying when transactions are being added or removed, and blocks being mined.~~",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3271483113",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "ready_for_review",
      "id": 19594317030,
      "node_id": "RFRE_lADOABII587JjYsgzwAAAASP6Yzm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19594317030",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-09T16:40:39Z"
    },
    {
      "event": "reviewed",
      "id": 3212403908,
      "node_id": "PRR_kwDOABII586_eWTE",
      "url": null,
      "actor": null,
      "commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-12T15:29:56Z",
      "author_association": "MEMBER",
      "body": "Did a first pass, overall approach looks good to me",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#pullrequestreview-3212403908",
      "submitted_at": "2025-09-12T15:29:56Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19777388764,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASa0wDc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19777388764",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "19ca89b57704f6ca8fa52dd3b03f0ae4305ce70b",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/19ca89b57704f6ca8fa52dd3b03f0ae4305ce70b",
      "created_at": "2025-09-18T14:34:09Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19777887460,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASa2pzk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19777887460",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "d7e402c37ee2287eaa31c17a34c609b5b1c40a6d",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/d7e402c37ee2287eaa31c17a34c609b5b1c40a6d",
      "created_at": "2025-09-18T14:53:18Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19778339306,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASa4YHq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19778339306",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "dbc911fe07fb3d07468cd76ed3155163f10b3d19",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/dbc911fe07fb3d07468cd76ed3155163f10b3d19",
      "created_at": "2025-09-18T15:09:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19779756007,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASa9x_n",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19779756007",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "created_at": "2025-09-18T16:08:37Z"
    },
    {
      "event": "commented",
      "id": 3308381089,
      "node_id": "IC_kwDOABII587FMeOh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3308381089",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-18T16:18:17Z",
      "updated_at": "2025-09-18T16:31:48Z",
      "author_association": "CONTRIBUTOR",
      "body": "The latest push adds two commits:\r\n- a5619ea631bd8b93b4ef02a20abb8c1c0705d8e4 \"test: add setup_validation_interface_no_scheduler to TestOpts\"\r\n  - Disables the scheduler completely if set. This is needed because this harness creates a `TestingSetup` inside `FUZZ_TARGET` and scheduling a [promise](https://github.com/bitcoin/bitcoin/blob/74fa028da1ea38c5348f988464074899684cebcf/src/test/util/setup_common.cpp#L249) can be non-deterministic as the scheduler's `serviceQueue` may start with a non-empty `taskQueue`. This is not an issue in the other fuzz tests because their `TestingSetup` is created in .init and `ResetCoverageCounters` is called after.\r\n- e2f921458913bcbbe74115cdb2174b0ab31784f2 \"node: sort m_dirty_blockindex by block hash\"\r\n  - I am ok with this commit being removed and want to know what others think. This sorts by block hash rather than memory address and does introduce a slow-down in production code for no production benefit (I think because memory addresses are ~generally going to be increasing while inserting into `m_dirty_blockindex`, whereas sorting by block hash won't). I added it to show the change needed to make this harness fully non-deterministic. It is also possible to add an #ifdef so that it doesn't negatively affect production code, but I also don't want to set a precedent and litter the codebase with fuzz-specific macros. The sorting is needed as otherwise leveldb's MemTable will be non-deterministic across runs. I tried some alternatives, but this is the best I could come up with that made the `determinstic-fuzz-coverage` script happy.",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3308381089",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "reviewed",
      "id": 3291568683,
      "node_id": "PRR_kwDOABII587EMVor",
      "url": null,
      "actor": null,
      "commit_id": "a473ec650987c267328ccbb9b472e7db8e361a54",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-01T23:26:52Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#pullrequestreview-3291568683",
      "submitted_at": "2025-10-01T23:26:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20063857987,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAASr5i1D",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20063857987",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/ed813c48f826d083becf93c741b483774c850c86",
      "created_at": "2025-10-02T16:33:59Z"
    },
    {
      "event": "commented",
      "id": 3362128175,
      "node_id": "IC_kwDOABII587IZgEv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3362128175",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-02T16:43:25Z",
      "updated_at": "2025-10-02T16:43:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "e2f921458913bcbbe74115cdb2174b0ab31784f2 -> ed813c48f826d083becf93c741b483774c850c86:\r\n- Fixes an issue pointed out by @marcofleon with the PoW checks failing\r\n- Adds more descriptive commit messages ",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3362128175",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "mentioned",
      "id": 20064013191,
      "node_id": "MEE_lADOABII587JjYsgzwAAAASr6IuH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20064013191",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-02T16:43:26Z"
    },
    {
      "event": "subscribed",
      "id": 20064013229,
      "node_id": "SE_lADOABII587JjYsgzwAAAASr6Iut",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20064013229",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-02T16:43:26Z"
    },
    {
      "event": "reviewed",
      "id": 3310414827,
      "node_id": "PRR_kwDOABII587FUOvr",
      "url": null,
      "actor": null,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-07T14:29:40Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#pullrequestreview-3310414827",
      "submitted_at": "2025-10-07T14:29:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
    },
    {
      "event": "reviewed",
      "id": 3315685387,
      "node_id": "PRR_kwDOABII587FoVgL",
      "url": null,
      "actor": null,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-08T16:57:20Z",
      "author_association": "CONTRIBUTOR",
      "body": "Some possible discussion about ed813c48f826d083becf93c741b483774c850c86 for review club.",
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#pullrequestreview-3315685387",
      "submitted_at": "2025-10-08T16:57:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
    },
    {
      "event": "labeled",
      "id": 20610060436,
      "node_id": "LE_lADOABII587JjYsgzwAAAATMdJCU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20610060436",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-30T13:55:50Z",
      "label": {
        "name": "Fuzzing",
        "color": "0e8a16"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20613576990,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAATMqjke",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20613576990",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "a1b58a250866e51c905270020f7d30a66373b8f4",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/a1b58a250866e51c905270020f7d30a66373b8f4",
      "created_at": "2025-10-30T16:06:20Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20613743580,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAATMrMPc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20613743580",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "created_at": "2025-10-30T16:13:20Z"
    },
    {
      "event": "commented",
      "id": 3469378663,
      "node_id": "IC_kwDOABII587OyoRn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3469378663",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-30T18:08:05Z",
      "updated_at": "2025-10-30T18:08:23Z",
      "author_association": "CONTRIBUTOR",
      "body": "Latest push ed813c48f826d083becf93c741b483774c850c86 -> f2ce362:\r\n- implements `GetStrongRandBytes` per [comment](https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2410849029)\r\n- modifies `create_tx` to choose a mempool UTXO only sometimes instead of most of the time\r\n- modifies `create_block` to generate more than 2 non-coinbase transactions per feedback from review club",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3469378663",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "reviewed",
      "id": 3447750850,
      "node_id": "PRR_kwDOABII587NgIDC",
      "url": null,
      "actor": null,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-11-11T16:23:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept and approach ACK, thanks for tackling this.\n\nI like how you've extracted the first few commits that I could quickly get out of the way to continue to the more difficult ones - which are a bit too difficult though, it would help me personally if we could split it into smaller functional chunks, so that the reviewers are guided through the change. The commit messages could give extra context where needed. I don't think we should split by functions, but rather functionalities so that each commit could theoretically be merged if needed - we shouldn't depend on a future commit to understand a previous one.\n\nI have provided some hints and some further context for the `LevelDB` related changes. I think we should do the set stabilization in a dedicated PR, but you can also adjust it here so that it likely performs similarly to the original.",
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#pullrequestreview-3447750850",
      "submitted_at": "2025-11-11T16:23:04Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21105198301,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAATp98Td",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21105198301",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "created_at": "2025-11-21T20:42:38Z"
    },
    {
      "event": "commented",
      "id": 3564792110,
      "node_id": "IC_kwDOABII587Uemku",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3564792110",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T22:13:24Z",
      "updated_at": "2025-11-21T22:13:24Z",
      "author_association": "CONTRIBUTOR",
      "body": "Latest push f2ce3626a6a40b8688d711da1924db156dc2f02c -> 039c3aa breaks up the harness into more reviewable chunks. I forgot to add @stringintech as co-author on a commit during rebase, will address the next time I push up.\r\n\r\n",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3564792110",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "mentioned",
      "id": 21106409323,
      "node_id": "MEE_lADOABII587JjYsgzwAAAATqCj9r",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21106409323",
      "actor": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T22:13:26Z"
    },
    {
      "event": "subscribed",
      "id": 21106409352,
      "node_id": "SE_lADOABII587JjYsgzwAAAATqCj-I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21106409352",
      "actor": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T22:13:26Z"
    },
    {
      "event": "reviewed",
      "id": 3586886869,
      "node_id": "PRR_kwDOABII587Vy4zV",
      "url": null,
      "actor": null,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-17T11:20:26Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK. fuzzing direction look reasonable.\r\n",
      "user": {
        "login": "frankomosh",
        "id": 33951953,
        "node_id": "MDQ6VXNlcjMzOTUxOTUz",
        "avatar_url": "https://avatars.githubusercontent.com/u/33951953?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/frankomosh",
        "html_url": "https://github.com/frankomosh",
        "followers_url": "https://api.github.com/users/frankomosh/followers",
        "following_url": "https://api.github.com/users/frankomosh/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/frankomosh/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/frankomosh/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/frankomosh/subscriptions",
        "organizations_url": "https://api.github.com/users/frankomosh/orgs",
        "repos_url": "https://api.github.com/users/frankomosh/repos",
        "events_url": "https://api.github.com/users/frankomosh/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/frankomosh/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#pullrequestreview-3586886869",
      "submitted_at": "2025-12-17T11:20:26Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
    },
    {
      "event": "labeled",
      "id": 22000703101,
      "node_id": "LE_lADOABII587JjYsgzwAAAAUfWBZ9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22000703101",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-12T21:54:30Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 3740672736,
      "node_id": "IC_kwDOABII587e9iLg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3740672736",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-12T21:54:31Z",
      "updated_at": "2026-01-12T21:54:31Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--cf906140f33d8803c4a75a2196329ecb-->\nðŸ™ This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3740672736",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "unsubscribed",
      "id": 22058483835,
      "node_id": "UE_lADOABII587JjYsgzwAAAAUiycB7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22058483835",
      "actor": {
        "login": "frankomosh",
        "id": 33951953,
        "node_id": "MDQ6VXNlcjMzOTUxOTUz",
        "avatar_url": "https://avatars.githubusercontent.com/u/33951953?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/frankomosh",
        "html_url": "https://github.com/frankomosh",
        "followers_url": "https://api.github.com/users/frankomosh/followers",
        "following_url": "https://api.github.com/users/frankomosh/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/frankomosh/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/frankomosh/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/frankomosh/subscriptions",
        "organizations_url": "https://api.github.com/users/frankomosh/orgs",
        "repos_url": "https://api.github.com/users/frankomosh/repos",
        "events_url": "https://api.github.com/users/frankomosh/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/frankomosh/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-15T02:35:26Z"
    },
    {
      "event": "unsubscribed",
      "id": 22058484442,
      "node_id": "UE_lADOABII587JjYsgzwAAAAUiycLa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22058484442",
      "actor": {
        "login": "frankomosh",
        "id": 33951953,
        "node_id": "MDQ6VXNlcjMzOTUxOTUz",
        "avatar_url": "https://avatars.githubusercontent.com/u/33951953?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/frankomosh",
        "html_url": "https://github.com/frankomosh",
        "followers_url": "https://api.github.com/users/frankomosh/followers",
        "following_url": "https://api.github.com/users/frankomosh/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/frankomosh/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/frankomosh/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/frankomosh/subscriptions",
        "organizations_url": "https://api.github.com/users/frankomosh/orgs",
        "repos_url": "https://api.github.com/users/frankomosh/repos",
        "events_url": "https://api.github.com/users/frankomosh/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/frankomosh/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-15T02:35:29Z"
    },
    {
      "event": "commented",
      "id": 3778997001,
      "node_id": "IC_kwDOABII587hPusJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3778997001",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-21T15:44:12Z",
      "updated_at": "2026-01-21T15:44:12Z",
      "author_association": "CONTRIBUTOR",
      "body": "I plan to update this branch to get rid of the directory copying to instead reset the state similar to how the process_message(s) harnesses do it. I still need to hunt down some stability issues with the new approach in AFL++, but then I can push up. It gives a noticeable speedup since each iteration isn't creating a `TestingSetup` and also lends nicely to eventually being able to mock the underlying file store (which itself gives another ~2-3x speedup).",
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3778997001",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33300"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDUwNmI5MWQ3YWExMWE2MWNhMjVjOTc0OWU1MTc5MjY2MDk5MmMyOWU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/506b91d7aa11a61ca25c9749e51792660992c29e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/506b91d7aa11a61ca25c9749e51792660992c29e",
      "tree": {
        "sha": "525f394492196b30a955e0f968f0a6b096778fcd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/525f394492196b30a955e0f968f0a6b096778fcd"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3532e242134e8f92fb5fe99bbd024ed185839e8c",
          "sha": "3532e242134e8f92fb5fe99bbd024ed185839e8c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/3532e242134e8f92fb5fe99bbd024ed185839e8c"
        }
      ],
      "message": "fuzz: initial compact block fuzz harness\n\nAdds a fuzz harness cmpctblock to test BIP152 compact block relay.\nCurrently just sets mock time in a loop.",
      "committer": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2026-02-03T20:18:26Z"
      },
      "author": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2026-02-03T18:01:35Z"
      },
      "sha": "506b91d7aa11a61ca25c9749e51792660992c29e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA5ZjU0NzM4NGFmZjkwMzU5YjhhOWU5YTZmNDY5YjE0NjgzZmZiYWI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/09f547384aff90359b8a9e9a6f469b14683ffbab",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/09f547384aff90359b8a9e9a6f469b14683ffbab",
      "tree": {
        "sha": "0fdb32b5e5f50d99f8055e7588eac28cab9b0b37",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0fdb32b5e5f50d99f8055e7588eac28cab9b0b37"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/506b91d7aa11a61ca25c9749e51792660992c29e",
          "sha": "506b91d7aa11a61ca25c9749e51792660992c29e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/506b91d7aa11a61ca25c9749e51792660992c29e"
        }
      ],
      "message": "net, fuzz: move CMPCTBLOCK_VERSION to header, use in cmpctblock harness\n\nThe cmpctblock harness now adds peers and processes the sendcmpct message.",
      "committer": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2026-02-03T21:18:23Z"
      },
      "author": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2026-02-03T19:41:50Z"
      },
      "sha": "09f547384aff90359b8a9e9a6f469b14683ffbab"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ5YTNiZGNlNjEzYmI5N2QwMTZjNDEyMGZhMTE2NTUwMzQyNjJhMTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/49a3bdce613bb97d016c4120fa11655034262a15",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/49a3bdce613bb97d016c4120fa11655034262a15",
      "tree": {
        "sha": "5339c0440b3bd3fa4242e90b5ce89c5a10b61614",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5339c0440b3bd3fa4242e90b5ce89c5a10b61614"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/09f547384aff90359b8a9e9a6f469b14683ffbab",
          "sha": "09f547384aff90359b8a9e9a6f469b14683ffbab",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/09f547384aff90359b8a9e9a6f469b14683ffbab"
        }
      ],
      "message": "fuzz: create and send transactions in cmpctblock harness\n\nIf the mempool is modified at all (determined by a change in the sequence\ncounter), reset the rng, mempool, and the chainman for the next iteration.",
      "committer": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2026-02-03T21:42:19Z"
      },
      "author": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2026-02-03T21:42:19Z"
      },
      "sha": "49a3bdce613bb97d016c4120fa11655034262a15"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU3OWY2NjNmMTg5N2M5ZDU4NGIwNGZiZDBkZjhkMDliYjA2Zjk0NDA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/579f663f1897c9d584b04fbd0df8d09bb06f9440",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/579f663f1897c9d584b04fbd0df8d09bb06f9440",
      "tree": {
        "sha": "4e71ed4b5953c5cac33e92f56b4996c393f144ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4e71ed4b5953c5cac33e92f56b4996c393f144ad"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/49a3bdce613bb97d016c4120fa11655034262a15",
          "sha": "49a3bdce613bb97d016c4120fa11655034262a15",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/49a3bdce613bb97d016c4120fa11655034262a15"
        }
      ],
      "message": "fuzz: mine blocks and send headers for them in cmpctblock harness\n\nThe blocks may include mempool and non-mempool transactions. If the\nblock index was added to, reset the rng, mempool, and chainman. Also\nmove FinalizeHeader from p2p_headers_presync.cpp to util.h so that\nthe mining function can use it to create valid headers.",
      "committer": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2026-02-04T14:35:24Z"
      },
      "author": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2026-02-03T22:04:02Z"
      },
      "sha": "579f663f1897c9d584b04fbd0df8d09bb06f9440"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU1OGE5NzQ4N2Y4NWJlNzMxZGM2NjNlMjY0Y2FkNDliNGUyNDE4M2I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/558a97487f85be731dc663e264cad49b4e24183b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/558a97487f85be731dc663e264cad49b4e24183b",
      "tree": {
        "sha": "c026dc5f1847ed7d9bac1988c6475b72f0b58b3c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c026dc5f1847ed7d9bac1988c6475b72f0b58b3c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/579f663f1897c9d584b04fbd0df8d09bb06f9440",
          "sha": "579f663f1897c9d584b04fbd0df8d09bb06f9440",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/579f663f1897c9d584b04fbd0df8d09bb06f9440"
        }
      ],
      "message": "fuzz: send compact blocks in cmpctblock harness\n\nUsing an existing block or a newly created block, send a compact\nblock message to the target node. Some of the time, the harness\nwill prefill multiple transactions from the block. Adds a\nFuzzedCBlockHeaderAndShortTxIDs class that's used to populate the\nprotected prefilledtxn and shorttxids fields.",
      "committer": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2026-02-04T14:48:12Z"
      },
      "author": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2026-02-04T14:48:12Z"
      },
      "sha": "558a97487f85be731dc663e264cad49b4e24183b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDNjNTE1MTAyZjRlODNiNDExN2Y1MmQ3ZDBmZDQxYWFjNTk3NDBiMTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3c515102f4e83b4117f52d7d0fd41aac59740b16",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/3c515102f4e83b4117f52d7d0fd41aac59740b16",
      "tree": {
        "sha": "6f737b95400720cdcf045b70bd1163403d7e9138",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6f737b95400720cdcf045b70bd1163403d7e9138"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/558a97487f85be731dc663e264cad49b4e24183b",
          "sha": "558a97487f85be731dc663e264cad49b4e24183b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/558a97487f85be731dc663e264cad49b4e24183b"
        }
      ],
      "message": "fuzz: send blocktxn messages in cmpctblock harness\n\nSometimes, blindly take an existing block and choose random\ntransactions to request in a blocktxn message.",
      "committer": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2026-02-04T15:10:00Z"
      },
      "author": {
        "name": "Eugene Siegel",
        "email": "elzeigel@gmail.com",
        "date": "2026-02-04T15:10:00Z"
      },
      "sha": "3c515102f4e83b4117f52d7d0fd41aac59740b16"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 22543016650,
      "node_id": "HRFPE_lADOABII587JjYsgzwAAAAU_qyLK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22543016650",
      "actor": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "3c515102f4e83b4117f52d7d0fd41aac59740b16",
      "commit_url": "https://api.github.com/repos/Crypt-iQ/bitcoin/commits/3c515102f4e83b4117f52d7d0fd41aac59740b16",
      "created_at": "2026-02-04T23:21:24Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2341477921",
      "pull_request_review_id": 3212403908,
      "id": 2341477921,
      "node_id": "PRRC_kwDOABII586LkB4h",
      "diff_hunk": "@@ -0,0 +1,421 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount amount_fee = 1000;",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 40,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit\r\n\r\n```suggestion\r\nconst CAmount AMOUNT_FEE{1000};\r\n```",
      "created_at": "2025-09-11T15:35:20Z",
      "updated_at": "2025-09-12T15:29:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2341477921",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2341477921"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2341484545",
      "pull_request_review_id": 3212403908,
      "id": 2341484545,
      "node_id": "PRRC_kwDOABII586LkDgB",
      "diff_hunk": "@@ -0,0 +1,421 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount amount_fee = 1000;\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - amount_fee;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbaseTx;\n+        coinbaseTx.vin.resize(1);\n+        coinbaseTx.vin[0].prevout.SetNull();\n+        coinbaseTx.vout.resize(1);\n+        coinbaseTx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbaseTx.vout[0].nValue = COIN;\n+        coinbaseTx.vin[0].scriptSig = CScript() << height << OP_0;\n+        block->vtx.push_back(MakeTransactionRef(coinbaseTx));\n+\n+        // Add a tx from mempool. Since we do not include parents, it may be an invalid block.\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            LOCK(setup->m_node.mempool->cs);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx();\n+            block->vtx.push_back(mempool_tx);\n+        }\n+\n+        // Create and add a (possibly invalid) tx that is not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            CTransactionRef non_mempool_tx = create_tx();\n+            if (non_mempool_tx != nullptr) {\n+                block->vtx.push_back(non_mempool_tx);\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+        FinalizeHeader(header, *setup->m_node.chainman);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+\n+        BlockInfo blockinfo;\n+        blockinfo.block = block;\n+        blockinfo.hash = block->GetHash();\n+        blockinfo.height = height;\n+\n+        return blockinfo;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo blockinfo = create_block();\n+                    cblock = blockinfo.block;\n+                    info.push_back(blockinfo);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctBlock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, baseCmpctBlock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctBlock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctBlock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;\n+                net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, baseCmpctBlock);\n+            },\n+            [&]() {\n+                // Send a blocktxn message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Fetch an existing block and randomly choose transactions to send over.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                const BlockInfo& block_info = info[index];\n+                BlockTransactions block_txn;\n+                block_txn.blockhash = block_info.hash;\n+                std::shared_ptr<CBlock> cblock = block_info.block;\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (num_txs > 1) {\n+                    for (size_t i = 1; i < num_txs; i++) {\n+                        if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                        block_txn.txn.push_back(cblock->vtx[i]);\n+                    }\n+                }\n+\n+                net_msg = NetMsg::Make(NetMsgType::BLOCKTXN, block_txn);\n+            },\n+            [&]() {\n+                // Send a headers message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Choose an existing block and send a HEADERS message for it.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                CBlock block = *info[index].block;",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 359,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\r\n                CBlock block = *info[index].block;\r\n                block.vtx.clear();\r\n```\r\n\r\nThe headers message is a vector of blocks without transactions, so I think you should clear the copy of the block here? Although, technically this doesn't matter because there's only one header in the vector being sent, so the following txs are just ignored.",
      "created_at": "2025-09-11T15:37:06Z",
      "updated_at": "2025-09-12T15:29:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2341484545",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2341484545"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 359,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2341516465",
      "pull_request_review_id": 3212403908,
      "id": 2341516465,
      "node_id": "PRRC_kwDOABII586LkLSx",
      "diff_hunk": "@@ -0,0 +1,421 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount amount_fee = 1000;\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - amount_fee;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbaseTx;\n+        coinbaseTx.vin.resize(1);\n+        coinbaseTx.vin[0].prevout.SetNull();\n+        coinbaseTx.vout.resize(1);\n+        coinbaseTx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbaseTx.vout[0].nValue = COIN;\n+        coinbaseTx.vin[0].scriptSig = CScript() << height << OP_0;\n+        block->vtx.push_back(MakeTransactionRef(coinbaseTx));\n+\n+        // Add a tx from mempool. Since we do not include parents, it may be an invalid block.\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            LOCK(setup->m_node.mempool->cs);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx();\n+            block->vtx.push_back(mempool_tx);\n+        }\n+\n+        // Create and add a (possibly invalid) tx that is not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            CTransactionRef non_mempool_tx = create_tx();\n+            if (non_mempool_tx != nullptr) {\n+                block->vtx.push_back(non_mempool_tx);\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+        FinalizeHeader(header, *setup->m_node.chainman);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+\n+        BlockInfo blockinfo;\n+        blockinfo.block = block;\n+        blockinfo.hash = block->GetHash();\n+        blockinfo.height = height;\n+\n+        return blockinfo;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo blockinfo = create_block();\n+                    cblock = blockinfo.block;\n+                    info.push_back(blockinfo);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctBlock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, baseCmpctBlock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctBlock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctBlock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 320,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\r\n                CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;\r\n```\r\n\r\nnit: there are few instances of camel case usage here. Our convention is to use snake case (see dev notes).",
      "created_at": "2025-09-11T15:44:19Z",
      "updated_at": "2025-09-12T15:29:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2341516465",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2341516465"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 320,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2359949673",
      "pull_request_review_id": 3240553602,
      "id": 2359949673,
      "node_id": "PRRC_kwDOABII586Mqflp",
      "diff_hunk": "@@ -0,0 +1,421 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount amount_fee = 1000;",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 40,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "in_reply_to_id": 2341477921,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Thanks, done.",
      "created_at": "2025-09-18T15:38:30Z",
      "updated_at": "2025-09-18T15:38:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2359949673",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2359949673"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2359951971",
      "pull_request_review_id": 3240556299,
      "id": 2359951971,
      "node_id": "PRRC_kwDOABII586MqgJj",
      "diff_hunk": "@@ -0,0 +1,421 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount amount_fee = 1000;\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - amount_fee;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbaseTx;\n+        coinbaseTx.vin.resize(1);\n+        coinbaseTx.vin[0].prevout.SetNull();\n+        coinbaseTx.vout.resize(1);\n+        coinbaseTx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbaseTx.vout[0].nValue = COIN;\n+        coinbaseTx.vin[0].scriptSig = CScript() << height << OP_0;\n+        block->vtx.push_back(MakeTransactionRef(coinbaseTx));\n+\n+        // Add a tx from mempool. Since we do not include parents, it may be an invalid block.\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            LOCK(setup->m_node.mempool->cs);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx();\n+            block->vtx.push_back(mempool_tx);\n+        }\n+\n+        // Create and add a (possibly invalid) tx that is not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            CTransactionRef non_mempool_tx = create_tx();\n+            if (non_mempool_tx != nullptr) {\n+                block->vtx.push_back(non_mempool_tx);\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+        FinalizeHeader(header, *setup->m_node.chainman);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+\n+        BlockInfo blockinfo;\n+        blockinfo.block = block;\n+        blockinfo.hash = block->GetHash();\n+        blockinfo.height = height;\n+\n+        return blockinfo;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo blockinfo = create_block();\n+                    cblock = blockinfo.block;\n+                    info.push_back(blockinfo);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctBlock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, baseCmpctBlock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctBlock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctBlock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;\n+                net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, baseCmpctBlock);\n+            },\n+            [&]() {\n+                // Send a blocktxn message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Fetch an existing block and randomly choose transactions to send over.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                const BlockInfo& block_info = info[index];\n+                BlockTransactions block_txn;\n+                block_txn.blockhash = block_info.hash;\n+                std::shared_ptr<CBlock> cblock = block_info.block;\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (num_txs > 1) {\n+                    for (size_t i = 1; i < num_txs; i++) {\n+                        if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                        block_txn.txn.push_back(cblock->vtx[i]);\n+                    }\n+                }\n+\n+                net_msg = NetMsg::Make(NetMsgType::BLOCKTXN, block_txn);\n+            },\n+            [&]() {\n+                // Send a headers message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Choose an existing block and send a HEADERS message for it.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                CBlock block = *info[index].block;",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 359,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "in_reply_to_id": 2341484545,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Ah nice catch, I completely missed this. Done.",
      "created_at": "2025-09-18T15:38:56Z",
      "updated_at": "2025-09-18T15:38:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2359951971",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2359951971"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 359,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2359953034",
      "pull_request_review_id": 3240557763,
      "id": 2359953034,
      "node_id": "PRRC_kwDOABII586MqgaK",
      "diff_hunk": "@@ -0,0 +1,421 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount amount_fee = 1000;\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - amount_fee;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbaseTx;\n+        coinbaseTx.vin.resize(1);\n+        coinbaseTx.vin[0].prevout.SetNull();\n+        coinbaseTx.vout.resize(1);\n+        coinbaseTx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbaseTx.vout[0].nValue = COIN;\n+        coinbaseTx.vin[0].scriptSig = CScript() << height << OP_0;\n+        block->vtx.push_back(MakeTransactionRef(coinbaseTx));\n+\n+        // Add a tx from mempool. Since we do not include parents, it may be an invalid block.\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            LOCK(setup->m_node.mempool->cs);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx();\n+            block->vtx.push_back(mempool_tx);\n+        }\n+\n+        // Create and add a (possibly invalid) tx that is not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            CTransactionRef non_mempool_tx = create_tx();\n+            if (non_mempool_tx != nullptr) {\n+                block->vtx.push_back(non_mempool_tx);\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+        FinalizeHeader(header, *setup->m_node.chainman);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+\n+        BlockInfo blockinfo;\n+        blockinfo.block = block;\n+        blockinfo.hash = block->GetHash();\n+        blockinfo.height = height;\n+\n+        return blockinfo;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo blockinfo = create_block();\n+                    cblock = blockinfo.block;\n+                    info.push_back(blockinfo);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctBlock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, baseCmpctBlock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctBlock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctBlock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs baseCmpctBlock = cmpctBlock;",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 320,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "0de9143aa06f19d9074fb8b651b5daa398922c46",
      "in_reply_to_id": 2341516465,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Thanks, I believe I've fixed all of the camel case.",
      "created_at": "2025-09-18T15:39:13Z",
      "updated_at": "2025-09-18T15:39:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2359953034",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2359953034"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 320,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2396228628",
      "pull_request_review_id": 3291568683,
      "id": 2396228628,
      "node_id": "PRRC_kwDOABII586O04wU",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - AMOUNT_FEE;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbase_tx;\n+        coinbase_tx.vin.resize(1);\n+        coinbase_tx.vin[0].prevout.SetNull();\n+        coinbase_tx.vin[0].scriptSig = CScript() << height << OP_0;\n+        coinbase_tx.vout.resize(1);\n+        coinbase_tx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbase_tx.vout[0].nValue = COIN;\n+        block->vtx.push_back(MakeTransactionRef(coinbase_tx));\n+\n+        // Add a tx from mempool. Since we do not include parents, it may be an invalid block.\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            LOCK(setup->m_node.mempool->cs);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx();\n+            block->vtx.push_back(mempool_tx);\n+        }\n+\n+        // Create and add a (possibly invalid) tx that is not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            CTransactionRef non_mempool_tx = create_tx();\n+            if (non_mempool_tx != nullptr) {\n+                block->vtx.push_back(non_mempool_tx);\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+        FinalizeHeader(header, *setup->m_node.chainman);",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 261,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "a473ec650987c267328ccbb9b472e7db8e361a54",
      "in_reply_to_id": null,
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Shouldn't `*block` be passed in here instead of `header`? Right now, I think the block just ends up with the random nonce from when the header was created. Although this still works half the time with the simplifed PoW check. Also, calling `GetHash()` on the header includes the merkle root, so finalizing the header should be after we calculate the merkle root below.",
      "created_at": "2025-10-01T23:26:52Z",
      "updated_at": "2025-10-01T23:26:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2396228628",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2396228628"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2398415091",
      "pull_request_review_id": 3294089595,
      "id": 2398415091,
      "node_id": "PRRC_kwDOABII586O9Ojz",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - AMOUNT_FEE;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbase_tx;\n+        coinbase_tx.vin.resize(1);\n+        coinbase_tx.vin[0].prevout.SetNull();\n+        coinbase_tx.vin[0].scriptSig = CScript() << height << OP_0;\n+        coinbase_tx.vout.resize(1);\n+        coinbase_tx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbase_tx.vout[0].nValue = COIN;\n+        block->vtx.push_back(MakeTransactionRef(coinbase_tx));\n+\n+        // Add a tx from mempool. Since we do not include parents, it may be an invalid block.\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            LOCK(setup->m_node.mempool->cs);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx();\n+            block->vtx.push_back(mempool_tx);\n+        }\n+\n+        // Create and add a (possibly invalid) tx that is not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            CTransactionRef non_mempool_tx = create_tx();\n+            if (non_mempool_tx != nullptr) {\n+                block->vtx.push_back(non_mempool_tx);\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+        FinalizeHeader(header, *setup->m_node.chainman);",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 261,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "a473ec650987c267328ccbb9b472e7db8e361a54",
      "in_reply_to_id": 2396228628,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Ah yes, nice catch. I was wondering why the PoW check was still failing so many times in the coverage.",
      "created_at": "2025-10-02T11:24:39Z",
      "updated_at": "2025-10-02T11:24:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2398415091",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2398415091"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2399412490",
      "pull_request_review_id": 3295464134,
      "id": 2399412490,
      "node_id": "PRRC_kwDOABII586PBCEK",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - AMOUNT_FEE;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbase_tx;\n+        coinbase_tx.vin.resize(1);\n+        coinbase_tx.vin[0].prevout.SetNull();\n+        coinbase_tx.vin[0].scriptSig = CScript() << height << OP_0;\n+        coinbase_tx.vout.resize(1);\n+        coinbase_tx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbase_tx.vout[0].nValue = COIN;\n+        block->vtx.push_back(MakeTransactionRef(coinbase_tx));\n+\n+        // Add a tx from mempool. Since we do not include parents, it may be an invalid block.\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            LOCK(setup->m_node.mempool->cs);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx();\n+            block->vtx.push_back(mempool_tx);\n+        }\n+\n+        // Create and add a (possibly invalid) tx that is not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            CTransactionRef non_mempool_tx = create_tx();\n+            if (non_mempool_tx != nullptr) {\n+                block->vtx.push_back(non_mempool_tx);\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+        FinalizeHeader(header, *setup->m_node.chainman);",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 261,
      "commit_id": "e2f921458913bcbbe74115cdb2174b0ab31784f2",
      "original_commit_id": "a473ec650987c267328ccbb9b472e7db8e361a54",
      "in_reply_to_id": 2396228628,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in ba89cdd93ee39e884c924ae12737dd06639cee8f, verified that the `CheckBlockHeader` call in validation.cpp no longer fails.",
      "created_at": "2025-10-02T16:41:44Z",
      "updated_at": "2025-10-02T16:41:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2399412490",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2399412490"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2410849029",
      "pull_request_review_id": 3310414827,
      "id": 2410849029,
      "node_id": "PRRC_kwDOABII586PsqMF",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 1,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "When fuzzing on macOS (Apple Silicon), I ran into lots of crashes when copying the cached dir into the destination:\r\n\r\n```\r\nlibc++abi: terminating due to uncaught exception of type std::__1::__fs::filesystem::filesystem_error: filesystem error: in copy_file: File exists [\"/var/folders/wc/3l6l_0b92zzg54v6rmvqqn300000gn/T/test_common bitcoin/cmpctblock/6c5e38c6dcfbc2607321/regtest/blocks/xor.dat\"] [\"/var/folders/wc/3l6l_0b92zzg54v6rmvqqn300000gn/T/cmpctblock_cachedca12974312651650d6b0/datadir/regtest/blocks/xor.dat\"]\r\n```\r\n\r\nThe issue is that the destination dir may already exist before `TryCreateDirectories()`, and it happens when the AFL++ fork server is enabled (it does not happen when fuzzing with `AFL_NO_FORKSRV=1`). It appears that forked processes are running into collisions when generating the random path (`rand_path()`) for creating the destination dir, and when we switch to strong randomness (like how the static dir name is generated), the issue seems to be resolved:\r\n```diff\r\ndiff --git a/src/test/util/setup_common.cpp b/src/test/util/setup_common.cpp\r\nindex e9768d4c5c..ac477caa62 100644\r\n--- a/src/test/util/setup_common.cpp\r\n+++ b/src/test/util/setup_common.cpp\r\n@@ -164,8 +164,9 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\r\n         // tests, such as the fuzz tests to run in several processes at the\r\n         // same time, add a random element to the path. Keep it small enough to\r\n         // avoid a MAX_PATH violation on Windows.\r\n-        const auto rand{HexStr(g_rng_temp_path.randbytes(10))};\r\n-        return fs::temp_directory_path() / TEST_DIR_PATH_ELEMENT / test_name / rand;\r\n+        std::vector<unsigned char> random_path_suffix(10);\r\n+        GetStrongRandBytes(random_path_suffix);\r\n+        return fs::temp_directory_path() / TEST_DIR_PATH_ELEMENT / test_name / HexStr(random_path_suffix);\r\n     };\r\n \r\n     if (m_node.args->IsArgSet(\"-testdatadir\")) {\r\n```",
      "created_at": "2025-10-07T14:29:40Z",
      "updated_at": "2025-10-07T14:29:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2410849029",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2410849029"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2411373516",
      "pull_request_review_id": 3311161304,
      "id": 2411373516,
      "node_id": "PRRC_kwDOABII586PuqPM",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 1,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2410849029,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Are you fuzzing with persistent mode?",
      "created_at": "2025-10-07T17:29:08Z",
      "updated_at": "2025-10-07T17:29:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2411373516",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2411373516"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2411570436",
      "pull_request_review_id": 3311443359,
      "id": 2411570436,
      "node_id": "PRRC_kwDOABII586PvaUE",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 1,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2410849029,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Yes. I am compiling using `afl-clang-fast++` (it seems that other options are either unavailable or obsolete on macOS). However, I just added a `#undef __AFL_LOOP` at the top of `fuzz.cpp` to disable persistent mode (I made sure I no longer see the `[+] Persistent mode binary detected` log when running) and reverted the above change to `rand_path()`, but the same crash still occurs.",
      "created_at": "2025-10-07T18:43:57Z",
      "updated_at": "2025-10-07T18:43:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2411570436",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2411570436"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2413540219",
      "pull_request_review_id": 3314374913,
      "id": 2413540219,
      "node_id": "PRRC_kwDOABII586P27N7",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 1,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2410849029,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Think this is because the child processes have the same `g_rng_temp_path` so they create the same directory. Will need to see if `GetStrongRandBytes` introduces non-determinism. I'm confused why fuzzing on debian didn't bring this up.",
      "created_at": "2025-10-08T11:27:43Z",
      "updated_at": "2025-10-08T11:27:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2413540219",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2413540219"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414395854",
      "pull_request_review_id": 3315607374,
      "id": 2414395854,
      "node_id": "PRRC_kwDOABII586P6MHO",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 1,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2410849029,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Thanks for pointing this out, `GetStrongRandBytes` does not introduce non-determinism. I'll change the next time I push up by making `rand_path` accept a `bool strong` so that the original behavior when `-testdatadir` is set is unchanged. ",
      "created_at": "2025-10-08T16:17:00Z",
      "updated_at": "2025-10-08T16:17:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2414395854",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414395854"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414451232",
      "pull_request_review_id": 3315685387,
      "id": 2414451232,
      "node_id": "PRRC_kwDOABII586P6Zog",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 147,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ba89cdd93ee39e884c924ae12737dd06639cee8f",
      "in_reply_to_id": null,
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "As we discussed a bit offline, increasing the number of peers here to greater than 3 should be enough to hit some of the missing \"eviction\" logic in `MaybeSetPeerAsAnnouncingHeaderAndIDs`. Maybe increasing to 8 peers would be fine? Although not sure if that would test anything more (somewhere else) than if it were 4.",
      "created_at": "2025-10-08T16:40:44Z",
      "updated_at": "2025-10-08T16:57:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2414451232",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414451232"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414480315",
      "pull_request_review_id": 3315685387,
      "id": 2414480315,
      "node_id": "PRRC_kwDOABII586P6gu7",
      "diff_hunk": "@@ -487,7 +492,7 @@ bool BlockManager::WriteBlockIndexDB()\n     }\n     std::vector<const CBlockIndex*> vBlocks;\n     vBlocks.reserve(m_dirty_blockindex.size());\n-    for (std::set<CBlockIndex*>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {\n+    for (std::set<CBlockIndex*, CBlockIndexBlockHashComparator>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {",
      "path": "src/node/blockstorage.cpp",
      "position": 1,
      "original_position": 17,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": null,
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I feel like I might be overlooking something here, but could we keep `m_dirty_blockindex` the same and then if `EnableFuzzDeterminism()` just sort `vBlocks` by hash before calling `WriteBatchSync()`?\r\n\r\nI guess I'm asking is there a reason why `m_dirty_blockindex` needs to be sorted by hash from the beginning vs right before the write.",
      "created_at": "2025-10-08T16:53:40Z",
      "updated_at": "2025-10-08T16:57:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2414480315",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414480315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 496,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414740159",
      "pull_request_review_id": 3316104414,
      "id": 2414740159,
      "node_id": "PRRC_kwDOABII586P7gK_",
      "diff_hunk": "@@ -487,7 +492,7 @@ bool BlockManager::WriteBlockIndexDB()\n     }\n     std::vector<const CBlockIndex*> vBlocks;\n     vBlocks.reserve(m_dirty_blockindex.size());\n-    for (std::set<CBlockIndex*>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {\n+    for (std::set<CBlockIndex*, CBlockIndexBlockHashComparator>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {",
      "path": "src/node/blockstorage.cpp",
      "position": 1,
      "original_position": 17,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2414480315,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Answered in the review club, also posting here:\r\n\r\nWithout this commit, leveldb's `MemTable` is non-deterministic since it depends on insert order. If we sort `vBlocks` right before calling `WriteBatchSync`, then the leveldb non-determinism is solved, but the number of times we call the comparison function varies since the initial ordering before sorting varies across runs of the same input. That means we need to sort when we insert into `m_dirty_blockindex` as the order of `CBlockIndex*` we insert here _is_ deterministic (i.e. we'll always insert A then B, even if it may sort as {A, B} or {B, A}). This is definitely confusing, I used pencil and paper to work this out.\r\n\r\nI did a simple benchmark and it showed ~O(n log n) slowdown. I was not sure how to bench this in a production scenario or what a realistic load here would look like. I guess it's possible to bench two different IBDs, but there may be other non-IBD scenarios?",
      "created_at": "2025-10-08T18:49:32Z",
      "updated_at": "2025-10-08T18:53:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2414740159",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414740159"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 496,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414764467",
      "pull_request_review_id": 3316138578,
      "id": 2414764467,
      "node_id": "PRRC_kwDOABII586P7mGz",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 147,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ba89cdd93ee39e884c924ae12737dd06639cee8f",
      "in_reply_to_id": 2414451232,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Will compare the coverage from increasing to 4 vs increasing to 8.",
      "created_at": "2025-10-08T19:00:49Z",
      "updated_at": "2025-10-08T19:00:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2414764467",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2414764467"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2417231848",
      "pull_request_review_id": 3319614699,
      "id": 2417231848,
      "node_id": "PRRC_kwDOABII586QFAfo",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 1,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2410849029,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Since the crash I explained wasn't observed by others, I doubted whether it was actually coming from multiple child processes running simultaneously or from missed data dir cleanup. So I added a bunch of logs (including pid and parent pid in each) to investigate this further and found this after reading the logs for multiple runs:\r\n\r\nI observed that AFL++ ran one worker process at a time, not multiple workers in parallel. Each worker created a static cached directory once, then ran multiple fuzz iterations sequentially; each iteration creating and destroying a temporary data directory. This worked fine until a worker died unexpectedly (not yet sure why), leaving behind both its last temp data directory and its static cached directory without cleanup.\r\n\r\nEach new worker had the same `g_rng_temp_path` as the previous worker, so it generated the same temp directory paths. When the next worker started, it faced the copy crash at exactly the same iteration where the previous worker died. For example, if process A died before completing iteration N, it left behind the temp data directory at that iteration. Process B then faced the `fs::copy()` crash at exactly iteration N, since the generated sequence of temp data directory paths was identical. This worker also died, leaving behind another orphaned static cached directory. This flow would repeat, eventually filling the disk with orphaned directories.",
      "created_at": "2025-10-09T15:54:49Z",
      "updated_at": "2025-10-09T15:54:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2417231848",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2417231848"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2417263019",
      "pull_request_review_id": 3319657981,
      "id": 2417263019,
      "node_id": "PRRC_kwDOABII586QFIGr",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 1,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2410849029,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": ">  I'm confused why fuzzing on debian didn't bring this up.\r\n\r\nYeah, I am also confused by this. While my case wasn't exactly a multi-process execution issue, it seems a true multi-process execution should observe the same crash because of the same `g_rng_temp_path` across processes.",
      "created_at": "2025-10-09T16:06:44Z",
      "updated_at": "2025-10-09T16:08:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2417263019",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2417263019"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2417331534",
      "pull_request_review_id": 3319756908,
      "id": 2417331534,
      "node_id": "PRRC_kwDOABII586QFY1O",
      "diff_hunk": "@@ -184,8 +195,27 @@ BasicTestingSetup::BasicTestingSetup(const ChainType chainType, TestOpts opts)\n         fs::remove_all(m_path_root);\n         if (!TryCreateDirectories(m_path_root)) ExitFailure(\"Cannot create test data directory\");\n \n-        // Print the test directory name if custom.\n-        std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        // Print the test directory name if custom and not fuzzing.\n+        if (!EnableFuzzDeterminism()) {\n+            std::cout << \"Test directory (will not be deleted): \" << m_path_root << std::endl;\n+        }\n+    } else if (m_node.args->IsArgSet(\"-fuzzcopydatadir\")) {\n+        // Copy passed directory\n+        fs::path cached_dir{m_node.args->GetPathArg(\"-fuzzcopydatadir\")};\n+        if (cached_dir.empty()) ExitFailure(\"-fuzzcopydatadir argument is empty, please specify a path\");\n+\n+        // Traverse lower into /datadir\n+        cached_dir = cached_dir / \"datadir\";\n+\n+        m_path_root = rand_path();\n+        TryCreateDirectories(m_path_root);\n+\n+        // Copy the cached directory into the newly created temporary directory.\n+        fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);",
      "path": "src/test/util/setup_common.cpp",
      "position": 1,
      "original_position": 75,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2410849029,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Some signals are not specifically handled by the fuzzer, so if it creates a datadir (i.e. `process_messages`) and you Ctrl-C, it will leave it around instead of deleting it in `~BasicTestingSetup`. In any case, not using `g_rng_temp_path` seems like the right choice.",
      "created_at": "2025-10-09T16:30:35Z",
      "updated_at": "2025-10-09T16:32:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2417331534",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2417331534"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": 210,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2458728270",
      "pull_request_review_id": 3374344921,
      "id": 2458728270,
      "node_id": "PRRC_kwDOABII586SjTdO",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 147,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ba89cdd93ee39e884c924ae12737dd06639cee8f",
      "in_reply_to_id": 2414451232,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Neither 4 nor 8 helped hit the case, will look into it more.",
      "created_at": "2025-10-24T04:03:42Z",
      "updated_at": "2025-10-24T04:03:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2458728270",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2458728270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478495348",
      "pull_request_review_id": 3400166664,
      "id": 2478495348,
      "node_id": "PRRC_kwDOABII586TutZ0",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 147,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ba89cdd93ee39e884c924ae12737dd06639cee8f",
      "in_reply_to_id": 2414451232,
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Non-blocking I'd say, so could be a followup once it's figured out.\r\n\r\nStrange though, now I'm curious.",
      "created_at": "2025-10-30T15:11:25Z",
      "updated_at": "2025-10-30T15:12:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2478495348",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478495348"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478627740",
      "pull_request_review_id": 3400349765,
      "id": 2478627740,
      "node_id": "PRRC_kwDOABII586TvNuc",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 3; ++i) {",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 147,
      "commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "original_commit_id": "ba89cdd93ee39e884c924ae12737dd06639cee8f",
      "in_reply_to_id": 2414451232,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think outbound connections are getting disconnected for some reason, latest coverage is [here](https://crypt-iq.github.io/fuzz_coverage_reports/cmpctblock-aflpp-inputs-10292025/). On a local branch, I modified the harness to return early if any of the test nodes did not complete the version-verack handshake, but coverage is still missing.",
      "created_at": "2025-10-30T15:48:43Z",
      "updated_at": "2025-10-30T16:07:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2478627740",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478627740"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2510713428",
      "pull_request_review_id": 3443445791,
      "id": 2510713428,
      "node_id": "PRRC_kwDOABII586VpnJU",
      "diff_hunk": "@@ -487,7 +492,7 @@ bool BlockManager::WriteBlockIndexDB()\n     }\n     std::vector<const CBlockIndex*> vBlocks;\n     vBlocks.reserve(m_dirty_blockindex.size());\n-    for (std::set<CBlockIndex*>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {\n+    for (std::set<CBlockIndex*, CBlockIndexBlockHashComparator>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {",
      "path": "src/node/blockstorage.cpp",
      "position": 1,
      "original_position": 17,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2414480315,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Ran this patch against master with -reindex (which puts lots of entries in `vBlocks`) and noticed no slowdown.\r\n\r\ncc @l0rinc, do you have any opinions about this? We need this for deterministic fuzzing, we can also wrap this in a fuzz-specific macro.",
      "created_at": "2025-11-10T14:07:08Z",
      "updated_at": "2025-11-10T14:07:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2510713428",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2510713428"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 496,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2513989045",
      "pull_request_review_id": 3447750850,
      "id": 2513989045,
      "node_id": "PRRC_kwDOABII586V2G21",
      "diff_hunk": "@@ -143,13 +143,6 @@ CBlock ConsumeBlock(FuzzedDataProvider& fuzzed_data_provider, const uint256& pre\n     return block;\n }\n \n-void FinalizeHeader(CBlockHeader& header, const ChainstateManager& chainman)",
      "path": "src/test/fuzz/p2p_headers_presync.cpp",
      "position": 12,
      "original_position": 4,
      "commit_id": "3c515102f4e83b4117f52d7d0fd41aac59740b16",
      "original_commit_id": "a54e759d050705fd36b89cb7f3e8d7b0a9772e24",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "do we still need `#include <pow.h>` here after the move?",
      "created_at": "2025-11-11T12:04:01Z",
      "updated_at": "2025-11-11T16:23:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2513989045",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2513989045"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 146,
      "original_line": 146,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514018993",
      "pull_request_review_id": 3447750850,
      "id": 2514018993,
      "node_id": "PRRC_kwDOABII586V2OKx",
      "diff_hunk": "@@ -136,6 +136,13 @@ static inline bool copy_file(const path& from, const path& to, copy_options opti\n     return std::filesystem::copy_file(from, to, options);\n }\n \n+// Disallow implicit std::string conversion for copy to avoid locale-dependent\n+// encoding on Windows. This is currently only used in fuzzing.\n+static inline void copy(const path& from, const path& to, copy_options options)",
      "path": "src/util/fs.h",
      "position": 1,
      "original_position": 6,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "8515594b3b716d05a89b9fef36dfe7e8032d19c7",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "8515594b3b716d05a89b9fef36dfe7e8032d19c7\r\n\r\nDo we still need this after https://github.com/bitcoin/bitcoin/pull/33550?\r\n\r\n> This is currently only used in fuzzing.\r\n\r\nAre we adding dead code in this commit? It's hard to judge if a solution is accurate if we see it before the problem is presented - can we make the question obvious before we provide the answer?\r\n\r\nAnd more concretely: my IDE is confused about the usage of this even at the tip - would it be possible to invalidate the conversions you don't want instead, maybe something like:\r\n```C++\r\nstatic void copy(const std::string&, const path&, copy_options) = delete;\r\nstatic void copy(const path&, const std::string&, copy_options) = delete;\r\nstatic void copy(const std::string&, const std::string&, copy_options) = delete;\r\n```\r\n\r\nnit: `inline` is implicit",
      "created_at": "2025-11-11T12:15:40Z",
      "updated_at": "2025-11-11T16:23:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2514018993",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514018993"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514060602",
      "pull_request_review_id": 3447750850,
      "id": 2514060602,
      "node_id": "PRRC_kwDOABII586V2YU6",
      "diff_hunk": "@@ -287,6 +287,8 @@ ChainTestingSetup::ChainTestingSetup(const ChainType chainType, TestOpts opts)\n             m_node.scheduler->scheduleFromNow([&promise] { promise.set_value(); }, 0ms);\n             promise.get_future().wait();\n         }\n+    } else if (opts.setup_validation_interface_no_scheduler) {\n+        m_node.validation_signals = std::make_unique<ValidationSignals>(std::make_unique<util::ImmediateTaskRunner>());",
      "path": "src/test/util/setup_common.cpp",
      "position": 1,
      "original_position": 5,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "71719d172e3a435dd983293fc9da6a08974f8b01",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I have the same problem in `71719d172e3a435dd983293fc9da6a08974f8b01` - we're introducing dead code, I don't have a way to judge if this is indeed the correct solution, since up to this point there wasn't any pain that this alleviates.\r\nLooking at the commit I see that `setup_validation_interface_no_scheduler` is always `false` in this commit therefore we can delete the code - and I have to check the next commits and come back here to reevaluate that.\r\nCan we add a simpler fuzz test which needs this in the same commit that introduces it - and extend the test with other functionality separately.",
      "created_at": "2025-11-11T12:29:34Z",
      "updated_at": "2025-11-11T16:23:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2514060602",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514060602"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 289,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514076456",
      "pull_request_review_id": 3447750850,
      "id": 2514076456,
      "node_id": "PRRC_kwDOABII586V2cMo",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 4; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - AMOUNT_FEE;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbase_tx;\n+        coinbase_tx.vin.resize(1);\n+        coinbase_tx.vin[0].prevout.SetNull();\n+        coinbase_tx.vin[0].scriptSig = CScript() << height << OP_0;\n+        coinbase_tx.vout.resize(1);\n+        coinbase_tx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbase_tx.vout[0].nValue = COIN;\n+        block->vtx.push_back(MakeTransactionRef(coinbase_tx));\n+\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            // Add txns from the mempool. Since we do not include parents, it may be an invalid block.\n+            size_t num_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, mempool_size);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+\n+            LOCK(setup->m_node.mempool->cs);\n+            for (size_t i = random_idx; i < random_idx + num_txns; ++i) {\n+                CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[i % mempool_size].second->GetSharedTx();\n+                block->vtx.push_back(mempool_tx);\n+            }\n+        }\n+\n+        // Create and add (possibly invalid) txns that are not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            size_t new_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 10);\n+            for (size_t i = 0; i < new_txns; ++i) {\n+                CTransactionRef non_mempool_tx = create_tx();\n+                if (non_mempool_tx != nullptr) {\n+                    block->vtx.push_back(non_mempool_tx);\n+                }\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+        FinalizeHeader(*block, *setup->m_node.chainman);\n+\n+        BlockInfo block_info;\n+        block_info.block = block;\n+        block_info.hash = block->GetHash();\n+        block_info.height = height;\n+\n+        return block_info;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo block_info = create_block();\n+                    cblock = block_info.block;\n+                    info.push_back(block_info);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctblock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctblock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctblock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+            },\n+            [&]() {\n+                // Send a blocktxn message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Fetch an existing block and randomly choose transactions to send over.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                const BlockInfo& block_info = info[index];\n+                BlockTransactions block_txn;\n+                block_txn.blockhash = block_info.hash;\n+                std::shared_ptr<CBlock> cblock = block_info.block;\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (num_txs > 1) {\n+                    for (size_t i = 1; i < num_txs; i++) {\n+                        if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                        block_txn.txn.push_back(cblock->vtx[i]);\n+                    }\n+                }\n+\n+                net_msg = NetMsg::Make(NetMsgType::BLOCKTXN, block_txn);\n+            },\n+            [&]() {\n+                // Send a headers message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Choose an existing block and send a HEADERS message for it.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                std::vector<CBlock> headers;\n+                headers.emplace_back(info[index].block->GetBlockHeader());\n+\n+                net_msg = NetMsg::Make(NetMsgType::HEADERS, TX_WITH_WITNESS(headers));\n+            },\n+            [&]() {\n+                // Send a sendcmpct message, optionally setting hb mode.\n+                bool hb = fuzzed_data_provider.ConsumeBool();\n+                net_msg = NetMsg::Make(NetMsgType::SENDCMPCT, /*high_bandwidth=*/hb, /*version=*/CMPCTBLOCKS_VERSION);\n+            },\n+            [&]() {\n+                // Mine a block, but don't send it over p2p.\n+                BlockInfo block_info = create_block();\n+                info.push_back(block_info);\n+                set_net_msg = false;\n+            },\n+            [&]() {\n+                // Send a txn over p2p.\n+                CTransactionRef tx = create_tx();\n+                if (tx == nullptr) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                net_msg = NetMsg::Make(NetMsgType::TX, TX_WITH_WITNESS(*tx));\n+            },\n+            [&]() {\n+                // Set mock time.\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+                } else {\n+                    // Set to tip's time so the CanDirectFetch check can pass in net_processing.\n+                    const uint64_t tip_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetBlockTime());\n+                    SetMockTime(tip_time);\n+                }\n+\n+                set_net_msg = false;\n+            });\n+\n+        if (!set_net_msg) {\n+            continue;\n+        }\n+\n+        CNode& random_node = *PickValue(fuzzed_data_provider, peers);\n+        connman.FlushSendBuffer(random_node);\n+        (void)connman.ReceiveMsgFrom(random_node, std::move(net_msg));\n+\n+        bool more_work{true};\n+        while (more_work) {\n+            random_node.fPauseSend = false;\n+\n+            try {\n+                more_work = connman.ProcessMessagesOnce(random_node);\n+            } catch (const std::ios_base::failure&) {\n+            }",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 422,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "1cfe4f0355879519b9f6aa52e971d757dd76a6d5",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\r\n                // Expected for truncated/invalid fuzzed messages; swallow to continue exercising code paths.\r\n                // TODO validate that the error is something expected, otherwise anything can happen here\r\n            }\r\n```",
      "created_at": "2025-11-11T12:33:59Z",
      "updated_at": "2025-11-11T16:24:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2514076456",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514076456"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": 419,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 422,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514085576",
      "pull_request_review_id": 3447750850,
      "id": 2514085576,
      "node_id": "PRRC_kwDOABII586V2ebI",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 4; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 199,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "1cfe4f0355879519b9f6aa52e971d757dd76a6d5",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: seems excessive to add a helper for a single usage here:\r\n```suggestion\r\n        const CAmount amount_in = Assert(amount_view.GetCoin(outpoint))->out.nValue;\r\n```",
      "created_at": "2025-11-11T12:36:50Z",
      "updated_at": "2025-11-11T16:23:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2514085576",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514085576"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 199,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514157586",
      "pull_request_review_id": 3447750850,
      "id": 2514157586,
      "node_id": "PRRC_kwDOABII586V2wAS",
      "diff_hunk": "",
      "path": "src/test/util/setup_common.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "5a0f0c3fac47053f7d0245ac0b005d4b26cacd48",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "5a0f0c3fac47053f7d0245ac0b005d4b26cacd48 nit:\r\n```patch\r\n- Since the caller is BasicTestingSetup() is not aware of the random path element\r\n+ Since the caller of BasicTestingSetup() is not aware of the random path element\r\n",
      "created_at": "2025-11-11T13:00:36Z",
      "updated_at": "2025-11-11T16:23:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2514157586",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514157586"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514170270",
      "pull_request_review_id": 3447750850,
      "id": 2514170270,
      "node_id": "PRRC_kwDOABII586V2zGe",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 4; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - AMOUNT_FEE;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbase_tx;\n+        coinbase_tx.vin.resize(1);\n+        coinbase_tx.vin[0].prevout.SetNull();\n+        coinbase_tx.vin[0].scriptSig = CScript() << height << OP_0;\n+        coinbase_tx.vout.resize(1);\n+        coinbase_tx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbase_tx.vout[0].nValue = COIN;\n+        block->vtx.push_back(MakeTransactionRef(coinbase_tx));\n+\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            // Add txns from the mempool. Since we do not include parents, it may be an invalid block.\n+            size_t num_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, mempool_size);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+\n+            LOCK(setup->m_node.mempool->cs);\n+            for (size_t i = random_idx; i < random_idx + num_txns; ++i) {\n+                CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[i % mempool_size].second->GetSharedTx();\n+                block->vtx.push_back(mempool_tx);\n+            }\n+        }\n+\n+        // Create and add (possibly invalid) txns that are not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            size_t new_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 10);\n+            for (size_t i = 0; i < new_txns; ++i) {\n+                CTransactionRef non_mempool_tx = create_tx();\n+                if (non_mempool_tx != nullptr) {\n+                    block->vtx.push_back(non_mempool_tx);\n+                }\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+        FinalizeHeader(*block, *setup->m_node.chainman);\n+\n+        BlockInfo block_info;\n+        block_info.block = block;\n+        block_info.hash = block->GetHash();\n+        block_info.height = height;\n+\n+        return block_info;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo block_info = create_block();\n+                    cblock = block_info.block;\n+                    info.push_back(block_info);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctblock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctblock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctblock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+            },\n+            [&]() {",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 343,
      "original_position": 332,
      "commit_id": "3c515102f4e83b4117f52d7d0fd41aac59740b16",
      "original_commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This commit is huge, it's hard to review it meaningfully. Can we separate some of these cases to independent commits that can provide more context?",
      "created_at": "2025-11-11T13:05:16Z",
      "updated_at": "2025-11-11T16:23:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2514170270",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514170270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 343,
      "original_line": 343,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514213312",
      "pull_request_review_id": 3447750850,
      "id": 2514213312,
      "node_id": "PRRC_kwDOABII586V29nA",
      "diff_hunk": "@@ -101,6 +102,7 @@ void SetupCommonTestArgs(ArgsManager& argsman)\n {\n     argsman.AddArg(\"-testdatadir\", strprintf(\"Custom data directory (default: %s<random_string>)\", fs::PathToString(fs::temp_directory_path() / TEST_DIR_PATH_ELEMENT / \"\")),\n                    ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-fuzzcopydatadir\", \"Copies the passed data directory to a temporary directory to use during a single fuzz iteration\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);",
      "path": "src/test/util/setup_common.cpp",
      "position": 1,
      "original_position": 12,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "5a0f0c3fac47053f7d0245ac0b005d4b26cacd48",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "5a0f0c3fac47053f7d0245ac0b005d4b26cacd48 commit is also quite big, can we split by functionality instead? I would prefer the commits telling a story, to each make be self-contained as much as possible, to make sense on their own as far as it's reasonable. Can we split this one by features, e.g. adding `rand_path ` to be able to specify strong random, maybe `fuzzcopydatadir` param and usage next, `EnableFuzzDeterminism` last - or something similar",
      "created_at": "2025-11-11T13:19:42Z",
      "updated_at": "2025-11-11T16:23:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2514213312",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514213312"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514623942",
      "pull_request_review_id": 3447750850,
      "id": 2514623942,
      "node_id": "PRRC_kwDOABII586V4h3G",
      "diff_hunk": "@@ -487,7 +492,7 @@ bool BlockManager::WriteBlockIndexDB()\n     }\n     std::vector<const CBlockIndex*> vBlocks;\n     vBlocks.reserve(m_dirty_blockindex.size());\n-    for (std::set<CBlockIndex*>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {\n+    for (std::set<CBlockIndex*, CBlockIndexBlockHashComparator>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {",
      "path": "src/node/blockstorage.cpp",
      "position": 1,
      "original_position": 17,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2414480315,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Is my understanding correct that we want to remove useless jitter that doesn't actually increase code coverage but confuses the fuzzer, such as the internal `Random` in leveldb's skiplist?\nIt seems to me that should be deterministic though, as long as we're actually giving it the same work on the same thread: https://github.com/bitcoin/bitcoin/blob/a7e80676104b5c90c5b5e3bfab815d55a9061052/src/leveldb/db/skiplist.h#L330\n\nAnd (as I think you also mentioned) the write and iteration order should be deterministic, regardless of the inputs:\n```patch\ndiff --git a/src/test/dbwrapper_tests.cpp b/src/test/dbwrapper_tests.cpp\n--- a/src/test/dbwrapper_tests.cpp\t(revision c44048159359f8a7335a00b768548b351b4181a5)\n+++ b/src/test/dbwrapper_tests.cpp\t(date 1762874342278)\n@@ -422,5 +422,29 @@\n     BOOST_CHECK(fs::exists(lockPath));\n }\n \n+BOOST_AUTO_TEST_CASE(leveldb_memtable_rand256_sorted)\n+{\n+    const fs::path path{m_args.GetDataDirBase() / \"dbwrapper_memtable_sorted\"};\n+    CDBWrapper dbw{{.path = path, .cache_bytes = 1_MiB, .memory_only = true, .wipe_data = true}};\n+\n+    // Write a batch of random keys.\n+    CDBBatch batch{dbw};\n+    for (int i{0}; i < 10; ++i) {\n+        auto key = m_rng.rand256().ToString().substr(0, 10);\n+        BOOST_TEST_MESSAGE(\"Adding: \" + key);\n+        batch.Write(key, /*value=*/0);\n+    }\n+    dbw.WriteBatch(batch);\n+\n+    // Get iterator and collect all keys as they are stored.\n+    std::unique_ptr<CDBIterator> it{dbw.NewIterator()};\n+    for (std::string prev{\"\"}; it->Valid(); it->Next()) {\n+        std::string key;\n+        BOOST_REQUIRE(it->GetKey(key));\n+        BOOST_TEST_MESSAGE(\"Got: \" + key);\n+        BOOST_CHECK_LE(prev, key);\n+        prev = key;\n+    }\n+}\n \n BOOST_AUTO_TEST_SUITE_END()\n```\n\nThese identity sets would indeed cause cross-run nondeterminism.\nWe've probably done it since we don't expect to have duplicate objects, we just care about pointer-equality for otherwise volatile instances and we don't really care about order, just set properties. \nBut having sorted sets of pointers does introduce needless jitter that I agree we should stabilize - and we seem to have quite a few:\n```bash\ngit grep -E 'std::set<[^>]+\\*>'\nsrc/node/blockstorage.cpp:    for (std::set<CBlockIndex*>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {\nsrc/node/blockstorage.h:    std::set<CBlockIndex*> m_dirty_blockindex;\nsrc/rpc/blockchain.cpp:    std::set<const CBlockIndex*> setOrphans;\nsrc/rpc/blockchain.cpp:    std::set<const CBlockIndex*> setPrevs;\nsrc/rpc/blockchain.cpp:    for (std::set<const CBlockIndex*>::iterator it = setOrphans.begin(); it != setOrphans.end(); ++it) {\nsrc/test/fuzz/txgraph.cpp:        std::set<std::vector<TxGraph::Ref*>> clusters;\nsrc/txgraph.cpp:    std::set<const Cluster*> expected_clusters[MAX_LEVELS];\nsrc/txgraph.cpp:        std::set<const Cluster*> actual_clusters;\nsrc/wallet/rpc/wallet.cpp:            std::set<ScriptPubKeyMan*> spkms;\nsrc/wallet/wallet.cpp:std::set<ScriptPubKeyMan*> CWallet::GetActiveScriptPubKeyMans() const\nsrc/wallet/wallet.cpp:    std::set<ScriptPubKeyMan*> spk_mans;\nsrc/wallet/wallet.cpp:std::set<ScriptPubKeyMan*> CWallet::GetAllScriptPubKeyMans() const\nsrc/wallet/wallet.cpp:    std::set<ScriptPubKeyMan*> spk_mans;\nsrc/wallet/wallet.cpp:std::set<ScriptPubKeyMan*> CWallet::GetScriptPubKeyMans(const CScript& script) const\nsrc/wallet/wallet.cpp:    std::set<ScriptPubKeyMan*> spk_mans;\nsrc/wallet/wallet.h:    std::set<ScriptPubKeyMan*> GetActiveScriptPubKeyMans() const;\nsrc/wallet/wallet.h:    std::set<ScriptPubKeyMan*> GetAllScriptPubKeyMans() const;\nsrc/wallet/wallet.h:    std::set<ScriptPubKeyMan*> GetScriptPubKeyMans(const CScript& script) const;\n```\n\nI think we should tackle these in a separate PR. In other cases we either have dedicated sorting methods for the red-black trees (e.g. https://github.com/bitcoin/bitcoin/pull/33637) or hash them and use a hashset (e.g. https://github.com/bitcoin/bitcoin/pull/30442). In this particular case sorting could help in seeding the MemTable since we'd be sorting already sorted content - as long as iteration is not a lot slower we should keep an `std::set`, but I would definitely add a dedicated sorter to avoid jitter (but I would prefer doing it in a separate PR and for all other cases as well. I will try something like that)",
      "created_at": "2025-11-11T15:16:52Z",
      "updated_at": "2025-11-11T16:23:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2514623942",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514623942"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 496,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514673448",
      "pull_request_review_id": 3447750850,
      "id": 2514673448,
      "node_id": "PRRC_kwDOABII586V4t8o",
      "diff_hunk": "@@ -180,6 +180,11 @@ bool CBlockIndexHeightOnlyComparator::operator()(const CBlockIndex* pa, const CB\n     return pa->nHeight < pb->nHeight;\n }\n \n+bool CBlockIndexBlockHashComparator::operator()(const CBlockIndex* pa, const CBlockIndex* pb) const\n+{\n+    return UintToArith256(pa->GetBlockHash()) < UintToArith256(pb->GetBlockHash());",
      "path": "src/node/blockstorage.cpp",
      "position": 1,
      "original_position": 6,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "What was your reason for instantiating new objects just for comparison, is it just to make sure you're sorting backwards?\r\n\r\n```suggestion\r\n    return pa->GetBlockHash().Compare(pb->GetBlockHash());\r\n```\r\nor\r\n```suggestion\r\n    return pa->GetBlockHash() < pb->GetBlockHash();\r\n```\r\n\r\nI don't think that's necessary, the above should likely be safe as well.\r\n\r\nBut since it's a lot faster to compare pointers for equality (which seems like an important feature, it's why most of these are a set in the first place I assume) and since that's stable across runs as well, we can likely optimize further to:\r\n```suggestion\r\n    return pa != pb && pa->GetBlockHash() < pb->GetBlockHash();\r\n```\r\n\r\nAnd if we inline this to the header it should be just as fast as pointers.",
      "created_at": "2025-11-11T15:31:21Z",
      "updated_at": "2025-11-12T11:49:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2514673448",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514673448"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514702311",
      "pull_request_review_id": 3447750850,
      "id": 2514702311,
      "node_id": "PRRC_kwDOABII586V40_n",
      "diff_hunk": "@@ -95,6 +95,10 @@ struct CBlockIndexHeightOnlyComparator {\n     bool operator()(const CBlockIndex* pa, const CBlockIndex* pb) const;\n };\n \n+struct CBlockIndexBlockHashComparator {\n+    bool operator()(const CBlockIndex* pa, const CBlockIndex* pb) const;",
      "path": "src/node/blockstorage.h",
      "position": 1,
      "original_position": 5,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'd just move this to header for easier inlinability, https://github.com/bitcoin/bitcoin/pull/33637 indicates that's generally a lot more performant",
      "created_at": "2025-11-11T15:38:26Z",
      "updated_at": "2025-11-11T16:23:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2514702311",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514702311"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2523928262",
      "pull_request_review_id": 3460377929,
      "id": 2523928262,
      "node_id": "PRRC_kwDOABII586WcBbG",
      "diff_hunk": "@@ -487,7 +492,7 @@ bool BlockManager::WriteBlockIndexDB()\n     }\n     std::vector<const CBlockIndex*> vBlocks;\n     vBlocks.reserve(m_dirty_blockindex.size());\n-    for (std::set<CBlockIndex*>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {\n+    for (std::set<CBlockIndex*, CBlockIndexBlockHashComparator>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {",
      "path": "src/node/blockstorage.cpp",
      "position": 1,
      "original_position": 17,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2414480315,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Is my understanding correct that we want to remove useless jitter that doesn't actually increase code coverage but confuses the fuzzer, such as the internal Random in leveldb's skiplist?\r\n\r\nIt depends on the specific fuzz engine as far as _exactly_ what happens (e.g. how it prioritizes or drops executed inputs). Speaking generally, if the fuzzer sees increased coverage (due to non-determinism) it could prioritize a no-coverage-gain input and if it sees decreased coverage it could de-prioritize an input where it shouldn't.\r\n\r\nTo clarify if I was unclear above, this non-determinism doesn't show up in what hits the disk (as it's a k-v store), only in the `MemTable` which depends on the order that we write to it.\r\n\r\n> I think we should tackle these in a separate PR.\r\n\r\nThis sounds fine to me and I can drop the commit here. https://github.com/bitcoin/bitcoin/pull/33469 is another case where a set of pointers caused non-determinism during fuzzing.\r\n\r\n<details>\r\n<summary> contrib/devtools/deterministic-fuzz-coverage output without this commit </summary>\r\n\r\n```\r\ndiff --git a/Users/eugenesiegel/btc/bitcoin/build_fuzzcov/fuzz_det_cov.show.t1.a.txt b/Users/eugenesiegel/btc/bitcoin/build_fuzzcov/fuzz_det_cov.show.t1.b.txt\r\nindex 8389ec5527..68708cc9fc 100644\r\n--- a/Users/eugenesiegel/btc/bitcoin/build_fuzzcov/fuzz_det_cov.show.t1.a.txt\r\n+++ b/Users/eugenesiegel/btc/bitcoin/build_fuzzcov/fuzz_det_cov.show.t1.b.txt\r\n@@ -61402,15 +61402,15 @@\r\n    45|      0|  return \"leveldb.InternalKeyComparator\";\r\n    46|      0|}\r\n    47|       |\r\n-   48|  6.11k|int InternalKeyComparator::Compare(const Slice& akey, const Slice& bkey) const {\r\n+   48|  6.01k|int InternalKeyComparator::Compare(const Slice& akey, const Slice& bkey) const {\r\n    49|       |  // Order by:\r\n    50|       |  //    increasing user key (according to user-supplied comparator)\r\n    51|       |  //    decreasing sequence number\r\n    52|       |  //    decreasing type (though sequence# should be enough to disambiguate)\r\n-   53|  6.11k|  int r = user_comparator_->Compare(ExtractUserKey(akey), ExtractUserKey(bkey));\r\n-   54|  6.11k|  if (r == 0) {\r\n+   53|  6.01k|  int r = user_comparator_->Compare(ExtractUserKey(akey), ExtractUserKey(bkey));\r\n+   54|  6.01k|  if (r == 0) {\r\n   ------------------\r\n-  |  Branch (54:7): [True: 61, False: 6.05k]\r\n+  |  Branch (54:7): [True: 61, False: 5.95k]\r\n   ------------------\r\n    55|     61|    const uint64_t anum = DecodeFixed64(akey.data() + akey.size() - 8);\r\n    56|     61|    const uint64_t bnum = DecodeFixed64(bkey.data() + bkey.size() - 8);\r\n@@ -61426,8 +61426,8 @@\r\n    60|     51|      r = +1;\r\n    61|     51|    }\r\n    62|     61|  }\r\n-   63|  6.11k|  return r;\r\n-   64|  6.11k|}\r\n+   63|  6.01k|  return r;\r\n+   64|  6.01k|}\r\n    65|       |\r\n    66|       |void InternalKeyComparator::FindShortestSeparator(std::string* start,\r\n    67|     10|                                                  const Slice& limit) const {\r\n@@ -61620,10 +61620,10 @@\r\n    92|       |bool ParseInternalKey(const Slice& internal_key, ParsedInternalKey* result);\r\n    93|       |\r\n    94|       |// Returns the user key portion of an internal key.\r\n-   95|  13.1k|inline Slice ExtractUserKey(const Slice& internal_key) {\r\n-   96|  13.1k|  assert(internal_key.size() >= 8);\r\n-   97|  13.1k|  return Slice(internal_key.data(), internal_key.size() - 8);\r\n-   98|  13.1k|}\r\n+   95|  12.9k|inline Slice ExtractUserKey(const Slice& internal_key) {\r\n+   96|  12.9k|  assert(internal_key.size() >= 8);\r\n+   97|  12.9k|  return Slice(internal_key.data(), internal_key.size() - 8);\r\n+   98|  12.9k|}\r\n    99|       |\r\n   100|       |// A comparator for internal keys that uses a specified comparator for\r\n   101|       |// the user key portion and breaks ties by decreasing sequence number.\r\n@@ -62498,12 +62498,12 @@\r\n    11|       |\r\n    12|       |namespace leveldb {\r\n    13|       |\r\n-   14|  11.1k|static Slice GetLengthPrefixedSlice(const char* data) {\r\n-   15|  11.1k|  uint32_t len;\r\n-   16|  11.1k|  const char* p = data;\r\n-   17|  11.1k|  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\r\n-   18|  11.1k|  return Slice(p, len);\r\n-   19|  11.1k|}\r\n+   14|  10.9k|static Slice GetLengthPrefixedSlice(const char* data) {\r\n+   15|  10.9k|  uint32_t len;\r\n+   16|  10.9k|  const char* p = data;\r\n+   17|  10.9k|  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\r\n+   18|  10.9k|  return Slice(p, len);\r\n+   19|  10.9k|}\r\n    20|       |\r\n    21|       |MemTable::MemTable(const InternalKeyComparator& comparator)\r\n    22|      4|    : comparator_(comparator), refs_(0), table_(comparator_, &arena_) {}\r\n@@ -62513,12 +62513,12 @@\r\n    26|      5|size_t MemTable::ApproximateMemoryUsage() { return arena_.MemoryUsage(); }\r\n    27|       |\r\n    28|       |int MemTable::KeyComparator::operator()(const char* aptr,\r\n-   29|  4.93k|                                        const char* bptr) const {\r\n+   29|  4.83k|                                        const char* bptr) const {\r\n    30|       |  // Internal keys are encoded as length-prefixed strings.\r\n-   31|  4.93k|  Slice a = GetLengthPrefixedSlice(aptr);\r\n-   32|  4.93k|  Slice b = GetLengthPrefixedSlice(bptr);\r\n-   33|  4.93k|  return comparator.Compare(a, b);\r\n-   34|  4.93k|}\r\n+   31|  4.83k|  Slice a = GetLengthPrefixedSlice(aptr);\r\n+   32|  4.83k|  Slice b = GetLengthPrefixedSlice(bptr);\r\n+   33|  4.83k|  return comparator.Compare(a, b);\r\n+   34|  4.83k|}\r\n    35|       |\r\n    36|       |// Encode a suitable internal key target for \"target\" and return it.\r\n    37|       |// Uses *scratch as scratch space, and the returned pointer will point\r\n@@ -62883,12 +62883,12 @@\r\n   150|       |\r\n   151|       |  // Accessors/mutators for links.  Wrapped in methods so we can\r\n   152|       |  // add the appropriate barriers as necessary.\r\n-  153|  5.55k|  Node* Next(int n) {\r\n-  154|  5.55k|    assert(n >= 0);\r\n+  153|  5.24k|  Node* Next(int n) {\r\n+  154|  5.24k|    assert(n >= 0);\r\n   155|       |    // Use an 'acquire load' so that we observe a fully initialized\r\n   156|       |    // version of the returned Node.\r\n-  157|  5.55k|    return next_[n].load(std::memory_order_acquire);\r\n-  158|  5.55k|  }\r\n+  157|  5.24k|    return next_[n].load(std::memory_order_acquire);\r\n+  158|  5.24k|  }\r\n   159|    587|  void SetNext(int n, Node* x) {\r\n   160|    587|    assert(n >= 0);\r\n   161|       |    // Use a 'release store' so that anybody who reads through this\r\n@@ -62995,15 +62995,15 @@\r\n   252|    414|}\r\n   253|       |\r\n   254|       |template <typename Key, class Comparator>\r\n-  255|  5.13k|bool SkipList<Key, Comparator>::KeyIsAfterNode(const Key& key, Node* n) const {\r\n+  255|  4.82k|bool SkipList<Key, Comparator>::KeyIsAfterNode(const Key& key, Node* n) const {\r\n   256|       |  // null n is considered infinite\r\n-  257|  5.13k|  return (n != nullptr) && (compare_(n->key, key) < 0);\r\n-                                         ^4.52k\r\n+  257|  4.82k|  return (n != nullptr) && (compare_(n->key, key) < 0);\r\n+                                         ^4.42k\r\n   ------------------\r\n-  |  Branch (257:10): [True: 4.52k, False: 613]\r\n-  |  Branch (257:28): [True: 3.25k, False: 1.26k]\r\n+  |  Branch (257:10): [True: 4.42k, False: 403]\r\n+  |  Branch (257:28): [True: 2.94k, False: 1.47k]\r\n   ------------------\r\n-  258|  5.13k|}\r\n+  258|  4.82k|}\r\n   259|       |\r\n   260|       |template <typename Key, class Comparator>\r\n   261|       |typename SkipList<Key, Comparator>::Node*\r\n@@ -63011,18 +63011,18 @@\r\n   263|    443|                                              Node** prev) const {\r\n   264|    443|  Node* x = head_;\r\n   265|    443|  int level = GetMaxHeight() - 1;\r\n-  266|  5.13k|  while (true) {\r\n+  266|  4.82k|  while (true) {\r\n   ------------------\r\n   |  Branch (266:10): [Folded - Ignored]\r\n   ------------------\r\n-  267|  5.13k|    Node* next = x->Next(level);\r\n-  268|  5.13k|    if (KeyIsAfterNode(key, next)) {\r\n+  267|  4.82k|    Node* next = x->Next(level);\r\n+  268|  4.82k|    if (KeyIsAfterNode(key, next)) {\r\n   ------------------\r\n-  |  Branch (268:9): [True: 3.25k, False: 1.87k]\r\n+  |  Branch (268:9): [True: 2.94k, False: 1.87k]\r\n   ------------------\r\n   269|       |      // Keep searching in this list\r\n-  270|  3.25k|      x = next;\r\n-  271|  3.25k|    } else {\r\n+  270|  2.94k|      x = next;\r\n+  271|  2.94k|    } else {\r\n   272|  1.87k|      if (prev != nullptr) prev[level] = x;\r\n                                          ^1.85k\r\n   ------------------\r\n@@ -63038,7 +63038,7 @@\r\n   277|  1.43k|        level--;\r\n   278|  1.43k|      }\r\n   279|  1.87k|    }\r\n-  280|  5.13k|  }\r\n+  280|  4.82k|  }\r\n   281|    443|}\r\n   282|       |\r\n   283|       |template <typename Key, class Comparator>\r\n@@ -68240,7 +68240,7 @@\r\n    31|    945|  Slice() : data_(\"\"), size_(0) {}\r\n    32|       |\r\n    33|       |  // Create a slice that refers to d[0,n-1].\r\n-   34|  27.6k|  Slice(const char* d, size_t n) : data_(d), size_(n) {}\r\n+   34|  27.2k|  Slice(const char* d, size_t n) : data_(d), size_(n) {}\r\n    35|       |\r\n    36|       |  // Create a slice that refers to the contents of \"s\"\r\n    37|  2.16k|  Slice(const std::string& s) : data_(s.data()), size_(s.size()) {}\r\n@@ -68253,10 +68253,10 @@\r\n    44|       |  Slice& operator=(const Slice&) = default;\r\n    45|       |\r\n    46|       |  // Return a pointer to the beginning of the referenced data\r\n-   47|  22.1k|  const char* data() const { return data_; }\r\n+   47|  21.9k|  const char* data() const { return data_; }\r\n    48|       |\r\n    49|       |  // Return the length (in bytes) of the referenced data\r\n-   50|  40.5k|  size_t size() const { return size_; }\r\n+   50|  40.1k|  size_t size() const { return size_; }\r\n    51|       |\r\n    52|       |  // Return true iff the length of the referenced data is zero\r\n    53|    433|  bool empty() const { return size_ == 0; }\r\n@@ -68322,16 +68322,16 @@\r\n   101|       |\r\n   102|     26|inline bool operator!=(const Slice& x, const Slice& y) { return !(x == y); }\r\n   103|       |\r\n-  104|  6.41k|inline int Slice::compare(const Slice& b) const {\r\n-  105|  6.41k|  const size_t min_len = (size_ < b.size_) ? size_ : b.size_;\r\n-                                                           ^227    ^6.19k\r\n+  104|  6.31k|inline int Slice::compare(const Slice& b) const {\r\n+  105|  6.31k|  const size_t min_len = (size_ < b.size_) ? size_ : b.size_;\r\n+                                                           ^227    ^6.09k\r\n   ------------------\r\n-  |  Branch (105:26): [True: 227, False: 6.19k]\r\n+  |  Branch (105:26): [True: 227, False: 6.09k]\r\n   ------------------\r\n-  106|  6.41k|  int r = memcmp(data_, b.data_, min_len);\r\n-  107|  6.41k|  if (r == 0) {\r\n+  106|  6.31k|  int r = memcmp(data_, b.data_, min_len);\r\n+  107|  6.31k|  if (r == 0) {\r\n   ------------------\r\n-  |  Branch (107:7): [True: 89, False: 6.32k]\r\n+  |  Branch (107:7): [True: 89, False: 6.22k]\r\n   ------------------\r\n   108|     89|    if (size_ < b.size_)\r\n   ------------------\r\n@@ -68344,8 +68344,8 @@\r\n   ------------------\r\n   111|      0|      r = +1;\r\n   112|     89|  }\r\n-  113|  6.41k|  return r;\r\n-  114|  6.41k|}\r\n+  113|  6.31k|  return r;\r\n+  114|  6.31k|}\r\n   115|       |\r\n   116|       |}  // namespace leveldb\r\n   117|       |\r\n@@ -72351,22 +72351,22 @@\r\n   106|       |const char* GetVarint32PtrFallback(const char* p, const char* limit,\r\n   107|       |                                   uint32_t* value);\r\n   108|       |inline const char* GetVarint32Ptr(const char* p, const char* limit,\r\n-  109|  11.9k|                                  uint32_t* value) {\r\n-  110|  11.9k|  if (p < limit) {\r\n+  109|  11.7k|                                  uint32_t* value) {\r\n+  110|  11.7k|  if (p < limit) {\r\n   ------------------\r\n-  |  Branch (110:7): [True: 11.9k, False: 4]\r\n+  |  Branch (110:7): [True: 11.7k, False: 4]\r\n   ------------------\r\n-  111|  11.9k|    uint32_t result = *(reinterpret_cast<const uint8_t*>(p));\r\n-  112|  11.9k|    if ((result & 128) == 0) {\r\n+  111|  11.7k|    uint32_t result = *(reinterpret_cast<const uint8_t*>(p));\r\ndiff --git a/Users/eugenesiegel/btc/bitcoin/build_fuzzcov/fuzz_det_cov.show.t0.a.txt b/Users/eugenesiegel/btc/bitcoin/build_fuzzcov/fuzz_det_cov.show.t0.b.txt\r\nindex 209490c47e..67c0258d57 100644\r\n+  112|  11.7k|    if ((result & 128) == 0) {\r\n   ------------------\r\n-  |  Branch (112:9): [True: 11.9k, False: 0]\r\n--- a/Users/eugenesiegel/btc/bitcoin/build_fuzzcov/fuzz_det_cov.show.t0.a.txt\r\n+  |  Branch (112:9): [True: 11.7k, False: 0]\r\n+++ b/Users/eugenesiegel/btc/bitcoin/build_fuzzcov/fuzz_det_cov.show.t0.b.txt\r\n   ------------------\r\n-  113|  11.9k|      *value = result;\r\n-  114|  11.9k|      return p + 1;\r\n-  115|  11.9k|    }\r\n-  116|  11.9k|  }\r\n@@ -61393,15 +61393,15 @@\r\n+  113|  11.7k|      *value = result;\r\n+  114|  11.7k|      return p + 1;\r\n    45|      0|  return \"leveldb.InternalKeyComparator\";\r\n+  115|  11.7k|    }\r\n    46|      0|}\r\n+  116|  11.7k|  }\r\n    47|       |\r\n   117|      4|  return GetVarint32PtrFallback(p, limit, value);\r\n-  118|  11.9k|}\r\n+  118|  11.7k|}\r\n-   48|  6.06k|int InternalKeyComparator::Compare(const Slice& akey, const Slice& bkey) const {\r\n   119|       |\r\n   120|       |}  // namespace leveldb\r\n   121|       |\r\n+   48|  6.01k|int InternalKeyComparator::Compare(const Slice& akey, const Slice& bkey) const {\r\n@@ -72399,9 +72399,9 @@\r\n    24|       |\r\n    25|      4|  const char* Name() const override { return \"leveldb.BytewiseComparator\"; }\r\n    26|       |\r\n    49|       |  // Order by:\r\n-   27|  6.41k|  int Compare(const Slice& a, const Slice& b) const override {\r\n    50|       |  //    increasing user key (according to user-supplied comparator)\r\n-   28|  6.41k|    return a.compare(b);\r\n    51|       |  //    decreasing sequence number\r\n-   29|  6.41k|  }\r\n    52|       |  //    decreasing type (though sequence# should be enough to disambiguate)\r\n+   27|  6.31k|  int Compare(const Slice& a, const Slice& b) const override {\r\n-   53|  6.06k|  int r = user_comparator_->Compare(ExtractUserKey(akey), ExtractUserKey(bkey));\r\n+   28|  6.31k|    return a.compare(b);\r\n-   54|  6.06k|  if (r == 0) {\r\n+   29|  6.31k|  }\r\n+   53|  6.01k|  int r = user_comparator_->Compare(ExtractUserKey(akey), ExtractUserKey(bkey));\r\n    30|       |\r\n+   54|  6.01k|  if (r == 0) {\r\n    31|       |  void FindShortestSeparator(std::string* start,\r\n   ------------------\r\n    32|     10|                             const Slice& limit) const override {\r\n-  |  Branch (54:7): [True: 66, False: 5.99k]\r\n+  |  Branch (54:7): [True: 66, False: 5.94k]\r\n   ------------------\r\n    55|     66|    const uint64_t anum = DecodeFixed64(akey.data() + akey.size() - 8);\r\n    56|     66|    const uint64_t bnum = DecodeFixed64(bkey.data() + bkey.size() - 8);\r\n@@ -61417,8 +61417,8 @@\r\n    60|     56|      r = +1;\r\n    61|     56|    }\r\n    62|     66|  }\r\n-   63|  6.06k|  return r;\r\n-   64|  6.06k|}\r\n+   63|  6.01k|  return r;\r\n+   64|  6.01k|}\r\n    65|       |\r\n    66|       |void InternalKeyComparator::FindShortestSeparator(std::string* start,\r\n    67|     10|                                                  const Slice& limit) const {\r\n@@ -61611,10 +61611,10 @@\r\n    92|       |bool ParseInternalKey(const Slice& internal_key, ParsedInternalKey* result);\r\n    93|       |\r\n    94|       |// Returns the user key portion of an internal key.\r\n-   95|  13.0k|inline Slice ExtractUserKey(const Slice& internal_key) {\r\n-   96|  13.0k|  assert(internal_key.size() >= 8);\r\n-   97|  13.0k|  return Slice(internal_key.data(), internal_key.size() - 8);\r\n-   98|  13.0k|}\r\n+   95|  12.9k|inline Slice ExtractUserKey(const Slice& internal_key) {\r\n+   96|  12.9k|  assert(internal_key.size() >= 8);\r\n+   97|  12.9k|  return Slice(internal_key.data(), internal_key.size() - 8);\r\n+   98|  12.9k|}\r\n    99|       |\r\n   100|       |// A comparator for internal keys that uses a specified comparator for\r\n   101|       |// the user key portion and breaks ties by decreasing sequence number.\r\n@@ -62489,12 +62489,12 @@\r\n    11|       |\r\n    12|       |namespace leveldb {\r\n    13|       |\r\n-   14|  10.9k|static Slice GetLengthPrefixedSlice(const char* data) {\r\n-   15|  10.9k|  uint32_t len;\r\n-   16|  10.9k|  const char* p = data;\r\n-   17|  10.9k|  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\r\n-   18|  10.9k|  return Slice(p, len);\r\n-   19|  10.9k|}\r\n+   14|  10.8k|static Slice GetLengthPrefixedSlice(const char* data) {\r\n+   15|  10.8k|  uint32_t len;\r\n+   16|  10.8k|  const char* p = data;\r\n+   17|  10.8k|  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\r\n+   18|  10.8k|  return Slice(p, len);\r\n+   19|  10.8k|}\r\n    20|       |\r\n    21|       |MemTable::MemTable(const InternalKeyComparator& comparator)\r\n    22|      4|    : comparator_(comparator), refs_(0), table_(comparator_, &arena_) {}\r\n@@ -62504,12 +62504,12 @@\r\n    26|      5|size_t MemTable::ApproximateMemoryUsage() { return arena_.MemoryUsage(); }\r\n    27|       |\r\n    28|       |int MemTable::KeyComparator::operator()(const char* aptr,\r\n-   29|  4.83k|                                        const char* bptr) const {\r\n+   29|  4.78k|                                        const char* bptr) const {\r\n    30|       |  // Internal keys are encoded as length-prefixed strings.\r\n-   31|  4.83k|  Slice a = GetLengthPrefixedSlice(aptr);\r\n-   32|  4.83k|  Slice b = GetLengthPrefixedSlice(bptr);\r\n-   33|  4.83k|  return comparator.Compare(a, b);\r\n-   34|  4.83k|}\r\n+   31|  4.78k|  Slice a = GetLengthPrefixedSlice(aptr);\r\n+   32|  4.78k|  Slice b = GetLengthPrefixedSlice(bptr);\r\n+   33|  4.78k|  return comparator.Compare(a, b);\r\n+   34|  4.78k|}\r\n    35|       |\r\n    36|       |// Encode a suitable internal key target for \"target\" and return it.\r\n    37|       |// Uses *scratch as scratch space, and the returned pointer will point\r\n@@ -62874,12 +62874,12 @@\r\n   150|       |\r\n   151|       |  // Accessors/mutators for links.  Wrapped in methods so we can\r\n   152|       |  // add the appropriate barriers as necessary.\r\n-  153|  5.37k|  Node* Next(int n) {\r\n-  154|  5.37k|    assert(n >= 0);\r\n+  153|  5.14k|  Node* Next(int n) {\r\n+  154|  5.14k|    assert(n >= 0);\r\n   155|       |    // Use an 'acquire load' so that we observe a fully initialized\r\n   156|       |    // version of the returned Node.\r\n-  157|  5.37k|    return next_[n].load(std::memory_order_acquire);\r\n-  158|  5.37k|  }\r\n+  157|  5.14k|    return next_[n].load(std::memory_order_acquire);\r\n+  158|  5.14k|  }\r\n   159|    587|  void SetNext(int n, Node* x) {\r\n   160|    587|    assert(n >= 0);\r\n   161|       |    // Use a 'release store' so that anybody who reads through this\r\n@@ -62986,15 +62986,15 @@\r\n   252|    414|}\r\n   253|       |\r\n   254|       |template <typename Key, class Comparator>\r\n-  255|  4.95k|bool SkipList<Key, Comparator>::KeyIsAfterNode(const Key& key, Node* n) const {\r\n+  255|  4.73k|bool SkipList<Key, Comparator>::KeyIsAfterNode(const Key& key, Node* n) const {\r\n   256|       |  // null n is considered infinite\r\n-  257|  4.95k|  return (n != nullptr) && (compare_(n->key, key) < 0);\r\n-                                         ^4.42k\r\n+  257|  4.73k|  return (n != nullptr) && (compare_(n->key, key) < 0);\r\n+                                         ^4.37k\r\n   ------------------\r\n-  |  Branch (257:10): [True: 4.42k, False: 534]\r\n-  |  Branch (257:28): [True: 3.07k, False: 1.35k]\r\n+  |  Branch (257:10): [True: 4.37k, False: 356]\r\n+  |  Branch (257:28): [True: 2.84k, False: 1.52k]\r\n   ------------------\r\n-  258|  4.95k|}\r\n+  258|  4.73k|}\r\n   259|       |\r\n   260|       |template <typename Key, class Comparator>\r\n   261|       |typename SkipList<Key, Comparator>::Node*\r\n@@ -63002,18 +63002,18 @@\r\n   263|    448|                                              Node** prev) const {\r\n   264|    448|  Node* x = head_;\r\n   265|    448|  int level = GetMaxHeight() - 1;\r\n-  266|  4.95k|  while (true) {\r\n+  266|  4.73k|  while (true) {\r\n   ------------------\r\n   |  Branch (266:10): [Folded - Ignored]\r\n   ------------------\r\n-  267|  4.95k|    Node* next = x->Next(level);\r\n-  268|  4.95k|    if (KeyIsAfterNode(key, next)) {\r\n+  267|  4.73k|    Node* next = x->Next(level);\r\n+  268|  4.73k|    if (KeyIsAfterNode(key, next)) {\r\n   ------------------\r\n-  |  Branch (268:9): [True: 3.07k, False: 1.88k]\r\n+  |  Branch (268:9): [True: 2.84k, False: 1.88k]\r\n   ------------------\r\n   269|       |      // Keep searching in this list\r\n-  270|  3.07k|      x = next;\r\n-  271|  3.07k|    } else {\r\n+  270|  2.84k|      x = next;\r\n+  271|  2.84k|    } else {\r\n   272|  1.88k|      if (prev != nullptr) prev[level] = x;\r\n                                          ^1.85k\r\n   ------------------\r\n@@ -63029,7 +63029,7 @@\r\n   277|  1.43k|        level--;\r\n   278|  1.43k|      }\r\n   279|  1.88k|    }\r\n-  280|  4.95k|  }\r\n+  280|  4.73k|  }\r\n   281|    448|}\r\n   282|       |\r\n   283|       |template <typename Key, class Comparator>\r\n@@ -68231,7 +68231,7 @@\r\n    31|    985|  Slice() : data_(\"\"), size_(0) {}\r\n    32|       |\r\n    33|       |  // Create a slice that refers to d[0,n-1].\r\n-   34|  27.4k|  Slice(const char* d, size_t n) : data_(d), size_(n) {}\r\n+   34|  27.2k|  Slice(const char* d, size_t n) : data_(d), size_(n) {}\r\n    35|       |\r\n    36|       |  // Create a slice that refers to the contents of \"s\"\r\n    37|  2.20k|  Slice(const std::string& s) : data_(s.data()), size_(s.size()) {}\r\n@@ -68244,10 +68244,10 @@\r\n    44|       |  Slice& operator=(const Slice&) = default;\r\n    45|       |\r\n    46|       |  // Return a pointer to the beginning of the referenced data\r\n-   47|  22.1k|  const char* data() const { return data_; }\r\n+   47|  22.0k|  const char* data() const { return data_; }\r\n    48|       |\r\n    49|       |  // Return the length (in bytes) of the referenced data\r\n-   50|  40.4k|  size_t size() const { return size_; }\r\n+   50|  40.2k|  size_t size() const { return size_; }\r\n    51|       |\r\n    52|       |  // Return true iff the length of the referenced data is zero\r\n    53|    433|  bool empty() const { return size_ == 0; }\r\n@@ -68313,16 +68313,16 @@\r\n   101|       |\r\n   102|     31|inline bool operator!=(const Slice& x, const Slice& y) { return !(x == y); }\r\n   103|       |\r\n-  104|  6.37k|inline int Slice::compare(const Slice& b) const {\r\n-  105|  6.37k|  const size_t min_len = (size_ < b.size_) ? size_ : b.size_;\r\n-                                                           ^250    ^6.12k\r\n+  104|  6.32k|inline int Slice::compare(const Slice& b) const {\r\n+  105|  6.32k|  const size_t min_len = (size_ < b.size_) ? size_ : b.size_;\r\n+                                                           ^239    ^6.08k\r\n   ------------------\r\n-  |  Branch (105:26): [True: 250, False: 6.12k]\r\n+  |  Branch (105:26): [True: 239, False: 6.08k]\r\n   ------------------\r\n-  106|  6.37k|  int r = memcmp(data_, b.data_, min_len);\r\n-  107|  6.37k|  if (r == 0) {\r\n+  106|  6.32k|  int r = memcmp(data_, b.data_, min_len);\r\n+  107|  6.32k|  if (r == 0) {\r\n   ------------------\r\n-  |  Branch (107:7): [True: 99, False: 6.27k]\r\n+  |  Branch (107:7): [True: 99, False: 6.22k]\r\n   ------------------\r\n   108|     99|    if (size_ < b.size_)\r\n   ------------------\r\n@@ -68335,8 +68335,8 @@\r\n   ------------------\r\n   111|      0|      r = +1;\r\n   112|     99|  }\r\n-  113|  6.37k|  return r;\r\n-  114|  6.37k|}\r\n+  113|  6.32k|  return r;\r\n+  114|  6.32k|}\r\n   115|       |\r\n   116|       |}  // namespace leveldb\r\n   117|       |\r\n@@ -71306,15 +71306,15 @@\r\n    45|    418|  char* result;\r\n    46|    418|  if (needed <= alloc_bytes_remaining_) {\r\n   ------------------\r\n-  |  Branch (46:7): [True: 411, False: 7]\r\n+  |  Branch (46:7): [True: 412, False: 6]\r\n   ------------------\r\n-   47|    411|    result = alloc_ptr_ + slop;\r\n-   48|    411|    alloc_ptr_ += needed;\r\n-   49|    411|    alloc_bytes_remaining_ -= needed;\r\n-   50|    411|  } else {\r\n+   47|    412|    result = alloc_ptr_ + slop;\r\n+   48|    412|    alloc_ptr_ += needed;\r\n+   49|    412|    alloc_bytes_remaining_ -= needed;\r\n+   50|    412|  } else {\r\n    51|       |    // AllocateFallback always returned aligned memory\r\n-   52|      7|    result = AllocateFallback(bytes);\r\n-   53|      7|  }\r\n+   52|      6|    result = AllocateFallback(bytes);\r\n+   53|      6|  }\r\n    54|    418|  assert((reinterpret_cast<uintptr_t>(result) & (align - 1)) == 0);\r\n    55|    418|  return result;\r\n    56|    418|}\r\n@@ -71391,14 +71391,14 @@\r\n    59|    414|  assert(bytes > 0);\r\n    60|    414|  if (bytes <= alloc_bytes_remaining_) {\r\n   ------------------\r\n-  |  Branch (60:7): [True: 405, False: 9]\r\n+  |  Branch (60:7): [True: 404, False: 10]\r\n   ------------------\r\n-   61|    405|    char* result = alloc_ptr_;\r\n-   62|    405|    alloc_ptr_ += bytes;\r\n-   63|    405|    alloc_bytes_remaining_ -= bytes;\r\n-   64|    405|    return result;\r\n-   65|    405|  }\r\n-   66|      9|  return AllocateFallback(bytes);\r\n+   61|    404|    char* result = alloc_ptr_;\r\n+   62|    404|    alloc_ptr_ += bytes;\r\n+   63|    404|    alloc_bytes_remaining_ -= bytes;\r\n+   64|    404|    return result;\r\n+   65|    404|  }\r\n+   66|     10|  return AllocateFallback(bytes);\r\n    67|    414|}\r\n    68|       |\r\n    69|       |}  // namespace leveldb\r\n@@ -72342,22 +72342,22 @@\r\n   106|       |const char* GetVarint32PtrFallback(const char* p, const char* limit,\r\n   107|       |                                   uint32_t* value);\r\n   108|       |inline const char* GetVarint32Ptr(const char* p, const char* limit,\r\n-  109|  11.7k|                                  uint32_t* value) {\r\n-  110|  11.7k|  if (p < limit) {\r\n+  109|  11.6k|                                  uint32_t* value) {\r\n+  110|  11.6k|  if (p < limit) {\r\n   ------------------\r\n-  |  Branch (110:7): [True: 11.7k, False: 4]\r\n+  |  Branch (110:7): [True: 11.6k, False: 4]\r\n   ------------------\r\n-  111|  11.7k|    uint32_t result = *(reinterpret_cast<const uint8_t*>(p));\r\n-  112|  11.7k|    if ((result & 128) == 0) {\r\n+  111|  11.6k|    uint32_t result = *(reinterpret_cast<const uint8_t*>(p));\r\n+  112|  11.6k|    if ((result & 128) == 0) {\r\n   ------------------\r\n-  |  Branch (112:9): [True: 11.7k, False: 0]\r\n+  |  Branch (112:9): [True: 11.6k, False: 0]\r\n   ------------------\r\n-  113|  11.7k|      *value = result;\r\n-  114|  11.7k|      return p + 1;\r\n-  115|  11.7k|    }\r\n-  116|  11.7k|  }\r\n+  113|  11.6k|      *value = result;\r\n+  114|  11.6k|      return p + 1;\r\n+  115|  11.6k|    }\r\n+  116|  11.6k|  }\r\n   117|      4|  return GetVarint32PtrFallback(p, limit, value);\r\n-  118|  11.7k|}\r\n+  118|  11.6k|}\r\n   119|       |\r\n   120|       |}  // namespace leveldb\r\n   121|       |\r\n@@ -72390,9 +72390,9 @@\r\n    24|       |\r\n    25|      4|  const char* Name() const override { return \"leveldb.BytewiseComparator\"; }\r\n    26|       |\r\n-   27|  6.36k|  int Compare(const Slice& a, const Slice& b) const override {\r\n-   28|  6.36k|    return a.compare(b);\r\n-   29|  6.36k|  }\r\n+   27|  6.32k|  int Compare(const Slice& a, const Slice& b) const override {\r\n+   28|  6.32k|    return a.compare(b);\r\n+   29|  6.32k|  }\r\n    30|       |\r\n    31|       |  void FindShortestSeparator(std::string* start,\r\n    32|     10|                             const Slice& limit) const override {\r\nâš ï¸\r\n\r\nThe coverage was not deterministic between runs.\r\nThe fuzz target input was /Users/eugenesiegel/btc/bitcoin/cmpctblock/cmpctblock/00095f04def2d4e203a2844032ee4bb88e33681d\r\n```\r\n</details>",
      "created_at": "2025-11-13T15:33:48Z",
      "updated_at": "2025-11-13T17:13:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2523928262",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2523928262"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 496,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2523964995",
      "pull_request_review_id": 3460423119,
      "id": 2523964995,
      "node_id": "PRRC_kwDOABII586WcKZD",
      "diff_hunk": "@@ -143,13 +143,6 @@ CBlock ConsumeBlock(FuzzedDataProvider& fuzzed_data_provider, const uint256& pre\n     return block;\n }\n \n-void FinalizeHeader(CBlockHeader& header, const ChainstateManager& chainman)",
      "path": "src/test/fuzz/p2p_headers_presync.cpp",
      "position": 12,
      "original_position": 4,
      "commit_id": "3c515102f4e83b4117f52d7d0fd41aac59740b16",
      "original_commit_id": "a54e759d050705fd36b89cb7f3e8d7b0a9772e24",
      "in_reply_to_id": 2513989045,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Nope, thanks.",
      "created_at": "2025-11-13T15:42:34Z",
      "updated_at": "2025-11-13T15:42:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2523964995",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2523964995"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 146,
      "original_line": 146,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2524170909",
      "pull_request_review_id": 3460693024,
      "id": 2524170909,
      "node_id": "PRRC_kwDOABII586Wc8qd",
      "diff_hunk": "@@ -136,6 +136,13 @@ static inline bool copy_file(const path& from, const path& to, copy_options opti\n     return std::filesystem::copy_file(from, to, options);\n }\n \n+// Disallow implicit std::string conversion for copy to avoid locale-dependent\n+// encoding on Windows. This is currently only used in fuzzing.\n+static inline void copy(const path& from, const path& to, copy_options options)",
      "path": "src/util/fs.h",
      "position": 1,
      "original_position": 6,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "8515594b3b716d05a89b9fef36dfe7e8032d19c7",
      "in_reply_to_id": 2514018993,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Do we still need this after https://github.com/bitcoin/bitcoin/pull/33550?\r\n\r\nI think it's still needed, I added it to get rid of linter warnings if `std::filesystem::copy` is instead called directly from the test code.\r\n\r\n> Are we adding dead code in this commit? It's hard to judge if a solution is accurate if we see it before the problem is presented - can we make the question obvious before we provide the answer?\r\n\r\nFair point, I'll rework the commits so it's a bit easier to tell where things are used.\r\n\r\n> would it be possible to invalidate the conversions you don't want instead, maybe something like\r\n\r\nYes, that also works.",
      "created_at": "2025-11-13T16:39:11Z",
      "updated_at": "2025-11-13T16:39:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2524170909",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2524170909"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2524183047",
      "pull_request_review_id": 3460710043,
      "id": 2524183047,
      "node_id": "PRRC_kwDOABII586Wc_oH",
      "diff_hunk": "@@ -287,6 +287,8 @@ ChainTestingSetup::ChainTestingSetup(const ChainType chainType, TestOpts opts)\n             m_node.scheduler->scheduleFromNow([&promise] { promise.set_value(); }, 0ms);\n             promise.get_future().wait();\n         }\n+    } else if (opts.setup_validation_interface_no_scheduler) {\n+        m_node.validation_signals = std::make_unique<ValidationSignals>(std::make_unique<util::ImmediateTaskRunner>());",
      "path": "src/test/util/setup_common.cpp",
      "position": 1,
      "original_position": 5,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "71719d172e3a435dd983293fc9da6a08974f8b01",
      "in_reply_to_id": 2514060602,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Can we add a simpler fuzz test which needs this in the same commit that introduces it - and extend the test with other functionality separately.\r\n\r\nYes, I'll do some variation of this. I think it might be cleaner to put it as one of the last commits.",
      "created_at": "2025-11-13T16:42:25Z",
      "updated_at": "2025-11-13T16:42:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2524183047",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2524183047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 289,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2524195439",
      "pull_request_review_id": 3460725103,
      "id": 2524195439,
      "node_id": "PRRC_kwDOABII586WdCpv",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 4; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - AMOUNT_FEE;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbase_tx;\n+        coinbase_tx.vin.resize(1);\n+        coinbase_tx.vin[0].prevout.SetNull();\n+        coinbase_tx.vin[0].scriptSig = CScript() << height << OP_0;\n+        coinbase_tx.vout.resize(1);\n+        coinbase_tx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbase_tx.vout[0].nValue = COIN;\n+        block->vtx.push_back(MakeTransactionRef(coinbase_tx));\n+\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            // Add txns from the mempool. Since we do not include parents, it may be an invalid block.\n+            size_t num_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, mempool_size);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+\n+            LOCK(setup->m_node.mempool->cs);\n+            for (size_t i = random_idx; i < random_idx + num_txns; ++i) {\n+                CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[i % mempool_size].second->GetSharedTx();\n+                block->vtx.push_back(mempool_tx);\n+            }\n+        }\n+\n+        // Create and add (possibly invalid) txns that are not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            size_t new_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 10);\n+            for (size_t i = 0; i < new_txns; ++i) {\n+                CTransactionRef non_mempool_tx = create_tx();\n+                if (non_mempool_tx != nullptr) {\n+                    block->vtx.push_back(non_mempool_tx);\n+                }\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+        FinalizeHeader(*block, *setup->m_node.chainman);\n+\n+        BlockInfo block_info;\n+        block_info.block = block;\n+        block_info.hash = block->GetHash();\n+        block_info.height = height;\n+\n+        return block_info;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo block_info = create_block();\n+                    cblock = block_info.block;\n+                    info.push_back(block_info);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctblock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctblock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctblock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+            },\n+            [&]() {\n+                // Send a blocktxn message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Fetch an existing block and randomly choose transactions to send over.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                const BlockInfo& block_info = info[index];\n+                BlockTransactions block_txn;\n+                block_txn.blockhash = block_info.hash;\n+                std::shared_ptr<CBlock> cblock = block_info.block;\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (num_txs > 1) {\n+                    for (size_t i = 1; i < num_txs; i++) {\n+                        if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                        block_txn.txn.push_back(cblock->vtx[i]);\n+                    }\n+                }\n+\n+                net_msg = NetMsg::Make(NetMsgType::BLOCKTXN, block_txn);\n+            },\n+            [&]() {\n+                // Send a headers message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Choose an existing block and send a HEADERS message for it.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                std::vector<CBlock> headers;\n+                headers.emplace_back(info[index].block->GetBlockHeader());\n+\n+                net_msg = NetMsg::Make(NetMsgType::HEADERS, TX_WITH_WITNESS(headers));\n+            },\n+            [&]() {\n+                // Send a sendcmpct message, optionally setting hb mode.\n+                bool hb = fuzzed_data_provider.ConsumeBool();\n+                net_msg = NetMsg::Make(NetMsgType::SENDCMPCT, /*high_bandwidth=*/hb, /*version=*/CMPCTBLOCKS_VERSION);\n+            },\n+            [&]() {\n+                // Mine a block, but don't send it over p2p.\n+                BlockInfo block_info = create_block();\n+                info.push_back(block_info);\n+                set_net_msg = false;\n+            },\n+            [&]() {\n+                // Send a txn over p2p.\n+                CTransactionRef tx = create_tx();\n+                if (tx == nullptr) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                net_msg = NetMsg::Make(NetMsgType::TX, TX_WITH_WITNESS(*tx));\n+            },\n+            [&]() {\n+                // Set mock time.\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+                } else {\n+                    // Set to tip's time so the CanDirectFetch check can pass in net_processing.\n+                    const uint64_t tip_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetBlockTime());\n+                    SetMockTime(tip_time);\n+                }\n+\n+                set_net_msg = false;\n+            });\n+\n+        if (!set_net_msg) {\n+            continue;\n+        }\n+\n+        CNode& random_node = *PickValue(fuzzed_data_provider, peers);\n+        connman.FlushSendBuffer(random_node);\n+        (void)connman.ReceiveMsgFrom(random_node, std::move(net_msg));\n+\n+        bool more_work{true};\n+        while (more_work) {\n+            random_node.fPauseSend = false;\n+\n+            try {\n+                more_work = connman.ProcessMessagesOnce(random_node);\n+            } catch (const std::ios_base::failure&) {\n+            }",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 422,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "1cfe4f0355879519b9f6aa52e971d757dd76a6d5",
      "in_reply_to_id": 2514076456,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This is copied from the `process_message(s)` harness. Unlike those, this fuzz test should always construct correctly serialized messages (even if the messages themselves are deemed \"protocol invalid\"), so I think the catch case can just be `assert(false)`.",
      "created_at": "2025-11-13T16:45:14Z",
      "updated_at": "2025-11-13T16:45:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2524195439",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2524195439"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": 419,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 422,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2524253265",
      "pull_request_review_id": 3460797109,
      "id": 2524253265,
      "node_id": "PRRC_kwDOABII586WdQxR",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 4; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 199,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "1cfe4f0355879519b9f6aa52e971d757dd76a6d5",
      "in_reply_to_id": 2514085576,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Will do, I think this was used in multiple places in an earlier version of this code.",
      "created_at": "2025-11-13T17:02:30Z",
      "updated_at": "2025-11-13T17:02:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2524253265",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2524253265"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 199,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2524255627",
      "pull_request_review_id": 3460799845,
      "id": 2524255627,
      "node_id": "PRRC_kwDOABII586WdRWL",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 4; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - AMOUNT_FEE;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbase_tx;\n+        coinbase_tx.vin.resize(1);\n+        coinbase_tx.vin[0].prevout.SetNull();\n+        coinbase_tx.vin[0].scriptSig = CScript() << height << OP_0;\n+        coinbase_tx.vout.resize(1);\n+        coinbase_tx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbase_tx.vout[0].nValue = COIN;\n+        block->vtx.push_back(MakeTransactionRef(coinbase_tx));\n+\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            // Add txns from the mempool. Since we do not include parents, it may be an invalid block.\n+            size_t num_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, mempool_size);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+\n+            LOCK(setup->m_node.mempool->cs);\n+            for (size_t i = random_idx; i < random_idx + num_txns; ++i) {\n+                CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[i % mempool_size].second->GetSharedTx();\n+                block->vtx.push_back(mempool_tx);\n+            }\n+        }\n+\n+        // Create and add (possibly invalid) txns that are not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            size_t new_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 10);\n+            for (size_t i = 0; i < new_txns; ++i) {\n+                CTransactionRef non_mempool_tx = create_tx();\n+                if (non_mempool_tx != nullptr) {\n+                    block->vtx.push_back(non_mempool_tx);\n+                }\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+        FinalizeHeader(*block, *setup->m_node.chainman);\n+\n+        BlockInfo block_info;\n+        block_info.block = block;\n+        block_info.hash = block->GetHash();\n+        block_info.height = height;\n+\n+        return block_info;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo block_info = create_block();\n+                    cblock = block_info.block;\n+                    info.push_back(block_info);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctblock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctblock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctblock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+            },\n+            [&]() {",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 343,
      "original_position": 332,
      "commit_id": "3c515102f4e83b4117f52d7d0fd41aac59740b16",
      "original_commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "in_reply_to_id": 2514170270,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'll incrementally add the cases so it's a bit easier to digest.",
      "created_at": "2025-11-13T17:03:17Z",
      "updated_at": "2025-11-13T17:03:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2524255627",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2524255627"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 343,
      "original_line": 343,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2524277972",
      "pull_request_review_id": 3460829517,
      "id": 2524277972,
      "node_id": "PRRC_kwDOABII586WdWzU",
      "diff_hunk": "@@ -180,6 +180,11 @@ bool CBlockIndexHeightOnlyComparator::operator()(const CBlockIndex* pa, const CB\n     return pa->nHeight < pb->nHeight;\n }\n \n+bool CBlockIndexBlockHashComparator::operator()(const CBlockIndex* pa, const CBlockIndex* pb) const\n+{\n+    return UintToArith256(pa->GetBlockHash()) < UintToArith256(pb->GetBlockHash());",
      "path": "src/node/blockstorage.cpp",
      "position": 1,
      "original_position": 6,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "in_reply_to_id": 2514673448,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "IIRC I tried comparing the `uint256` block hashes similar to your second suggestion, and while it fixed the leveldb non-determinism, it introduced its own non-determinism.",
      "created_at": "2025-11-13T17:10:57Z",
      "updated_at": "2025-11-13T17:10:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2524277972",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2524277972"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2526743891",
      "pull_request_review_id": 3463985580,
      "id": 2526743891,
      "node_id": "PRRC_kwDOABII586Wmw1T",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 4; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - AMOUNT_FEE;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbase_tx;\n+        coinbase_tx.vin.resize(1);\n+        coinbase_tx.vin[0].prevout.SetNull();\n+        coinbase_tx.vin[0].scriptSig = CScript() << height << OP_0;\n+        coinbase_tx.vout.resize(1);\n+        coinbase_tx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbase_tx.vout[0].nValue = COIN;\n+        block->vtx.push_back(MakeTransactionRef(coinbase_tx));\n+\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            // Add txns from the mempool. Since we do not include parents, it may be an invalid block.\n+            size_t num_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, mempool_size);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+\n+            LOCK(setup->m_node.mempool->cs);\n+            for (size_t i = random_idx; i < random_idx + num_txns; ++i) {\n+                CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[i % mempool_size].second->GetSharedTx();\n+                block->vtx.push_back(mempool_tx);\n+            }\n+        }\n+\n+        // Create and add (possibly invalid) txns that are not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            size_t new_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 10);\n+            for (size_t i = 0; i < new_txns; ++i) {\n+                CTransactionRef non_mempool_tx = create_tx();\n+                if (non_mempool_tx != nullptr) {\n+                    block->vtx.push_back(non_mempool_tx);\n+                }\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+        FinalizeHeader(*block, *setup->m_node.chainman);\n+\n+        BlockInfo block_info;\n+        block_info.block = block;\n+        block_info.hash = block->GetHash();\n+        block_info.height = height;\n+\n+        return block_info;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo block_info = create_block();\n+                    cblock = block_info.block;\n+                    info.push_back(block_info);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctblock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctblock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctblock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+            },\n+            [&]() {\n+                // Send a blocktxn message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Fetch an existing block and randomly choose transactions to send over.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                const BlockInfo& block_info = info[index];\n+                BlockTransactions block_txn;\n+                block_txn.blockhash = block_info.hash;\n+                std::shared_ptr<CBlock> cblock = block_info.block;\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (num_txs > 1) {\n+                    for (size_t i = 1; i < num_txs; i++) {\n+                        if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                        block_txn.txn.push_back(cblock->vtx[i]);\n+                    }\n+                }\n+\n+                net_msg = NetMsg::Make(NetMsgType::BLOCKTXN, block_txn);\n+            },\n+            [&]() {\n+                // Send a headers message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Choose an existing block and send a HEADERS message for it.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                std::vector<CBlock> headers;\n+                headers.emplace_back(info[index].block->GetBlockHeader());\n+\n+                net_msg = NetMsg::Make(NetMsgType::HEADERS, TX_WITH_WITNESS(headers));\n+            },\n+            [&]() {\n+                // Send a sendcmpct message, optionally setting hb mode.\n+                bool hb = fuzzed_data_provider.ConsumeBool();\n+                net_msg = NetMsg::Make(NetMsgType::SENDCMPCT, /*high_bandwidth=*/hb, /*version=*/CMPCTBLOCKS_VERSION);\n+            },\n+            [&]() {\n+                // Mine a block, but don't send it over p2p.\n+                BlockInfo block_info = create_block();\n+                info.push_back(block_info);\n+                set_net_msg = false;\n+            },\n+            [&]() {\n+                // Send a txn over p2p.\n+                CTransactionRef tx = create_tx();\n+                if (tx == nullptr) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                net_msg = NetMsg::Make(NetMsgType::TX, TX_WITH_WITNESS(*tx));\n+            },\n+            [&]() {\n+                // Set mock time.\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+                } else {\n+                    // Set to tip's time so the CanDirectFetch check can pass in net_processing.\n+                    const uint64_t tip_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetBlockTime());\n+                    SetMockTime(tip_time);\n+                }\n+\n+                set_net_msg = false;\n+            });\n+\n+        if (!set_net_msg) {\n+            continue;\n+        }\n+\n+        CNode& random_node = *PickValue(fuzzed_data_provider, peers);\n+        connman.FlushSendBuffer(random_node);\n+        (void)connman.ReceiveMsgFrom(random_node, std::move(net_msg));\n+\n+        bool more_work{true};\n+        while (more_work) {\n+            random_node.fPauseSend = false;\n+\n+            try {\n+                more_work = connman.ProcessMessagesOnce(random_node);\n+            } catch (const std::ios_base::failure&) {\n+            }",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 422,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "1cfe4f0355879519b9f6aa52e971d757dd76a6d5",
      "in_reply_to_id": 2514076456,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Isn't it cleaner to just drop the try/catch entirely in that case?",
      "created_at": "2025-11-14T09:42:03Z",
      "updated_at": "2025-11-14T09:42:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2526743891",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2526743891"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": 419,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 422,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2526752792",
      "pull_request_review_id": 3463996021,
      "id": 2526752792,
      "node_id": "PRRC_kwDOABII586WmzAY",
      "diff_hunk": "@@ -180,6 +180,11 @@ bool CBlockIndexHeightOnlyComparator::operator()(const CBlockIndex* pa, const CB\n     return pa->nHeight < pb->nHeight;\n }\n \n+bool CBlockIndexBlockHashComparator::operator()(const CBlockIndex* pa, const CBlockIndex* pb) const\n+{\n+    return UintToArith256(pa->GetBlockHash()) < UintToArith256(pb->GetBlockHash());",
      "path": "src/node/blockstorage.cpp",
      "position": 1,
      "original_position": 6,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "in_reply_to_id": 2514673448,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The suggested comparator is a pure function, I don't see how it could be non-deterministic - unless it's broken, in which case we should definitely dig deeper.\r\nCan you try it again an report what you see?",
      "created_at": "2025-11-14T09:43:45Z",
      "updated_at": "2025-11-14T09:43:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2526752792",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2526752792"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2527112930",
      "pull_request_review_id": 3464431540,
      "id": 2527112930,
      "node_id": "PRRC_kwDOABII586WoK7i",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 4; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - AMOUNT_FEE;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbase_tx;\n+        coinbase_tx.vin.resize(1);\n+        coinbase_tx.vin[0].prevout.SetNull();\n+        coinbase_tx.vin[0].scriptSig = CScript() << height << OP_0;\n+        coinbase_tx.vout.resize(1);\n+        coinbase_tx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbase_tx.vout[0].nValue = COIN;\n+        block->vtx.push_back(MakeTransactionRef(coinbase_tx));\n+\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            // Add txns from the mempool. Since we do not include parents, it may be an invalid block.\n+            size_t num_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, mempool_size);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+\n+            LOCK(setup->m_node.mempool->cs);\n+            for (size_t i = random_idx; i < random_idx + num_txns; ++i) {\n+                CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[i % mempool_size].second->GetSharedTx();\n+                block->vtx.push_back(mempool_tx);\n+            }\n+        }\n+\n+        // Create and add (possibly invalid) txns that are not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            size_t new_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 10);\n+            for (size_t i = 0; i < new_txns; ++i) {\n+                CTransactionRef non_mempool_tx = create_tx();\n+                if (non_mempool_tx != nullptr) {\n+                    block->vtx.push_back(non_mempool_tx);\n+                }\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+        FinalizeHeader(*block, *setup->m_node.chainman);\n+\n+        BlockInfo block_info;\n+        block_info.block = block;\n+        block_info.hash = block->GetHash();\n+        block_info.height = height;\n+\n+        return block_info;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo block_info = create_block();\n+                    cblock = block_info.block;\n+                    info.push_back(block_info);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctblock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctblock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctblock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+            },\n+            [&]() {\n+                // Send a blocktxn message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Fetch an existing block and randomly choose transactions to send over.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                const BlockInfo& block_info = info[index];\n+                BlockTransactions block_txn;\n+                block_txn.blockhash = block_info.hash;\n+                std::shared_ptr<CBlock> cblock = block_info.block;\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (num_txs > 1) {\n+                    for (size_t i = 1; i < num_txs; i++) {\n+                        if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                        block_txn.txn.push_back(cblock->vtx[i]);\n+                    }\n+                }\n+\n+                net_msg = NetMsg::Make(NetMsgType::BLOCKTXN, block_txn);\n+            },\n+            [&]() {\n+                // Send a headers message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Choose an existing block and send a HEADERS message for it.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                std::vector<CBlock> headers;\n+                headers.emplace_back(info[index].block->GetBlockHeader());\n+\n+                net_msg = NetMsg::Make(NetMsgType::HEADERS, TX_WITH_WITNESS(headers));\n+            },\n+            [&]() {\n+                // Send a sendcmpct message, optionally setting hb mode.\n+                bool hb = fuzzed_data_provider.ConsumeBool();\n+                net_msg = NetMsg::Make(NetMsgType::SENDCMPCT, /*high_bandwidth=*/hb, /*version=*/CMPCTBLOCKS_VERSION);\n+            },\n+            [&]() {\n+                // Mine a block, but don't send it over p2p.\n+                BlockInfo block_info = create_block();\n+                info.push_back(block_info);\n+                set_net_msg = false;\n+            },\n+            [&]() {\n+                // Send a txn over p2p.\n+                CTransactionRef tx = create_tx();\n+                if (tx == nullptr) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                net_msg = NetMsg::Make(NetMsgType::TX, TX_WITH_WITNESS(*tx));\n+            },\n+            [&]() {\n+                // Set mock time.\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+                } else {\n+                    // Set to tip's time so the CanDirectFetch check can pass in net_processing.\n+                    const uint64_t tip_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetBlockTime());\n+                    SetMockTime(tip_time);\n+                }\n+\n+                set_net_msg = false;\n+            });\n+\n+        if (!set_net_msg) {\n+            continue;\n+        }\n+\n+        CNode& random_node = *PickValue(fuzzed_data_provider, peers);\n+        connman.FlushSendBuffer(random_node);\n+        (void)connman.ReceiveMsgFrom(random_node, std::move(net_msg));\n+\n+        bool more_work{true};\n+        while (more_work) {\n+            random_node.fPauseSend = false;\n+\n+            try {\n+                more_work = connman.ProcessMessagesOnce(random_node);\n+            } catch (const std::ios_base::failure&) {\n+            }",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 422,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "1cfe4f0355879519b9f6aa52e971d757dd76a6d5",
      "in_reply_to_id": 2514076456,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Ah yes, that is cleaner.",
      "created_at": "2025-11-14T11:09:49Z",
      "updated_at": "2025-11-14T11:09:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2527112930",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2527112930"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": 419,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 422,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542621198",
      "pull_request_review_id": 3483520927,
      "id": 2542621198,
      "node_id": "PRRC_kwDOABII586XjVIO",
      "diff_hunk": "@@ -180,6 +180,11 @@ bool CBlockIndexHeightOnlyComparator::operator()(const CBlockIndex* pa, const CB\n     return pa->nHeight < pb->nHeight;\n }\n \n+bool CBlockIndexBlockHashComparator::operator()(const CBlockIndex* pa, const CBlockIndex* pb) const\n+{\n+    return UintToArith256(pa->GetBlockHash()) < UintToArith256(pb->GetBlockHash());",
      "path": "src/node/blockstorage.cpp",
      "position": 1,
      "original_position": 6,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "in_reply_to_id": 2514673448,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "My bad, I must have tested a slightly different comparator. The suggested ones are deterministic.",
      "created_at": "2025-11-19T15:54:44Z",
      "updated_at": "2025-11-19T15:54:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2542621198",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542621198"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542808323",
      "pull_request_review_id": 3483767323,
      "id": 2542808323,
      "node_id": "PRRC_kwDOABII586XkC0D",
      "diff_hunk": "@@ -136,6 +136,13 @@ static inline bool copy_file(const path& from, const path& to, copy_options opti\n     return std::filesystem::copy_file(from, to, options);\n }\n \n+// Disallow implicit std::string conversion for copy to avoid locale-dependent\n+// encoding on Windows. This is currently only used in fuzzing.\n+static inline void copy(const path& from, const path& to, copy_options options)",
      "path": "src/util/fs.h",
      "position": 1,
      "original_position": 6,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "8515594b3b716d05a89b9fef36dfe7e8032d19c7",
      "in_reply_to_id": 2514018993,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> would it be possible to invalidate the conversions you don't want instead, maybe something like\r\n\r\nCurrently implementing this and wondering if this is necessary; can you share what your IDE is confused about? The constructor of `path` that takes a `std::string` is deleted.",
      "created_at": "2025-11-19T16:44:10Z",
      "updated_at": "2025-11-19T16:44:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2542808323",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542808323"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542843754",
      "pull_request_review_id": 3483811609,
      "id": 2542843754,
      "node_id": "PRRC_kwDOABII586XkLdq",
      "diff_hunk": "@@ -136,6 +136,13 @@ static inline bool copy_file(const path& from, const path& to, copy_options opti\n     return std::filesystem::copy_file(from, to, options);\n }\n \n+// Disallow implicit std::string conversion for copy to avoid locale-dependent\n+// encoding on Windows. This is currently only used in fuzzing.\n+static inline void copy(const path& from, const path& to, copy_options options)",
      "path": "src/util/fs.h",
      "position": 1,
      "original_position": 6,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "8515594b3b716d05a89b9fef36dfe7e8032d19c7",
      "in_reply_to_id": 2514018993,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I don't have Windows, it's why I asked if instead of adding a new method we can just delete the conversions, somewhat similarly to the mentioned https://github.com/bitcoin/bitcoin/pull/33550/files#diff-69423eb01bf14b3bd0d930c0b3e1fd6f4f061ffefacab579053eaa734fc22f38R65 (since the error seemed superficially similar to me).",
      "created_at": "2025-11-19T16:54:43Z",
      "updated_at": "2025-11-19T16:54:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2542843754",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542843754"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2546530265",
      "pull_request_review_id": 3488474873,
      "id": 2546530265,
      "node_id": "PRRC_kwDOABII586XyPfZ",
      "diff_hunk": "@@ -136,6 +136,13 @@ static inline bool copy_file(const path& from, const path& to, copy_options opti\n     return std::filesystem::copy_file(from, to, options);\n }\n \n+// Disallow implicit std::string conversion for copy to avoid locale-dependent\n+// encoding on Windows. This is currently only used in fuzzing.\n+static inline void copy(const path& from, const path& to, copy_options options)",
      "path": "src/util/fs.h",
      "position": 1,
      "original_position": 6,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "8515594b3b716d05a89b9fef36dfe7e8032d19c7",
      "in_reply_to_id": 2514018993,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Deleting the conversions instead of adding a new method does not work because overload resolution considers these functions even though they are deleted and then the compiler errors that `copy` is ambiguous:\r\n\r\n```\r\n/Users/eugenesiegel/btc/bitcoin-clone/src/test/util/setup_common.cpp:210:9: error: call to 'copy' is ambiguous\r\n  210 |         fs::copy(cached_dir, m_path_root, fs::copy_options::recursive);\r\n      |         ^~~~~~~~\r\n/Users/eugenesiegel/btc/bitcoin-clone/src/util/fs.h:142:13: note: candidate function has been explicitly deleted\r\n  142 | static void copy(const path&, const std::string&, copy_options) = delete;\r\n      |             ^\r\n/Users/eugenesiegel/btc/bitcoin-clone/src/util/fs.h:141:13: note: candidate function has been explicitly deleted\r\n  141 | static void copy(const std::string&, const path&, copy_options) = delete;\r\n```",
      "created_at": "2025-11-20T15:27:28Z",
      "updated_at": "2025-11-20T15:27:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2546530265",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2546530265"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2550914901",
      "pull_request_review_id": 3494301733,
      "id": 2550914901,
      "node_id": "PRRC_kwDOABII586YC99V",
      "diff_hunk": "@@ -136,6 +136,13 @@ static inline bool copy_file(const path& from, const path& to, copy_options opti\n     return std::filesystem::copy_file(from, to, options);\n }\n \n+// Disallow implicit std::string conversion for copy to avoid locale-dependent\n+// encoding on Windows. This is currently only used in fuzzing.\n+static inline void copy(const path& from, const path& to, copy_options options)",
      "path": "src/util/fs.h",
      "position": 1,
      "original_position": 6,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "8515594b3b716d05a89b9fef36dfe7e8032d19c7",
      "in_reply_to_id": 2514018993,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> nit: inline is implicit\r\n\r\nclang warns about unused functions if I remove the `inline`",
      "created_at": "2025-11-21T20:43:29Z",
      "updated_at": "2025-11-21T20:43:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2550914901",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2550914901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556512190",
      "pull_request_review_id": 3500691625,
      "id": 2556512190,
      "node_id": "PRRC_kwDOABII586YYUe-",
      "diff_hunk": "@@ -487,7 +492,7 @@ bool BlockManager::WriteBlockIndexDB()\n     }\n     std::vector<const CBlockIndex*> vBlocks;\n     vBlocks.reserve(m_dirty_blockindex.size());\n-    for (std::set<CBlockIndex*>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {\n+    for (std::set<CBlockIndex*, CBlockIndexBlockHashComparator>::iterator it = m_dirty_blockindex.begin(); it != m_dirty_blockindex.end();) {",
      "path": "src/node/blockstorage.cpp",
      "position": 1,
      "original_position": 17,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "ed813c48f826d083becf93c741b483774c850c86",
      "in_reply_to_id": 2414480315,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Resolving as this commit has been removed.",
      "created_at": "2025-11-24T14:25:58Z",
      "updated_at": "2025-11-24T14:25:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2556512190",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556512190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 496,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556520957",
      "pull_request_review_id": 3500703056,
      "id": 2556520957,
      "node_id": "PRRC_kwDOABII586YYWn9",
      "diff_hunk": "@@ -287,6 +287,8 @@ ChainTestingSetup::ChainTestingSetup(const ChainType chainType, TestOpts opts)\n             m_node.scheduler->scheduleFromNow([&promise] { promise.set_value(); }, 0ms);\n             promise.get_future().wait();\n         }\n+    } else if (opts.setup_validation_interface_no_scheduler) {\n+        m_node.validation_signals = std::make_unique<ValidationSignals>(std::make_unique<util::ImmediateTaskRunner>());",
      "path": "src/test/util/setup_common.cpp",
      "position": 1,
      "original_position": 5,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "71719d172e3a435dd983293fc9da6a08974f8b01",
      "in_reply_to_id": 2514060602,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in 0190ac6622ff017aeead385289918d388a85218a",
      "created_at": "2025-11-24T14:27:39Z",
      "updated_at": "2025-11-24T14:27:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2556520957",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556520957"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 289,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556523653",
      "pull_request_review_id": 3500706407,
      "id": 2556523653,
      "node_id": "PRRC_kwDOABII586YYXSF",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 4; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - AMOUNT_FEE;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbase_tx;\n+        coinbase_tx.vin.resize(1);\n+        coinbase_tx.vin[0].prevout.SetNull();\n+        coinbase_tx.vin[0].scriptSig = CScript() << height << OP_0;\n+        coinbase_tx.vout.resize(1);\n+        coinbase_tx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbase_tx.vout[0].nValue = COIN;\n+        block->vtx.push_back(MakeTransactionRef(coinbase_tx));\n+\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            // Add txns from the mempool. Since we do not include parents, it may be an invalid block.\n+            size_t num_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, mempool_size);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+\n+            LOCK(setup->m_node.mempool->cs);\n+            for (size_t i = random_idx; i < random_idx + num_txns; ++i) {\n+                CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[i % mempool_size].second->GetSharedTx();\n+                block->vtx.push_back(mempool_tx);\n+            }\n+        }\n+\n+        // Create and add (possibly invalid) txns that are not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            size_t new_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 10);\n+            for (size_t i = 0; i < new_txns; ++i) {\n+                CTransactionRef non_mempool_tx = create_tx();\n+                if (non_mempool_tx != nullptr) {\n+                    block->vtx.push_back(non_mempool_tx);\n+                }\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+        FinalizeHeader(*block, *setup->m_node.chainman);\n+\n+        BlockInfo block_info;\n+        block_info.block = block;\n+        block_info.hash = block->GetHash();\n+        block_info.height = height;\n+\n+        return block_info;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo block_info = create_block();\n+                    cblock = block_info.block;\n+                    info.push_back(block_info);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctblock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctblock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctblock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+            },\n+            [&]() {\n+                // Send a blocktxn message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Fetch an existing block and randomly choose transactions to send over.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                const BlockInfo& block_info = info[index];\n+                BlockTransactions block_txn;\n+                block_txn.blockhash = block_info.hash;\n+                std::shared_ptr<CBlock> cblock = block_info.block;\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (num_txs > 1) {\n+                    for (size_t i = 1; i < num_txs; i++) {\n+                        if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                        block_txn.txn.push_back(cblock->vtx[i]);\n+                    }\n+                }\n+\n+                net_msg = NetMsg::Make(NetMsgType::BLOCKTXN, block_txn);\n+            },\n+            [&]() {\n+                // Send a headers message for an existing block (if one exists).\n+                size_t num_blocks = info.size();\n+                if (num_blocks == 0) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                // Choose an existing block and send a HEADERS message for it.\n+                size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, num_blocks - 1);\n+                std::vector<CBlock> headers;\n+                headers.emplace_back(info[index].block->GetBlockHeader());\n+\n+                net_msg = NetMsg::Make(NetMsgType::HEADERS, TX_WITH_WITNESS(headers));\n+            },\n+            [&]() {\n+                // Send a sendcmpct message, optionally setting hb mode.\n+                bool hb = fuzzed_data_provider.ConsumeBool();\n+                net_msg = NetMsg::Make(NetMsgType::SENDCMPCT, /*high_bandwidth=*/hb, /*version=*/CMPCTBLOCKS_VERSION);\n+            },\n+            [&]() {\n+                // Mine a block, but don't send it over p2p.\n+                BlockInfo block_info = create_block();\n+                info.push_back(block_info);\n+                set_net_msg = false;\n+            },\n+            [&]() {\n+                // Send a txn over p2p.\n+                CTransactionRef tx = create_tx();\n+                if (tx == nullptr) {\n+                    set_net_msg = false;\n+                    return;\n+                }\n+\n+                net_msg = NetMsg::Make(NetMsgType::TX, TX_WITH_WITNESS(*tx));\n+            },\n+            [&]() {\n+                // Set mock time.\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    SetMockTime(ConsumeTime(fuzzed_data_provider));\n+                } else {\n+                    // Set to tip's time so the CanDirectFetch check can pass in net_processing.\n+                    const uint64_t tip_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetBlockTime());\n+                    SetMockTime(tip_time);\n+                }\n+\n+                set_net_msg = false;\n+            });\n+\n+        if (!set_net_msg) {\n+            continue;\n+        }\n+\n+        CNode& random_node = *PickValue(fuzzed_data_provider, peers);\n+        connman.FlushSendBuffer(random_node);\n+        (void)connman.ReceiveMsgFrom(random_node, std::move(net_msg));\n+\n+        bool more_work{true};\n+        while (more_work) {\n+            random_node.fPauseSend = false;\n+\n+            try {\n+                more_work = connman.ProcessMessagesOnce(random_node);\n+            } catch (const std::ios_base::failure&) {\n+            }",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 422,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "1cfe4f0355879519b9f6aa52e971d757dd76a6d5",
      "in_reply_to_id": 2514076456,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in 62f2b9e4601ba34e504171f87577f315af51f3c9",
      "created_at": "2025-11-24T14:28:14Z",
      "updated_at": "2025-11-24T14:28:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2556523653",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556523653"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": 419,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 422,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556526561",
      "pull_request_review_id": 3500710250,
      "id": 2556526561,
      "node_id": "PRRC_kwDOABII586YYX_h",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 4; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 199,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "1cfe4f0355879519b9f6aa52e971d757dd76a6d5",
      "in_reply_to_id": 2514085576,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in 04d1dc78599362623bdd4b55c7be0c7b0f9f2174",
      "created_at": "2025-11-24T14:28:54Z",
      "updated_at": "2025-11-24T14:28:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2556526561",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556526561"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 199,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556529044",
      "pull_request_review_id": 3500713561,
      "id": 2556529044,
      "node_id": "PRRC_kwDOABII586YYYmU",
      "diff_hunk": "",
      "path": "src/test/util/setup_common.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "5a0f0c3fac47053f7d0245ac0b005d4b26cacd48",
      "in_reply_to_id": 2514157586,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Resolving since commit message changed so no longer relevant.",
      "created_at": "2025-11-24T14:29:19Z",
      "updated_at": "2025-11-24T14:29:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2556529044",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556529044"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556535563",
      "pull_request_review_id": 3500721549,
      "id": 2556535563,
      "node_id": "PRRC_kwDOABII586YYaML",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <consensus/consensus.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <pow.h>\n+#include <protocol.h>\n+#include <script/script.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/validation.h>\n+#include <util/fs_helpers.h>\n+#include <util/strencodings.h>\n+#include <util/time.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each fuzz iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Unchanging value to make valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created in the .init function.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock() {\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 4; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+    const auto GetAmount = [&](const COutPoint& outpoint) {\n+        auto coin{amount_view.GetCoin(outpoint).value()};\n+        return coin.out.nValue;\n+    };\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);\n+        } else if (mature_coinbase.size() != 0) {\n+            auto pop = mature_coinbase.begin();\n+            std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mature_coinbase.size() - 1));\n+            outpoint = *pop;\n+            mature_coinbase.erase(pop);\n+        } else {\n+            // We have no utxos available to make a transaction.\n+            return nullptr;\n+        }\n+\n+        const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+        const auto script_sig = CScript{};\n+        const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+\n+        CTxIn in;\n+        in.prevout = outpoint;\n+        in.nSequence = sequence;\n+        in.scriptSig = script_sig;\n+        in.scriptWitness.stack = script_wit_stack;\n+        tx_mut.vin.push_back(in);\n+\n+        const CAmount amount_in = GetAmount(outpoint);\n+        const CAmount amount_out = amount_in - AMOUNT_FEE;\n+        tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+\n+        auto tx = MakeTransactionRef(tx_mut);\n+        return tx;\n+    };\n+\n+    auto create_block = [&]() {\n+        uint256 prev;\n+        uint32_t height;\n+\n+        if (fuzzed_data_provider.ConsumeBool() || info.size() == 0) {\n+            LOCK(cs_main);\n+            prev = setup->m_node.chainman->ActiveChain().Tip()->GetBlockHash();\n+            height = setup->m_node.chainman->ActiveChain().Height() + 1;\n+        } else {\n+            size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+            prev = info[index].hash;\n+            height = info[index].height + 1;\n+        }\n+\n+        const auto new_time = WITH_LOCK(::cs_main, return setup->m_node.chainman->ActiveChain().Tip()->GetMedianTimePast() + 1);\n+\n+        CBlockHeader header;\n+        header.nNonce = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+        header.hashPrevBlock = prev;\n+        header.nBits = g_nBits;\n+        header.nTime = new_time;\n+        header.nVersion = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+        std::shared_ptr<CBlock> block = std::make_shared<CBlock>();\n+        *block = header;\n+\n+        CMutableTransaction coinbase_tx;\n+        coinbase_tx.vin.resize(1);\n+        coinbase_tx.vin[0].prevout.SetNull();\n+        coinbase_tx.vin[0].scriptSig = CScript() << height << OP_0;\n+        coinbase_tx.vout.resize(1);\n+        coinbase_tx.vout[0].scriptPubKey = CScript() << OP_TRUE;\n+        coinbase_tx.vout[0].nValue = COIN;\n+        block->vtx.push_back(MakeTransactionRef(coinbase_tx));\n+\n+        const auto mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            // Add txns from the mempool. Since we do not include parents, it may be an invalid block.\n+            size_t num_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, mempool_size);\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+\n+            LOCK(setup->m_node.mempool->cs);\n+            for (size_t i = random_idx; i < random_idx + num_txns; ++i) {\n+                CTransactionRef mempool_tx = setup->m_node.mempool->txns_randomized[i % mempool_size].second->GetSharedTx();\n+                block->vtx.push_back(mempool_tx);\n+            }\n+        }\n+\n+        // Create and add (possibly invalid) txns that are not in the mempool.\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            size_t new_txns = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 10);\n+            for (size_t i = 0; i < new_txns; ++i) {\n+                CTransactionRef non_mempool_tx = create_tx();\n+                if (non_mempool_tx != nullptr) {\n+                    block->vtx.push_back(non_mempool_tx);\n+                }\n+            }\n+        }\n+\n+        CBlockIndex* pindexPrev{WITH_LOCK(::cs_main, return setup->m_node.chainman->m_blockman.LookupBlockIndex(prev))};\n+        setup->m_node.chainman->GenerateCoinbaseCommitment(*block, pindexPrev);\n+\n+        bool mutated;\n+        block->hashMerkleRoot = BlockMerkleRoot(*block, &mutated);\n+        FinalizeHeader(*block, *setup->m_node.chainman);\n+\n+        BlockInfo block_info;\n+        block_info.block = block;\n+        block_info.hash = block->GetHash();\n+        block_info.height = height;\n+\n+        return block_info;\n+    };\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 1000)\n+    {\n+        CSerializedNetMsg net_msg;\n+        bool set_net_msg = true;\n+\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&]() {\n+                // Send a compact block.\n+                std::shared_ptr<CBlock> cblock;\n+\n+                // Pick an existing block or create a new block.\n+                if (fuzzed_data_provider.ConsumeBool() && info.size() != 0) {\n+                    size_t index = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, info.size() - 1);\n+                    cblock = info[index].block;\n+                } else {\n+                    BlockInfo block_info = create_block();\n+                    cblock = block_info.block;\n+                    info.push_back(block_info);\n+                }\n+\n+                uint64_t nonce = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                FuzzedCBlockHeaderAndShortTxIDs cmpctblock(*cblock, nonce);\n+\n+                size_t num_txs = cblock->vtx.size();\n+                if (fuzzed_data_provider.ConsumeBool() || num_txs == 1) {\n+                    CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                    net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+                    return;\n+                }\n+\n+                int prev_idx = 0;\n+                size_t num_erased = 0;\n+\n+                for (size_t i = 1; i < num_txs; ++i) {\n+                    if (fuzzed_data_provider.ConsumeBool()) continue;\n+\n+                    uint16_t prefill_idx = i - prev_idx - 1;\n+                    prev_idx = i;\n+                    CTransactionRef txref = cblock->vtx[i];\n+                    PrefilledTransaction prefilledtx = {/*index=*/prefill_idx, txref};\n+                    cmpctblock.AddPrefilledTx(std::move(prefilledtx));\n+\n+                    // Remove from shorttxids since we've prefilled. Subtract however many txs have been prefilled.\n+                    cmpctblock.EraseShortTxIDs(i - 1 - num_erased);\n+                    ++num_erased;\n+                }\n+\n+                CBlockHeaderAndShortTxIDs base_cmpctblock = cmpctblock;\n+                net_msg = NetMsg::Make(NetMsgType::CMPCTBLOCK, base_cmpctblock);\n+            },\n+            [&]() {",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 343,
      "original_position": 332,
      "commit_id": "3c515102f4e83b4117f52d7d0fd41aac59740b16",
      "original_commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "in_reply_to_id": 2514170270,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in the latest push to 039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "created_at": "2025-11-24T14:30:47Z",
      "updated_at": "2025-11-24T14:30:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2556535563",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556535563"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 343,
      "original_line": 343,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556547584",
      "pull_request_review_id": 3500736053,
      "id": 2556547584,
      "node_id": "PRRC_kwDOABII586YYdIA",
      "diff_hunk": "@@ -101,6 +102,7 @@ void SetupCommonTestArgs(ArgsManager& argsman)\n {\n     argsman.AddArg(\"-testdatadir\", strprintf(\"Custom data directory (default: %s<random_string>)\", fs::PathToString(fs::temp_directory_path() / TEST_DIR_PATH_ELEMENT / \"\")),\n                    ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-fuzzcopydatadir\", \"Copies the passed data directory to a temporary directory to use during a single fuzz iteration\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);",
      "path": "src/test/util/setup_common.cpp",
      "position": 1,
      "original_position": 12,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "5a0f0c3fac47053f7d0245ac0b005d4b26cacd48",
      "in_reply_to_id": 2514213312,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in f07ef4149b89d2c1d71af2cafd1bf29f6661b35a which introduces `rand_path` using strong randomness, and `-fuzzcopydatadir` and uses both in the same commit. The `EnableFuzzDeterminism` change is done in 039c3aab3b79e61e8ffe193bffee36b826ca2984.",
      "created_at": "2025-11-24T14:34:14Z",
      "updated_at": "2025-11-24T14:34:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2556547584",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556547584"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556550709",
      "pull_request_review_id": 3500739768,
      "id": 2556550709,
      "node_id": "PRRC_kwDOABII586YYd41",
      "diff_hunk": "@@ -180,6 +180,11 @@ bool CBlockIndexHeightOnlyComparator::operator()(const CBlockIndex* pa, const CB\n     return pa->nHeight < pb->nHeight;\n }\n \n+bool CBlockIndexBlockHashComparator::operator()(const CBlockIndex* pa, const CBlockIndex* pb) const\n+{\n+    return UintToArith256(pa->GetBlockHash()) < UintToArith256(pb->GetBlockHash());",
      "path": "src/node/blockstorage.cpp",
      "position": 1,
      "original_position": 6,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "in_reply_to_id": 2514673448,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Resolving as the commit has been removed.",
      "created_at": "2025-11-24T14:35:10Z",
      "updated_at": "2025-11-24T14:35:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2556550709",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556550709"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556552245",
      "pull_request_review_id": 3500741742,
      "id": 2556552245,
      "node_id": "PRRC_kwDOABII586YYeQ1",
      "diff_hunk": "@@ -95,6 +95,10 @@ struct CBlockIndexHeightOnlyComparator {\n     bool operator()(const CBlockIndex* pa, const CBlockIndex* pb) const;\n };\n \n+struct CBlockIndexBlockHashComparator {\n+    bool operator()(const CBlockIndex* pa, const CBlockIndex* pb) const;",
      "path": "src/node/blockstorage.h",
      "position": 1,
      "original_position": 5,
      "commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "original_commit_id": "f2ce3626a6a40b8688d711da1924db156dc2f02c",
      "in_reply_to_id": 2514702311,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Resolving as the commit has been removed.",
      "created_at": "2025-11-24T14:35:38Z",
      "updated_at": "2025-11-24T14:35:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2556552245",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2556552245"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626340174",
      "pull_request_review_id": 3586886869,
      "id": 2626340174,
      "node_id": "PRRC_kwDOABII586cisVO",
      "diff_hunk": "@@ -136,6 +136,13 @@ static inline bool copy_file(const path& from, const path& to, copy_options opti\n     return std::filesystem::copy_file(from, to, options);\n }\n \n+// Disallow implicit std::string conversion for copy to avoid locale-dependent\n+// encoding on Windows. This is currently only used in fuzzing.\n+static inline void copy(const path& from, const path& to, copy_options options)",
      "path": "src/util/fs.h",
      "position": 1,
      "original_position": 6,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "8515594b3b716d05a89b9fef36dfe7e8032d19c7",
      "in_reply_to_id": 2514018993,
      "user": {
        "login": "frankomosh",
        "id": 33951953,
        "node_id": "MDQ6VXNlcjMzOTUxOTUz",
        "avatar_url": "https://avatars.githubusercontent.com/u/33951953?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/frankomosh",
        "html_url": "https://github.com/frankomosh",
        "followers_url": "https://api.github.com/users/frankomosh/followers",
        "following_url": "https://api.github.com/users/frankomosh/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/frankomosh/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/frankomosh/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/frankomosh/subscriptions",
        "organizations_url": "https://api.github.com/users/frankomosh/orgs",
        "repos_url": "https://api.github.com/users/frankomosh/repos",
        "events_url": "https://api.github.com/users/frankomosh/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/frankomosh/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Since this helper appears to be used only by fuzz test code, is there any downside to keeping it in a test only location(i.e under `src/test/util`) instead of `src/util/fs.h`? Maybe that could help keep utilâ€™s interface focused on production use, but happy to defer if thereâ€™s a reason it needs to live here specifically. ",
      "created_at": "2025-12-17T09:48:38Z",
      "updated_at": "2025-12-17T11:20:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2626340174",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626340174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626463355",
      "pull_request_review_id": 3586886869,
      "id": 2626463355,
      "node_id": "PRRC_kwDOABII586cjKZ7",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <random.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/validation.h>\n+#include <util/fs.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Constant value used to create valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created during init.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock()\n+{\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 4; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 165,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "in_reply_to_id": null,
      "user": {
        "login": "frankomosh",
        "id": 33951953,
        "node_id": "MDQ6VXNlcjMzOTUxOTUz",
        "avatar_url": "https://avatars.githubusercontent.com/u/33951953?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/frankomosh",
        "html_url": "https://github.com/frankomosh",
        "followers_url": "https://api.github.com/users/frankomosh/followers",
        "following_url": "https://api.github.com/users/frankomosh/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/frankomosh/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/frankomosh/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/frankomosh/subscriptions",
        "organizations_url": "https://api.github.com/users/frankomosh/orgs",
        "repos_url": "https://api.github.com/users/frankomosh/repos",
        "events_url": "https://api.github.com/users/frankomosh/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/frankomosh/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Seems like `txns_randomized` reorders between runs, could this cause the same fuzz seed to pick different transactions? If so, would it make sense to snapshot the vector first for stable indexing?",
      "created_at": "2025-12-17T10:24:22Z",
      "updated_at": "2025-12-17T11:20:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2626463355",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2626463355"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2631870905",
      "pull_request_review_id": 3594000195,
      "id": 2631870905,
      "node_id": "PRRC_kwDOABII586c3ym5",
      "diff_hunk": "@@ -136,6 +136,13 @@ static inline bool copy_file(const path& from, const path& to, copy_options opti\n     return std::filesystem::copy_file(from, to, options);\n }\n \n+// Disallow implicit std::string conversion for copy to avoid locale-dependent\n+// encoding on Windows. This is currently only used in fuzzing.\n+static inline void copy(const path& from, const path& to, copy_options options)",
      "path": "src/util/fs.h",
      "position": 1,
      "original_position": 6,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "8515594b3b716d05a89b9fef36dfe7e8032d19c7",
      "in_reply_to_id": 2514018993,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This needs to be here because of the linter which checks that `std::filesystem` isn't used outside of this `fs` namespace.",
      "created_at": "2025-12-18T17:03:38Z",
      "updated_at": "2025-12-18T17:03:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2631870905",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2631870905"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2631874918",
      "pull_request_review_id": 3594005515,
      "id": 2631874918,
      "node_id": "PRRC_kwDOABII586c3zlm",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <random.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/validation.h>\n+#include <util/fs.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Constant value used to create valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created during init.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock()\n+{\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 4; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 165,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "in_reply_to_id": 2626463355,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I don't think `txns_randomized` gets reordered between runs, its randomness depends on the order that inserts/deletes happen in the mempool which is deterministic. I've also checked that this harness is fully deterministic with the `deterministic-fuzz-coverage` script.",
      "created_at": "2025-12-18T17:05:09Z",
      "updated_at": "2025-12-18T17:05:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2631874918",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2631874918"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2632037542",
      "pull_request_review_id": 3594252748,
      "id": 2632037542,
      "node_id": "PRRC_kwDOABII586c4bSm",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+// Copyright (c) 2025 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockencodings.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <random.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/net.h>\n+#include <test/util/mining.h>\n+#include <test/util/net.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/validation.h>\n+#include <util/fs.h>\n+#include <validationinterface.h>\n+\n+#include <memory>\n+#include <vector>\n+\n+using namespace util::hex_literals;\n+\n+namespace {\n+\n+//! Fee each created tx will pay.\n+const CAmount AMOUNT_FEE{1000};\n+//! Cached coinbases that each iteration can copy and use.\n+std::vector<COutPoint> g_mature_coinbase;\n+//! Constant value used to create valid headers.\n+uint32_t g_nBits;\n+//! Cached path to the datadir created during init.\n+fs::path g_cached_path;\n+//! One for each block the fuzzer generates.\n+struct BlockInfo {\n+    std::shared_ptr<CBlock> block;\n+    uint256 hash;\n+    uint32_t height;\n+};\n+//! Used to access prefilledtxn and shorttxids.\n+class FuzzedCBlockHeaderAndShortTxIDs : public CBlockHeaderAndShortTxIDs\n+{\n+    using CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs;\n+\n+public:\n+    void AddPrefilledTx(PrefilledTransaction&& prefilledtx)\n+    {\n+        prefilledtxn.push_back(std::move(prefilledtx));\n+    }\n+\n+    void EraseShortTxIDs(size_t index)\n+    {\n+        shorttxids.erase(shorttxids.begin() + index);\n+    }\n+};\n+//! Class to delete the statically-named datadir at the end of a fuzzing run.\n+class FuzzedDirectoryWrapper\n+{\n+private:\n+    fs::path staticdir;\n+\n+public:\n+    FuzzedDirectoryWrapper(fs::path name) : staticdir(name) {}\n+\n+    ~FuzzedDirectoryWrapper()\n+    {\n+        fs::remove_all(staticdir);\n+    }\n+};\n+\n+} // namespace\n+\n+void initialize_cmpctblock()\n+{\n+    std::vector<unsigned char> random_path_suffix(10);\n+    GetStrongRandBytes(random_path_suffix);\n+    std::string testdatadir = \"-testdatadir=\";\n+    std::string staticdir = \"cmpctblock_cached\" + HexStr(random_path_suffix);\n+    g_cached_path = fs::temp_directory_path() / staticdir;\n+    auto cached_datadir_arg = testdatadir + fs::PathToString(g_cached_path);\n+\n+    const auto initial_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {cached_datadir_arg.c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false});\n+\n+    static const FuzzedDirectoryWrapper wrapper(g_cached_path);\n+\n+    SetMockTime(Params().GenesisBlock().Time());\n+\n+    node::BlockAssembler::Options options;\n+    options.coinbase_output_script = P2WSH_OP_TRUE;\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(initial_setup->m_node, options)};\n+        if (i < COINBASE_MATURITY) {\n+            g_mature_coinbase.push_back(prevout);\n+        }\n+    }\n+\n+    initial_setup->m_node.chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    g_nBits = Params().GenesisBlock().nBits;\n+}\n+\n+FUZZ_TARGET(cmpctblock, .init=initialize_cmpctblock)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    std::string fuzzcopydatadir = \"-fuzzcopydatadir=\";\n+    auto copy_datadir_arg = fuzzcopydatadir + fs::PathToString(g_cached_path);\n+    const auto mock_start_time{1610000000};\n+\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(\n+        /*chain_type=*/ChainType::REGTEST,\n+        {.extra_args = {copy_datadir_arg.c_str(),\n+                        strprintf(\"-mocktime=%d\", mock_start_time).c_str()},\n+         .coins_db_in_memory = false,\n+         .block_tree_db_in_memory = false,\n+         .setup_validation_interface = false,\n+         .setup_validation_interface_no_scheduler = true});\n+\n+    auto setup = testing_setup.get();\n+\n+    setup->m_node.validation_signals->RegisterValidationInterface(setup->m_node.peerman.get());\n+    setup->m_node.validation_signals->SyncWithValidationInterfaceQueue();\n+    auto& chainman = static_cast<TestChainstateManager&>(*setup->m_node.chainman);\n+    chainman.ResetIbd();\n+\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+\n+    std::vector<CNode*> peers;\n+    auto& connman = *static_cast<ConnmanTestMsg*>(setup->m_node.connman.get());\n+    for (int i = 0; i < 4; ++i) {\n+        peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n+        CNode& p2p_node = *peers.back();\n+        FillNode(fuzzed_data_provider, connman, p2p_node);\n+        connman.AddTestNode(p2p_node);\n+    }\n+\n+    // Stores blocks generated this iteration.\n+    std::vector<BlockInfo> info;\n+\n+    // Coinbase UTXOs for this iteration.\n+    std::vector<COutPoint> mature_coinbase = g_mature_coinbase;\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &setup->m_node.chainman->ActiveChainstate().CoinsTip()), *setup->m_node.mempool};\n+\n+    auto create_tx = [&]() -> CTransactionRef {\n+        CMutableTransaction tx_mut;\n+        tx_mut.version = CTransaction::CURRENT_VERSION;\n+        tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+        // If the mempool is non-empty, choose a mempool outpoint. Otherwise, choose a coinbase.\n+        COutPoint outpoint;\n+        unsigned long mempool_size = setup->m_node.mempool->size();\n+        if (fuzzed_data_provider.ConsumeBool() && mempool_size != 0) {\n+            size_t random_idx = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, mempool_size - 1);\n+            LOCK(setup->m_node.mempool->cs);\n+            outpoint = COutPoint(setup->m_node.mempool->txns_randomized[random_idx].second->GetSharedTx()->GetHash(), 0);",
      "path": "src/test/fuzz/cmpctblock.cpp",
      "position": 1,
      "original_position": 165,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "in_reply_to_id": 2626463355,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Actually, the harness is not fully deterministic because I dropped a commit that will be done in a follow-up which causes some LevelDB non-determinism. But it is deterministic as far as the usage of txns_randomized goes.",
      "created_at": "2025-12-18T17:58:06Z",
      "updated_at": "2025-12-18T17:58:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2632037542",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2632037542"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2632784333",
      "pull_request_review_id": 3595241066,
      "id": 2632784333,
      "node_id": "PRRC_kwDOABII586c7RnN",
      "diff_hunk": "@@ -136,6 +136,13 @@ static inline bool copy_file(const path& from, const path& to, copy_options opti\n     return std::filesystem::copy_file(from, to, options);\n }\n \n+// Disallow implicit std::string conversion for copy to avoid locale-dependent\n+// encoding on Windows. This is currently only used in fuzzing.\n+static inline void copy(const path& from, const path& to, copy_options options)",
      "path": "src/util/fs.h",
      "position": 1,
      "original_position": 6,
      "commit_id": "039c3aab3b79e61e8ffe193bffee36b826ca2984",
      "original_commit_id": "8515594b3b716d05a89b9fef36dfe7e8032d19c7",
      "in_reply_to_id": 2514018993,
      "user": {
        "login": "Crypt-iQ",
        "id": 15145615,
        "node_id": "MDQ6VXNlcjE1MTQ1NjE1",
        "avatar_url": "https://avatars.githubusercontent.com/u/15145615?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Crypt-iQ",
        "html_url": "https://github.com/Crypt-iQ",
        "followers_url": "https://api.github.com/users/Crypt-iQ/followers",
        "following_url": "https://api.github.com/users/Crypt-iQ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Crypt-iQ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Crypt-iQ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Crypt-iQ/subscriptions",
        "organizations_url": "https://api.github.com/users/Crypt-iQ/orgs",
        "repos_url": "https://api.github.com/users/Crypt-iQ/repos",
        "events_url": "https://api.github.com/users/Crypt-iQ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Crypt-iQ/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Hmm, I guess the linter could be modified. I'll need to think a bit more on this. Ideally this wouldn't live in production code if it's not used in production.",
      "created_at": "2025-12-18T22:01:05Z",
      "updated_at": "2025-12-18T22:01:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33300#discussion_r2632784333",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2632784333"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33300"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 141,
      "side": "RIGHT"
    }
  ]
}