{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126",
    "id": 1874254526,
    "node_id": "PR_kwDOABII585vttq-",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30126",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30126.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30126.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/647fa37cdbadbeebba147ca6b24e138559cffaaf",
    "number": 30126,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "cluster mempool: cluster linearization algorithm",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Part of cluster mempool: #30289 \r\n\r\n\r\nThis introduces low-level cluster linearization code, including tests and some benchmarks. It is currently not hooked up to anything.\r\n\r\nUltimately, what this PR adds is a function `Linearize` which operates on instances of `DepGraph` (instances of which represent pre-processed transaction clusters) to produce and/or improve linearizations for that cluster.\r\n\r\nTo provide assurance, the code heavily relies on fuzz tests. A novel approach is used here, where the fuzz input is parsed using the serialization.h framework rather than `FuzzedDataProvider`, with a custom serializer/deserializer for `DepGraph` objects. By including serialization, it's possible to ascertain that the format can represent every relevant cluster, as well as potentially permitting the construction of ad-hoc fuzz inputs from clusters (not included in this PR, but used during development).\r\n\r\n---\r\n\r\nThe `Linearize(depgraph, iteration_limit, rng_seed, old_linearization)` function is an implementation of the (single) LIMO algorithm, with the $S$ in every iteration found as the best out of (a) the best remaining ancestor set and (b) randomized computationally-bounded search. It incrementally builds up a linearization by finding good topologically-valid subsets to move to the front, in such a way that the resulting linearization has a diagram that is at least as good as the `old_linearization` passed in (if any).\r\n* Despite using both best ancestor set and search, this is not Double LIMO, as no intersections between these are involved; just the best of the two.\r\n* The `iteration_limit` and `rng_seed` only control the (b) randomized search. Even with 0 iterations, the result will be as good as the old linearization, and the included sets at every point will have a feerate at least as high as the best remaining ancestor set at that point.\r\n\r\nThe search algorithm used in the (b) step is very basic, and largely matches Section 2.1 of [How to Linearize your Cluster.](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303#h-21-searching-6). See #30286 for optimizations to make it more efficient.\r\n\r\nFor background and references, see [Introduction to cluster linearization](https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032).",
    "labels": [
      {
        "id": 164208572,
        "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
        "name": "Mempool",
        "color": "fef2c0",
        "default": false
      }
    ],
    "created_at": "2024-05-16T20:29:15Z",
    "updated_at": "2024-07-26T11:12:19Z",
    "closed_at": "2024-07-26T11:12:19Z",
    "mergeable_state": "unknown",
    "merged_at": "2024-07-26T11:12:19Z",
    "merge_commit_sha": "37bd70a2253331ffd24650e6536695e7f47a86b0",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "requested_teams": [],
    "head": {
      "label": "sipa:202405_clusterlin",
      "ref": "202405_clusterlin",
      "sha": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 22,
        "stargazers_count": 86,
        "watchers_count": 86,
        "size": 243190,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-07-25T14:17:29Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2024-06-02T01:19:44Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "5d280130446d57d653c749005a2e363265d87686",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35665,
        "stargazers_count": 77342,
        "watchers_count": 77342,
        "size": 263904,
        "default_branch": "master",
        "open_issues_count": 662,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-07-26T11:41:21Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-07-26T11:41:29Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 2142,
    "deletions": 0,
    "changed_files": 9,
    "commits": 12,
    "review_comments": 246,
    "comments": 33
  },
  "events": [
    {
      "event": "commented",
      "id": 2116123949,
      "node_id": "IC_kwDOABII585-IX0t",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2116123949",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T20:29:17Z",
      "updated_at": "2024-07-25T21:51:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30126).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [instagibbs](https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2250609880), [glozow](https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2250613908), [sdaftuar](https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2251358535) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#30286](https://github.com/bitcoin/bitcoin/pull/30286) (cluster mempool: optimized candidate search by sipa)\n* [#30285](https://github.com/bitcoin/bitcoin/pull/30285) (cluster mempool: merging & postprocessing of linearizations by sipa)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2116123949",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "labeled",
      "id": 12840661156,
      "node_id": "LE_lADOABII586JKtCPzwAAAAL9XPCk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12840661156",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T22:28:58Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2116307861,
      "node_id": "IC_kwDOABII585-JEuV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2116307861",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T22:28:59Z",
      "updated_at": "2024-05-16T22:28:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\nðŸš§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25072594213</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2116307861",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12841939086,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL9cHCO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12841939086",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T02:20:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12841977041,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL9cQTR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12841977041",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T02:25:12Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12841998527,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL9cVi_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12841998527",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T02:28:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12847794028,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL9ycds",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12847794028",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T12:38:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12848600848,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL91hcQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12848600848",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T13:38:24Z"
    },
    {
      "event": "unlabeled",
      "id": 12849722556,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAL95zS8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12849722556",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T14:53:37Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 12852777283,
      "node_id": "LE_lADOABII586JKtCPzwAAAAL-FdFD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12852777283",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T19:54:02Z",
      "label": {
        "name": "Mempool",
        "color": "fef2c0"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12859897701,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL-gndl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12859897701",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T01:34:42Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12859902015,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL-gog_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12859902015",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T01:35:33Z"
    },
    {
      "event": "labeled",
      "id": 12860230371,
      "node_id": "LE_lADOABII586JKtCPzwAAAAL-h4rj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12860230371",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T02:43:26Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 12868212799,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAL_AVg_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12868212799",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T16:03:14Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12869818131,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL_GdcT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12869818131",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T18:49:29Z"
    },
    {
      "event": "commented",
      "id": 2121018386,
      "node_id": "IC_kwDOABII585-bCwS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2121018386",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T18:53:52Z",
      "updated_at": "2024-05-20T19:16:50Z",
      "author_association": "MEMBER",
      "body": "Benchmarks on my Ryzen 5950X system:\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|            2,373.94 |          421,240.11 |    0.1% |      1.10 | `LinearizeNoIters16TxWorstCase`\r\n|            7,530.22 |          132,798.26 |    0.0% |      1.07 | `LinearizeNoIters32TxWorstCase`\r\n|           16,585.34 |           60,294.20 |    0.1% |      1.10 | `LinearizeNoIters48TxWorstCase`\r\n|           28,591.70 |           34,975.18 |    0.1% |      1.10 | `LinearizeNoIters64TxWorstCase`\r\n|           53,918.56 |           18,546.49 |    0.0% |      1.10 | `LinearizeNoIters75TxWorstCase`\r\n|           93,589.21 |           10,684.99 |    0.1% |      1.10 | `LinearizeNoIters99TxWorstCase`\r\n\r\n|            ns/iters |             iters/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|               45.36 |       22,045,550.98 |    0.5% |      1.10 | `LinearizePerIter16TxWorstCase`\r\n|               35.57 |       28,111,376.58 |    0.1% |      1.10 | `LinearizePerIter32TxWorstCase`\r\n|               33.04 |       30,262,951.89 |    0.0% |      1.10 | `LinearizePerIter48TxWorstCase`\r\n|               33.21 |       30,107,745.17 |    0.1% |      1.10 | `LinearizePerIter64TxWorstCase`\r\n|               75.98 |       13,161,530.63 |    0.4% |      1.07 | `LinearizePerIter75TxWorstCase`\r\n|               76.62 |       13,051,066.77 |    0.5% |      1.08 | `LinearizePerIter99TxWorstCase`\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|              332.97 |        3,003,274.74 |    0.0% |      1.10 | `PostLinearize16TxWorstCase`\r\n|            1,121.92 |          891,330.77 |    0.0% |      1.10 | `PostLinearize32TxWorstCase`\r\n|            3,358.33 |          297,767.01 |    0.3% |      1.13 | `PostLinearize48TxWorstCase`\r\n|            5,826.72 |          171,623.05 |    0.5% |      1.11 | `PostLinearize64TxWorstCase`\r\n|            7,453.31 |          134,168.55 |    0.1% |      1.07 | `PostLinearize75TxWorstCase`\r\n|           12,476.44 |           80,151.09 |    0.1% |      1.10 | `PostLinearize99TxWorstCase`\r\n\r\nThis means that for a 64-transaction cluster, it should be possible to linearize (28.59 Âµs) with 100 candidate search iterations (3.32 Âµs) plus postlinearize (5.83 Âµs), within a total of 37.74 Âµs, on my system.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2121018386",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12871304039,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL_MINn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12871304039",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T21:33:55Z"
    },
    {
      "event": "labeled",
      "id": 12884960646,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMAAOWG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12884960646",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-21T20:09:26Z",
      "label": {
        "name": "DrahtBot Guix build requested",
        "color": "bfd4f2"
      }
    },
    {
      "event": "reviewed",
      "id": 2074233399,
      "node_id": "PRR_kwDOABII5857oko3",
      "url": null,
      "actor": null,
      "commit_id": "316e2044aad16e1ed8d024d3325bfcee8c04cd1f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2074233399",
      "submitted_at": "2024-05-23T14:55:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12911183405,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMBkQYt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12911183405",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:15:40Z"
    },
    {
      "event": "commented",
      "id": 2127404990,
      "node_id": "IC_kwDOABII585-zZ--",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2127404990",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:18:30Z",
      "updated_at": "2024-05-23T15:19:11Z",
      "author_association": "MEMBER",
      "body": "I've dropped the dependency on #29625, and switched to using FastRandomContext instead; there is a measurable slowdown from using the (ChaCha20-based) FastRandomContext over the (xoroshiro128++-based) InsecureRandomContext introduced there, but it's no more than 1-2%. I can switch back to that approach if 29625 were to make it in.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2127404990",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12911356100,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMBk6jE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12911356100",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:28:02Z"
    },
    {
      "event": "unlabeled",
      "id": 12911651125,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMBmCk1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12911651125",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:48:19Z",
      "label": {
        "name": "DrahtBot Guix build requested",
        "color": "bfd4f2"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12913685226,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMBtzLq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12913685226",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T18:23:24Z"
    },
    {
      "event": "commented",
      "id": 2127799066,
      "node_id": "IC_kwDOABII585-06Ma",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2127799066",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T18:33:11Z",
      "updated_at": "2024-05-23T18:33:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--9cd9c72976c961c55c7acef8f6ba82cd-->\n### Guix builds (on x86_64) [untrusted test-only build, possibly unsafe, not for production use]\n\n| File | commit 83ae1bac9d3e01de994734b4bc7002deaf19bc67<br>(master) | commit e5cbc2372efc917784b6cae4175b8653a20517c4<br>(master and this pull) |\n|--|--|--|\n| SHA256SUMS.part | [`24fd016e03e8c7da...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/SHA256SUMS.part) | [`15fae3483445e33b...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/SHA256SUMS.part) |\n| *-aarch64-linux-gnu-debug.tar.gz | [`94942cf7dedf3604...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-aarch64-linux-gnu-debug.tar.gz) | [`23eeccf77ee5799d...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-aarch64-linux-gnu-debug.tar.gz) |\n| *-aarch64-linux-gnu.tar.gz | [`4b30ca93b6788f48...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-aarch64-linux-gnu.tar.gz) | [`ed8e5024d960f53e...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-aarch64-linux-gnu.tar.gz) |\n| *-arm-linux-gnueabihf-debug.tar.gz | [`a0f57c45e5f02bb1...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-arm-linux-gnueabihf-debug.tar.gz) | [`f22f89c1eba49dda...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-arm-linux-gnueabihf-debug.tar.gz) |\n| *-arm-linux-gnueabihf.tar.gz | [`9f0376baaf54b988...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-arm-linux-gnueabihf.tar.gz) | [`17da8a968635c492...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-arm-linux-gnueabihf.tar.gz) |\n| *-arm64-apple-darwin-unsigned.tar.gz | [`9b952b32db70d099...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-arm64-apple-darwin-unsigned.tar.gz) | [`16d805ab4bcf8d54...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-arm64-apple-darwin-unsigned.tar.gz) |\n| *-arm64-apple-darwin-unsigned.zip | [`d49361bbbc5529fc...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-arm64-apple-darwin-unsigned.zip) | [`e225d79a24b058a5...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-arm64-apple-darwin-unsigned.zip) |\n| *-arm64-apple-darwin.tar.gz | [`34e9cf4b79cbc190...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-arm64-apple-darwin.tar.gz) | [`29b28e6d57761201...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-arm64-apple-darwin.tar.gz) |\n| *-powerpc64-linux-gnu-debug.tar.gz | [`5f322a7b213e244e...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-powerpc64-linux-gnu-debug.tar.gz) | [`cb5f37b036b5c52c...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-powerpc64-linux-gnu-debug.tar.gz) |\n| *-powerpc64-linux-gnu.tar.gz | [`bb57b46482c5b1e6...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-powerpc64-linux-gnu.tar.gz) | [`57adf954458a27d5...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-powerpc64-linux-gnu.tar.gz) |\n| *-riscv64-linux-gnu-debug.tar.gz | [`d1a3a405c5b45fff...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-riscv64-linux-gnu-debug.tar.gz) | [`237eb467f8547d22...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-riscv64-linux-gnu-debug.tar.gz) |\n| *-riscv64-linux-gnu.tar.gz | [`68d7e6671e2dba30...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-riscv64-linux-gnu.tar.gz) | [`29d9f1e9052e96d3...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-riscv64-linux-gnu.tar.gz) |\n| *-x86_64-apple-darwin-unsigned.tar.gz | [`6fb22000e8c14c40...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-x86_64-apple-darwin-unsigned.tar.gz) | [`67e5bd5b86483c8a...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-x86_64-apple-darwin-unsigned.tar.gz) |\n| *-x86_64-apple-darwin-unsigned.zip | [`1c5f2a216e87cbf5...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-x86_64-apple-darwin-unsigned.zip) | [`abdbca97fafc146f...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-x86_64-apple-darwin-unsigned.zip) |\n| *-x86_64-apple-darwin.tar.gz | [`66f17a574163ecaf...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-x86_64-apple-darwin.tar.gz) | [`f002830b4b8da330...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-x86_64-apple-darwin.tar.gz) |\n| *-x86_64-linux-gnu-debug.tar.gz | [`a5044f956a824228...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-x86_64-linux-gnu-debug.tar.gz) | [`0791685e39e80672...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-x86_64-linux-gnu-debug.tar.gz) |\n| *-x86_64-linux-gnu.tar.gz | [`23af1dc6cb921b37...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-x86_64-linux-gnu.tar.gz) | [`ff9625165c3f19c2...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-x86_64-linux-gnu.tar.gz) |\n| *.tar.gz | [`caac4a182deb1e04...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e.tar.gz) | [`ba8abeef4165dafb...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc.tar.gz) |\n| guix_build.log | [`c7cc0190f7085f04...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/guix_build.log) | [`100da60c2f0e6686...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/guix_build.log) |\n| guix_build.log.diff |  | [`7c460aa3b1aafc32...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/guix_build.log.diff) |\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2127799066",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12926701844,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMCfdEU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12926701844",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T15:33:59Z"
    },
    {
      "event": "commented",
      "id": 2129982443,
      "node_id": "IC_kwDOABII585-9PPr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129982443",
      "actor": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T16:49:21Z",
      "updated_at": "2024-05-24T16:49:21Z",
      "author_association": "MEMBER",
      "body": "Some more benchmarks.\r\n\r\nMacBook M3 Max:\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|            1,678.30 |          595,841.56 |    0.4% |      1.11 | `LinearizeNoIters16TxWorstCase`\r\n|            4,975.16 |          200,998.49 |    0.1% |      1.10 | `LinearizeNoIters32TxWorstCase`\r\n|           10,624.85 |           94,118.94 |    0.1% |      1.10 | `LinearizeNoIters48TxWorstCase`\r\n|           18,570.63 |           53,848.46 |    0.1% |      1.10 | `LinearizeNoIters64TxWorstCase`\r\n|           38,962.09 |           25,665.97 |    0.1% |      1.10 | `LinearizeNoIters75TxWorstCase`\r\n|           65,933.96 |           15,166.69 |    0.1% |      1.06 | `LinearizeNoIters99TxWorstCase`\r\n\r\n|            ns/iters |             iters/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|               37.31 |       26,803,657.99 |    0.1% |      1.10 | `LinearizePerIter16TxWorstCase`\r\n|               26.62 |       37,561,209.12 |    0.2% |      1.10 | `LinearizePerIter32TxWorstCase`\r\n|               25.79 |       38,768,485.22 |    0.2% |      1.10 | `LinearizePerIter48TxWorstCase`\r\n|               26.05 |       38,392,847.23 |    0.1% |      1.10 | `LinearizePerIter64TxWorstCase`\r\n|               37.99 |       26,322,699.89 |    0.2% |      1.09 | `LinearizePerIter75TxWorstCase`\r\n|               38.21 |       26,169,082.76 |    0.1% |      1.10 | `LinearizePerIter99TxWorstCase`\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|              375.76 |        2,661,273.20 |    0.3% |      1.11 | `PostLinearize16TxWorstCase`\r\n|            1,295.00 |          772,200.32 |    0.1% |      1.10 | `PostLinearize32TxWorstCase`\r\n|            2,850.98 |          350,756.38 |    0.0% |      1.10 | `PostLinearize48TxWorstCase`\r\n|            5,155.30 |          193,975.14 |    0.0% |      1.10 | `PostLinearize64TxWorstCase`\r\n|            6,804.84 |          146,954.16 |    0.1% |      1.06 | `PostLinearize75TxWorstCase`\r\n|           11,696.22 |           85,497.68 |    0.0% |      1.10 | `PostLinearize99TxWorstCase`\r\n\r\nRaspberry Pi 4 (arm32):\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|           24,979.12 |           40,033.43 |    0.1% |       62,303.01 |       37,432.31 |  1.664 |      1.10 | `LinearizeNoIters16TxWorstCase`\r\n|           79,796.77 |           12,531.84 |    0.0% |      199,042.69 |      119,579.10 |  1.665 |      1.08 | `LinearizeNoIters32TxWorstCase`\r\n|          206,049.75 |            4,853.20 |    0.0% |      514,152.74 |      308,732.11 |  1.665 |      1.10 | `LinearizeNoIters48TxWorstCase`\r\n|          339,314.40 |            2,947.12 |    0.0% |      866,686.12 |      508,414.12 |  1.705 |      1.10 | `LinearizeNoIters64TxWorstCase`\r\n|          574,288.94 |            1,741.28 |    0.0% |    1,309,819.21 |      860,366.98 |  1.522 |      1.10 | `LinearizeNoIters75TxWorstCase`\r\n|          983,808.56 |            1,016.46 |    0.0% |    2,278,204.68 |    1,474,149.12 |  1.545 |      1.10 | `LinearizeNoIters99TxWorstCase`\r\n\r\n|            ns/iters |             iters/s |    err% |       ins/iters |       cyc/iters |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|              362.94 |        2,755,255.49 |    0.1% |          862.03 |          543.89 |  1.585 |      1.10 | `LinearizePerIter16TxWorstCase`\r\n|              290.11 |        3,446,974.76 |    0.2% |          692.02 |          434.73 |  1.592 |      1.10 | `LinearizePerIter32TxWorstCase`\r\n|              529.35 |        1,889,094.80 |    0.1% |        1,319.02 |          793.26 |  1.663 |      1.11 | `LinearizePerIter48TxWorstCase`\r\n|              530.00 |        1,886,788.68 |    0.2% |        1,324.44 |          794.26 |  1.668 |      1.11 | `LinearizePerIter64TxWorstCase`\r\n|              782.35 |        1,278,197.39 |    0.5% |        2,079.81 |        1,172.37 |  1.774 |      1.06 | `LinearizePerIter75TxWorstCase`\r\n|              737.95 |        1,355,112.46 |    0.5% |        1,684.40 |        1,105.59 |  1.524 |      1.07 | `LinearizePerIter99TxWorstCase`\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|            5,010.36 |          199,586.29 |    0.8% |       10,606.00 |        7,506.09 |  1.413 |      1.10 | `PostLinearize16TxWorstCase`\r\n|           14,365.91 |           69,609.26 |    0.0% |       34,330.00 |       21,530.90 |  1.594 |      1.09 | `PostLinearize32TxWorstCase`\r\n|           32,751.91 |           30,532.57 |    0.0% |       76,671.01 |       49,085.98 |  1.562 |      1.10 | `PostLinearize48TxWorstCase`\r\n|           55,794.83 |           17,922.81 |    0.0% |      131,423.02 |       83,621.11 |  1.572 |      1.10 | `PostLinearize64TxWorstCase`\r\n|           81,534.00 |           12,264.82 |    1.6% |      210,784.02 |      120,341.56 |  1.752 |      1.09 | `PostLinearize75TxWorstCase`\r\n|          144,665.53 |            6,912.50 |    0.0% |      399,573.04 |      216,805.74 |  1.843 |      1.10 | `PostLinearize99TxWorstCase`\r\n\r\nRaspberry Pi 4 (aarch64):\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|           13,765.93 |           72,643.09 |    0.1% |       37,001.00 |       20,625.64 |  1.794 |     11.01 | `LinearizeNoIters16TxWorstCase`\r\n|           41,091.94 |           24,335.67 |    0.2% |      107,447.00 |       61,567.66 |  1.745 |     10.99 | `LinearizeNoIters32TxWorstCase`\r\n|           73,005.68 |           13,697.56 |    0.1% |      210,986.00 |      109,380.97 |  1.929 |     10.67 | `LinearizeNoIters48TxWorstCase`\r\n|          118,418.69 |            8,444.61 |    0.0% |      348,914.00 |      177,423.52 |  1.967 |     11.01 | `LinearizeNoIters64TxWorstCase`\r\n|          229,345.84 |            4,360.23 |    0.0% |      618,749.67 |      343,589.10 |  1.801 |     11.01 | `LinearizeNoIters75TxWorstCase`\r\n|          377,809.11 |            2,646.84 |    0.0% |    1,021,644.01 |      565,996.91 |  1.805 |     11.00 | `LinearizeNoIters99TxWorstCase`\r\n\r\n|            ns/iters |             iters/s |    err% |       ins/iters |       cyc/iters |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|              231.99 |        4,310,566.43 |    0.0% |          643.14 |          347.59 |  1.850 |     11.00 | `LinearizePerIter16TxWorstCase`\r\n|              190.47 |        5,250,207.80 |    0.1% |          525.81 |          285.35 |  1.843 |     11.03 | `LinearizePerIter32TxWorstCase`\r\n|              175.35 |        5,702,969.82 |    0.1% |          492.10 |          262.75 |  1.873 |     11.01 | `LinearizePerIter48TxWorstCase`\r\n|              175.70 |        5,691,481.30 |    0.1% |          494.56 |          263.25 |  1.879 |     11.00 | `LinearizePerIter64TxWorstCase`\r\n|              293.22 |        3,410,384.42 |    0.2% |          763.38 |          439.30 |  1.738 |     11.01 | `LinearizePerIter75TxWorstCase`\r\n|              293.55 |        3,406,519.94 |    0.1% |          766.88 |          439.77 |  1.744 |     11.01 | `LinearizePerIter99TxWorstCase`\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|            2,915.23 |          343,026.59 |    0.1% |        5,325.00 |        4,368.47 |  1.219 |     11.01 | `PostLinearize16TxWorstCase`\r\n|            9,830.26 |          101,726.71 |    0.0% |       17,247.00 |       14,729.95 |  1.171 |     11.00 | `PostLinearize32TxWorstCase`\r\n|           20,550.14 |           48,661.46 |    0.0% |       35,742.00 |       30,794.09 |  1.161 |     11.00 | `PostLinearize48TxWorstCase`\r\n|           35,211.73 |           28,399.62 |    0.0% |       61,199.00 |       52,763.93 |  1.160 |     11.00 | `PostLinearize64TxWorstCase`\r\n|           31,801.73 |           31,444.83 |    0.0% |       95,378.00 |       47,653.77 |  2.001 |     11.00 | `PostLinearize75TxWorstCase`\r\n|           52,955.80 |           18,883.67 |    0.0% |      162,443.00 |       79,349.66 |  2.047 |     11.00 | `PostLinearize99TxWorstCase`",
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2129982443",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927624409,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMCi-TZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927624409",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:03:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927882366,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMCj9R-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927882366",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:30:34Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927934896,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMCkKGw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927934896",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:36:57Z"
    },
    {
      "event": "labeled",
      "id": 12927935505,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMCkKQR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927935505",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:37:01Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2130060489,
      "node_id": "IC_kwDOABII585-9iTJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130060489",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:37:02Z",
      "updated_at": "2024-05-24T17:37:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\nðŸš§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25390396918</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2130060489",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "commented",
      "id": 2130129883,
      "node_id": "IC_kwDOABII585-9zPb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130129883",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T18:26:06Z",
      "updated_at": "2024-05-24T18:26:06Z",
      "author_association": "MEMBER",
      "body": "> Ancestor-set based presplitting inside the search is replaced with using the best ancestor set as one of the LIMO set choices.\r\n\r\nCan this be elaborated a bit? I've taken a few minutes looking at the commits and it wasn't immediately clear how this all maps to existing public discussions and the comments:\r\n\r\n```\r\n        // This is an implementation of the (single) LIMO algorithm:\r\n        // https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825\r\n        // where S is instantiated to be the result of a bounded search, which itself is seeded\r\n        // with the best prefix of what remains of the input linearization, or the best ancestor set.\r\n```\r\nthanks!",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2130129883",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "commented",
      "id": 2130187888,
      "node_id": "IC_kwDOABII585--BZw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130187888",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T19:05:02Z",
      "updated_at": "2024-05-24T19:16:08Z",
      "author_association": "MEMBER",
      "body": "@instagibbs I've expanded the explanation in the PR description. Happy to elaborate more if things are unclear.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2130187888",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "mentioned",
      "id": 12928689814,
      "node_id": "MEE_lADOABII586JKtCPzwAAAAMCnCaW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12928689814",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T19:05:04Z"
    },
    {
      "event": "subscribed",
      "id": 12928689822,
      "node_id": "SE_lADOABII586JKtCPzwAAAAMCnCae",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12928689822",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T19:05:04Z"
    },
    {
      "event": "unlabeled",
      "id": 12930191775,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMCsxGf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12930191775",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T22:47:36Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12934054913,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMC7gQB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12934054913",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-25T22:07:02Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12934290395,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMC8Zvb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12934290395",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-25T23:42:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12934323825,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMC8h5x",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12934323825",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-26T00:00:13Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12936811909,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMDGBWF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12936811909",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-26T13:32:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12958045312,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMEXBSA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12958045312",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T13:50:27Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12975512592,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMFZpwQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12975512592",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-29T18:06:13Z"
    },
    {
      "event": "commented",
      "id": 2138188901,
      "node_id": "IC_kwDOABII585_cixl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2138188901",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-29T20:14:05Z",
      "updated_at": "2024-05-29T20:14:05Z",
      "author_association": "MEMBER",
      "body": "I've added support for merging linearizations to this PR (`MergeLinearizations()` function), plus benchmarks and tests.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2138188901",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "labeled",
      "id": 12980402065,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMFsTeR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12980402065",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T05:55:09Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2138735594,
      "node_id": "IC_kwDOABII585_eoPq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2138735594",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T05:55:10Z",
      "updated_at": "2024-05-30T05:55:10Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\nðŸš§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25568469819</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2138735594",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12985679275,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMGAb2r",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12985679275",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T12:52:10Z"
    },
    {
      "event": "unlabeled",
      "id": 12991846022,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMGX9aG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12991846022",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T21:07:01Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2077166958,
      "node_id": "PRR_kwDOABII5857zw1u",
      "url": null,
      "actor": null,
      "commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "glanced in the context of checking what of VecDeque/BitSet actually required",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2077166958",
      "submitted_at": "2024-06-06T14:13:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13070771117,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMLFCOt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13070771117",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T18:33:20Z"
    },
    {
      "event": "referenced",
      "id": 13081030834,
      "node_id": "REFE_lADOABII586JKtCPzwAAAAMLsLCy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13081030834",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "feab35189bc00bc4cf15e9dcb5cf6b34ff3a1e91",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/feab35189bc00bc4cf15e9dcb5cf6b34ff3a1e91",
      "created_at": "2024-06-07T13:33:20Z"
    },
    {
      "event": "labeled",
      "id": 13082095784,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMLwPCo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13082095784",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T14:44:39Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13082513580,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMLx1Cs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13082513580",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T15:20:40Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13084466690,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAML5R4C",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13084466690",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T18:52:51Z"
    },
    {
      "event": "unlabeled",
      "id": 13084572312,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAML5rqY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13084572312",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T19:04:25Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13085738874,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAML-Id6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13085738874",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T21:37:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13093283115,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMMa6Ur",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13093283115",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-10T00:28:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13109045660,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMNXCmc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13109045660",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T00:58:52Z"
    },
    {
      "event": "labeled",
      "id": 13110771411,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMNdn7T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13110771411",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T05:11:18Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2159806599,
      "node_id": "IC_kwDOABII586AvAiH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2159806599",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T05:11:19Z",
      "updated_at": "2024-06-11T05:11:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\nðŸš§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/26052313359</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2159806599",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13115580682,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMNv-EK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13115580682",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T11:23:21Z"
    },
    {
      "event": "unlabeled",
      "id": 13117085849,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMN1tiZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13117085849",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T13:15:11Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13122043976,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMOIoBI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13122043976",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T19:51:04Z"
    },
    {
      "event": "referenced",
      "id": 13122953655,
      "node_id": "REFE_lADOABII586JKtCPzwAAAAMOMGG3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13122953655",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "91e0beede2859dea987ba6db746e95dca0ceb024",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/91e0beede2859dea987ba6db746e95dca0ceb024",
      "created_at": "2024-06-11T21:28:58Z"
    },
    {
      "event": "labeled",
      "id": 13123639969,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMOOtqh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13123639969",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T23:12:20Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13123652095,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMOOwn_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13123652095",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T23:14:29Z"
    },
    {
      "event": "unlabeled",
      "id": 13124366874,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMORfIa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13124366874",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-12T01:17:30Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13137473518,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMPDe_u",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13137473518",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-12T21:14:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13137755681,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMPEj4h",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13137755681",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-12T21:47:11Z"
    },
    {
      "event": "labeled",
      "id": 13143080877,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMPY3-t",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13143080877",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T08:57:45Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2165049648,
      "node_id": "IC_kwDOABII586BDAkw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2165049648",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T08:57:46Z",
      "updated_at": "2024-06-13T08:57:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\nðŸš§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/26153096652</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2165049648",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13147233559,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMPot0X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13147233559",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T13:49:39Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13148811159,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMPuu-X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13148811159",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T15:26:12Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13150112020,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMPzskU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13150112020",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T17:01:33Z"
    },
    {
      "event": "unlabeled",
      "id": 13151725563,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMP52f7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13151725563",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T19:14:32Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13151774954,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMP6Cjq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13151774954",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T19:19:18Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13154448696,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMQEPU4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13154448696",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T01:47:25Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13154557139,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMQEpzT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13154557139",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T02:05:33Z"
    },
    {
      "event": "renamed",
      "id": 13160829573,
      "node_id": "RTE_lADOABII586JKtCPzwAAAAMQclKF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13160829573",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T13:12:50Z",
      "rename": {
        "from": "Low-level cluster linearization code",
        "to": "cluster mempool: cluster linearization algorithm"
      }
    },
    {
      "event": "commented",
      "id": 2168024936,
      "node_id": "IC_kwDOABII586BOW9o",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2168024936",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T13:17:11Z",
      "updated_at": "2024-06-14T13:17:11Z",
      "author_association": "MEMBER",
      "body": "I have split off the optimizations for candidate search to PR #30286, and the merging & postprocessing algorithms to PR #30285, and renamed the PR. It is now focused on just adding the `Linearize()` function, with its eventual interface (including passing in an old linearization, and a randomization seed), but without optimizations beyond that.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2168024936",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13235415708,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMU5Gqc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13235415708",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-20T23:08:33Z"
    },
    {
      "event": "commented",
      "id": 2181689921,
      "node_id": "IC_kwDOABII586CCfJB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2181689921",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-20T23:09:06Z",
      "updated_at": "2024-06-20T23:09:06Z",
      "author_association": "MEMBER",
      "body": "Added a big description about the fuzzer serialization format for DepGraph objects.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2181689921",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "reviewed",
      "id": 2116172410,
      "node_id": "PRR_kwDOABII585-Ijp6",
      "url": null,
      "actor": null,
      "commit_id": "9633b40722fd9295b93baaf9914b31b9dec96f45",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "couldn't find any logic issues in the parts I complete understood, I've run the fuzzer on each commit and reviewed through  https://github.com/bitcoin/bitcoin/pull/30126/commits/9633b40722fd9295b93baaf9914b31b9dec96f45\r\n\r\na couple general comments:\r\n\r\n1) The bespoke DepGraphFormatter is pretty artisanal and as a reviewer I'm relying heavily on the cluster->depgraph->check depgraph matches -> serialization round-trip for asserting correctness. Unit tests-as-documentation is one thing I'm kind of missing, especially with the more involved parts.\r\n2) Matching the actual LIMO commit with the LIMO literature/theory available is difficult for me(e.g., what's sufficient vs necessary). I know there's a new writeup coming, so I'll wait for that before investigating further.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2116172410",
      "submitted_at": "2024-06-27T15:02:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13323909917,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMaKrsd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13323909917",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T21:57:19Z"
    },
    {
      "event": "commented",
      "id": 2195728404,
      "node_id": "IC_kwDOABII586C4CgU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2195728404",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T21:59:06Z",
      "updated_at": "2024-06-27T21:59:06Z",
      "author_association": "MEMBER",
      "body": "Addressed some of @instagibbs' comments, which involved moving some of the `src/test/fuzz/cluster_linearize.cpp` code to a common `src/test/util/cluster_linearize.h`, where it is also available to a newly-added (but pretty barebones) `src/test/cluster_linearize_tests.cpp`.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2195728404",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "mentioned",
      "id": 13323922870,
      "node_id": "MEE_lADOABII586JKtCPzwAAAAMaKu22",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13323922870",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T21:59:08Z"
    },
    {
      "event": "subscribed",
      "id": 13323922878,
      "node_id": "SE_lADOABII586JKtCPzwAAAAMaKu2-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13323922878",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T21:59:08Z"
    },
    {
      "event": "commented",
      "id": 2195825414,
      "node_id": "IC_kwDOABII586C4aMG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2195825414",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T23:27:50Z",
      "updated_at": "2024-06-27T23:27:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\nðŸš§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/26783773668</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2195825414",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "labeled",
      "id": 13324461892,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMaMydE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13324461892",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T23:27:50Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13326060235,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMaS4rL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13326060235",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-28T03:53:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13326149312,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMaTObA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13326149312",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-28T04:09:31Z"
    },
    {
      "event": "unlabeled",
      "id": 13326607204,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMaU-Nk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13326607204",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-28T05:25:03Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13335385605,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMa2dYF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13335385605",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-28T19:21:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13343634959,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMbV7YP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13343634959",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-01T00:56:32Z"
    },
    {
      "event": "labeled",
      "id": 13362254729,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMcc9OJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13362254729",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-02T08:47:38Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 13366998273,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMcvDUB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13366998273",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-02T14:16:55Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13371378031,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMc_wlv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13371378031",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-02T20:20:20Z"
    },
    {
      "event": "reviewed",
      "id": 2151679554,
      "node_id": "PRR_kwDOABII586AQAZC",
      "url": null,
      "actor": null,
      "commit_id": "48e83f9521050e150aa52c0e949ac4746ac30340",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Just reviewed through the first 3 commits so far.",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2151679554",
      "submitted_at": "2024-07-03T20:23:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "reviewed",
      "id": 2160552969,
      "node_id": "PRR_kwDOABII586Ax2wJ",
      "url": null,
      "actor": null,
      "commit_id": "48e83f9521050e150aa52c0e949ac4746ac30340",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2160552969",
      "submitted_at": "2024-07-05T12:20:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13417499895,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMfvsz3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13417499895",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T04:36:02Z"
    },
    {
      "event": "reviewed",
      "id": 2118340933,
      "node_id": "PRR_kwDOABII585-Q1FF",
      "url": null,
      "actor": null,
      "commit_id": "dc46e54606ca42dd34fb66ae5e3deb1a95e9589e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Looked at the first 4 commits so far, just doing code review and trying the algos out in `MiniMiner`.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2118340933",
      "submitted_at": "2024-07-08T15:34:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13429537844,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMgdnw0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13429537844",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T20:35:05Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13432484821,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMgo3PV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13432484821",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T02:53:54Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13449420292,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMhpd4E",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13449420292",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T03:32:11Z"
    },
    {
      "event": "labeled",
      "id": 13449848675,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMhrGdj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13449848675",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T04:51:42Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13455435119,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMiAaVv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13455435119",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T12:32:55Z"
    },
    {
      "event": "reviewed",
      "id": 2169903436,
      "node_id": "PRR_kwDOABII586BVhlM",
      "url": null,
      "actor": null,
      "commit_id": "41e31ce727ebb80c083255f53e109fc413e2d39f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2169903436",
      "submitted_at": "2024-07-10T18:12:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13461439023,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMiXUIv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13461439023",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T20:04:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13462199005,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMiaNrd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13462199005",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T20:49:34Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13464507559,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMijBSn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13464507559",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T01:10:52Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13470969521,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMi7q6x",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13470969521",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T12:24:05Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13471126723,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMi8RTD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13471126723",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T12:36:40Z"
    },
    {
      "event": "unlabeled",
      "id": 13472345995,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMjA6-L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13472345995",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T13:59:59Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2223139418,
      "node_id": "IC_kwDOABII586Egmpa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2223139418",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:49:20Z",
      "updated_at": "2024-07-11T17:04:47Z",
      "author_association": "MEMBER",
      "body": "I've made a few changes the past few days, and the code should be ready for more review now:\r\n* The fuzzer serialization format for `DepGraph` was changed to something simpler.\r\n* The linearization -> chunk feerates function `ChunkLinearization` was moved from the fuzz tests to the main cluster_linearization.h file, in a new separate commit, which also includes a fuzz test for just that function.\r\n* The LIMO code now runs intersections with the chunk prefixes of the *current* chunk boundaries of the remainder of the old linearization, rather than prefixes of the remainders of the *original* chunk boundaries of the old linearization:\r\n  * This should be a bit faster for what I believe to be the worst case.\r\n  * It can only improve the quality of the linearizations that come out (though probably not substantially).\r\n  * It means a significant part of the LIMO complexity can now be shared with the Merge algorithm from #30285. Because of that, this part (keeping track of the chunking of the remainder of a linearization, and computing intersections with its prefixes) has been abstracted out into a separate class `LinearizationChunking`, which is introduced in a separate commit, with its own new fuzz test.\r\n\r\nFurther, I have posted https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032 which I'd encourage people to look at if they want to understand the usefulness of these algorithms.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2223139418",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13473310265,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMjEmY5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13473310265",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T15:06:13Z"
    },
    {
      "event": "commented",
      "id": 2223184322,
      "node_id": "IC_kwDOABII586EgxnC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2223184322",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T15:06:43Z",
      "updated_at": "2024-07-11T15:06:59Z",
      "author_association": "MEMBER",
      "body": "Sorry, one small push to get rid of an extra function that I introduced in the mean time, but that ended up being unnecessary.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2223184322",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13478109315,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMjW6CD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13478109315",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T21:09:24Z"
    },
    {
      "event": "subscribed",
      "id": 13490590967,
      "node_id": "SE_lADOABII586JKtCPzwAAAAMkGhT3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13490590967",
      "actor": {
        "login": "kashifs",
        "id": 1489460,
        "node_id": "MDQ6VXNlcjE0ODk0NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1489460?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kashifs",
        "html_url": "https://github.com/kashifs",
        "followers_url": "https://api.github.com/users/kashifs/followers",
        "following_url": "https://api.github.com/users/kashifs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kashifs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kashifs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kashifs/subscriptions",
        "organizations_url": "https://api.github.com/users/kashifs/orgs",
        "repos_url": "https://api.github.com/users/kashifs/repos",
        "events_url": "https://api.github.com/users/kashifs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kashifs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T17:48:25Z"
    },
    {
      "event": "reviewed",
      "id": 2177326357,
      "node_id": "PRR_kwDOABII586Bx10V",
      "url": null,
      "actor": null,
      "commit_id": "23496cb4d43327c3d27401a531586bcfc985b6ad",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2177326357",
      "submitted_at": "2024-07-15T11:05:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "commented",
      "id": 2229460209,
      "node_id": "IC_kwDOABII586E4tzx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2229460209",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-15T21:19:06Z",
      "updated_at": "2024-07-15T21:19:06Z",
      "author_association": "MEMBER",
      "body": "c192b30156ae41638291010b40b874479ea1943c \"clusterlin: add algorithms for connectedness/connected components\" seems to be only relevant for the optimizations in #30286, so could be dropped from here?",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2229460209",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "reviewed",
      "id": 2178360431,
      "node_id": "PRR_kwDOABII586B1yRv",
      "url": null,
      "actor": null,
      "commit_id": "23496cb4d43327c3d27401a531586bcfc985b6ad",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "another pass, through https://github.com/bitcoin/bitcoin/pull/30126/commits/23496cb4d43327c3d27401a531586bcfc985b6ad\r\n\r\nchanges since last look make sense, I would like to spend more time validating the optimizations ",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2178360431",
      "submitted_at": "2024-07-16T19:36:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13526883450,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMmQ9x6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13526883450",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-16T20:44:00Z"
    },
    {
      "event": "reviewed",
      "id": 2180007217,
      "node_id": "PRR_kwDOABII586B8EUx",
      "url": null,
      "actor": null,
      "commit_id": "4ec9f2e44dfeeee3d0409fb1f5dba605f7531b18",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2180007217",
      "submitted_at": "2024-07-16T21:35:10Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "reviewed",
      "id": 2181382355,
      "node_id": "PRR_kwDOABII586CBUDT",
      "url": null,
      "actor": null,
      "commit_id": "4ec9f2e44dfeeee3d0409fb1f5dba605f7531b18",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Reviewed:\r\n\r\n- [x] 4409a282d7fe7a0ebee67c8fb9fb4ef157ed5883\r\n- [x] f5fa49f589f477caa5a4ca41d8331acdca6d7298\r\n- [x] 48f086eb624a5371b846e908b4702b28726465fa\r\n- [x] ccde33054e9573bc9c263acd9746b8003578cb29\r\n- [x] 6fdb3d07d4350b0d93bda5765ea1053c29866c0a\r\n- [x] 448b8b977920b8d2f90008fa1939d3d3bba63668\r\n- [x] 896b52337be5765cb3a7d3f0458475f2f8e2cb3a\r\n\r\nI spent time understanding the [cluster linearization theory](https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032).\r\nThe serialization and de-serialization code in f5fa49f589f477caa5a4ca41d8331acdca6d7298 are well documented ðŸ’¯ \r\n",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2181382355",
      "submitted_at": "2024-07-16T21:58:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13530021720,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMmc79Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13530021720",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-17T03:03:24Z"
    },
    {
      "event": "labeled",
      "id": 13530707356,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMmfjWc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13530707356",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-17T04:47:59Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 13532508219,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMmmbA7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13532508219",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-17T07:57:10Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2233483074,
      "node_id": "IC_kwDOABII586FID9C",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2233483074",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-17T14:35:56Z",
      "updated_at": "2024-07-17T14:35:56Z",
      "author_association": "MEMBER",
      "body": "reviewed through https://github.com/bitcoin/bitcoin/pull/30126/commits/2003bb8a279c8891e55bab190ca36f0c6c8697ea\r\n\r\nvia `git range-diff master 23496cb 2003bb8a279c8891e55bab190ca36f0c6c8697ea`",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2233483074",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "reviewed",
      "id": 2183948520,
      "node_id": "PRR_kwDOABII586CLGjo",
      "url": null,
      "actor": null,
      "commit_id": "2003bb8a279c8891e55bab190ca36f0c6c8697ea",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2183948520",
      "submitted_at": "2024-07-17T20:17:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "reviewed",
      "id": 2183951716,
      "node_id": "PRR_kwDOABII586CLHVk",
      "url": null,
      "actor": null,
      "commit_id": "2003bb8a279c8891e55bab190ca36f0c6c8697ea",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2183951716",
      "submitted_at": "2024-07-17T20:18:34Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "reviewed",
      "id": 2183957817,
      "node_id": "PRR_kwDOABII586CLI05",
      "url": null,
      "actor": null,
      "commit_id": "faf8a3bdd3f9cf795f197b413f94b8e2d0905fd9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2183957817",
      "submitted_at": "2024-07-17T20:20:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13542819385,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMnNwY5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13542819385",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-17T20:38:16Z"
    },
    {
      "event": "commented",
      "id": 2234250901,
      "node_id": "IC_kwDOABII586FK_aV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2234250901",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-17T20:45:57Z",
      "updated_at": "2024-07-17T20:45:57Z",
      "author_association": "MEMBER",
      "body": "I have made a number of changes:\r\n* Addressed a number of typos\r\n* Moved connected-component logic to #30286 (where `MakeConnected` is now optional, and `FindConnectedComponent` has its own fuzz test).\r\n* Moved the chunk-caching logic in `LinearizationChunking` to #30286.\r\n* Added more explanatory comments, especially in the `DepGraphFormatter` format description.\r\n* Made the `DepGraphFormatter` deserializer resilient to EOF (previously it would return an empty graph in this case), plus added a test for it in `SanityCheck(const DepGraph&)`.\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2234250901",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "commented",
      "id": 2236852405,
      "node_id": "IC_kwDOABII586FU6i1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2236852405",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-18T15:23:01Z",
      "updated_at": "2024-07-18T15:23:01Z",
      "author_association": "MEMBER",
      "body": "ACK https://github.com/bitcoin/bitcoin/pull/30126/commits/6160ccf9b4327649e9bb0293fba630a10b3befc3\r\n\r\nreviewed via `git range-diff master 2003bb8a279c8891e55bab190ca36f0c6c8697ea 6160ccf9b4327649e9bb0293fba630a10b3befc3`\r\n\r\nI didn't validate that the BFS optimisation for search improved results, but it at least doesn't seem to hurt benchmark performance.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2236852405",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "reviewed",
      "id": 2187965242,
      "node_id": "PRR_kwDOABII586CabM6",
      "url": null,
      "actor": null,
      "commit_id": "6160ccf9b4327649e9bb0293fba630a10b3befc3",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2187965242",
      "submitted_at": "2024-07-19T12:40:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "reviewed",
      "id": 2182496612,
      "node_id": "PRR_kwDOABII586CFkFk",
      "url": null,
      "actor": null,
      "commit_id": "6160ccf9b4327649e9bb0293fba630a10b3befc3",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "code review ACK, planning to spend more time reviewing the tests",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2182496612",
      "submitted_at": "2024-07-19T17:02:10Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13578784871,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMpW9Bn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13578784871",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-19T17:33:24Z"
    },
    {
      "event": "commented",
      "id": 2242983915,
      "node_id": "IC_kwDOABII586FsTfr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2242983915",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-22T13:37:04Z",
      "updated_at": "2024-07-22T13:37:04Z",
      "author_association": "MEMBER",
      "body": "reACK https://github.com/bitcoin/bitcoin/pull/30126/commits/cad318fa843f411e52c6761a4882bfaf0ad21812\r\n\r\nvia `git range-diff master 6160ccf9b4327649e9bb0293fba630a10b3befc3 cad318fa843f411e52c6761a4882bfaf0ad21812`",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2242983915",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "review_requested",
      "id": 13601496319,
      "node_id": "RRE_lADOABII586JKtCPzwAAAAMqtlz_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13601496319",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-22T13:37:10Z",
      "requested_reviewer": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 2191951101,
      "node_id": "PRR_kwDOABII586CpoT9",
      "url": null,
      "actor": null,
      "commit_id": "cad318fa843f411e52c6761a4882bfaf0ad21812",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK cad318fa843\r\n\r\nI did code review to convince myself that the code does what it's supposed to be doing / what's described in the delving post. Everything is a bit abstract so I manually tested by writing some naive versions of `BlockAssembler` and  `MiniMiner` using cluster_linearize. I also code reviewed the tests and introduced bugs to check their coverage. I didn't really dive into `DepGraphFormatter` but it seems to work.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2191951101",
      "submitted_at": "2024-07-23T16:38:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "reviewed",
      "id": 2167121806,
      "node_id": "PRR_kwDOABII586BK6eO",
      "url": null,
      "actor": null,
      "commit_id": "cad318fa843f411e52c6761a4882bfaf0ad21812",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Code review ACK cad318fa843f411e52c6761a4882bfaf0ad21812.  Left some non-blocking nits/suggestions.\r\n\r\nI've run the fuzz tests in earlier versions of this PR for a while, but I haven't done so with the latest branch -- will do that and also post some benchmarks in a bit.",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2167121806",
      "submitted_at": "2024-07-24T17:20:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "commented",
      "id": 2248546746,
      "node_id": "IC_kwDOABII586GBhm6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2248546746",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-24T17:27:57Z",
      "updated_at": "2024-07-24T17:27:57Z",
      "author_association": "MEMBER",
      "body": "Benchmark results on my ryzen 7995wx:\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|            1,474.01 |          678,422.17 |    0.3% |      0.01 | `LinearizeNoIters16TxWorstCaseAnc`\r\n|            1,473.48 |          678,667.50 |    0.2% |      0.01 | `LinearizeNoIters16TxWorstCaseLIMO`\r\n|            4,763.02 |          209,951.04 |    0.1% |      0.01 | `LinearizeNoIters32TxWorstCaseAnc`\r\n|            5,138.13 |          194,623.26 |    0.0% |      0.01 | `LinearizeNoIters32TxWorstCaseLIMO`\r\n|           10,296.19 |           97,123.33 |    0.0% |      0.01 | `LinearizeNoIters48TxWorstCaseAnc`\r\n|           11,148.56 |           89,697.71 |    0.0% |      0.01 | `LinearizeNoIters48TxWorstCaseLIMO`\r\n|           17,321.56 |           57,731.51 |    0.1% |      0.01 | `LinearizeNoIters64TxWorstCaseAnc`\r\n|           19,224.32 |           52,017.44 |    0.0% |      0.01 | `LinearizeNoIters64TxWorstCaseLIMO`\r\n|           25,346.32 |           39,453.45 |    0.1% |      0.01 | `LinearizeNoIters75TxWorstCaseAnc`\r\n|           28,625.57 |           34,933.81 |    0.1% |      0.01 | `LinearizeNoIters75TxWorstCaseLIMO`\r\n|           43,628.14 |           22,920.98 |    0.1% |      0.01 | `LinearizeNoIters99TxWorstCaseAnc`\r\n|           49,273.81 |           20,294.76 |    0.1% |      0.01 | `LinearizeNoIters99TxWorstCaseLIMO`\r\n\r\n|            ns/iters |             iters/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|               13.81 |       72,390,978.12 |    0.1% |      0.01 | `LinearizePerIter16TxWorstCase`\r\n|                9.62 |      103,944,701.42 |    0.2% |      0.01 | `LinearizePerIter32TxWorstCase`\r\n|                9.29 |      107,658,429.17 |    0.2% |      0.01 | `LinearizePerIter48TxWorstCase`\r\n|                9.30 |      107,518,263.44 |    0.2% |      0.01 | `LinearizePerIter64TxWorstCase`\r\n|               10.21 |       97,957,584.37 |    0.1% |      0.01 | `LinearizePerIter75TxWorstCase`\r\n|               10.07 |       99,325,875.28 |    0.2% |      0.01 | `LinearizePerIter99TxWorstCase`\r\n",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2248546746",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13636017898,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMsxR7q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13636017898",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-24T20:27:21Z"
    },
    {
      "event": "reviewed",
      "id": 2199052326,
      "node_id": "PRR_kwDOABII586DEuAm",
      "url": null,
      "actor": null,
      "commit_id": "df749c06e9d45ba92a4699e1d3e58522f93ad6bb",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reACK df749c06e9d via range-diff",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2199052326",
      "submitted_at": "2024-07-25T11:35:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "review_requested",
      "id": 13644361834,
      "node_id": "RRE_lADOABII586JKtCPzwAAAAMtRHBq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13644361834",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T11:35:41Z",
      "requested_reviewer": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 13644361937,
      "node_id": "RRE_lADOABII586JKtCPzwAAAAMtRHDR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13644361937",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T11:35:42Z",
      "requested_reviewer": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 2250179956,
      "node_id": "IC_kwDOABII586GHwV0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2250179956",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T12:14:13Z",
      "updated_at": "2024-07-25T12:14:13Z",
      "author_association": "MEMBER",
      "body": "reACK https://github.com/bitcoin/bitcoin/pull/30126/commits/df749c06e9d45ba92a4699e1d3e58522f93ad6bb\r\n\r\nvia `range-diff master cad318fa843f411e52c6761a4882bfaf0ad21812 df749c06e9d45ba92a4699e1d3e58522f93ad6bb`\r\n\r\nDidn't verify the mermaid diagrams in the comments.\r\n\r\nAt this point could we maybe not rebase on master unless necessary? :)",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2250179956",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13644815597,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMtS1zt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13644815597",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T12:14:14Z"
    },
    {
      "event": "commented",
      "id": 2250182427,
      "node_id": "IC_kwDOABII586GHw8b",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2250182427",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T12:15:33Z",
      "updated_at": "2024-07-25T12:15:33Z",
      "author_association": "MEMBER",
      "body": "> At this point could we maybe not rebase on master unless necessary? :)\r\n\r\nI shall resist.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2250182427",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "commented",
      "id": 2250188693,
      "node_id": "IC_kwDOABII586GHyeV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2250188693",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T12:19:13Z",
      "updated_at": "2024-07-25T12:19:13Z",
      "author_association": "MEMBER",
      "body": "reACK https://github.com/bitcoin/bitcoin/pull/30126/commits/448374f2c901c48824904357b4e1297105e97315 \r\n\r\nvia `git range-diff master df749c06e9d45ba92a4699e1d3e58522f93ad6bb 448374f2c901c48824904357b4e1297105e97315`\r\n\r\nonly changes to MakeHardGraph to reflect the intended topology",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2250188693",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "review_requested",
      "id": 13644877380,
      "node_id": "RRE_lADOABII586JKtCPzwAAAAMtTE5E",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13644877380",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T12:19:20Z",
      "requested_reviewer": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 2250281391,
      "node_id": "IC_kwDOABII586GIJGv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2250281391",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T13:08:20Z",
      "updated_at": "2024-07-25T13:08:20Z",
      "author_association": "MEMBER",
      "body": "reACK 448374f2c90 via range-diff",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2250281391",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGE2ZTA3ZTc2OWExYWY2NTJhMTRlNTMzZjZkMzU1OGNjZGVmYjFkZTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a6e07e769a1af652a14e533f6d3558ccdefb1de5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a6e07e769a1af652a14e533f6d3558ccdefb1de5",
      "tree": {
        "sha": "fcf17ad39faf8d5bf1dd550f233810aea210ffbc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fcf17ad39faf8d5bf1dd550f233810aea210ffbc"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5d280130446d57d653c749005a2e363265d87686",
          "sha": "5d280130446d57d653c749005a2e363265d87686",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5d280130446d57d653c749005a2e363265d87686"
        }
      ],
      "message": "clusterlin: introduce cluster_linearize.h with Cluster and DepGraph types\n\nThis primarily adds the DepGraph class, which encapsulates precomputed\nancestor/descendant information for a given transaction cluster, with a\nnumber of utility features (inspectors for set feerates, computing\nreduced parents/children, adding transactions, adding dependencies), which\nwill become needed in future commits.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-25T14:16:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-01-30T03:05:53Z"
      },
      "sha": "a6e07e769a1af652a14e533f6d3558ccdefb1de5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU4ZjdlMDFkYjRiYWQ2ZDk1OGQ0NGYyYmNkZmQ5ZGY5ZTIyOTMxYTQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/58f7e01db4bad6d958d44f2bcdfd9df9e22931a4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/58f7e01db4bad6d958d44f2bcdfd9df9e22931a4",
      "tree": {
        "sha": "92ca1cfe8b5d48f6e2a256bf74346cc61384d379",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/92ca1cfe8b5d48f6e2a256bf74346cc61384d379"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a6e07e769a1af652a14e533f6d3558ccdefb1de5",
          "sha": "a6e07e769a1af652a14e533f6d3558ccdefb1de5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a6e07e769a1af652a14e533f6d3558ccdefb1de5"
        }
      ],
      "message": "tests: framework for testing DepGraph class\n\nThis introduces a bespoke fuzzing-focused serialization format for DepGraphs,\nand then tests that this format can represent any graph, roundtrips, and then\nuses that to test the correctness of DepGraph itself.\n\nThis forms the basis for future fuzz tests that need to work with interesting\ngraphs.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-25T14:16:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-09T00:52:56Z"
      },
      "sha": "58f7e01db4bad6d958d44f2bcdfd9df9e22931a4"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ4MjgwNzlkYjMyN2JmMmFlYWVkNzQ0ODQzYTQxNWQxNjU0ZTg3OTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4828079db327bf2aeaed744843a415d1654e8796",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4828079db327bf2aeaed744843a415d1654e8796",
      "tree": {
        "sha": "2767f2171c5181e8356ae129f42f9f5dd3ca7603",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2767f2171c5181e8356ae129f42f9f5dd3ca7603"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/58f7e01db4bad6d958d44f2bcdfd9df9e22931a4",
          "sha": "58f7e01db4bad6d958d44f2bcdfd9df9e22931a4",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/58f7e01db4bad6d958d44f2bcdfd9df9e22931a4"
        }
      ],
      "message": "clusterlin: add AncestorCandidateFinder class\n\nThis is a class that encapsulates precomputed ancestor set feerates, and\npresents an interface for getting the best remaining ancestor set.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-25T14:16:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-08T22:56:59Z"
      },
      "sha": "4828079db327bf2aeaed744843a415d1654e8796"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDJhNDFmMTUxYWZiODI0NjY0ODY0MDJlMjUwMzI3ZTIyMzE5Yzc1NGU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2a41f151afb82466486402e250327e22319c754e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/2a41f151afb82466486402e250327e22319c754e",
      "tree": {
        "sha": "fc65f41470299b87d12a1352d39d65f75181afd7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fc65f41470299b87d12a1352d39d65f75181afd7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4828079db327bf2aeaed744843a415d1654e8796",
          "sha": "4828079db327bf2aeaed744843a415d1654e8796",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4828079db327bf2aeaed744843a415d1654e8796"
        }
      ],
      "message": "clusterlin: add SearchCandidateFinder class\n\nSimilar to AncestorCandidateFinder, this encapsulates the state needed for\nfinding good candidate sets using a search algorithm.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-25T14:16:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-08T22:09:34Z"
      },
      "sha": "2a41f151afb82466486402e250327e22319c754e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGVlMGRkZmU0ZjYyNmJmYjRiNTg5MjdkYjg5ZDMxN2NiMzUzMTgxM2Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ee0ddfe4f626bfb4b58927db89d317cb3531813f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ee0ddfe4f626bfb4b58927db89d317cb3531813f",
      "tree": {
        "sha": "c2bffbfaf8b4ac0a0191f66a9357b2be63b3fd23",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c2bffbfaf8b4ac0a0191f66a9357b2be63b3fd23"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2a41f151afb82466486402e250327e22319c754e",
          "sha": "2a41f151afb82466486402e250327e22319c754e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/2a41f151afb82466486402e250327e22319c754e"
        }
      ],
      "message": "clusterlin: add chunking algorithm\n\nA fuzz test is added which verifies various of its expected properties, including\ncorrectness",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-25T14:16:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-10T00:38:12Z"
      },
      "sha": "ee0ddfe4f626bfb4b58927db89d317cb3531813f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ2YWFkOWIwOTk4NmZlYjFkNTRmYzQyMjlhMGQyMjRkYTk0ZmI4MGE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/46aad9b09986feb1d54fc4229a0d224da94fb80a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/46aad9b09986feb1d54fc4229a0d224da94fb80a",
      "tree": {
        "sha": "09cf5719b71eaf835a67a5cf332d317230507a74",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/09cf5719b71eaf835a67a5cf332d317230507a74"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ee0ddfe4f626bfb4b58927db89d317cb3531813f",
          "sha": "ee0ddfe4f626bfb4b58927db89d317cb3531813f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ee0ddfe4f626bfb4b58927db89d317cb3531813f"
        }
      ],
      "message": "clusterlin: add Linearize function\n\nThis adds a first version of the overall linearization interface, which given\na DepGraph constructs a good linearization, by incrementally including good\ncandidate sets (found using AncestorCandidateFinder and SearchCandidateFinder).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-25T14:16:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-08T21:28:39Z"
      },
      "sha": "46aad9b09986feb1d54fc4229a0d224da94fb80a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQ5YjIzNWU3ZDI4ODgxNGU4ZWUyNDhiNjhkOTFlYjY4ODY2YjMyYmQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d9b235e7d288814e8ee248b68d91eb68866b32bd",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d9b235e7d288814e8ee248b68d91eb68866b32bd",
      "tree": {
        "sha": "be605f777f91a0ffdf8b1eb377ab9faf708ec44b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/be605f777f91a0ffdf8b1eb377ab9faf708ec44b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/46aad9b09986feb1d54fc4229a0d224da94fb80a",
          "sha": "46aad9b09986feb1d54fc4229a0d224da94fb80a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/46aad9b09986feb1d54fc4229a0d224da94fb80a"
        }
      ],
      "message": "bench: Candidate finding and linearization benchmarks\n\nAdd benchmarks for known bad graphs for the purpose of search (as\nan upper bound on work per search iterations) and ancestor sorting\n(as an upper bound on linearization work with no search iterations).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-25T14:16:40Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-16T01:09:31Z"
      },
      "sha": "d9b235e7d288814e8ee248b68d91eb68866b32bd"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk5MWZmOWE5YTRmMjE3MWFiOTljYjBjYTFkNzBlYmJjMGRiOWQzODg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/991ff9a9a4f2171ab99cb0ca1d70ebbc0db9d388",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/991ff9a9a4f2171ab99cb0ca1d70ebbc0db9d388",
      "tree": {
        "sha": "c813dd50b81340dee9791d9cdd4d15df208886ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c813dd50b81340dee9791d9cdd4d15df208886ec"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d9b235e7d288814e8ee248b68d91eb68866b32bd",
          "sha": "d9b235e7d288814e8ee248b68d91eb68866b32bd",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d9b235e7d288814e8ee248b68d91eb68866b32bd"
        }
      ],
      "message": "clusterlin: use bounded BFS exploration (optimization)\n\nSwitch to BFS exploration of the search tree in SearchCandidateFinder\ninstead of DFS exploration. This appears to behave better for real\nworld clusters.\n\nAs BFS has the downside of needing far larger search queues, switch\nback to DFS temporarily when the queue grows too large.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-25T14:16:40Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-09T15:53:02Z"
      },
      "sha": "991ff9a9a4f2171ab99cb0ca1d70ebbc0db9d388"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQ1OTE4ZGMzYzZkOTQ4MGM4YTVlMjk1ZGIwZjRkNDg5MmIwMTM4ZjY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d5918dc3c6d9480c8a5e295db0f4d4892b0138f6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d5918dc3c6d9480c8a5e295db0f4d4892b0138f6",
      "tree": {
        "sha": "6e7f1bc90d57fbb32feb754a7328e619c12cfc9a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6e7f1bc90d57fbb32feb754a7328e619c12cfc9a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/991ff9a9a4f2171ab99cb0ca1d70ebbc0db9d388",
          "sha": "991ff9a9a4f2171ab99cb0ca1d70ebbc0db9d388",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/991ff9a9a4f2171ab99cb0ca1d70ebbc0db9d388"
        }
      ],
      "message": "clusterlin: randomize the SearchCandidateFinder search order\n\nTo make search non-deterministic, change the BFS logic from always picking\nthe first queue item to randomly picking the first or second queue item.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-25T14:16:40Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-10T01:41:52Z"
      },
      "sha": "d5918dc3c6d9480c8a5e295db0f4d4892b0138f6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk3ZDk4NzE4YjAwNWFkYzBiZGY1MTNkNzI0ODc0NjAxZDhhYTEzYWQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97d98718b005adc0bdf513d724874601d8aa13ad",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/97d98718b005adc0bdf513d724874601d8aa13ad",
      "tree": {
        "sha": "53376441726177c6e1040361ab788966caa87c9d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/53376441726177c6e1040361ab788966caa87c9d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d5918dc3c6d9480c8a5e295db0f4d4892b0138f6",
          "sha": "d5918dc3c6d9480c8a5e295db0f4d4892b0138f6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d5918dc3c6d9480c8a5e295db0f4d4892b0138f6"
        }
      ],
      "message": "clusterlin: add LinearizationChunking class\n\nIt encapsulates a given linearization in chunked form, permitting arbitrary\nsubsets of transactions to be removed from the linearization. Its purpose\nis adding the Intersect function, which is a crucial operation that will\nbe used in a further commit to make Linearize improve existing linearizations.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-25T14:16:40Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-10T15:08:42Z"
      },
      "sha": "97d98718b005adc0bdf513d724874601d8aa13ad"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI4NTQ5NzkxYjM4MDJmYzA3ODEyOGY1NTJjNmY1M2FjM2RlODkzYTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/28549791b3802fc078128f552c6f53ac3de893a6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/28549791b3802fc078128f552c6f53ac3de893a6",
      "tree": {
        "sha": "611ec4ff64baf5c1d7ff9bfbb40958af3d979188",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/611ec4ff64baf5c1d7ff9bfbb40958af3d979188"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97d98718b005adc0bdf513d724874601d8aa13ad",
          "sha": "97d98718b005adc0bdf513d724874601d8aa13ad",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/97d98718b005adc0bdf513d724874601d8aa13ad"
        }
      ],
      "message": "clusterlin: permit passing in existing linearization to Linearize\n\nThis implements the LIMO algorithm for linearizing by improving an existing\nlinearization. See\nhttps://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging\nfor details.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-25T14:16:40Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-09T13:02:18Z"
      },
      "sha": "28549791b3802fc078128f552c6f53ac3de893a6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDY0N2ZhMzdjZGJhZGJlZWJiYTE0N2NhNmIyNGUxMzg1NTljZmZhYWY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "tree": {
        "sha": "293da874dc04d9db6f463c3cc60aefafd8d9254c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/293da874dc04d9db6f463c3cc60aefafd8d9254c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/28549791b3802fc078128f552c6f53ac3de893a6",
          "sha": "28549791b3802fc078128f552c6f53ac3de893a6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/28549791b3802fc078128f552c6f53ac3de893a6"
        }
      ],
      "message": "bench: add cluster linearization improvement benchmark",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-25T14:16:40Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-11T21:08:23Z"
      },
      "sha": "647fa37cdbadbeebba147ca6b24e138559cffaaf"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13646548777,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMtZc8p",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13646548777",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T14:17:32Z"
    },
    {
      "event": "commented",
      "id": 2250442971,
      "node_id": "IC_kwDOABII586GIwjb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2250442971",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T14:19:06Z",
      "updated_at": "2024-07-25T14:19:06Z",
      "author_association": "MEMBER",
      "body": "Ok, the mermaid diagrams should be fixed now, match the code, and I've verified (post- #30286) that the claims about difficulty of linearization hold for the code.\r\n\r\n> I shall resist.\r\n\r\nI failed.\r\n\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2250442971",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "commented",
      "id": 2250609880,
      "node_id": "IC_kwDOABII586GJZTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2250609880",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T15:04:06Z",
      "updated_at": "2024-07-25T15:04:14Z",
      "author_association": "MEMBER",
      "body": "reACK 647fa37cdbadbeebba147ca6b24e138559cffaaf\r\n\r\nvia `git range-diff master 448374f2c901c48824904357b4e1297105e97315 647fa37cdbadbeebba147ca6b24e138559cffaaf`\r\n\r\nI traced through the generated diagrams + code, seems to match. Didn't verify difficulty.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2250609880",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "commented",
      "id": 2250613908,
      "node_id": "IC_kwDOABII586GJaSU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2250613908",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T15:05:11Z",
      "updated_at": "2024-07-25T15:05:11Z",
      "author_association": "MEMBER",
      "body": "reACK 647fa37cdba, both code and mermaid diagram look correct to me\r\n\r\nThe git diff is always greener\r\nWhen you rebase by mistake\r\nWe dream about cluster mempool\r\nDon care how many reACKs it take\r\nJust look at the code around you\r\nThe bench was correct before!\r\nUnder the sea, Under the sea...",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2250613908",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "commented",
      "id": 2251358535,
      "node_id": "IC_kwDOABII586GMQFH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2251358535",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T20:41:09Z",
      "updated_at": "2024-07-25T20:41:09Z",
      "author_association": "MEMBER",
      "body": "ACK 647fa37cdbadbeebba147ca6b24e138559cffaaf\r\n\r\nIn addition to some manual testing, I ran all the fuzz targets on my machine for a while as well.",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2251358535",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "merged",
      "id": 13659809081,
      "node_id": "ME_lADOABII586JKtCPzwAAAAMuMCU5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13659809081",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "37bd70a2253331ffd24650e6536695e7f47a86b0",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37bd70a2253331ffd24650e6536695e7f47a86b0",
      "created_at": "2024-07-26T11:12:19Z"
    },
    {
      "event": "closed",
      "id": 13659809104,
      "node_id": "CE_lADOABII586JKtCPzwAAAAMuMCVQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13659809104",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-26T11:12:19Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611851597",
      "pull_request_review_id": 2074233399,
      "id": 1611851597,
      "node_id": "PRRC_kwDOABII585gEudN",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+#ifdef _MSC_VER\n+#  include <intrin.h>",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 15,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "316e2044aad16e1ed8d024d3325bfcee8c04cd1f",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why is this needed?",
      "created_at": "2024-05-23T14:55:40Z",
      "updated_at": "2024-05-23T14:55:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1611851597",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611851597"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611885584",
      "pull_request_review_id": 2074291321,
      "id": 1611885584,
      "node_id": "PRRC_kwDOABII585gE2wQ",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+#ifdef _MSC_VER\n+#  include <intrin.h>",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 15,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "316e2044aad16e1ed8d024d3325bfcee8c04cd1f",
      "in_reply_to_id": 1611851597,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Remnant of a long-lost pre-C++20 past. Gone.",
      "created_at": "2024-05-23T15:16:07Z",
      "updated_at": "2024-05-23T15:16:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1611885584",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611885584"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613617080",
      "pull_request_review_id": 2077166958,
      "id": 1613617080,
      "node_id": "PRRC_kwDOABII585gLde4",
      "diff_hunk": "@@ -469,6 +485,56 @@ class SearchCandidateFinder\n     }\n };\n \n+/** Improve a linearization of a cluster.\n+ *\n+ * @param[in]     depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in,out] iteration_limit    On input, an upper bound on the number of optimization steps\n+ *                                   that will be performed in order to find a good linearization.\n+ *                                   On output the number will be reduced by the number of actually\n+ *                                   performed optimization steps. If that number is nonzero, the\n+ *                                   linearization is optimal.\n+ */\n+template<typename S>\n+std::vector<ClusterIndex> Linearize(const DepGraph<S>& depgraph, uint64_t& iteration_limit) noexcept\n+{\n+    auto todo = S::Fill(depgraph.TxCount());\n+    std::vector<ClusterIndex> linearization;\n+\n+    AncestorCandidateFinder anc_finder(depgraph);\n+    SearchCandidateFinder src_finder(depgraph);\n+    linearization.reserve(depgraph.TxCount());\n+    bool perfect = true;\n+\n+    while (todo.Any()) {\n+        // Initialize best to be either the best ancestor set.\n+        auto best = anc_finder.FindCandidateSet();\n+\n+        // Invoke bounded search to update best, with up to half of our remaining iterations as\n+        // limit.\n+        uint64_t iterations = (iteration_limit + 1) / 2;\n+        iteration_limit -= iterations;",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 54,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "f6deff9f4c5dbb379fd4f099f17e09387de27efc",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in/out args for iterations is kinda spooky and made these few lines really hard to read, could `FindCandidateSet` just return a `std::pair` or similar?",
      "created_at": "2024-05-24T14:59:17Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1613617080",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613617080"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 825,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622515654",
      "pull_request_review_id": 2077166958,
      "id": 1622515654,
      "node_id": "PRRC_kwDOABII585gtZ_G",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 48,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For this operator are `S ancestors` and `S descendants` ordered? Is it just compared via `m_val` for `BitSets`? Is ordering by these elements meaningful?",
      "created_at": "2024-05-31T14:31:45Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1622515654",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622515654"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622564714",
      "pull_request_review_id": 2077166958,
      "id": 1622564714,
      "node_id": "PRRC_kwDOABII585gtl9q",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);",
      "path": "src/cluster_linearize.h",
      "position": 78,
      "original_position": 75,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "it crashes once it hits `S::Singleton` if violated but maybe an earlier crash is more immediately informative\r\n```suggestion\r\n        Assume(ntx <= S::Size());\r\n        entries.resize(ntx);\r\n```",
      "created_at": "2024-05-31T15:04:38Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1622564714",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622564714"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 78,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622574793",
      "pull_request_review_id": 2077166958,
      "id": 1622574793,
      "node_id": "PRRC_kwDOABII585gtobJ",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = S::Singleton(i);\n+            entries[i].descendants = S::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<S>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            S to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given another DepGraph and a mapping from old to new.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    DepGraph(const DepGraph<S>& depgraph, Span<const ClusterIndex> mapping) noexcept : entries(depgraph.TxCount())\n+    {\n+        // Fill in fee, size, ancestors.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 123,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "to avoid an OOB access regression\r\n```suggestion\r\n        Assert(mapping.size() == depgraph.TxCount());\r\n        // Fill in fee, size, ancestors.\r\n```",
      "created_at": "2024-05-31T15:13:10Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1622574793",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622574793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622667577",
      "pull_request_review_id": 2077166958,
      "id": 1622667577,
      "node_id": "PRRC_kwDOABII585gt_E5",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 34,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "not super important but can we use a more descriptive typename since our use-case is pretty narrow? I'm mentally substituting `S` everywhere with `bitset` which is a fair mental leap and it's relatively difficult to grep for being so short.\r\n\r\n`S_bitset`? I don't know why the conventions are the way they are :sweat_smile: ",
      "created_at": "2024-05-31T16:16:35Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1622667577",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622667577"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626377280",
      "pull_request_review_id": 2077166958,
      "id": 1626377280,
      "node_id": "PRRC_kwDOABII585g8IxA",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = S::Singleton(i);\n+            entries[i].descendants = S::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<S>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            S to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given another DepGraph and a mapping from old to new.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    DepGraph(const DepGraph<S>& depgraph, Span<const ClusterIndex> mapping) noexcept : entries(depgraph.TxCount())\n+    {\n+        // Fill in fee, size, ancestors.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            const auto& input = depgraph.entries[i];\n+            auto& output = entries[mapping[i]];\n+            output.feerate = input.feerate;\n+            for (auto j : input.ancestors) output.ancestors.Set(mapping[j]);\n+        }\n+        // Fill in descendant information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the mutable feerate of a given transaction i. Complexity: O(1). */\n+    FeeFrac& FeeRate(ClusterIndex i) noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const S& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const S& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, S::Singleton(new_idx), S::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.\n+        const auto& chl_des = entries[child].descendants;\n+        for (auto anc_of_par : Ancestors(parent)) {\n+            entries[anc_of_par].descendants |= chl_des;\n+        }\n+        // To each descendant of the child, add as ancestors the ancestors of the parent.\n+        const auto& par_anc = entries[parent].ancestors;\n+        for (auto dec_of_chl : Descendants(child)) {\n+            entries[dec_of_chl].ancestors |= par_anc;\n+        }\n+    }\n+\n+    /** Compute the aggregate feerate of a set of nodes in this graph.\n+     *\n+     * Complexity: O(N) where N=elems.Count().\n+     **/\n+    FeeFrac FeeRate(const S& elems) const noexcept\n+    {\n+        FeeFrac ret;\n+        for (auto pos : elems) ret += entries[pos].feerate;\n+        return ret;\n+    }\n+\n+    /** Find some connected component within the subset \"left\" of this graph.\n+     *\n+     * Complexity: O(ret.Count()).\n+     */\n+    S FindConnectedComponent(const S& left) const noexcept\n+    {\n+        if (left.None()) return left;\n+        auto first = left.First();\n+        S ret = Descendants(first) | Ancestors(first);\n+        ret &= left;\n+        S to_add = ret;\n+        to_add.Reset(first);\n+        do {\n+            S old = ret;\n+            for (auto add : to_add) {\n+                ret |= Descendants(add);\n+                ret |= Ancestors(add);\n+            }\n+            ret &= left;\n+            to_add = ret - old;\n+        } while (to_add.Any());\n+        return ret;\n+    }\n+\n+    /** Determine if a subset is connected.\n+     *\n+     * Complexity: O(subset.Count()).\n+     */\n+    bool IsConnected(const S& subset) const noexcept\n+    {\n+        return FindConnectedComponent(subset) == subset;\n+    }\n+\n+    /** Determine if this entire graph is connected.\n+     *\n+     * Complexity: O(TxCount()).\n+     */\n+    bool IsConnected() const noexcept { return IsConnected(S::Fill(TxCount())); }\n+\n+    /** Append the entries of select to list in a topologically valid order.\n+     *\n+     * Complexity: O(select.Count() * log(select.Count())).\n+     */\n+    void AppendTopo(std::vector<ClusterIndex>& list, const S& select) const noexcept\n+    {\n+        ClusterIndex old_len = list.size();\n+        for (auto i : select) list.push_back(i);\n+        std::sort(list.begin() + old_len, list.end(), [&](ClusterIndex a, ClusterIndex b) noexcept {\n+            const auto a_anc_count = entries[a].ancestors.Count();\n+            const auto b_anc_count = entries[b].ancestors.Count();\n+            if (a_anc_count != b_anc_count) return a_anc_count < b_anc_count;\n+            return a < b;\n+        });\n+    }\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename S>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<S>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    S m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<S>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{S::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            S anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(S select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {\n+                if (!(m_ancestor_set_feerates[i] > m_ancestor_set_feerates[*best])) continue;\n+            }\n+            best = i;\n+        }\n+        Assume(best.has_value());\n+        return {m_depgraph.Ancestors(*best) & m_todo, m_ancestor_set_feerates[*best]};\n+    }\n+};\n+\n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename S>\n+class SearchCandidateFinder\n+{\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** m_sorted_to_original[i] is the original position that sorted transaction position i had. */\n+    std::vector<ClusterIndex> m_sorted_to_original;\n+    /** m_original_to_sorted[i] is the sorted position original transaction position i has. */\n+    std::vector<ClusterIndex> m_original_to_sorted;\n+    /** Internal dependency graph for the cluster (with transactions in decreasing individual\n+     *  feerate order). */\n+    DepGraph<S> m_depgraph;\n+    /** Which transactions are left to do (indices in m_depgraph's sorted order). */\n+    S m_todo;\n+\n+    static uint256 GetRNGKey(uint64_t rng_seed) noexcept\n+    {\n+        uint256 rng_key;\n+        WriteLE64(rng_key.data(), rng_seed);\n+        return rng_key;\n+    }\n+\n+    /** Given a set of transactions with sorted indices, get their original indices. */\n+    S SortedToOriginal(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_sorted_to_original[pos]);\n+        return ret;\n+    }\n+\n+    /** Given a set of transactions with original indices, get their sorted indices. */\n+    S OriginalToSorted(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_original_to_sorted[pos]);\n+        return ret;\n+    }\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     * @param[in] rng_seed   A random seed to control the search order.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.Count().\n+     */\n+    SearchCandidateFinder(const DepGraph<S>& depgraph, uint64_t rng_seed) noexcept :\n+        m_rng(GetRNGKey(rng_seed)),\n+        m_sorted_to_original(depgraph.TxCount()),\n+        m_original_to_sorted(depgraph.TxCount())\n+    {\n+        // Determine reordering mapping, by sorting by decreasing feerate.\n+        std::iota(m_sorted_to_original.begin(), m_sorted_to_original.end(), ClusterIndex{0});\n+        std::sort(m_sorted_to_original.begin(), m_sorted_to_original.end(), [&](auto a, auto b) {\n+            auto feerate_cmp = depgraph.FeeRate(a) <=> depgraph.FeeRate(b);\n+            if (feerate_cmp == 0) return a < b;\n+            return feerate_cmp > 0;\n+        });\n+        // Compute reverse mapping.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            m_original_to_sorted[m_sorted_to_original[i]] = i;\n+        }\n+        // Compute reordered dependency graph.\n+        m_depgraph = DepGraph(depgraph, m_original_to_sorted);\n+        // Set todo to the entire graph.\n+        m_todo = S::Fill(depgraph.TxCount());\n+    }\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in,out] iterations_left    On input, an upper bound on the number of optimization\n+     *                                   steps that can be performed. On output, that number is\n+     *                                   reduced by the number of actually performed optimization\n+     *                                   steps.\n+     * @param[in] best                   A set/feerate pair with an already-known good candidate.\n+     *                                   This can be empty.\n+     * @return                           The best (highest feerate, smallest size as tiebreaker)\n+     *                                   topologically-valid subset of what remains of the cluster\n+     *                                   that was encountered during search. If iterations_left is\n+     *                                   nonzero on output, it is the absolute best such subset. If\n+     *                                   not, the feerate of the returned set will be at least as\n+     *                                   good as the best passed in.\n+     *\n+     * Complexity: possibly O(N * min(iterations_left, sqrt(2^N))) where N=depgraph.TxCount().\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet(uint64_t& iterations_left, std::pair<S, FeeFrac> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        if (best.second.IsEmpty()) {\n+            // Set best to the entire remainder if not provided.\n+            best.first = m_todo;\n+            best.second = m_depgraph.FeeRate(m_todo);\n+        } else {\n+            // Otherwise convert to internal sorted indices.\n+            best.first = OriginalToSorted(best.first);\n+        }\n+        Assume(!best.second.IsEmpty());\n+        Assume(best.first.Any());\n+        Assume(best.first.IsSubsetOf(m_todo));\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included. This must be a subset of m_todo, and be\n+             *  topologically valid (includes all in-m_todo ancestors of itself). */\n+            S inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            S und;\n+            /** (Only when inc is not empty) The subset with the best feerate of any superset of\n+             *  inc that is also a subset of (inc | und), without requiring it to be topologically\n+             *  valid. If the real best such feerate does not exceed best.second, then this value\n+             *  is not guaranteed to be accurate. */\n+            S pot;\n+            /** Equal to m_depgraph.FeeRate(inc). */\n+            FeeFrac inc_feerate;\n+            /** Equal to m_depgraph.FeeRate(pot). It forms a conservative upper bound on how good\n+             *  a set this work item can give rise to, unless that's known to be below best.second.\n+             */\n+            FeeFrac pot_feerate;\n+            /** Construct a new work item. */\n+            WorkItem(S&& i, S&& u, S&& p, FeeFrac&& i_f, FeeFrac&& p_f) noexcept :\n+                inc(std::move(i)), und(std::move(u)), pot(std::move(p)),\n+                inc_feerate(std::move(i_f)), pot_feerate(std::move(p_f)) {}\n+            /** Swap two WorkItems. */\n+            void Swap(WorkItem& other) noexcept\n+            {\n+                swap(inc, other.inc);\n+                swap(und, other.und);\n+                swap(pot, other.pot);\n+                swap(inc_feerate, other.inc_feerate);\n+                swap(pot_feerate, other.pot_feerate);\n+            }\n+        };\n+\n+        /** The queue of work items. */\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));\n+\n+        /** The set of transactions in m_todo which have feerate > best_feerate. */\n+        S imp = m_todo;\n+        while (imp.Any()) {\n+            ClusterIndex check = imp.Last();\n+            if (m_depgraph.FeeRate(check) >> best.second) break;\n+            imp.Reset(check);\n+        }\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iteration_limit = iterations_left;\n+\n+        /** Internal function to add a work item, possibly improving it before doing so.\n+         *\n+         * - inc: the \"inc\" value for the new work item\n+         * - und: the \"und\" value for the new work item\n+         * - pot: a subset of the \"pot\" value for the new work item (but a superset of inc).\n+         *        It does not need to be the full pot value; missing pot transactions will be added\n+         *        to it by add_fn.\n+         * - inc_feerate: equal to m_depgraph.FeeRate(inc)\n+         * - pot_feerate: equal to m_depgraph.FeeRate(pot)\n+         * - grow_inc: whether to attempt moving transactions from und to inc, if it can be proven\n+         *             that they must be a part of the best topologically valid superset of inc and\n+         *             subset of (inc | und). Transactions that are missing from pot are always\n+         *             considered, regardless of grow_inc. It only makes sense to enable this if\n+         *             transactions were added to inc.\n+         */\n+        auto add_fn = [&](S inc, S und, S pot, FeeFrac inc_feerate, FeeFrac pot_feerate, bool grow_inc) noexcept {\n+            Assume(inc.IsSubsetOf(m_todo));\n+            Assume(und.IsSubsetOf(m_todo));\n+            Assume(!inc.Overlaps(und));\n+            Assume(pot.IsSupersetOf(inc));\n+            Assume(pot.IsSubsetOf(inc | und));\n+            Assume(pot.None() == inc.None());\n+\n+            if (!inc_feerate.IsEmpty()) {\n+                /** Which transactions to consider adding to inc. */\n+                S consider_inc = grow_inc ? pot - inc : S{};\n+                // Add entries to pot (and pot_feerate). We iterate over all undecided transactions\n+                // whose feerate is higher than best_feerate, and aren't already part of pot. While\n+                // undecided transactions of lower feerate may improve pot still, if they do, the\n+                // resulting pot_feerate cannot possibly exceed best.second (resulting in the item\n+                // being skipped in split_fn).\n+                for (auto pos : (imp & und) - pot) {\n+                    // Determine if adding transaction pos to pot (ignoring topology) would improve it. If\n+                    // not, we're done updating pot. This relies on the fact that m_depgraph, and\n+                    // thus the set iterated over, is in decreasing individual feerate order.\n+                    if (!(m_depgraph.FeeRate(pos) >> pot_feerate)) break;\n+                    pot_feerate += m_depgraph.FeeRate(pos);\n+                    pot.Set(pos);\n+                    consider_inc.Set(pos);\n+                }\n+\n+                // The \"jump ahead\" optimization: whenever pot has a topologically-valid subset,\n+                // that subset can be added to inc. Any subset of (pot - inc) has the property that\n+                // its feerate exceeds that of any set compatible with this work item (superset of\n+                // inc, subset of (inc | und)). Thus, if T is a topological subset of pot, and B is\n+                // the best topologically-valid set compatible with this work item, and (T - B) is\n+                // non-empty, then (T | B) is better than B and also topological. This is in\n+                // contradiction with the assumption that B is best. Thus, (T - B) must be empty,\n+                // or T must be a subset of B.\n+                //\n+                // See https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303 section 2.4.\n+                const S init_inc = inc;\n+                for (auto pos : consider_inc) {\n+                    // If the transaction's ancestors are a subset of pot, we can add it together\n+                    // with its ancestors to inc.\n+                    auto anc_todo = m_depgraph.Ancestors(pos) & m_todo;\n+                    if (anc_todo.IsSubsetOf(pot)) inc |= anc_todo;\n+                }\n+                // Finally update und and inc_feerate to account for the added transactions.\n+                und -= inc;\n+                inc_feerate += m_depgraph.FeeRate(inc - init_inc);\n+\n+                // If inc_feerate is better than best_feerate, remember inc as our new best.\n+                if (inc_feerate > best.second) {\n+                    best = {inc, inc_feerate};\n+                    // See if we can remove any entries from imp now.\n+                    while (imp.Any()) {\n+                        ClusterIndex check = imp.Last();\n+                        if (m_depgraph.FeeRate(check) >> best.second) break;\n+                        imp.Reset(check);\n+                    }\n+                }\n+\n+                // If no potential transactions exist beyond the already included ones, no improvement\n+                // is possible anymore.\n+                if (pot == inc) return;\n+                // At this point und must be non-empty. If it were empty then pot would equal inc.\n+                Assume(und.Any());\n+            } else {\n+                // If inc is empty, we just make sure there are undecided transactions left to\n+                // split on.\n+                if (und.None()) return;\n+            }\n+\n+            // Actually construct new work item on the queue.\n+            Assume(queue.size() < queue.capacity());",
      "path": "src/cluster_linearize.h",
      "position": 581,
      "original_position": 558,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "is this for ensuring no allocations are going to take place? How do we know this?",
      "created_at": "2024-06-04T17:29:25Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1626377280",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626377280"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 581,
      "original_line": 581,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631584746",
      "pull_request_review_id": 2105193198,
      "id": 1631584746,
      "node_id": "PRRC_kwDOABII585hQAHq",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 34,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1622667577,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've renamed it to `SetType` everywhere. While it's expected to be instantiated with `BitSet`, that's not a necessity, and I expect that for certain temporarily-very-large clusters in TxGraph we'll need some algorithms instantiated by another type (something using an `std::set` or a sorted vector, for example).",
      "created_at": "2024-06-07T18:54:41Z",
      "updated_at": "2024-06-07T18:54:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1631584746",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631584746"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631724039",
      "pull_request_review_id": 2105418287,
      "id": 1631724039,
      "node_id": "PRRC_kwDOABII585hQiIH",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 48,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1622515654,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think any attempt to invoke this comparison operator would just have failed, as `BitSet` doesn't have an `operator<=>` (it did at some point, but I had dropped it). I've just removed the operator here too.",
      "created_at": "2024-06-07T21:41:58Z",
      "updated_at": "2024-06-07T21:41:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1631724039",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631724039"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102449",
      "pull_request_review_id": 2114235927,
      "id": 1637102449,
      "node_id": "PRRC_kwDOABII585hlDNx",
      "diff_hunk": "@@ -469,6 +485,56 @@ class SearchCandidateFinder\n     }\n };\n \n+/** Improve a linearization of a cluster.\n+ *\n+ * @param[in]     depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in,out] iteration_limit    On input, an upper bound on the number of optimization steps\n+ *                                   that will be performed in order to find a good linearization.\n+ *                                   On output the number will be reduced by the number of actually\n+ *                                   performed optimization steps. If that number is nonzero, the\n+ *                                   linearization is optimal.\n+ */\n+template<typename S>\n+std::vector<ClusterIndex> Linearize(const DepGraph<S>& depgraph, uint64_t& iteration_limit) noexcept\n+{\n+    auto todo = S::Fill(depgraph.TxCount());\n+    std::vector<ClusterIndex> linearization;\n+\n+    AncestorCandidateFinder anc_finder(depgraph);\n+    SearchCandidateFinder src_finder(depgraph);\n+    linearization.reserve(depgraph.TxCount());\n+    bool perfect = true;\n+\n+    while (todo.Any()) {\n+        // Initialize best to be either the best ancestor set.\n+        auto best = anc_finder.FindCandidateSet();\n+\n+        // Invoke bounded search to update best, with up to half of our remaining iterations as\n+        // limit.\n+        uint64_t iterations = (iteration_limit + 1) / 2;\n+        iteration_limit -= iterations;",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 54,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "f6deff9f4c5dbb379fd4f099f17e09387de27efc",
      "in_reply_to_id": 1613617080,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done. I've encapsulated the `std::pair<SetType, FeeFrac>` for representing sets with their feerates into a new `SetInfo<SetType>` type, and changed the return type of candidate finders which count iterations to be `std::pair<SetInfo<SetType>, uint64_t>`, representing the found candidate and the number of performed iterations. I've also changed the Linearization functions to just return a `bool optimal`, rather than an iteration count (as it wasn't used anywhere anyway).",
      "created_at": "2024-06-12T21:16:57Z",
      "updated_at": "2024-06-12T21:16:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1637102449",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102449"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 825,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102621",
      "pull_request_review_id": 2114236128,
      "id": 1637102621,
      "node_id": "PRRC_kwDOABII585hlDQd",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);",
      "path": "src/cluster_linearize.h",
      "position": 78,
      "original_position": 75,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1622564714,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-12T21:17:06Z",
      "updated_at": "2024-06-12T21:17:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1637102621",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102621"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 78,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102708",
      "pull_request_review_id": 2114236246,
      "id": 1637102708,
      "node_id": "PRRC_kwDOABII585hlDR0",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = S::Singleton(i);\n+            entries[i].descendants = S::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<S>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            S to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given another DepGraph and a mapping from old to new.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    DepGraph(const DepGraph<S>& depgraph, Span<const ClusterIndex> mapping) noexcept : entries(depgraph.TxCount())\n+    {\n+        // Fill in fee, size, ancestors.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 123,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1622574793,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-12T21:17:11Z",
      "updated_at": "2024-06-12T21:17:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1637102708",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102708"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637103088",
      "pull_request_review_id": 2114236678,
      "id": 1637103088,
      "node_id": "PRRC_kwDOABII585hlDXw",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = S::Singleton(i);\n+            entries[i].descendants = S::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<S>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            S to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given another DepGraph and a mapping from old to new.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    DepGraph(const DepGraph<S>& depgraph, Span<const ClusterIndex> mapping) noexcept : entries(depgraph.TxCount())\n+    {\n+        // Fill in fee, size, ancestors.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            const auto& input = depgraph.entries[i];\n+            auto& output = entries[mapping[i]];\n+            output.feerate = input.feerate;\n+            for (auto j : input.ancestors) output.ancestors.Set(mapping[j]);\n+        }\n+        // Fill in descendant information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the mutable feerate of a given transaction i. Complexity: O(1). */\n+    FeeFrac& FeeRate(ClusterIndex i) noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const S& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const S& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, S::Singleton(new_idx), S::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.\n+        const auto& chl_des = entries[child].descendants;\n+        for (auto anc_of_par : Ancestors(parent)) {\n+            entries[anc_of_par].descendants |= chl_des;\n+        }\n+        // To each descendant of the child, add as ancestors the ancestors of the parent.\n+        const auto& par_anc = entries[parent].ancestors;\n+        for (auto dec_of_chl : Descendants(child)) {\n+            entries[dec_of_chl].ancestors |= par_anc;\n+        }\n+    }\n+\n+    /** Compute the aggregate feerate of a set of nodes in this graph.\n+     *\n+     * Complexity: O(N) where N=elems.Count().\n+     **/\n+    FeeFrac FeeRate(const S& elems) const noexcept\n+    {\n+        FeeFrac ret;\n+        for (auto pos : elems) ret += entries[pos].feerate;\n+        return ret;\n+    }\n+\n+    /** Find some connected component within the subset \"left\" of this graph.\n+     *\n+     * Complexity: O(ret.Count()).\n+     */\n+    S FindConnectedComponent(const S& left) const noexcept\n+    {\n+        if (left.None()) return left;\n+        auto first = left.First();\n+        S ret = Descendants(first) | Ancestors(first);\n+        ret &= left;\n+        S to_add = ret;\n+        to_add.Reset(first);\n+        do {\n+            S old = ret;\n+            for (auto add : to_add) {\n+                ret |= Descendants(add);\n+                ret |= Ancestors(add);\n+            }\n+            ret &= left;\n+            to_add = ret - old;\n+        } while (to_add.Any());\n+        return ret;\n+    }\n+\n+    /** Determine if a subset is connected.\n+     *\n+     * Complexity: O(subset.Count()).\n+     */\n+    bool IsConnected(const S& subset) const noexcept\n+    {\n+        return FindConnectedComponent(subset) == subset;\n+    }\n+\n+    /** Determine if this entire graph is connected.\n+     *\n+     * Complexity: O(TxCount()).\n+     */\n+    bool IsConnected() const noexcept { return IsConnected(S::Fill(TxCount())); }\n+\n+    /** Append the entries of select to list in a topologically valid order.\n+     *\n+     * Complexity: O(select.Count() * log(select.Count())).\n+     */\n+    void AppendTopo(std::vector<ClusterIndex>& list, const S& select) const noexcept\n+    {\n+        ClusterIndex old_len = list.size();\n+        for (auto i : select) list.push_back(i);\n+        std::sort(list.begin() + old_len, list.end(), [&](ClusterIndex a, ClusterIndex b) noexcept {\n+            const auto a_anc_count = entries[a].ancestors.Count();\n+            const auto b_anc_count = entries[b].ancestors.Count();\n+            if (a_anc_count != b_anc_count) return a_anc_count < b_anc_count;\n+            return a < b;\n+        });\n+    }\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename S>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<S>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    S m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<S>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{S::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            S anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(S select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {\n+                if (!(m_ancestor_set_feerates[i] > m_ancestor_set_feerates[*best])) continue;\n+            }\n+            best = i;\n+        }\n+        Assume(best.has_value());\n+        return {m_depgraph.Ancestors(*best) & m_todo, m_ancestor_set_feerates[*best]};\n+    }\n+};\n+\n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename S>\n+class SearchCandidateFinder\n+{\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** m_sorted_to_original[i] is the original position that sorted transaction position i had. */\n+    std::vector<ClusterIndex> m_sorted_to_original;\n+    /** m_original_to_sorted[i] is the sorted position original transaction position i has. */\n+    std::vector<ClusterIndex> m_original_to_sorted;\n+    /** Internal dependency graph for the cluster (with transactions in decreasing individual\n+     *  feerate order). */\n+    DepGraph<S> m_depgraph;\n+    /** Which transactions are left to do (indices in m_depgraph's sorted order). */\n+    S m_todo;\n+\n+    static uint256 GetRNGKey(uint64_t rng_seed) noexcept\n+    {\n+        uint256 rng_key;\n+        WriteLE64(rng_key.data(), rng_seed);\n+        return rng_key;\n+    }\n+\n+    /** Given a set of transactions with sorted indices, get their original indices. */\n+    S SortedToOriginal(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_sorted_to_original[pos]);\n+        return ret;\n+    }\n+\n+    /** Given a set of transactions with original indices, get their sorted indices. */\n+    S OriginalToSorted(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_original_to_sorted[pos]);\n+        return ret;\n+    }\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     * @param[in] rng_seed   A random seed to control the search order.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.Count().\n+     */\n+    SearchCandidateFinder(const DepGraph<S>& depgraph, uint64_t rng_seed) noexcept :\n+        m_rng(GetRNGKey(rng_seed)),\n+        m_sorted_to_original(depgraph.TxCount()),\n+        m_original_to_sorted(depgraph.TxCount())\n+    {\n+        // Determine reordering mapping, by sorting by decreasing feerate.\n+        std::iota(m_sorted_to_original.begin(), m_sorted_to_original.end(), ClusterIndex{0});\n+        std::sort(m_sorted_to_original.begin(), m_sorted_to_original.end(), [&](auto a, auto b) {\n+            auto feerate_cmp = depgraph.FeeRate(a) <=> depgraph.FeeRate(b);\n+            if (feerate_cmp == 0) return a < b;\n+            return feerate_cmp > 0;\n+        });\n+        // Compute reverse mapping.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            m_original_to_sorted[m_sorted_to_original[i]] = i;\n+        }\n+        // Compute reordered dependency graph.\n+        m_depgraph = DepGraph(depgraph, m_original_to_sorted);\n+        // Set todo to the entire graph.\n+        m_todo = S::Fill(depgraph.TxCount());\n+    }\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in,out] iterations_left    On input, an upper bound on the number of optimization\n+     *                                   steps that can be performed. On output, that number is\n+     *                                   reduced by the number of actually performed optimization\n+     *                                   steps.\n+     * @param[in] best                   A set/feerate pair with an already-known good candidate.\n+     *                                   This can be empty.\n+     * @return                           The best (highest feerate, smallest size as tiebreaker)\n+     *                                   topologically-valid subset of what remains of the cluster\n+     *                                   that was encountered during search. If iterations_left is\n+     *                                   nonzero on output, it is the absolute best such subset. If\n+     *                                   not, the feerate of the returned set will be at least as\n+     *                                   good as the best passed in.\n+     *\n+     * Complexity: possibly O(N * min(iterations_left, sqrt(2^N))) where N=depgraph.TxCount().\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet(uint64_t& iterations_left, std::pair<S, FeeFrac> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        if (best.second.IsEmpty()) {\n+            // Set best to the entire remainder if not provided.\n+            best.first = m_todo;\n+            best.second = m_depgraph.FeeRate(m_todo);\n+        } else {\n+            // Otherwise convert to internal sorted indices.\n+            best.first = OriginalToSorted(best.first);\n+        }\n+        Assume(!best.second.IsEmpty());\n+        Assume(best.first.Any());\n+        Assume(best.first.IsSubsetOf(m_todo));\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included. This must be a subset of m_todo, and be\n+             *  topologically valid (includes all in-m_todo ancestors of itself). */\n+            S inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            S und;\n+            /** (Only when inc is not empty) The subset with the best feerate of any superset of\n+             *  inc that is also a subset of (inc | und), without requiring it to be topologically\n+             *  valid. If the real best such feerate does not exceed best.second, then this value\n+             *  is not guaranteed to be accurate. */\n+            S pot;\n+            /** Equal to m_depgraph.FeeRate(inc). */\n+            FeeFrac inc_feerate;\n+            /** Equal to m_depgraph.FeeRate(pot). It forms a conservative upper bound on how good\n+             *  a set this work item can give rise to, unless that's known to be below best.second.\n+             */\n+            FeeFrac pot_feerate;\n+            /** Construct a new work item. */\n+            WorkItem(S&& i, S&& u, S&& p, FeeFrac&& i_f, FeeFrac&& p_f) noexcept :\n+                inc(std::move(i)), und(std::move(u)), pot(std::move(p)),\n+                inc_feerate(std::move(i_f)), pot_feerate(std::move(p_f)) {}\n+            /** Swap two WorkItems. */\n+            void Swap(WorkItem& other) noexcept\n+            {\n+                swap(inc, other.inc);\n+                swap(und, other.und);\n+                swap(pot, other.pot);\n+                swap(inc_feerate, other.inc_feerate);\n+                swap(pot_feerate, other.pot_feerate);\n+            }\n+        };\n+\n+        /** The queue of work items. */\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));\n+\n+        /** The set of transactions in m_todo which have feerate > best_feerate. */\n+        S imp = m_todo;\n+        while (imp.Any()) {\n+            ClusterIndex check = imp.Last();\n+            if (m_depgraph.FeeRate(check) >> best.second) break;\n+            imp.Reset(check);\n+        }\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iteration_limit = iterations_left;\n+\n+        /** Internal function to add a work item, possibly improving it before doing so.\n+         *\n+         * - inc: the \"inc\" value for the new work item\n+         * - und: the \"und\" value for the new work item\n+         * - pot: a subset of the \"pot\" value for the new work item (but a superset of inc).\n+         *        It does not need to be the full pot value; missing pot transactions will be added\n+         *        to it by add_fn.\n+         * - inc_feerate: equal to m_depgraph.FeeRate(inc)\n+         * - pot_feerate: equal to m_depgraph.FeeRate(pot)\n+         * - grow_inc: whether to attempt moving transactions from und to inc, if it can be proven\n+         *             that they must be a part of the best topologically valid superset of inc and\n+         *             subset of (inc | und). Transactions that are missing from pot are always\n+         *             considered, regardless of grow_inc. It only makes sense to enable this if\n+         *             transactions were added to inc.\n+         */\n+        auto add_fn = [&](S inc, S und, S pot, FeeFrac inc_feerate, FeeFrac pot_feerate, bool grow_inc) noexcept {\n+            Assume(inc.IsSubsetOf(m_todo));\n+            Assume(und.IsSubsetOf(m_todo));\n+            Assume(!inc.Overlaps(und));\n+            Assume(pot.IsSupersetOf(inc));\n+            Assume(pot.IsSubsetOf(inc | und));\n+            Assume(pot.None() == inc.None());\n+\n+            if (!inc_feerate.IsEmpty()) {\n+                /** Which transactions to consider adding to inc. */\n+                S consider_inc = grow_inc ? pot - inc : S{};\n+                // Add entries to pot (and pot_feerate). We iterate over all undecided transactions\n+                // whose feerate is higher than best_feerate, and aren't already part of pot. While\n+                // undecided transactions of lower feerate may improve pot still, if they do, the\n+                // resulting pot_feerate cannot possibly exceed best.second (resulting in the item\n+                // being skipped in split_fn).\n+                for (auto pos : (imp & und) - pot) {\n+                    // Determine if adding transaction pos to pot (ignoring topology) would improve it. If\n+                    // not, we're done updating pot. This relies on the fact that m_depgraph, and\n+                    // thus the set iterated over, is in decreasing individual feerate order.\n+                    if (!(m_depgraph.FeeRate(pos) >> pot_feerate)) break;\n+                    pot_feerate += m_depgraph.FeeRate(pos);\n+                    pot.Set(pos);\n+                    consider_inc.Set(pos);\n+                }\n+\n+                // The \"jump ahead\" optimization: whenever pot has a topologically-valid subset,\n+                // that subset can be added to inc. Any subset of (pot - inc) has the property that\n+                // its feerate exceeds that of any set compatible with this work item (superset of\n+                // inc, subset of (inc | und)). Thus, if T is a topological subset of pot, and B is\n+                // the best topologically-valid set compatible with this work item, and (T - B) is\n+                // non-empty, then (T | B) is better than B and also topological. This is in\n+                // contradiction with the assumption that B is best. Thus, (T - B) must be empty,\n+                // or T must be a subset of B.\n+                //\n+                // See https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303 section 2.4.\n+                const S init_inc = inc;\n+                for (auto pos : consider_inc) {\n+                    // If the transaction's ancestors are a subset of pot, we can add it together\n+                    // with its ancestors to inc.\n+                    auto anc_todo = m_depgraph.Ancestors(pos) & m_todo;\n+                    if (anc_todo.IsSubsetOf(pot)) inc |= anc_todo;\n+                }\n+                // Finally update und and inc_feerate to account for the added transactions.\n+                und -= inc;\n+                inc_feerate += m_depgraph.FeeRate(inc - init_inc);\n+\n+                // If inc_feerate is better than best_feerate, remember inc as our new best.\n+                if (inc_feerate > best.second) {\n+                    best = {inc, inc_feerate};\n+                    // See if we can remove any entries from imp now.\n+                    while (imp.Any()) {\n+                        ClusterIndex check = imp.Last();\n+                        if (m_depgraph.FeeRate(check) >> best.second) break;\n+                        imp.Reset(check);\n+                    }\n+                }\n+\n+                // If no potential transactions exist beyond the already included ones, no improvement\n+                // is possible anymore.\n+                if (pot == inc) return;\n+                // At this point und must be non-empty. If it were empty then pot would equal inc.\n+                Assume(und.Any());\n+            } else {\n+                // If inc is empty, we just make sure there are undecided transactions left to\n+                // split on.\n+                if (und.None()) return;\n+            }\n+\n+            // Actually construct new work item on the queue.\n+            Assume(queue.size() < queue.capacity());",
      "path": "src/cluster_linearize.h",
      "position": 581,
      "original_position": 558,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1626377280,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed. I've added a comment. LMK whether it's clearer now.",
      "created_at": "2024-06-12T21:17:31Z",
      "updated_at": "2024-06-12T21:17:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1637103088",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637103088"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 581,
      "original_line": 581,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638438741",
      "pull_request_review_id": 2116172410,
      "id": 1638438741,
      "node_id": "PRRC_kwDOABII585hqJdV",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 266,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`Cluster<TestBitSet> cluster(num_tx, std::make_pair(FeeFrac{0, 1}, TestBitSet()));` should work?",
      "created_at": "2024-06-13T15:43:33Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1638438741",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638438741"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 525,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638450101",
      "pull_request_review_id": 2116172410,
      "id": 1638450101,
      "node_id": "PRRC_kwDOABII585hqMO1",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 270,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n    // Read (parent, child) pairs, and add them to the cluster and depgraph.\r\n```",
      "created_at": "2024-06-13T15:51:50Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1638450101",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638450101"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 529,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638465834",
      "pull_request_review_id": 2116172410,
      "id": 1638465834,
      "node_id": "PRRC_kwDOABII585hqQEq",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, SetType::Singleton(new_idx), SetType::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.",
      "path": "src/cluster_linearize.h",
      "position": 151,
      "original_position": 141,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "06c600099abe129a5bb5c6a5a533018f03e51304",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should we `Assume()`/short-circuit if `parent == child`",
      "created_at": "2024-06-13T16:00:24Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1638465834",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638465834"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638472774",
      "pull_request_review_id": 2116172410,
      "id": 1638472774,
      "node_id": "PRRC_kwDOABII585hqRxG",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 126,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "06c600099abe129a5bb5c6a5a533018f03e51304",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Where does the amortization come in?",
      "created_at": "2024-06-13T16:03:29Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1638472774",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638472774"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 131,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638488625",
      "pull_request_review_id": 2116172410,
      "id": 1638488625,
      "node_id": "PRRC_kwDOABII585hqVox",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 1024) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 271,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n    LIMITED_WHILE(provider.remaining_bytes() > 0, TestBitSet::Size() * TestBitSet::Size()) {\r\n```",
      "created_at": "2024-06-13T16:15:47Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1638488625",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638488625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 530,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1639799588",
      "pull_request_review_id": 2118340933,
      "id": 1639799588,
      "node_id": "PRRC_kwDOABII585hvVsk",
      "diff_hunk": "@@ -162,6 +163,100 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 88,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In the docs, maybe instead of \"best remaining ancestor set\", say \"highest feerate ancestor set\" ?\r\n\r\nSide note - I was thinking that this was a replica of the ancestor set algo in `BlockAssembler` but this isn't the minimum of individual and ancestor feerate.",
      "created_at": "2024-06-14T13:06:16Z",
      "updated_at": "2024-07-08T15:34:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1639799588",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1639799588"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 339,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1640177227",
      "pull_request_review_id": 2116172410,
      "id": 1640177227,
      "node_id": "PRRC_kwDOABII585hwx5L",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 154,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e5ba6ece9b2ae3f46625825cfabcf348c229f935",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could leave an assert to this effect right after this",
      "created_at": "2024-06-14T18:00:33Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1640177227",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1640177227"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1640177309",
      "pull_request_review_id": 2116172410,
      "id": 1640177309,
      "node_id": "PRRC_kwDOABII585hwx6d",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 159,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e5ba6ece9b2ae3f46625825cfabcf348c229f935",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could leave an assert to this effect right after this",
      "created_at": "2024-06-14T18:00:38Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1640177309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1640177309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644451932",
      "pull_request_review_id": 2118340933,
      "id": 1644451932,
      "node_id": "PRRC_kwDOABII585iBFhc",
      "diff_hunk": "@@ -257,6 +277,145 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included (and its feerate). This must be a subset\n+             *  of m_todo, and be topologically valid (includes all in-m_todo ancestors of\n+             *  itself). */\n+            SetInfo<SetType> inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            SetType und;\n+\n+            /** Construct a new work item. */\n+            WorkItem(SetInfo<SetType>&& i, SetType&& u) noexcept :\n+                inc(std::move(i)), und(std::move(u)) {}\n+        };\n+\n+        /** The queue of work items. */\n+        std::vector<WorkItem> queue;\n+\n+        // Create an initial entry with m_todo as undecided. Also use it as best if not provided,\n+        // so that during the work processing loop below, and during the add_fn/split_fn calls, we\n+        // do not need to deal with the best=empty case.\n+        if (best.feerate.IsEmpty()) best = SetInfo(m_depgraph, m_todo);\n+        queue.emplace_back(SetInfo<SetType>{}, SetType{m_todo});\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iterations_left = max_iterations;\n+\n+        /** Internal function to add a work item.\n+         *\n+         * - inc: the \"inc\" value for the new work item",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 116,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "maybe mention that caller must ensure inc includes `Ancestors(inc)`",
      "created_at": "2024-06-18T13:17:17Z",
      "updated_at": "2024-07-08T15:34:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644451932",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644451932"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644863011",
      "pull_request_review_id": 2116172410,
      "id": 1644863011,
      "node_id": "PRRC_kwDOABII585iCp4j",
      "diff_hunk": "@@ -162,6 +163,100 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];",
      "path": "src/cluster_linearize.h",
      "position": 406,
      "original_position": 61,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n                Assume(!m_ancestor_set_feerates[first].IsEmpty());\r\n                anc_feerate = m_ancestor_set_feerates[first];\r\n```",
      "created_at": "2024-06-18T18:04:46Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644863011",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644863011"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 406,
      "original_line": 406,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644905104",
      "pull_request_review_id": 2116172410,
      "id": 1644905104,
      "node_id": "PRRC_kwDOABII585iC0KQ",
      "diff_hunk": "@@ -162,6 +163,100 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {",
      "path": "src/cluster_linearize.h",
      "position": 453,
      "original_position": 96,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "belt and suspenders nit prior to a comparison\r\n```Suggestion\r\n            if (best.has_value()) {\r\n                Assume(!m_ancestor_set_feerates[i].IsEmpty());\r\n```",
      "created_at": "2024-06-18T18:46:31Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644905104",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644905104"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 453,
      "original_line": 453,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644945090",
      "pull_request_review_id": 2116172410,
      "id": 1644945090,
      "node_id": "PRRC_kwDOABII585iC97C",
      "diff_hunk": "@@ -346,3 +364,49 @@ FUZZ_TARGET(clusterlin_depgraph_serialization)\n     // Verify the graph is a DAG.\n     assert(IsAcyclic(depgraph));\n }\n+\n+FUZZ_TARGET(clusterlin_ancestor_finder)\n+{\n+    // Verify that AncestorCandidateFinder works as expected.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    AncestorCandidateFinder anc_finder(depgraph);\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // Call the ancestor finder's FindCandidateSet for what remains of the graph.\n+        auto best_anc = anc_finder.FindCandidateSet();\n+        // Sanity check the result.\n+        assert(best_anc.transactions.Any());\n+        assert(best_anc.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(best_anc.transactions) == best_anc.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : best_anc.transactions) {\n+            assert((depgraph.Ancestors(i) & todo).IsSubsetOf(best_anc.transactions));\n+        }\n+\n+        // Compute all remaining ancestor sets.\n+        std::optional<SetInfo<TestBitSet>> real_best_anc;\n+        for (auto i : todo) {\n+            SetInfo info(depgraph, todo & depgraph.Ancestors(i));\n+            if (!real_best_anc.has_value() || info.feerate > real_best_anc->feerate) {\n+                real_best_anc = info;\n+            }\n+        }\n+        // The set returned by anc_finder must equal the real best ancestor sets.\n+        assert(real_best_anc.has_value());\n+        assert(*real_best_anc == best_anc);\n+\n+        // Find a topologically valid subset of transactions to remove from the graph.\n+        auto del_set = ReadTopologicalSet(depgraph, todo, reader);\n+        // If we did not find anything, use best_anc itself, because we should remove something.\n+        if (del_set.None()) del_set = best_anc.transactions;\n+        todo -= del_set;\n+        anc_finder.MarkDone(del_set);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 382,
      "original_position": 72,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "it'd be worth it to have `del_set` be sometimes overcomplete, including random subsets of `~todo` which should be handled internally by being dropped. Alternatively it could be disallowed via `Assume()`?",
      "created_at": "2024-06-18T19:26:19Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644945090",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644945090"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 382,
      "original_line": 382,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644952136",
      "pull_request_review_id": 2116172410,
      "id": 1644952136,
      "node_id": "PRRC_kwDOABII585iC_pI",
      "diff_hunk": "@@ -193,6 +193,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 45,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A top-level description of what this is useful for would be appreciated.",
      "created_at": "2024-06-18T19:33:51Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644952136",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644952136"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644963760",
      "pull_request_review_id": 2116172410,
      "id": 1644963760,
      "node_id": "PRRC_kwDOABII585iDCew",
      "diff_hunk": "@@ -410,3 +510,86 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(0x3ffff);\n+            assert(found.feerate >= simple.feerate);\n+            if (simple_iters < 0x3ffff) assert(found.feerate == simple.feerate);\n+\n+            // Compare with AncestorCandidateFinder;\n+            auto anc = anc_finder.FindCandidateSet();\n+            assert(found.feerate >= anc.feerate);\n+\n+            // If todo isn't too big, compare with ExhaustiveCandidateFinder.\n+            if (todo.Count() <= 12) {\n+                auto exhaustive = exh_finder.FindCandidateSet();\n+                assert(exhaustive.feerate == found.feerate);\n+                // Also compare ExhaustiveCandidateFinder with SimpleCandidateFinder (this is more\n+                // a test for SimpleCandidateFinder's correctness).\n+                assert(exhaustive.feerate >= simple.feerate);\n+                if (simple_iters < 0x3ffff) assert(exhaustive.feerate == simple.feerate);\n+            }\n+        }\n+\n+        // Find a topologically valid subset of transactions to remove from the graph.\n+        auto del_set = ReadTopologicalSet(depgraph, todo, reader);\n+        // If we did not find anything, use found_set itself, because we should remove something.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 185,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`found_set` doesn't exist",
      "created_at": "2024-06-18T19:45:42Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644963760",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644963760"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 459,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644966180",
      "pull_request_review_id": 2116172410,
      "id": 1644966180,
      "node_id": "PRRC_kwDOABII585iDDEk",
      "diff_hunk": "@@ -193,6 +193,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 55,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "SimpleCandidateFinder",
      "created_at": "2024-06-18T19:48:05Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644966180",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644966180"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644966317",
      "pull_request_review_id": 2116172410,
      "id": 1644966317,
      "node_id": "PRRC_kwDOABII585iDDGt",
      "diff_hunk": "@@ -193,6 +193,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 14,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ExhaustiveCandidateFinder",
      "created_at": "2024-06-18T19:48:15Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644966317",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644966317"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644982295",
      "pull_request_review_id": 2116172410,
      "id": 1644982295,
      "node_id": "PRRC_kwDOABII585iDHAX",
      "diff_hunk": "@@ -410,3 +510,86 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(0x3ffff);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 164,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "please consti-fy `0x3ffff` since it's use 3x",
      "created_at": "2024-06-18T20:00:54Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644982295",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644982295"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 438,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649155445",
      "pull_request_review_id": 2116172410,
      "id": 1649155445,
      "node_id": "PRRC_kwDOABII585iTB11",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 74,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "useful note in code would be this is the only critical check to ensure fuzzer doesn't generate a cyclical graph, and the other checks are optimizations? ",
      "created_at": "2024-06-21T15:59:58Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649155445",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649155445"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649205112",
      "pull_request_review_id": 2116172410,
      "id": 1649205112,
      "node_id": "PRRC_kwDOABII585iTN94",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 75,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I can't make an example that causes this clause to fail which hinders my understanding of what it's doing.\r\n\r\nThis is where having static unit test for this case firing would be helpful to step through.",
      "created_at": "2024-06-21T16:46:08Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649205112",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649205112"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649232974",
      "pull_request_review_id": 2116172410,
      "id": 1649232974,
      "node_id": "PRRC_kwDOABII585iTUxO",
      "diff_hunk": "@@ -452,3 +552,86 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(0x3ffff);\n+            assert(found.feerate >= simple.feerate);\n+            if (simple_iters < 0x3ffff) assert(found.feerate == simple.feerate);\n+\n+            // Compare with AncestorCandidateFinder;\n+            auto anc = anc_finder.FindCandidateSet();\n+            assert(found.feerate >= anc.feerate);\n+\n+            // If todo isn't too big, compare with ExhaustiveCandidateFinder.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 172,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If we're checking against exhaustive we can avoid using the other finders?",
      "created_at": "2024-06-21T17:10:41Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649232974",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649232974"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 446,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649259334",
      "pull_request_review_id": 2116172410,
      "id": 1649259334,
      "node_id": "PRRC_kwDOABII585iTbNG",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions\n+                // that share ancestry with inc so far (which means only connected sets will be\n+                // considered).\n+                if (inc_none || inc.Overlaps(m_depgraph.Ancestors(pivot))) {\n+                    // Add a queue entry with pivot included.\n+                    SetInfo new_inc(m_depgraph, inc | (m_todo & m_depgraph.Ancestors(pivot)));\n+                    queue.emplace_back(new_inc.transactions, und - new_inc.transactions);\n+                    // Add a queue entry with pivot excluded.\n+                    queue.emplace_back(inc, und - m_depgraph.Descendants(pivot));\n+                    // Update statistics to account for the candidate new_inc.\n+                    if (new_inc.feerate > best.feerate) best = new_inc;\n+                    break;\n+                }\n+            }\n+        }\n+        return {std::move(best), max_iterations - iterations_left};",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 88,
      "original_position": 100,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "double-checking: In this and other candidate set finders it seems like `max_iterations - iterations_left` could be zero even if it was optimal on the very last step?",
      "created_at": "2024-06-21T17:36:53Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649259334",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649259334"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649287854",
      "pull_request_review_id": 2116172410,
      "id": 1649287854,
      "node_id": "PRRC_kwDOABII585iTiKu",
      "diff_hunk": "@@ -257,6 +277,145 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 84,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this needs coverage or should be disallowed entirely",
      "created_at": "2024-06-21T18:08:55Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649287854",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649287854"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 398,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649300280",
      "pull_request_review_id": 2116172410,
      "id": 1649300280,
      "node_id": "PRRC_kwDOABII585iTlM4",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "can we call this split rather than pivot since it only occurs here in the codebase?",
      "created_at": "2024-06-21T18:22:57Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649300280",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649300280"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649308286",
      "pull_request_review_id": 2116172410,
      "id": 1649308286,
      "node_id": "PRRC_kwDOABII585iTnJ-",
      "diff_hunk": "@@ -257,6 +277,145 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included (and its feerate). This must be a subset\n+             *  of m_todo, and be topologically valid (includes all in-m_todo ancestors of\n+             *  itself). */\n+            SetInfo<SetType> inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            SetType und;\n+\n+            /** Construct a new work item. */\n+            WorkItem(SetInfo<SetType>&& i, SetType&& u) noexcept :\n+                inc(std::move(i)), und(std::move(u)) {}\n+        };\n+\n+        /** The queue of work items. */\n+        std::vector<WorkItem> queue;\n+\n+        // Create an initial entry with m_todo as undecided. Also use it as best if not provided,\n+        // so that during the work processing loop below, and during the add_fn/split_fn calls, we\n+        // do not need to deal with the best=empty case.\n+        if (best.feerate.IsEmpty()) best = SetInfo(m_depgraph, m_todo);\n+        queue.emplace_back(SetInfo<SetType>{}, SetType{m_todo});\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iterations_left = max_iterations;\n+\n+        /** Internal function to add a work item.\n+         *\n+         * - inc: the \"inc\" value for the new work item\n+         * - und: the \"und\" value for the new work item\n+         */\n+        auto add_fn = [&](SetInfo<SetType> inc, SetType und) noexcept {\n+            if (!inc.feerate.IsEmpty()) {\n+                // If inc's feerate is better than best's, remember it as our new best.\n+                if (inc.feerate > best.feerate) {\n+                    best = inc;\n+                }\n+            }",
      "path": "src/cluster_linearize.h",
      "position": 573,
      "original_position": 125,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n            } else {\r\n                Assume(inc.transactions.None())\r\n            }\r\n```",
      "created_at": "2024-06-21T18:32:10Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649308286",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649308286"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 573,
      "original_line": 573,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649373379",
      "pull_request_review_id": 2116172410,
      "id": 1649373379,
      "node_id": "PRRC_kwDOABII585iT3DD",
      "diff_hunk": "@@ -635,3 +688,68 @@ FUZZ_TARGET(clusterlin_search_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_linearize)\n+{\n+    // Verify the behavior of Linearize().\n+\n+    // Retrieve an iteration count, and a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    uint64_t iter_count{0};\n+    try {\n+        reader >> VARINT(iter_count) >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Invoke Linearize().\n+    iter_count &= 0x7ffff;\n+    auto [linearization, optimal] = Linearize(depgraph, iter_count);\n+    SanityCheck(depgraph, linearization);\n+    auto chunking = ChunkLinearization(depgraph, linearization);\n+\n+    // If the iteration count is sufficiently high, an optimal linearization must be found.\n+    // Each linearization step can use up to 2^k iterations, with steps k=1..n. That sum is\n+    // 2 * (2^n - 1)\n+    const uint64_t n = depgraph.TxCount();\n+    if (n <= 18 && iter_count > 2U * ((uint64_t{1} << n) - 1U)) {\n+        assert(optimal);\n+    }\n+\n+    // If Linearize claims optimal result, run quality tests.\n+    if (optimal) {\n+        // It must be as good as SimpleLinearize.\n+        auto [simple_linearization, simple_optimal] = SimpleLinearize(depgraph, 0x3ffff);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 115,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "a34467001c258adf6b6f6d5d626221e7f89d38df",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`0x3ffff` should be explained",
      "created_at": "2024-06-21T19:53:05Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649373379",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649373379"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 541,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649396138",
      "pull_request_review_id": 2116172410,
      "id": 1649396138,
      "node_id": "PRRC_kwDOABII585iT8mq",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms.\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        if (ntx & 1) {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 2});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({14, 2});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({6, 1});\n+                depgraph.AddDependency(2, 1);\n+            } else if (i == 3) {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(2, 3);\n+            } else if ((i & 1) == 0) {\n+                depgraph.AddTransaction({7, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(i, 4);\n+            }\n+        } else {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 1});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({3, 1});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({1, 1});\n+                depgraph.AddDependency(0, 2);\n+            } else if (i & 1) {\n+                depgraph.AddTransaction({4, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({0, 1});\n+                depgraph.AddDependency(i, 3);\n+            }\n+        }\n+    }\n+    return depgraph;\n+}\n+\n+/** Benchmark that does search-based candidate finding with 10000 iterations. */\n+template<typename SetType>\n+void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeHardGraph<SetType>(ntx);\n+    const auto iter_limit = std::min<uint64_t>(10000, uint64_t{1} << (ntx / 2 - 1));\n+    bench.batch(iter_limit).unit(\"iters\").run([&] {\n+        SearchCandidateFinder finder(depgraph);\n+        auto [candidate, iters_performed] = finder.FindCandidateSet(iter_limit, {});\n+        assert(iters_performed == iter_limit);\n+    });\n+}\n+\n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort. */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeLinearGraph<SetType>(ntx);\n+    bench.run([&] {\n+        // Do 10 iterations just to make sure some of that logic is executed, but this is\n+        // effectively negligible.",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 94,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "a little confused what this is trying to say",
      "created_at": "2024-06-21T20:22:14Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649396138",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649396138"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649399637",
      "pull_request_review_id": 2116172410,
      "id": 1649399637,
      "node_id": "PRRC_kwDOABII585iT9dV",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms.\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        if (ntx & 1) {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 2});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({14, 2});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({6, 1});\n+                depgraph.AddDependency(2, 1);\n+            } else if (i == 3) {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(2, 3);\n+            } else if ((i & 1) == 0) {\n+                depgraph.AddTransaction({7, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(i, 4);\n+            }\n+        } else {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 1});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({3, 1});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({1, 1});\n+                depgraph.AddDependency(0, 2);\n+            } else if (i & 1) {\n+                depgraph.AddTransaction({4, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({0, 1});\n+                depgraph.AddDependency(i, 3);\n+            }\n+        }\n+    }\n+    return depgraph;\n+}\n+\n+/** Benchmark that does search-based candidate finding with 10000 iterations. */\n+template<typename SetType>\n+void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeHardGraph<SetType>(ntx);\n+    const auto iter_limit = std::min<uint64_t>(10000, uint64_t{1} << (ntx / 2 - 1));\n+    bench.batch(iter_limit).unit(\"iters\").run([&] {\n+        SearchCandidateFinder finder(depgraph);\n+        auto [candidate, iters_performed] = finder.FindCandidateSet(iter_limit, {});\n+        assert(iters_performed == iter_limit);\n+    });\n+}\n+\n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort. */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeLinearGraph<SetType>(ntx);\n+    bench.run([&] {\n+        // Do 10 iterations just to make sure some of that logic is executed, but this is\n+        // effectively negligible.\n+        uint64_t iters = 10;\n+        Linearize(depgraph, iters);\n+    });\n+}\n+\n+} // namespace\n+\n+static void LinearizePerIter16TxWorstCase(benchmark::Bench& bench) { BenchLinearizePerIterWorstCase<BitSet<16>>(16, bench); }",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 102,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "if each benchmark matches the BitSet::Size(), no need for `ntx` args?",
      "created_at": "2024-06-21T20:25:27Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649399637",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649399637"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 106,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649401042",
      "pull_request_review_id": 2116172410,
      "id": 1649401042,
      "node_id": "PRRC_kwDOABII585iT9zS",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms.\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        if (ntx & 1) {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 2});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({14, 2});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({6, 1});\n+                depgraph.AddDependency(2, 1);\n+            } else if (i == 3) {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(2, 3);\n+            } else if ((i & 1) == 0) {\n+                depgraph.AddTransaction({7, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(i, 4);\n+            }\n+        } else {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 1});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({3, 1});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({1, 1});\n+                depgraph.AddDependency(0, 2);\n+            } else if (i & 1) {\n+                depgraph.AddTransaction({4, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({0, 1});\n+                depgraph.AddDependency(i, 3);\n+            }\n+        }\n+    }\n+    return depgraph;\n+}\n+\n+/** Benchmark that does search-based candidate finding with 10000 iterations. */\n+template<typename SetType>\n+void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeHardGraph<SetType>(ntx);\n+    const auto iter_limit = std::min<uint64_t>(10000, uint64_t{1} << (ntx / 2 - 1));\n+    bench.batch(iter_limit).unit(\"iters\").run([&] {\n+        SearchCandidateFinder finder(depgraph);\n+        auto [candidate, iters_performed] = finder.FindCandidateSet(iter_limit, {});\n+        assert(iters_performed == iter_limit);\n+    });\n+}\n+\n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort. */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "having trouble understanding what `PerIter` and `NoIter` mean",
      "created_at": "2024-06-21T20:27:22Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649401042",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649401042"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651203077",
      "pull_request_review_id": 2116172410,
      "id": 1651203077,
      "node_id": "PRRC_kwDOABII585ia1wF",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 27,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can you add a description of how it's inherently difficult and what these two types of topologies are achieving? \r\n",
      "created_at": "2024-06-24T15:09:14Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651203077",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651203077"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651302872",
      "pull_request_review_id": 2116172410,
      "id": 1651302872,
      "node_id": "PRRC_kwDOABII585ibOHY",
      "diff_hunk": "@@ -351,7 +352,8 @@ class SearchCandidateFinder\n         };\n \n         /** The queue of work items. */\n-        std::vector<WorkItem> queue;\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));",
      "path": "src/cluster_linearize.h",
      "position": 548,
      "original_position": 14,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think 256 is ever exceeded in bench(99)/fuzz(32) cases?\r\n\r\nIIUC If the other value were ever exercised, it has to at least be `m_todo.Count() + 1`",
      "created_at": "2024-06-24T16:18:03Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651302872",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651302872"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 548,
      "original_line": 548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651468145",
      "pull_request_review_id": 2116172410,
      "id": 1651468145,
      "node_id": "PRRC_kwDOABII585ib2dx",
      "diff_hunk": "@@ -411,10 +416,36 @@ class SearchCandidateFinder\n         };\n \n         // Work processing loop.\n+        //\n+        // New work items are always added at the back of the queue, but items to process use a\n+        // hybrid approach where they can be taken from the front or the back.\n+        //\n+        // Depth-first search (DFS) corresponds to always taking from the back of the queue. This\n+        // is very memory-efficient (linear in the number of transactions). Breadth-first search\n+        // (BFS) corresponds to always taking from the front, which potentially uses more memory\n+        // (up to exponential in the transaction count), but seems to work better in practice.\n+        //\n+        // The approach here combines the two: use BFS until the queue grows too large, at which\n+        // point we temporarily switch to DFS until the size shrinks again.\n         while (!queue.empty()) {\n+            // See if processing the first queue item (BFS) is possible without exceeding the queue\n+            // capacity(), assuming we process the last queue items (DFS) after that.\n+            const auto queuesize_for_front = queue.capacity() - queue.front().und.Count();",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 48,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I believe this is all correct and understand reasoning for flow, but I don't really understand what `queuesize_for_front` name is meant to convey. It took me a while to convince myself this section was correct fwiw\r\n\r\n",
      "created_at": "2024-06-24T18:40:00Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651468145",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651468145"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 524,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651471330",
      "pull_request_review_id": 2116172410,
      "id": 1651471330,
      "node_id": "PRRC_kwDOABII585ib3Pi",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = S::Singleton(i);\n+            entries[i].descendants = S::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<S>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            S to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given another DepGraph and a mapping from old to new.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    DepGraph(const DepGraph<S>& depgraph, Span<const ClusterIndex> mapping) noexcept : entries(depgraph.TxCount())\n+    {\n+        // Fill in fee, size, ancestors.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            const auto& input = depgraph.entries[i];\n+            auto& output = entries[mapping[i]];\n+            output.feerate = input.feerate;\n+            for (auto j : input.ancestors) output.ancestors.Set(mapping[j]);\n+        }\n+        // Fill in descendant information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the mutable feerate of a given transaction i. Complexity: O(1). */\n+    FeeFrac& FeeRate(ClusterIndex i) noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const S& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const S& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, S::Singleton(new_idx), S::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.\n+        const auto& chl_des = entries[child].descendants;\n+        for (auto anc_of_par : Ancestors(parent)) {\n+            entries[anc_of_par].descendants |= chl_des;\n+        }\n+        // To each descendant of the child, add as ancestors the ancestors of the parent.\n+        const auto& par_anc = entries[parent].ancestors;\n+        for (auto dec_of_chl : Descendants(child)) {\n+            entries[dec_of_chl].ancestors |= par_anc;\n+        }\n+    }\n+\n+    /** Compute the aggregate feerate of a set of nodes in this graph.\n+     *\n+     * Complexity: O(N) where N=elems.Count().\n+     **/\n+    FeeFrac FeeRate(const S& elems) const noexcept\n+    {\n+        FeeFrac ret;\n+        for (auto pos : elems) ret += entries[pos].feerate;\n+        return ret;\n+    }\n+\n+    /** Find some connected component within the subset \"left\" of this graph.\n+     *\n+     * Complexity: O(ret.Count()).\n+     */\n+    S FindConnectedComponent(const S& left) const noexcept\n+    {\n+        if (left.None()) return left;\n+        auto first = left.First();\n+        S ret = Descendants(first) | Ancestors(first);\n+        ret &= left;\n+        S to_add = ret;\n+        to_add.Reset(first);\n+        do {\n+            S old = ret;\n+            for (auto add : to_add) {\n+                ret |= Descendants(add);\n+                ret |= Ancestors(add);\n+            }\n+            ret &= left;\n+            to_add = ret - old;\n+        } while (to_add.Any());\n+        return ret;\n+    }\n+\n+    /** Determine if a subset is connected.\n+     *\n+     * Complexity: O(subset.Count()).\n+     */\n+    bool IsConnected(const S& subset) const noexcept\n+    {\n+        return FindConnectedComponent(subset) == subset;\n+    }\n+\n+    /** Determine if this entire graph is connected.\n+     *\n+     * Complexity: O(TxCount()).\n+     */\n+    bool IsConnected() const noexcept { return IsConnected(S::Fill(TxCount())); }\n+\n+    /** Append the entries of select to list in a topologically valid order.\n+     *\n+     * Complexity: O(select.Count() * log(select.Count())).\n+     */\n+    void AppendTopo(std::vector<ClusterIndex>& list, const S& select) const noexcept\n+    {\n+        ClusterIndex old_len = list.size();\n+        for (auto i : select) list.push_back(i);\n+        std::sort(list.begin() + old_len, list.end(), [&](ClusterIndex a, ClusterIndex b) noexcept {\n+            const auto a_anc_count = entries[a].ancestors.Count();\n+            const auto b_anc_count = entries[b].ancestors.Count();\n+            if (a_anc_count != b_anc_count) return a_anc_count < b_anc_count;\n+            return a < b;\n+        });\n+    }\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename S>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<S>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    S m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<S>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{S::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            S anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(S select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {\n+                if (!(m_ancestor_set_feerates[i] > m_ancestor_set_feerates[*best])) continue;\n+            }\n+            best = i;\n+        }\n+        Assume(best.has_value());\n+        return {m_depgraph.Ancestors(*best) & m_todo, m_ancestor_set_feerates[*best]};\n+    }\n+};\n+\n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename S>\n+class SearchCandidateFinder\n+{\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** m_sorted_to_original[i] is the original position that sorted transaction position i had. */\n+    std::vector<ClusterIndex> m_sorted_to_original;\n+    /** m_original_to_sorted[i] is the sorted position original transaction position i has. */\n+    std::vector<ClusterIndex> m_original_to_sorted;\n+    /** Internal dependency graph for the cluster (with transactions in decreasing individual\n+     *  feerate order). */\n+    DepGraph<S> m_depgraph;\n+    /** Which transactions are left to do (indices in m_depgraph's sorted order). */\n+    S m_todo;\n+\n+    static uint256 GetRNGKey(uint64_t rng_seed) noexcept\n+    {\n+        uint256 rng_key;\n+        WriteLE64(rng_key.data(), rng_seed);\n+        return rng_key;\n+    }\n+\n+    /** Given a set of transactions with sorted indices, get their original indices. */\n+    S SortedToOriginal(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_sorted_to_original[pos]);\n+        return ret;\n+    }\n+\n+    /** Given a set of transactions with original indices, get their sorted indices. */\n+    S OriginalToSorted(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_original_to_sorted[pos]);\n+        return ret;\n+    }\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     * @param[in] rng_seed   A random seed to control the search order.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.Count().\n+     */\n+    SearchCandidateFinder(const DepGraph<S>& depgraph, uint64_t rng_seed) noexcept :\n+        m_rng(GetRNGKey(rng_seed)),\n+        m_sorted_to_original(depgraph.TxCount()),\n+        m_original_to_sorted(depgraph.TxCount())\n+    {\n+        // Determine reordering mapping, by sorting by decreasing feerate.\n+        std::iota(m_sorted_to_original.begin(), m_sorted_to_original.end(), ClusterIndex{0});\n+        std::sort(m_sorted_to_original.begin(), m_sorted_to_original.end(), [&](auto a, auto b) {\n+            auto feerate_cmp = depgraph.FeeRate(a) <=> depgraph.FeeRate(b);\n+            if (feerate_cmp == 0) return a < b;\n+            return feerate_cmp > 0;\n+        });\n+        // Compute reverse mapping.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            m_original_to_sorted[m_sorted_to_original[i]] = i;\n+        }\n+        // Compute reordered dependency graph.\n+        m_depgraph = DepGraph(depgraph, m_original_to_sorted);\n+        // Set todo to the entire graph.\n+        m_todo = S::Fill(depgraph.TxCount());\n+    }\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in,out] iterations_left    On input, an upper bound on the number of optimization\n+     *                                   steps that can be performed. On output, that number is\n+     *                                   reduced by the number of actually performed optimization\n+     *                                   steps.\n+     * @param[in] best                   A set/feerate pair with an already-known good candidate.\n+     *                                   This can be empty.\n+     * @return                           The best (highest feerate, smallest size as tiebreaker)\n+     *                                   topologically-valid subset of what remains of the cluster\n+     *                                   that was encountered during search. If iterations_left is\n+     *                                   nonzero on output, it is the absolute best such subset. If\n+     *                                   not, the feerate of the returned set will be at least as\n+     *                                   good as the best passed in.\n+     *\n+     * Complexity: possibly O(N * min(iterations_left, sqrt(2^N))) where N=depgraph.TxCount().\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet(uint64_t& iterations_left, std::pair<S, FeeFrac> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        if (best.second.IsEmpty()) {\n+            // Set best to the entire remainder if not provided.\n+            best.first = m_todo;\n+            best.second = m_depgraph.FeeRate(m_todo);\n+        } else {\n+            // Otherwise convert to internal sorted indices.\n+            best.first = OriginalToSorted(best.first);\n+        }\n+        Assume(!best.second.IsEmpty());\n+        Assume(best.first.Any());\n+        Assume(best.first.IsSubsetOf(m_todo));\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included. This must be a subset of m_todo, and be\n+             *  topologically valid (includes all in-m_todo ancestors of itself). */\n+            S inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            S und;\n+            /** (Only when inc is not empty) The subset with the best feerate of any superset of\n+             *  inc that is also a subset of (inc | und), without requiring it to be topologically\n+             *  valid. If the real best such feerate does not exceed best.second, then this value\n+             *  is not guaranteed to be accurate. */\n+            S pot;\n+            /** Equal to m_depgraph.FeeRate(inc). */\n+            FeeFrac inc_feerate;\n+            /** Equal to m_depgraph.FeeRate(pot). It forms a conservative upper bound on how good\n+             *  a set this work item can give rise to, unless that's known to be below best.second.\n+             */\n+            FeeFrac pot_feerate;\n+            /** Construct a new work item. */\n+            WorkItem(S&& i, S&& u, S&& p, FeeFrac&& i_f, FeeFrac&& p_f) noexcept :\n+                inc(std::move(i)), und(std::move(u)), pot(std::move(p)),\n+                inc_feerate(std::move(i_f)), pot_feerate(std::move(p_f)) {}\n+            /** Swap two WorkItems. */\n+            void Swap(WorkItem& other) noexcept\n+            {\n+                swap(inc, other.inc);\n+                swap(und, other.und);\n+                swap(pot, other.pot);\n+                swap(inc_feerate, other.inc_feerate);\n+                swap(pot_feerate, other.pot_feerate);\n+            }\n+        };\n+\n+        /** The queue of work items. */\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));\n+\n+        /** The set of transactions in m_todo which have feerate > best_feerate. */\n+        S imp = m_todo;\n+        while (imp.Any()) {\n+            ClusterIndex check = imp.Last();\n+            if (m_depgraph.FeeRate(check) >> best.second) break;\n+            imp.Reset(check);\n+        }\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iteration_limit = iterations_left;\n+\n+        /** Internal function to add a work item, possibly improving it before doing so.\n+         *\n+         * - inc: the \"inc\" value for the new work item\n+         * - und: the \"und\" value for the new work item\n+         * - pot: a subset of the \"pot\" value for the new work item (but a superset of inc).\n+         *        It does not need to be the full pot value; missing pot transactions will be added\n+         *        to it by add_fn.\n+         * - inc_feerate: equal to m_depgraph.FeeRate(inc)\n+         * - pot_feerate: equal to m_depgraph.FeeRate(pot)\n+         * - grow_inc: whether to attempt moving transactions from und to inc, if it can be proven\n+         *             that they must be a part of the best topologically valid superset of inc and\n+         *             subset of (inc | und). Transactions that are missing from pot are always\n+         *             considered, regardless of grow_inc. It only makes sense to enable this if\n+         *             transactions were added to inc.\n+         */\n+        auto add_fn = [&](S inc, S und, S pot, FeeFrac inc_feerate, FeeFrac pot_feerate, bool grow_inc) noexcept {\n+            Assume(inc.IsSubsetOf(m_todo));\n+            Assume(und.IsSubsetOf(m_todo));\n+            Assume(!inc.Overlaps(und));\n+            Assume(pot.IsSupersetOf(inc));\n+            Assume(pot.IsSubsetOf(inc | und));\n+            Assume(pot.None() == inc.None());\n+\n+            if (!inc_feerate.IsEmpty()) {\n+                /** Which transactions to consider adding to inc. */\n+                S consider_inc = grow_inc ? pot - inc : S{};\n+                // Add entries to pot (and pot_feerate). We iterate over all undecided transactions\n+                // whose feerate is higher than best_feerate, and aren't already part of pot. While\n+                // undecided transactions of lower feerate may improve pot still, if they do, the\n+                // resulting pot_feerate cannot possibly exceed best.second (resulting in the item\n+                // being skipped in split_fn).\n+                for (auto pos : (imp & und) - pot) {\n+                    // Determine if adding transaction pos to pot (ignoring topology) would improve it. If\n+                    // not, we're done updating pot. This relies on the fact that m_depgraph, and\n+                    // thus the set iterated over, is in decreasing individual feerate order.\n+                    if (!(m_depgraph.FeeRate(pos) >> pot_feerate)) break;\n+                    pot_feerate += m_depgraph.FeeRate(pos);\n+                    pot.Set(pos);\n+                    consider_inc.Set(pos);\n+                }\n+\n+                // The \"jump ahead\" optimization: whenever pot has a topologically-valid subset,\n+                // that subset can be added to inc. Any subset of (pot - inc) has the property that\n+                // its feerate exceeds that of any set compatible with this work item (superset of\n+                // inc, subset of (inc | und)). Thus, if T is a topological subset of pot, and B is\n+                // the best topologically-valid set compatible with this work item, and (T - B) is\n+                // non-empty, then (T | B) is better than B and also topological. This is in\n+                // contradiction with the assumption that B is best. Thus, (T - B) must be empty,\n+                // or T must be a subset of B.\n+                //\n+                // See https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303 section 2.4.\n+                const S init_inc = inc;\n+                for (auto pos : consider_inc) {\n+                    // If the transaction's ancestors are a subset of pot, we can add it together\n+                    // with its ancestors to inc.\n+                    auto anc_todo = m_depgraph.Ancestors(pos) & m_todo;\n+                    if (anc_todo.IsSubsetOf(pot)) inc |= anc_todo;\n+                }\n+                // Finally update und and inc_feerate to account for the added transactions.\n+                und -= inc;\n+                inc_feerate += m_depgraph.FeeRate(inc - init_inc);\n+\n+                // If inc_feerate is better than best_feerate, remember inc as our new best.\n+                if (inc_feerate > best.second) {\n+                    best = {inc, inc_feerate};\n+                    // See if we can remove any entries from imp now.\n+                    while (imp.Any()) {\n+                        ClusterIndex check = imp.Last();\n+                        if (m_depgraph.FeeRate(check) >> best.second) break;\n+                        imp.Reset(check);\n+                    }\n+                }\n+\n+                // If no potential transactions exist beyond the already included ones, no improvement\n+                // is possible anymore.\n+                if (pot == inc) return;\n+                // At this point und must be non-empty. If it were empty then pot would equal inc.\n+                Assume(und.Any());\n+            } else {\n+                // If inc is empty, we just make sure there are undecided transactions left to\n+                // split on.\n+                if (und.None()) return;\n+            }\n+\n+            // Actually construct new work item on the queue.\n+            Assume(queue.size() < queue.capacity());",
      "path": "src/cluster_linearize.h",
      "position": 581,
      "original_position": 558,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1626377280,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yes, took me a while to convince myself, but the claim is clear",
      "created_at": "2024-06-24T18:43:01Z",
      "updated_at": "2024-06-27T15:02:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651471330",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651471330"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 581,
      "original_line": 581,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651482096",
      "pull_request_review_id": 2116172410,
      "id": 1651482096,
      "node_id": "PRRC_kwDOABII585ib53w",
      "diff_hunk": "@@ -77,8 +77,9 @@ void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n {",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 1,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2228113dbbdd356aaaad385fd3e46a71308392aa",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "2228113dbbdd356aaaad385fd3e46a71308392aa commit message nit:\r\n\r\ns/item,/item to/",
      "created_at": "2024-06-24T18:53:07Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651482096",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651482096"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651484882",
      "pull_request_review_id": 2116172410,
      "id": 1651484882,
      "node_id": "PRRC_kwDOABII585ib6jS",
      "diff_hunk": "@@ -467,6 +495,7 @@ class SearchCandidateFinder\n  *\n  * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n  * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed        A random number seed to control search order.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 86,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2228113dbbdd356aaaad385fd3e46a71308392aa",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I presume the non-determinism is helpful to reduce the influence other nodes have on your linearization? Or maybe the idea that you could run linearizatio algo intermittently and make improvements? Other motivations?",
      "created_at": "2024-06-24T18:55:22Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651484882",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651484882"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 498,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652892335",
      "pull_request_review_id": 2116172410,
      "id": 1652892335,
      "node_id": "PRRC_kwDOABII585ihSKv",
      "diff_hunk": "@@ -491,33 +495,65 @@ class SearchCandidateFinder\n     }\n };\n \n-/** Find a linearization for a cluster.\n+/** Find or improve a linearization for a cluster.\n  *\n- * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n- * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n- * @param[in] rng_seed        A random number seed to control search order.\n- * @return                    A pair of:\n- *                            - The resulting linearization.\n- *                            - A boolean indicating whether the result is guaranteed to be\n- *                              optimal.\n+ * @param[in] depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in] max_iterations     Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed           A random number seed to control search order.\n+ * @param[in] old_linearization  An existing linearization for the cluster, or empty.\n+ * @return                       A pair of:\n+ *                               - The resulting linearization. It is guaranteed to be at least as\n+ *                                 good (in the feerate diagram sense) as old_linearization.\n+ *                               - A boolean indicating whether the result is guaranteed to be\n+ *                                 optimal.\n  *\n  * Complexity: O(N * min(max_iterations + N, 2^N)) where N=depgraph.TxCount().\n  */\n template<typename SetType>\n-std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed) noexcept\n+std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed, Span<const ClusterIndex> old_linearization = {}) noexcept\n {\n     uint64_t iterations_left = max_iterations;\n     auto todo = SetType::Fill(depgraph.TxCount());\n     std::vector<ClusterIndex> linearization;\n ",
      "path": "src/cluster_linearize.h",
      "position": 691,
      "original_position": 44,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n\r\n    Assume(old_linearization.empty() || old_linearization.size() == depgraph.TxCount());\r\n```",
      "created_at": "2024-06-25T14:08:01Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1652892335",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652892335"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 691,
      "original_line": 691,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652946934",
      "pull_request_review_id": 2116172410,
      "id": 1652946934,
      "node_id": "PRRC_kwDOABII585ihff2",
      "diff_hunk": "@@ -491,33 +495,65 @@ class SearchCandidateFinder\n     }\n };\n \n-/** Find a linearization for a cluster.\n+/** Find or improve a linearization for a cluster.\n  *\n- * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n- * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n- * @param[in] rng_seed        A random number seed to control search order.\n- * @return                    A pair of:\n- *                            - The resulting linearization.\n- *                            - A boolean indicating whether the result is guaranteed to be\n- *                              optimal.\n+ * @param[in] depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in] max_iterations     Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed           A random number seed to control search order.\n+ * @param[in] old_linearization  An existing linearization for the cluster, or empty.\n+ * @return                       A pair of:\n+ *                               - The resulting linearization. It is guaranteed to be at least as\n+ *                                 good (in the feerate diagram sense) as old_linearization.\n+ *                               - A boolean indicating whether the result is guaranteed to be\n+ *                                 optimal.\n  *\n  * Complexity: O(N * min(max_iterations + N, 2^N)) where N=depgraph.TxCount().\n  */\n template<typename SetType>\n-std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed) noexcept\n+std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed, Span<const ClusterIndex> old_linearization = {}) noexcept\n {\n     uint64_t iterations_left = max_iterations;\n     auto todo = SetType::Fill(depgraph.TxCount());\n     std::vector<ClusterIndex> linearization;\n \n+    // Precompute chunking of the existing linearization.\n+    std::vector<SetInfo<SetType>> chunks;\n+    for (auto i : old_linearization) {\n+        SetInfo new_chunk(depgraph, i);\n+        while (!chunks.empty() && new_chunk.feerate >> chunks.back().feerate) {\n+            new_chunk |= chunks.back();\n+            chunks.pop_back();\n+        }\n+        chunks.push_back(std::move(new_chunk));\n+    }\n+\n     AncestorCandidateFinder anc_finder(depgraph);\n     SearchCandidateFinder src_finder(depgraph, rng_seed);\n     linearization.reserve(depgraph.TxCount());\n     bool optimal = true;\n \n     while (todo.Any()) {\n-        // Initialize best as the best remaining ancestor set.\n-        auto best = anc_finder.FindCandidateSet();\n+        // This is an implementation of the (single) LIMO algorithm:\n+        // https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825\n+        // where S is instantiated to be the result of a bounded search, which itself is seeded\n+        // with the best prefix of what remains of the input linearization, or the best ancestor set.\n+\n+        // Find the highest-feerate prefix of remainder of original chunks.\n+        SetInfo<SetType> best_prefix, best_prefix_acc;\n+        for (const auto& chunk : chunks) {\n+            SetType intersect = chunk.transactions & todo;\n+            if (intersect.Any()) {\n+                best_prefix_acc |= SetInfo(depgraph, intersect);\n+                if (best_prefix.feerate.IsEmpty() || best_prefix_acc.feerate > best_prefix.feerate) {\n+                    best_prefix = best_prefix_acc;\n+                }\n+            }\n+        }\n+\n+        // Then initialize best to be either the best remaining ancestor set, or the first chunk.\n+        auto best_anc = anc_finder.FindCandidateSet();",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 82,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`best_anc` seems unneeded since it's only read once next line?",
      "created_at": "2024-06-25T14:28:52Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1652946934",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652946934"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 617,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652960236",
      "pull_request_review_id": 2116172410,
      "id": 1652960236,
      "node_id": "PRRC_kwDOABII585ihivs",
      "diff_hunk": "@@ -527,6 +563,24 @@ std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>\n \n         if (iterations_done_now == max_iterations_now) {\n             optimal = false;\n+            // If the search result is not (guaranteed to be) optimal, run intersections to make\n+            // sure we don't pick something that makes us unable to reach further diagram points\n+            // of the old linearization.\n+            if (best.transactions != best_prefix.transactions) {",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 95,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this section bears further elaboration, or direct citation to a good explanation of what this is necessary for correctness.",
      "created_at": "2024-06-25T14:36:53Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1652960236",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652960236"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 687,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653136174",
      "pull_request_review_id": 2116172410,
      "id": 1653136174,
      "node_id": "PRRC_kwDOABII585iiNsu",
      "diff_hunk": "@@ -464,6 +464,37 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Given a dependency graph, construct any valid linearization for it, reading from a SpanReader. */\n+template<typename BS>\n+std::vector<ClusterIndex> ReadLinearization(const DepGraph<BS>& depgraph, SpanReader& reader)\n+{\n+    std::vector<ClusterIndex> linearization;\n+    TestBitSet todo = TestBitSet::Fill(depgraph.TxCount());\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 10,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`i` is never used, which was confusing for me, perhaps this?\r\n```Suggestion\r\n    while (todo.Any()) {\r\n```\r\n\r\nalong with asserting that `todo.Count()` is going down for each iteration of the loop to avoid infinite loops ala `assert(todo.Count() < todo_count);`?",
      "created_at": "2024-06-25T16:17:12Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1653136174",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653136174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653168294",
      "pull_request_review_id": 2116172410,
      "id": 1653168294,
      "node_id": "PRRC_kwDOABII585iiVim",
      "diff_hunk": "@@ -166,6 +166,45 @@ class DepGraph\n         return ret;\n     }\n \n+    /** Find some connected component within the subset \"left\" of this graph.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 4,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "9633b40722fd9295b93baaf9914b31b9dec96f45",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I kept reading \"Left\" and is left vs right, since it was taking the `First` bit. \"todo\" probably matches better.",
      "created_at": "2024-06-25T16:39:59Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1653168294",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653168294"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653204539",
      "pull_request_review_id": 2116172410,
      "id": 1653204539,
      "node_id": "PRRC_kwDOABII585iieY7",
      "diff_hunk": "@@ -427,6 +427,21 @@ void SanityCheck(const DepGraph<SetType>& depgraph, Span<const ClusterIndex> lin\n     }\n }\n \n+/** Stitch connected components together in a DepGraph, guaranteeing its corresponding cluster is connected. */\n+template<typename BS>\n+void MakeConnected(DepGraph<BS>& depgraph)\n+{\n+    auto todo = BS::Fill(depgraph.TxCount());\n+    auto comp = depgraph.FindConnectedComponent(todo);\n+    todo -= comp;\n+    while (todo.Any()) {\n+        auto nextcomp = depgraph.FindConnectedComponent(todo);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 12,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "9633b40722fd9295b93baaf9914b31b9dec96f45",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n        Assume(!depgraph.IsConnected());\r\n        auto nextcomp = depgraph.FindConnectedComponent(todo);\r\n```",
      "created_at": "2024-06-25T16:57:19Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1653204539",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653204539"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657303810",
      "pull_request_review_id": 2116172410,
      "id": 1657303810,
      "node_id": "PRRC_kwDOABII585iyHMC",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 read children.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 1024) {\n+        auto parent = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 1);\n+        auto child = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 2);\n+        child += (child >= parent);\n+        cluster[child].second.Set(parent);\n+        depgraph.AddDependency(parent, child);\n+        assert(depgraph.Ancestors(child)[parent]);\n+        assert(depgraph.Descendants(parent)[child]);\n+    }\n+    // Sanity check the result.\n+    SanityCheck(depgraph);\n+    // Verify that the resulting DepGraph matches one recomputed from the cluster.\n+    assert(DepGraph(cluster) == depgraph);\n+}\n+\n+FUZZ_TARGET(clusterlin_cluster_serialization)\n+{\n+    // Verify that any graph of transaction has its ancestry correctly computed by DepGraph, and if\n+    // it is a DAG, it can be serialized as a DepGraph in a way that roundtrips. This guarantees\n+    // that any acyclic cluster has a corresponding DepGraph serialization.\n+\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    // Construct a cluster in a naive way (using a FuzzedDataProvider-based serialization).\n+    Cluster<TestBitSet> cluster;\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(1, 32);\n+    cluster.resize(num_tx);\n+    for (ClusterIndex i = 0; i < num_tx; ++i) {\n+        cluster[i].first.size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+        cluster[i].first.fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n+        for (ClusterIndex j = 0; j < num_tx; ++j) {\n+            if (i == j) continue;\n+            if (provider.ConsumeBool()) cluster[i].second.Set(j);\n+        }\n+    }\n+\n+    // Construct dependency graph. The sanity check here includes a round-trip check.\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+\n+    // Verify that ancestry is computed correctly.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 353,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "for assurance shouldn't we also be checking the descendants are being computed as expected? Or is that covered somewhere else?",
      "created_at": "2024-06-27T15:01:17Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657303810",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657303810"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657850742",
      "pull_request_review_id": 2146569823,
      "id": 1657850742,
      "node_id": "PRRC_kwDOABII585i0Mt2",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, SetType::Singleton(new_idx), SetType::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.",
      "path": "src/cluster_linearize.h",
      "position": 151,
      "original_position": 141,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "06c600099abe129a5bb5c6a5a533018f03e51304",
      "in_reply_to_id": 1638465834,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think there is a need for that. If `parent == child` then this is a no-op (every transaction is already an ancestor and descendant of itself).",
      "created_at": "2024-06-27T21:48:39Z",
      "updated_at": "2024-06-27T21:48:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657850742",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657850742"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857264",
      "pull_request_review_id": 2146580224,
      "id": 1657857264,
      "node_id": "PRRC_kwDOABII585i0OTw",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 266,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": 1638438741,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-27T21:57:25Z",
      "updated_at": "2024-06-27T21:57:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857264",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857264"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 525,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857307",
      "pull_request_review_id": 2146580297,
      "id": 1657857307,
      "node_id": "PRRC_kwDOABII585i0OUb",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 270,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": 1638450101,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-27T21:57:30Z",
      "updated_at": "2024-06-27T21:57:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857307",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857307"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 529,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857391",
      "pull_request_review_id": 2146580422,
      "id": 1657857391,
      "node_id": "PRRC_kwDOABII585i0OVv",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 126,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "06c600099abe129a5bb5c6a5a533018f03e51304",
      "in_reply_to_id": 1638472774,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a comment.",
      "created_at": "2024-06-27T21:57:38Z",
      "updated_at": "2024-06-27T21:57:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857391",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 131,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857455",
      "pull_request_review_id": 2146580502,
      "id": 1657857455,
      "node_id": "PRRC_kwDOABII585i0OWv",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 1024) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 271,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": 1638488625,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-27T21:57:42Z",
      "updated_at": "2024-06-27T21:57:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857455",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 530,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857579",
      "pull_request_review_id": 2146580710,
      "id": 1657857579,
      "node_id": "PRRC_kwDOABII585i0OYr",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 159,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e5ba6ece9b2ae3f46625825cfabcf348c229f935",
      "in_reply_to_id": 1640177309,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done with a `static_assert`.",
      "created_at": "2024-06-27T21:57:53Z",
      "updated_at": "2024-06-27T21:57:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857579",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857631",
      "pull_request_review_id": 2146580809,
      "id": 1657857631,
      "node_id": "PRRC_kwDOABII585i0OZf",
      "diff_hunk": "@@ -162,6 +163,100 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];",
      "path": "src/cluster_linearize.h",
      "position": 406,
      "original_position": 61,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": 1644863011,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-27T21:57:58Z",
      "updated_at": "2024-06-27T21:57:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857631",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857631"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 406,
      "original_line": 406,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857760",
      "pull_request_review_id": 2146581040,
      "id": 1657857760,
      "node_id": "PRRC_kwDOABII585i0Obg",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 154,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e5ba6ece9b2ae3f46625825cfabcf348c229f935",
      "in_reply_to_id": 1640177227,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done with a `static_assert`.",
      "created_at": "2024-06-27T21:58:11Z",
      "updated_at": "2024-06-27T21:58:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857760",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857760"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659216405",
      "pull_request_review_id": 2148798778,
      "id": 1659216405,
      "node_id": "PRRC_kwDOABII585i5aIV",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms.\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        if (ntx & 1) {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 2});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({14, 2});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({6, 1});\n+                depgraph.AddDependency(2, 1);\n+            } else if (i == 3) {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(2, 3);\n+            } else if ((i & 1) == 0) {\n+                depgraph.AddTransaction({7, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(i, 4);\n+            }\n+        } else {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 1});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({3, 1});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({1, 1});\n+                depgraph.AddDependency(0, 2);\n+            } else if (i & 1) {\n+                depgraph.AddTransaction({4, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({0, 1});\n+                depgraph.AddDependency(i, 3);\n+            }\n+        }\n+    }\n+    return depgraph;\n+}\n+\n+/** Benchmark that does search-based candidate finding with 10000 iterations. */\n+template<typename SetType>\n+void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeHardGraph<SetType>(ntx);\n+    const auto iter_limit = std::min<uint64_t>(10000, uint64_t{1} << (ntx / 2 - 1));\n+    bench.batch(iter_limit).unit(\"iters\").run([&] {\n+        SearchCandidateFinder finder(depgraph);\n+        auto [candidate, iters_performed] = finder.FindCandidateSet(iter_limit, {});\n+        assert(iters_performed == iter_limit);\n+    });\n+}\n+\n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort. */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeLinearGraph<SetType>(ntx);\n+    bench.run([&] {\n+        // Do 10 iterations just to make sure some of that logic is executed, but this is\n+        // effectively negligible.\n+        uint64_t iters = 10;\n+        Linearize(depgraph, iters);\n+    });\n+}\n+\n+} // namespace\n+\n+static void LinearizePerIter16TxWorstCase(benchmark::Bench& bench) { BenchLinearizePerIterWorstCase<BitSet<16>>(16, bench); }",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 102,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": 1649399637,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`BitSet<N>::Size()` may differ from `N`.",
      "created_at": "2024-06-28T19:20:43Z",
      "updated_at": "2024-06-28T19:20:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659216405",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659216405"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 106,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659217667",
      "pull_request_review_id": 2148801193,
      "id": 1659217667,
      "node_id": "PRRC_kwDOABII585i5acD",
      "diff_hunk": "@@ -162,6 +163,100 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {",
      "path": "src/cluster_linearize.h",
      "position": 453,
      "original_position": 96,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": 1644905104,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-28T19:21:35Z",
      "updated_at": "2024-06-28T19:21:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659217667",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659217667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 453,
      "original_line": 453,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218218",
      "pull_request_review_id": 2148802168,
      "id": 1659218218,
      "node_id": "PRRC_kwDOABII585i5akq",
      "diff_hunk": "@@ -346,3 +364,49 @@ FUZZ_TARGET(clusterlin_depgraph_serialization)\n     // Verify the graph is a DAG.\n     assert(IsAcyclic(depgraph));\n }\n+\n+FUZZ_TARGET(clusterlin_ancestor_finder)\n+{\n+    // Verify that AncestorCandidateFinder works as expected.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    AncestorCandidateFinder anc_finder(depgraph);\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // Call the ancestor finder's FindCandidateSet for what remains of the graph.\n+        auto best_anc = anc_finder.FindCandidateSet();\n+        // Sanity check the result.\n+        assert(best_anc.transactions.Any());\n+        assert(best_anc.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(best_anc.transactions) == best_anc.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : best_anc.transactions) {\n+            assert((depgraph.Ancestors(i) & todo).IsSubsetOf(best_anc.transactions));\n+        }\n+\n+        // Compute all remaining ancestor sets.\n+        std::optional<SetInfo<TestBitSet>> real_best_anc;\n+        for (auto i : todo) {\n+            SetInfo info(depgraph, todo & depgraph.Ancestors(i));\n+            if (!real_best_anc.has_value() || info.feerate > real_best_anc->feerate) {\n+                real_best_anc = info;\n+            }\n+        }\n+        // The set returned by anc_finder must equal the real best ancestor sets.\n+        assert(real_best_anc.has_value());\n+        assert(*real_best_anc == best_anc);\n+\n+        // Find a topologically valid subset of transactions to remove from the graph.\n+        auto del_set = ReadTopologicalSet(depgraph, todo, reader);\n+        // If we did not find anything, use best_anc itself, because we should remove something.\n+        if (del_set.None()) del_set = best_anc.transactions;\n+        todo -= del_set;\n+        anc_finder.MarkDone(del_set);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 382,
      "original_position": 72,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": 1644945090,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've outlawed `MarkDone()` with `select` not a subset of `todo`.",
      "created_at": "2024-06-28T19:21:56Z",
      "updated_at": "2024-06-28T19:21:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659218218",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 382,
      "original_line": 382,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218521",
      "pull_request_review_id": 2148802769,
      "id": 1659218521,
      "node_id": "PRRC_kwDOABII585i5apZ",
      "diff_hunk": "@@ -193,6 +193,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 45,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": 1644952136,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added, please have a look if this is what you meant.",
      "created_at": "2024-06-28T19:22:09Z",
      "updated_at": "2024-06-28T19:22:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659218521",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218521"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218637",
      "pull_request_review_id": 2148802983,
      "id": 1659218637,
      "node_id": "PRRC_kwDOABII585i5arN",
      "diff_hunk": "@@ -410,3 +510,86 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(0x3ffff);\n+            assert(found.feerate >= simple.feerate);\n+            if (simple_iters < 0x3ffff) assert(found.feerate == simple.feerate);\n+\n+            // Compare with AncestorCandidateFinder;\n+            auto anc = anc_finder.FindCandidateSet();\n+            assert(found.feerate >= anc.feerate);\n+\n+            // If todo isn't too big, compare with ExhaustiveCandidateFinder.\n+            if (todo.Count() <= 12) {\n+                auto exhaustive = exh_finder.FindCandidateSet();\n+                assert(exhaustive.feerate == found.feerate);\n+                // Also compare ExhaustiveCandidateFinder with SimpleCandidateFinder (this is more\n+                // a test for SimpleCandidateFinder's correctness).\n+                assert(exhaustive.feerate >= simple.feerate);\n+                if (simple_iters < 0x3ffff) assert(exhaustive.feerate == simple.feerate);\n+            }\n+        }\n+\n+        // Find a topologically valid subset of transactions to remove from the graph.\n+        auto del_set = ReadTopologicalSet(depgraph, todo, reader);\n+        // If we did not find anything, use found_set itself, because we should remove something.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 185,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": 1644963760,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-06-28T19:22:14Z",
      "updated_at": "2024-06-28T19:22:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659218637",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218637"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 459,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218822",
      "pull_request_review_id": 2148803329,
      "id": 1659218822,
      "node_id": "PRRC_kwDOABII585i5auG",
      "diff_hunk": "@@ -193,6 +193,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 55,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": 1644966180,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-06-28T19:22:22Z",
      "updated_at": "2024-06-28T19:22:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659218822",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218822"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218927",
      "pull_request_review_id": 2148803534,
      "id": 1659218927,
      "node_id": "PRRC_kwDOABII585i5avv",
      "diff_hunk": "@@ -193,6 +193,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 14,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": 1644966317,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-06-28T19:22:27Z",
      "updated_at": "2024-06-28T19:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659218927",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218927"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659219435",
      "pull_request_review_id": 2148804406,
      "id": 1659219435,
      "node_id": "PRRC_kwDOABII585i5a3r",
      "diff_hunk": "@@ -410,3 +510,86 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(0x3ffff);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 164,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": 1644982295,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, named it `MAX_SIMPLE_ITERATIONS` (and used more readable number 300000).",
      "created_at": "2024-06-28T19:22:49Z",
      "updated_at": "2024-06-28T19:22:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659219435",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659219435"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 438,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659219716",
      "pull_request_review_id": 2148804813,
      "id": 1659219716,
      "node_id": "PRRC_kwDOABII585i5a8E",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 74,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": 1649155445,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-28T19:22:58Z",
      "updated_at": "2024-06-28T19:22:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659219716",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659219716"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659220190",
      "pull_request_review_id": 2148805579,
      "id": 1659220190,
      "node_id": "PRRC_kwDOABII585i5bDe",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 75,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": 1649205112,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "See new unit test.",
      "created_at": "2024-06-28T19:23:14Z",
      "updated_at": "2024-06-28T19:23:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659220190",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659220190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659220493",
      "pull_request_review_id": 2148805988,
      "id": 1659220493,
      "node_id": "PRRC_kwDOABII585i5bIN",
      "diff_hunk": "@@ -452,3 +552,86 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(0x3ffff);\n+            assert(found.feerate >= simple.feerate);\n+            if (simple_iters < 0x3ffff) assert(found.feerate == simple.feerate);\n+\n+            // Compare with AncestorCandidateFinder;\n+            auto anc = anc_finder.FindCandidateSet();\n+            assert(found.feerate >= anc.feerate);\n+\n+            // If todo isn't too big, compare with ExhaustiveCandidateFinder.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 172,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649232974,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'd rather not. The point of `ExhaustiveCandidateFinder` is really testing the correctness of `SimpleCandidateFinder` (whose correctness may not be obvious to reviewers), so that `SimpleCandidateFinder` on its turn can be used to test `SearchCandidateFinder`. I added comments to explain that.\r\n\r\nBoth of these are done within the same fuzz test, which is perhaps confusing? I could split up the tests (an exhaustive-vs-simple test, and a simple-vs-search test).",
      "created_at": "2024-06-28T19:23:22Z",
      "updated_at": "2024-06-28T19:23:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659220493",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659220493"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 446,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659220875",
      "pull_request_review_id": 2148806518,
      "id": 1659220875,
      "node_id": "PRRC_kwDOABII585i5bOL",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions\n+                // that share ancestry with inc so far (which means only connected sets will be\n+                // considered).\n+                if (inc_none || inc.Overlaps(m_depgraph.Ancestors(pivot))) {\n+                    // Add a queue entry with pivot included.\n+                    SetInfo new_inc(m_depgraph, inc | (m_todo & m_depgraph.Ancestors(pivot)));\n+                    queue.emplace_back(new_inc.transactions, und - new_inc.transactions);\n+                    // Add a queue entry with pivot excluded.\n+                    queue.emplace_back(inc, und - m_depgraph.Descendants(pivot));\n+                    // Update statistics to account for the candidate new_inc.\n+                    if (new_inc.feerate > best.feerate) best = new_inc;\n+                    break;\n+                }\n+            }\n+        }\n+        return {std::move(best), max_iterations - iterations_left};",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 88,
      "original_position": 100,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649259334,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed. I don't think 1 iteration matters.",
      "created_at": "2024-06-28T19:23:33Z",
      "updated_at": "2024-06-28T19:23:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659220875",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659220875"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659221292",
      "pull_request_review_id": 2148807122,
      "id": 1659221292,
      "node_id": "PRRC_kwDOABII585i5bUs",
      "diff_hunk": "@@ -257,6 +277,145 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 84,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649287854,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Disallowed.",
      "created_at": "2024-06-28T19:23:47Z",
      "updated_at": "2024-06-28T19:23:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659221292",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659221292"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 398,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659221511",
      "pull_request_review_id": 2148807474,
      "id": 1659221511,
      "node_id": "PRRC_kwDOABII585i5bYH",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649300280,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-28T19:23:55Z",
      "updated_at": "2024-06-28T19:23:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659221511",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659221511"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659221633",
      "pull_request_review_id": 2148807726,
      "id": 1659221633,
      "node_id": "PRRC_kwDOABII585i5baB",
      "diff_hunk": "@@ -257,6 +277,145 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included (and its feerate). This must be a subset\n+             *  of m_todo, and be topologically valid (includes all in-m_todo ancestors of\n+             *  itself). */\n+            SetInfo<SetType> inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            SetType und;\n+\n+            /** Construct a new work item. */\n+            WorkItem(SetInfo<SetType>&& i, SetType&& u) noexcept :\n+                inc(std::move(i)), und(std::move(u)) {}\n+        };\n+\n+        /** The queue of work items. */\n+        std::vector<WorkItem> queue;\n+\n+        // Create an initial entry with m_todo as undecided. Also use it as best if not provided,\n+        // so that during the work processing loop below, and during the add_fn/split_fn calls, we\n+        // do not need to deal with the best=empty case.\n+        if (best.feerate.IsEmpty()) best = SetInfo(m_depgraph, m_todo);\n+        queue.emplace_back(SetInfo<SetType>{}, SetType{m_todo});\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iterations_left = max_iterations;\n+\n+        /** Internal function to add a work item.\n+         *\n+         * - inc: the \"inc\" value for the new work item\n+         * - und: the \"und\" value for the new work item\n+         */\n+        auto add_fn = [&](SetInfo<SetType> inc, SetType und) noexcept {\n+            if (!inc.feerate.IsEmpty()) {\n+                // If inc's feerate is better than best's, remember it as our new best.\n+                if (inc.feerate > best.feerate) {\n+                    best = inc;\n+                }\n+            }",
      "path": "src/cluster_linearize.h",
      "position": 573,
      "original_position": 125,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649308286,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-28T19:24:02Z",
      "updated_at": "2024-06-28T19:24:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659221633",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659221633"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 573,
      "original_line": 573,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659222412",
      "pull_request_review_id": 2148808767,
      "id": 1659222412,
      "node_id": "PRRC_kwDOABII585i5bmM",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms.\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        if (ntx & 1) {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 2});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({14, 2});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({6, 1});\n+                depgraph.AddDependency(2, 1);\n+            } else if (i == 3) {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(2, 3);\n+            } else if ((i & 1) == 0) {\n+                depgraph.AddTransaction({7, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(i, 4);\n+            }\n+        } else {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 1});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({3, 1});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({1, 1});\n+                depgraph.AddDependency(0, 2);\n+            } else if (i & 1) {\n+                depgraph.AddTransaction({4, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({0, 1});\n+                depgraph.AddDependency(i, 3);\n+            }\n+        }\n+    }\n+    return depgraph;\n+}\n+\n+/** Benchmark that does search-based candidate finding with 10000 iterations. */\n+template<typename SetType>\n+void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeHardGraph<SetType>(ntx);\n+    const auto iter_limit = std::min<uint64_t>(10000, uint64_t{1} << (ntx / 2 - 1));\n+    bench.batch(iter_limit).unit(\"iters\").run([&] {\n+        SearchCandidateFinder finder(depgraph);\n+        auto [candidate, iters_performed] = finder.FindCandidateSet(iter_limit, {});\n+        assert(iters_performed == iter_limit);\n+    });\n+}\n+\n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort. */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeLinearGraph<SetType>(ntx);\n+    bench.run([&] {\n+        // Do 10 iterations just to make sure some of that logic is executed, but this is\n+        // effectively negligible.",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 94,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": 1649396138,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I was trying to explain why using 10 iterations instead of 0 made sense. I have instead just changed it to 0 iterations.",
      "created_at": "2024-06-28T19:24:38Z",
      "updated_at": "2024-06-28T19:24:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659222412",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659222412"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659228321",
      "pull_request_review_id": 2148816572,
      "id": 1659228321,
      "node_id": "PRRC_kwDOABII585i5dCh",
      "diff_hunk": "@@ -411,10 +416,36 @@ class SearchCandidateFinder\n         };\n \n         // Work processing loop.\n+        //\n+        // New work items are always added at the back of the queue, but items to process use a\n+        // hybrid approach where they can be taken from the front or the back.\n+        //\n+        // Depth-first search (DFS) corresponds to always taking from the back of the queue. This\n+        // is very memory-efficient (linear in the number of transactions). Breadth-first search\n+        // (BFS) corresponds to always taking from the front, which potentially uses more memory\n+        // (up to exponential in the transaction count), but seems to work better in practice.\n+        //\n+        // The approach here combines the two: use BFS until the queue grows too large, at which\n+        // point we temporarily switch to DFS until the size shrinks again.\n         while (!queue.empty()) {\n+            // See if processing the first queue item (BFS) is possible without exceeding the queue\n+            // capacity(), assuming we process the last queue items (DFS) after that.\n+            const auto queuesize_for_front = queue.capacity() - queue.front().und.Count();",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 48,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": 1651468145,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It means \"what the **queue size** needs to be before we can process an element from the **front**\".",
      "created_at": "2024-06-28T19:29:27Z",
      "updated_at": "2024-06-28T19:29:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659228321",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659228321"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 524,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660345204",
      "pull_request_review_id": 2150238176,
      "id": 1660345204,
      "node_id": "PRRC_kwDOABII585i9tt0",
      "diff_hunk": "@@ -467,6 +495,7 @@ class SearchCandidateFinder\n  *\n  * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n  * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed        A random number seed to control search order.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 86,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2228113dbbdd356aaaad385fd3e46a71308392aa",
      "in_reply_to_id": 1651484882,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, it is to reduce the ability for peers to construct cases that just happen to be worst case for the exact search order they know we're going to try.",
      "created_at": "2024-07-01T00:42:03Z",
      "updated_at": "2024-07-01T00:42:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1660345204",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660345204"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 498,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349106",
      "pull_request_review_id": 2150244036,
      "id": 1660349106,
      "node_id": "PRRC_kwDOABII585i9uqy",
      "diff_hunk": "@@ -635,3 +688,68 @@ FUZZ_TARGET(clusterlin_search_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_linearize)\n+{\n+    // Verify the behavior of Linearize().\n+\n+    // Retrieve an iteration count, and a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    uint64_t iter_count{0};\n+    try {\n+        reader >> VARINT(iter_count) >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Invoke Linearize().\n+    iter_count &= 0x7ffff;\n+    auto [linearization, optimal] = Linearize(depgraph, iter_count);\n+    SanityCheck(depgraph, linearization);\n+    auto chunking = ChunkLinearization(depgraph, linearization);\n+\n+    // If the iteration count is sufficiently high, an optimal linearization must be found.\n+    // Each linearization step can use up to 2^k iterations, with steps k=1..n. That sum is\n+    // 2 * (2^n - 1)\n+    const uint64_t n = depgraph.TxCount();\n+    if (n <= 18 && iter_count > 2U * ((uint64_t{1} << n) - 1U)) {\n+        assert(optimal);\n+    }\n+\n+    // If Linearize claims optimal result, run quality tests.\n+    if (optimal) {\n+        // It must be as good as SimpleLinearize.\n+        auto [simple_linearization, simple_optimal] = SimpleLinearize(depgraph, 0x3ffff);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 115,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "a34467001c258adf6b6f6d5d626221e7f89d38df",
      "in_reply_to_id": 1649373379,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, named as `MAX_SIMPLE_ITERATIONS`.",
      "created_at": "2024-07-01T00:56:56Z",
      "updated_at": "2024-07-01T00:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1660349106",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349106"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 541,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349184",
      "pull_request_review_id": 2150244105,
      "id": 1660349184,
      "node_id": "PRRC_kwDOABII585i9usA",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms.\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        if (ntx & 1) {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 2});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({14, 2});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({6, 1});\n+                depgraph.AddDependency(2, 1);\n+            } else if (i == 3) {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(2, 3);\n+            } else if ((i & 1) == 0) {\n+                depgraph.AddTransaction({7, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(i, 4);\n+            }\n+        } else {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 1});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({3, 1});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({1, 1});\n+                depgraph.AddDependency(0, 2);\n+            } else if (i & 1) {\n+                depgraph.AddTransaction({4, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({0, 1});\n+                depgraph.AddDependency(i, 3);\n+            }\n+        }\n+    }\n+    return depgraph;\n+}\n+\n+/** Benchmark that does search-based candidate finding with 10000 iterations. */\n+template<typename SetType>\n+void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeHardGraph<SetType>(ntx);\n+    const auto iter_limit = std::min<uint64_t>(10000, uint64_t{1} << (ntx / 2 - 1));\n+    bench.batch(iter_limit).unit(\"iters\").run([&] {\n+        SearchCandidateFinder finder(depgraph);\n+        auto [candidate, iters_performed] = finder.FindCandidateSet(iter_limit, {});\n+        assert(iters_performed == iter_limit);\n+    });\n+}\n+\n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort. */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": 1649401042,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added comments.",
      "created_at": "2024-07-01T00:57:05Z",
      "updated_at": "2024-07-01T00:57:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1660349184",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349184"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349260",
      "pull_request_review_id": 2150244251,
      "id": 1660349260,
      "node_id": "PRRC_kwDOABII585i9utM",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 27,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": 1651203077,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I have no idea! Added a comment that it was found empirically.",
      "created_at": "2024-07-01T00:57:22Z",
      "updated_at": "2024-07-01T00:57:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1660349260",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349260"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349319",
      "pull_request_review_id": 2150244330,
      "id": 1660349319,
      "node_id": "PRRC_kwDOABII585i9uuH",
      "diff_hunk": "@@ -77,8 +77,9 @@ void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n {",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 1,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2228113dbbdd356aaaad385fd3e46a71308392aa",
      "in_reply_to_id": 1651482096,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-01T00:57:32Z",
      "updated_at": "2024-07-01T00:57:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1660349319",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349319"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349373",
      "pull_request_review_id": 2150244420,
      "id": 1660349373,
      "node_id": "PRRC_kwDOABII585i9uu9",
      "diff_hunk": "@@ -467,6 +495,7 @@ class SearchCandidateFinder\n  *\n  * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n  * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed        A random number seed to control search order.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 86,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2228113dbbdd356aaaad385fd3e46a71308392aa",
      "in_reply_to_id": 1651484882,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a comment to `Linearize` to reflect this.",
      "created_at": "2024-07-01T00:57:46Z",
      "updated_at": "2024-07-01T00:57:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1660349373",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349373"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 498,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349427",
      "pull_request_review_id": 2150244485,
      "id": 1660349427,
      "node_id": "PRRC_kwDOABII585i9uvz",
      "diff_hunk": "@@ -491,33 +495,65 @@ class SearchCandidateFinder\n     }\n };\n \n-/** Find a linearization for a cluster.\n+/** Find or improve a linearization for a cluster.\n  *\n- * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n- * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n- * @param[in] rng_seed        A random number seed to control search order.\n- * @return                    A pair of:\n- *                            - The resulting linearization.\n- *                            - A boolean indicating whether the result is guaranteed to be\n- *                              optimal.\n+ * @param[in] depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in] max_iterations     Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed           A random number seed to control search order.\n+ * @param[in] old_linearization  An existing linearization for the cluster, or empty.\n+ * @return                       A pair of:\n+ *                               - The resulting linearization. It is guaranteed to be at least as\n+ *                                 good (in the feerate diagram sense) as old_linearization.\n+ *                               - A boolean indicating whether the result is guaranteed to be\n+ *                                 optimal.\n  *\n  * Complexity: O(N * min(max_iterations + N, 2^N)) where N=depgraph.TxCount().\n  */\n template<typename SetType>\n-std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed) noexcept\n+std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed, Span<const ClusterIndex> old_linearization = {}) noexcept\n {\n     uint64_t iterations_left = max_iterations;\n     auto todo = SetType::Fill(depgraph.TxCount());\n     std::vector<ClusterIndex> linearization;\n ",
      "path": "src/cluster_linearize.h",
      "position": 691,
      "original_position": 44,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": 1652892335,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-01T00:57:53Z",
      "updated_at": "2024-07-01T00:57:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1660349427",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349427"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 691,
      "original_line": 691,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1661222360",
      "pull_request_review_id": 2151679554,
      "id": 1661222360,
      "node_id": "PRRC_kwDOABII585jBD3Y",
      "diff_hunk": "@@ -132,6 +132,7 @@ BITCOIN_CORE_H = \\\n   chainparamsseeds.h \\",
      "path": "src/Makefile.am",
      "position": 1,
      "original_position": 1,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2ab345e52c55590c489dcdc1a1945f123d692a44",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: noticed a couple typos in the commit message, if you end up touching this again:\r\n```\r\nThis primarily adds the DepGraph class, which encapsulated precomputed\r\n```\r\nencapsulate**s**\r\n\r\n```\r\nnumber of a utility features (inspectors for set feerates, computing\r\n```\r\n~~a~~",
      "created_at": "2024-07-01T15:27:09Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1661222360",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1661222360"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 132,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1661239839",
      "pull_request_review_id": 2151679554,
      "id": 1661239839,
      "node_id": "PRRC_kwDOABII585jBIIf",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;",
      "path": "src/cluster_linearize.h",
      "position": 49,
      "original_position": 43,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2ab345e52c55590c489dcdc1a1945f123d692a44",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is this only used for verifying whether two DepGraph objects are identical, eg in the serialization/deserialization tests in the next commit?\r\n\r\nIt occurred to me that there might be some contexts where an equality operator for two Entry objects might want to be defined differently -- eg because you could have two Entry's in the same DepGraph with identical feerate and ancestor/descendant state, but still treat them as different objects -- but I'm guessing that is not the case for any of the uses currently contemplated?",
      "created_at": "2024-07-01T15:41:01Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1661239839",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1661239839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 49,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662746393",
      "pull_request_review_id": 2151679554,
      "id": 1662746393,
      "node_id": "PRRC_kwDOABII585jG38Z",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: O(1) (amortized, due to resizing of backing vector).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();",
      "path": "src/cluster_linearize.h",
      "position": 138,
      "original_position": 130,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2ab345e52c55590c489dcdc1a1945f123d692a44",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should this function be checking that we haven't exceeded the capacity of the SetType?",
      "created_at": "2024-07-02T15:25:15Z",
      "updated_at": "2024-07-12T14:56:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1662746393",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662746393"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 138,
      "original_line": 138,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662798441",
      "pull_request_review_id": 2151679554,
      "id": 1662798441,
      "node_id": "PRRC_kwDOABII585jHEpp",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 79,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: \"satisyfy\" --> \"satisfy\"",
      "created_at": "2024-07-02T16:01:29Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1662798441",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662798441"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662822694",
      "pull_request_review_id": 2151679554,
      "id": 1662822694,
      "node_id": "PRRC_kwDOABII585jHKkm",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    /** Test whether adding a dependency between parent and child is valid and meaningful. */\n+    template<typename SetType>\n+    static bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // If child is already an ancestor of parent, the dependency would cause a cycle. Without\n+        // this condition, it would be possible for DepGraphFormatter to deserialize to a cyclic\n+        // graph.\n+        if (depgraph.Ancestors(parent)[child]) return false;\n+        // If child is already a descendant of parent, the dependency would be redundant. This is\n+        // an optimization whose goal is maximizing the probability to changes to the encoding map\n+        // to semantically distinct graphs.\n+        if (depgraph.Descendants(parent)[child]) return false;\n+        // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+        // that dependency will have been redundant if a dependency between parent and child is\n+        // added. This is also just an optimization.\n+        const auto& descendants = depgraph.Descendants(child);\n+        for (auto i : depgraph.Ancestors(parent)) {\n+            if (descendants.Overlaps(depgraph.Descendants(i))) {\n+                if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 176,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I was really confused about why we need to use `CanAddDependency` here -- as far as I can understand, it's basically about compression, so that we get shorter serializations?  And conceptually, the reason compression is helpful is in the context of serializations that are produced by a fuzzer being as meaningful as possible?\r\n\r\nI guess compression doesn't hurt here, but just to verify my understanding: would all this logic work just fine if we dropped the use of `CanAddDependency` in the serializer, but left it in place in the deserializer?  Or are there cases where that difference would result in the round trip of serializing/deserializing to not result in the same graph?  (And if so, could you provide such an example so I can try to better understand this logic?)",
      "created_at": "2024-07-02T16:20:50Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1662822694",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662822694"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662824605",
      "pull_request_review_id": 2151679554,
      "id": 1662824605,
      "node_id": "PRRC_kwDOABII585jHLCd",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    /** Test whether adding a dependency between parent and child is valid and meaningful. */\n+    template<typename SetType>\n+    static bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // If child is already an ancestor of parent, the dependency would cause a cycle. Without\n+        // this condition, it would be possible for DepGraphFormatter to deserialize to a cyclic\n+        // graph.\n+        if (depgraph.Ancestors(parent)[child]) return false;\n+        // If child is already a descendant of parent, the dependency would be redundant. This is\n+        // an optimization whose goal is maximizing the probability to changes to the encoding map\n+        // to semantically distinct graphs.\n+        if (depgraph.Descendants(parent)[child]) return false;\n+        // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+        // that dependency will have been redundant if a dependency between parent and child is\n+        // added. This is also just an optimization.\n+        const auto& descendants = depgraph.Descendants(child);\n+        for (auto i : depgraph.Ancestors(parent)) {\n+            if (descendants.Overlaps(depgraph.Descendants(i))) {\n+                if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 160,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should this say \"serializer\" instead of \"deserializer\"?",
      "created_at": "2024-07-02T16:22:32Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1662824605",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662824605"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662836077",
      "pull_request_review_id": 2151679554,
      "id": 1662836077,
      "node_id": "PRRC_kwDOABII585jHN1t",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 102,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Left another comment down below regarding `CanAddDependency()` in the serializer -- it makes sense to me to use it in the deserializer in the context of having a fuzzer produce random bytes which we try to deserialize into a graph, but I don't follow why it's necessary in the serializer.",
      "created_at": "2024-07-02T16:29:45Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1662836077",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662836077"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662861895",
      "pull_request_review_id": 2151679554,
      "id": 1662861895,
      "node_id": "PRRC_kwDOABII585jHUJH",
      "diff_hunk": "@@ -0,0 +1,80 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <test/util/cluster_linearize.h>\n+#include <test/util/setup_common.h>\n+#include <util/bitset.h>\n+#include <util/strencodings.h>\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(cluster_linearize_tests, BasicTestingSetup)\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+template<typename SetType>\n+void TestDepGraphSerialization(const Cluster<SetType>& cluster, const std::string& hexenc)\n+{\n+    DepGraph depgraph(cluster);\n+\n+    // Test that depgraph has all the fees/sizes/parents required by cluster.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        BOOST_CHECK(depgraph.FeeRate(i) == cluster[i].first);\n+        for (ClusterIndex par : cluster[i].second) {\n+            BOOST_CHECK(depgraph.Ancestors(i)[par]);\n+            BOOST_CHECK(depgraph.Descendants(par)[i]);\n+        }\n+    }\n+\n+    // Run normal sanity checks on depgraph.\n+    SanityCheck(depgraph);\n+\n+    // Test that the serialization of depgraph matches hexenc.\n+    std::vector<unsigned char> encoding;\n+    VectorWriter writer(encoding, 0);\n+    writer << Using<DepGraphFormatter>(depgraph);\n+    BOOST_CHECK_EQUAL(HexStr(encoding), hexenc);\n+\n+    // Test that deserializing that encoding yields depgraph.\n+    SpanReader reader(encoding);\n+    DepGraph<SetType> depgraph_read;\n+    reader >> Using<DepGraphFormatter>(depgraph_read);\n+    BOOST_CHECK(depgraph == depgraph_read);\n+}\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(depgraph_ser_tests)\n+{\n+    // Empty cluster.\n+    TestDepGraphSerialization<TestBitSet>({}, \"00\");\n+\n+    // Transactions: A(fee=0,size=1).\n+    TestDepGraphSerialization<TestBitSet>({{{0, 1}, {}}}, \"010000\");\n+\n+    // Transactions: A(fee=42,size=11), B(fee=-13,size=7), B depends on A.\n+    TestDepGraphSerialization<TestBitSet>(\n+        {{{42, 11}, {}}, {{-13, 7}, {0}}},\n+        \"0b5407190100\");",
      "path": "src/test/cluster_linearize_tests.cpp",
      "position": null,
      "original_position": 64,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is the best way to review this code to manually check that the encoding is as described in the serialization code?",
      "created_at": "2024-07-02T16:46:18Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1662861895",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662861895"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662966890",
      "pull_request_review_id": 2151679554,
      "id": 1662966890,
      "node_id": "PRRC_kwDOABII585jHtxq",
      "diff_hunk": "@@ -0,0 +1,80 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <test/util/cluster_linearize.h>\n+#include <test/util/setup_common.h>\n+#include <util/bitset.h>\n+#include <util/strencodings.h>\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(cluster_linearize_tests, BasicTestingSetup)\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+template<typename SetType>\n+void TestDepGraphSerialization(const Cluster<SetType>& cluster, const std::string& hexenc)\n+{\n+    DepGraph depgraph(cluster);\n+\n+    // Test that depgraph has all the fees/sizes/parents required by cluster.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        BOOST_CHECK(depgraph.FeeRate(i) == cluster[i].first);\n+        for (ClusterIndex par : cluster[i].second) {\n+            BOOST_CHECK(depgraph.Ancestors(i)[par]);\n+            BOOST_CHECK(depgraph.Descendants(par)[i]);\n+        }\n+    }\n+\n+    // Run normal sanity checks on depgraph.\n+    SanityCheck(depgraph);\n+\n+    // Test that the serialization of depgraph matches hexenc.\n+    std::vector<unsigned char> encoding;\n+    VectorWriter writer(encoding, 0);\n+    writer << Using<DepGraphFormatter>(depgraph);\n+    BOOST_CHECK_EQUAL(HexStr(encoding), hexenc);\n+\n+    // Test that deserializing that encoding yields depgraph.\n+    SpanReader reader(encoding);\n+    DepGraph<SetType> depgraph_read;\n+    reader >> Using<DepGraphFormatter>(depgraph_read);\n+    BOOST_CHECK(depgraph == depgraph_read);\n+}\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(depgraph_ser_tests)\n+{\n+    // Empty cluster.\n+    TestDepGraphSerialization<TestBitSet>({}, \"00\");\n+\n+    // Transactions: A(fee=0,size=1).\n+    TestDepGraphSerialization<TestBitSet>({{{0, 1}, {}}}, \"010000\");\n+\n+    // Transactions: A(fee=42,size=11), B(fee=-13,size=7), B depends on A.\n+    TestDepGraphSerialization<TestBitSet>(\n+        {{{42, 11}, {}}, {{-13, 7}, {0}}},\n+        \"0b5407190100\");\n+\n+    // Transactions: A(64,128), B(128,256), C(1,1), C depends on A and B.\n+    TestDepGraphSerialization<TestBitSet>(\n+        {{{64, 128}, {}}, {{128, 256}, {}}, {{1, 1}, {0, 1}}},\n+        \"8000800081008100000102010100\");\n+\n+    // Transactions: A(-58,113), B(36,114), C(-59,115), D(37,116). Deps: B->A, C->A, D->C, in order",
      "path": "src/test/cluster_linearize_tests.cpp",
      "position": null,
      "original_position": 71,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: The fee/size values in this comment don't seem to match the fee/size values in the test below.",
      "created_at": "2024-07-02T18:12:14Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1662966890",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662966890"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 71,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663121757",
      "pull_request_review_id": 2154795931,
      "id": 1663121757,
      "node_id": "PRRC_kwDOABII585jITld",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 read children.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 1024) {\n+        auto parent = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 1);\n+        auto child = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 2);\n+        child += (child >= parent);\n+        cluster[child].second.Set(parent);\n+        depgraph.AddDependency(parent, child);\n+        assert(depgraph.Ancestors(child)[parent]);\n+        assert(depgraph.Descendants(parent)[child]);\n+    }\n+    // Sanity check the result.\n+    SanityCheck(depgraph);\n+    // Verify that the resulting DepGraph matches one recomputed from the cluster.\n+    assert(DepGraph(cluster) == depgraph);\n+}\n+\n+FUZZ_TARGET(clusterlin_cluster_serialization)\n+{\n+    // Verify that any graph of transaction has its ancestry correctly computed by DepGraph, and if\n+    // it is a DAG, it can be serialized as a DepGraph in a way that roundtrips. This guarantees\n+    // that any acyclic cluster has a corresponding DepGraph serialization.\n+\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    // Construct a cluster in a naive way (using a FuzzedDataProvider-based serialization).\n+    Cluster<TestBitSet> cluster;\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(1, 32);\n+    cluster.resize(num_tx);\n+    for (ClusterIndex i = 0; i < num_tx; ++i) {\n+        cluster[i].first.size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+        cluster[i].first.fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n+        for (ClusterIndex j = 0; j < num_tx; ++j) {\n+            if (i == j) continue;\n+            if (provider.ConsumeBool()) cluster[i].second.Set(j);\n+        }\n+    }\n+\n+    // Construct dependency graph. The sanity check here includes a round-trip check.\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+\n+    // Verify that ancestry is computed correctly.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 353,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": 1657303810,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's covered in `SanityCheck`.",
      "created_at": "2024-07-02T20:19:24Z",
      "updated_at": "2024-07-02T20:19:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663121757",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663121757"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663124799",
      "pull_request_review_id": 2154801669,
      "id": 1663124799,
      "node_id": "PRRC_kwDOABII585jIUU_",
      "diff_hunk": "@@ -351,7 +352,8 @@ class SearchCandidateFinder\n         };\n \n         /** The queue of work items. */\n-        std::vector<WorkItem> queue;\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));",
      "path": "src/cluster_linearize.h",
      "position": 548,
      "original_position": 14,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": 1651302872,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The way the bound was computed was inaccurate; I have fixed that (256 does get reached (but not exceeded) now in the bench(99) benchmark if you increase the iteration count to 100000). I've also rewritten the comments and computation a bit.",
      "created_at": "2024-07-02T20:21:37Z",
      "updated_at": "2024-07-08T14:09:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663124799",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663124799"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 548,
      "original_line": 548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663124892",
      "pull_request_review_id": 2154801917,
      "id": 1663124892,
      "node_id": "PRRC_kwDOABII585jIUWc",
      "diff_hunk": "@@ -411,10 +416,36 @@ class SearchCandidateFinder\n         };\n \n         // Work processing loop.\n+        //\n+        // New work items are always added at the back of the queue, but items to process use a\n+        // hybrid approach where they can be taken from the front or the back.\n+        //\n+        // Depth-first search (DFS) corresponds to always taking from the back of the queue. This\n+        // is very memory-efficient (linear in the number of transactions). Breadth-first search\n+        // (BFS) corresponds to always taking from the front, which potentially uses more memory\n+        // (up to exponential in the transaction count), but seems to work better in practice.\n+        //\n+        // The approach here combines the two: use BFS until the queue grows too large, at which\n+        // point we temporarily switch to DFS until the size shrinks again.\n         while (!queue.empty()) {\n+            // See if processing the first queue item (BFS) is possible without exceeding the queue\n+            // capacity(), assuming we process the last queue items (DFS) after that.\n+            const auto queuesize_for_front = queue.capacity() - queue.front().und.Count();",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 48,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": 1651468145,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I have rewritten this.",
      "created_at": "2024-07-02T20:21:44Z",
      "updated_at": "2024-07-02T20:21:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663124892",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663124892"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 524,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663125068",
      "pull_request_review_id": 2154802227,
      "id": 1663125068,
      "node_id": "PRRC_kwDOABII585jIUZM",
      "diff_hunk": "@@ -491,33 +495,65 @@ class SearchCandidateFinder\n     }\n };\n \n-/** Find a linearization for a cluster.\n+/** Find or improve a linearization for a cluster.\n  *\n- * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n- * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n- * @param[in] rng_seed        A random number seed to control search order.\n- * @return                    A pair of:\n- *                            - The resulting linearization.\n- *                            - A boolean indicating whether the result is guaranteed to be\n- *                              optimal.\n+ * @param[in] depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in] max_iterations     Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed           A random number seed to control search order.\n+ * @param[in] old_linearization  An existing linearization for the cluster, or empty.\n+ * @return                       A pair of:\n+ *                               - The resulting linearization. It is guaranteed to be at least as\n+ *                                 good (in the feerate diagram sense) as old_linearization.\n+ *                               - A boolean indicating whether the result is guaranteed to be\n+ *                                 optimal.\n  *\n  * Complexity: O(N * min(max_iterations + N, 2^N)) where N=depgraph.TxCount().\n  */\n template<typename SetType>\n-std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed) noexcept\n+std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed, Span<const ClusterIndex> old_linearization = {}) noexcept\n {\n     uint64_t iterations_left = max_iterations;\n     auto todo = SetType::Fill(depgraph.TxCount());\n     std::vector<ClusterIndex> linearization;\n \n+    // Precompute chunking of the existing linearization.\n+    std::vector<SetInfo<SetType>> chunks;\n+    for (auto i : old_linearization) {\n+        SetInfo new_chunk(depgraph, i);\n+        while (!chunks.empty() && new_chunk.feerate >> chunks.back().feerate) {\n+            new_chunk |= chunks.back();\n+            chunks.pop_back();\n+        }\n+        chunks.push_back(std::move(new_chunk));\n+    }\n+\n     AncestorCandidateFinder anc_finder(depgraph);\n     SearchCandidateFinder src_finder(depgraph, rng_seed);\n     linearization.reserve(depgraph.TxCount());\n     bool optimal = true;\n \n     while (todo.Any()) {\n-        // Initialize best as the best remaining ancestor set.\n-        auto best = anc_finder.FindCandidateSet();\n+        // This is an implementation of the (single) LIMO algorithm:\n+        // https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825\n+        // where S is instantiated to be the result of a bounded search, which itself is seeded\n+        // with the best prefix of what remains of the input linearization, or the best ancestor set.\n+\n+        // Find the highest-feerate prefix of remainder of original chunks.\n+        SetInfo<SetType> best_prefix, best_prefix_acc;\n+        for (const auto& chunk : chunks) {\n+            SetType intersect = chunk.transactions & todo;\n+            if (intersect.Any()) {\n+                best_prefix_acc |= SetInfo(depgraph, intersect);\n+                if (best_prefix.feerate.IsEmpty() || best_prefix_acc.feerate > best_prefix.feerate) {\n+                    best_prefix = best_prefix_acc;\n+                }\n+            }\n+        }\n+\n+        // Then initialize best to be either the best remaining ancestor set, or the first chunk.\n+        auto best_anc = anc_finder.FindCandidateSet();",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 82,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": 1652946934,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Gone.",
      "created_at": "2024-07-02T20:21:53Z",
      "updated_at": "2024-07-02T20:21:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663125068",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663125068"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 617,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663125681",
      "pull_request_review_id": 2154803367,
      "id": 1663125681,
      "node_id": "PRRC_kwDOABII585jIUix",
      "diff_hunk": "@@ -527,6 +563,24 @@ std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>\n \n         if (iterations_done_now == max_iterations_now) {\n             optimal = false;\n+            // If the search result is not (guaranteed to be) optimal, run intersections to make\n+            // sure we don't pick something that makes us unable to reach further diagram points\n+            // of the old linearization.\n+            if (best.transactions != best_prefix.transactions) {",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 95,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": 1652960236,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think my in-progress delving post will cover this. I will postpone addressing this until that's out.",
      "created_at": "2024-07-02T20:22:25Z",
      "updated_at": "2024-07-02T20:22:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663125681",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663125681"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 687,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663126806",
      "pull_request_review_id": 2154805782,
      "id": 1663126806,
      "node_id": "PRRC_kwDOABII585jIU0W",
      "diff_hunk": "@@ -464,6 +464,37 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Given a dependency graph, construct any valid linearization for it, reading from a SpanReader. */\n+template<typename BS>\n+std::vector<ClusterIndex> ReadLinearization(const DepGraph<BS>& depgraph, SpanReader& reader)\n+{\n+    std::vector<ClusterIndex> linearization;\n+    TestBitSet todo = TestBitSet::Fill(depgraph.TxCount());\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 10,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": 1653136174,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done. I've added an `assert(todo[j]);` before `todo.Reset(j);` to make sure infinite iteration is not possible.",
      "created_at": "2024-07-02T20:23:32Z",
      "updated_at": "2024-07-02T20:23:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663126806",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663126806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663126949",
      "pull_request_review_id": 2154805987,
      "id": 1663126949,
      "node_id": "PRRC_kwDOABII585jIU2l",
      "diff_hunk": "@@ -166,6 +166,45 @@ class DepGraph\n         return ret;\n     }\n \n+    /** Find some connected component within the subset \"left\" of this graph.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 4,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "9633b40722fd9295b93baaf9914b31b9dec96f45",
      "in_reply_to_id": 1653168294,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-02T20:23:37Z",
      "updated_at": "2024-07-02T20:23:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663126949",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663126949"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663127067",
      "pull_request_review_id": 2154806208,
      "id": 1663127067,
      "node_id": "PRRC_kwDOABII585jIU4b",
      "diff_hunk": "@@ -427,6 +427,21 @@ void SanityCheck(const DepGraph<SetType>& depgraph, Span<const ClusterIndex> lin\n     }\n }\n \n+/** Stitch connected components together in a DepGraph, guaranteeing its corresponding cluster is connected. */\n+template<typename BS>\n+void MakeConnected(DepGraph<BS>& depgraph)\n+{\n+    auto todo = BS::Fill(depgraph.TxCount());\n+    auto comp = depgraph.FindConnectedComponent(todo);\n+    todo -= comp;\n+    while (todo.Any()) {\n+        auto nextcomp = depgraph.FindConnectedComponent(todo);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 12,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "9633b40722fd9295b93baaf9914b31b9dec96f45",
      "in_reply_to_id": 1653204539,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-02T20:23:43Z",
      "updated_at": "2024-07-02T20:23:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663127067",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663127067"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664681970",
      "pull_request_review_id": 2151679554,
      "id": 1664681970,
      "node_id": "PRRC_kwDOABII585jOQfy",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 read children.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 1024) {\n+        auto parent = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 1);\n+        auto child = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 2);\n+        child += (child >= parent);\n+        cluster[child].second.Set(parent);\n+        depgraph.AddDependency(parent, child);\n+        assert(depgraph.Ancestors(child)[parent]);\n+        assert(depgraph.Descendants(parent)[child]);\n+    }\n+    // Sanity check the result.\n+    SanityCheck(depgraph);\n+    // Verify that the resulting DepGraph matches one recomputed from the cluster.\n+    assert(DepGraph(cluster) == depgraph);\n+}\n+\n+FUZZ_TARGET(clusterlin_cluster_serialization)\n+{\n+    // Verify that any graph of transaction has its ancestry correctly computed by DepGraph, and if\n+    // it is a DAG, it can be serialized as a DepGraph in a way that roundtrips. This guarantees\n+    // that any acyclic cluster has a corresponding DepGraph serialization.\n+\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    // Construct a cluster in a naive way (using a FuzzedDataProvider-based serialization).\n+    Cluster<TestBitSet> cluster;\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(1, 32);\n+    cluster.resize(num_tx);\n+    for (ClusterIndex i = 0; i < num_tx; ++i) {\n+        cluster[i].first.size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+        cluster[i].first.fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n+        for (ClusterIndex j = 0; j < num_tx; ++j) {\n+            if (i == j) continue;\n+            if (provider.ConsumeBool()) cluster[i].second.Set(j);\n+        }\n+    }\n+\n+    // Construct dependency graph. The sanity check here includes a round-trip check.\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+\n+    // Verify that ancestry is computed correctly.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 353,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": 1657303810,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think `SanityCheck` is already checking that the ancestors and descendants are consistent with each other, so it's sufficient here to check that the ancestors are correct.",
      "created_at": "2024-07-03T19:49:05Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1664681970",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664681970"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664704882",
      "pull_request_review_id": 2151679554,
      "id": 1664704882,
      "node_id": "PRRC_kwDOABII585jOWFy",
      "diff_hunk": "@@ -5,6 +5,7 @@\n #ifndef BITCOIN_CLUSTER_LINEARIZE_H",
      "path": "src/cluster_linearize.h",
      "position": 5,
      "original_position": 1,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ca6f49dd0de718d1e29060e2ef2f0d6a48f7dcc4",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: if you touch up this commit, I think the commit message has a couple typos:\r\n\r\n`This is a class that encapsulated precomputes ancestor set feerates, and`\r\n\r\nshould read \"encapsulates precomputed ancestor set feerates\"\r\n",
      "created_at": "2024-07-03T20:03:34Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1664704882",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664704882"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 5,
      "original_line": 5,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664822525",
      "pull_request_review_id": 2157483747,
      "id": 1664822525,
      "node_id": "PRRC_kwDOABII585jOyz9",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    /** Test whether adding a dependency between parent and child is valid and meaningful. */\n+    template<typename SetType>\n+    static bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // If child is already an ancestor of parent, the dependency would cause a cycle. Without\n+        // this condition, it would be possible for DepGraphFormatter to deserialize to a cyclic\n+        // graph.\n+        if (depgraph.Ancestors(parent)[child]) return false;\n+        // If child is already a descendant of parent, the dependency would be redundant. This is\n+        // an optimization whose goal is maximizing the probability to changes to the encoding map\n+        // to semantically distinct graphs.\n+        if (depgraph.Descendants(parent)[child]) return false;\n+        // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+        // that dependency will have been redundant if a dependency between parent and child is\n+        // added. This is also just an optimization.\n+        const auto& descendants = depgraph.Descendants(child);\n+        for (auto i : depgraph.Ancestors(parent)) {\n+            if (descendants.Overlaps(depgraph.Descendants(i))) {\n+                if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 176,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662822694,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, it is needed, for the simple reason that the serializer needs to predict what the deserializer state will be when reading this, or they will go out of sync. If they disagree about which dependencies are possible, the delta-encoded differences between them will be off, resulting in possibly widely different DepGraphs on decoding. An example where this matters is in the 4th unit test (specifically constructed for that, suggested by @instagibbs).\r\n\r\nI am considering a simplification for the encoding format however, but I'm not sure yet if it'll be an improvement. I'll try pushing a commit that switches things over in the next few days. Perhaps it's worth holding off reviewing the encoding format and associated logic until then.",
      "created_at": "2024-07-03T21:19:11Z",
      "updated_at": "2024-07-03T21:19:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1664822525",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664822525"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1666706287",
      "pull_request_review_id": 2160552969,
      "id": 1666706287,
      "node_id": "PRRC_kwDOABII585jV-tv",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;",
      "path": "src/cluster_linearize.h",
      "position": 49,
      "original_position": 43,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2ab345e52c55590c489dcdc1a1945f123d692a44",
      "in_reply_to_id": 1661239839,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`Entry` struct does not have any other distinguishing information, are you suggesting adding txid to `Entry`?",
      "created_at": "2024-07-05T11:42:04Z",
      "updated_at": "2024-07-05T12:20:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1666706287",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1666706287"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 49,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1666706550",
      "pull_request_review_id": 2160552969,
      "id": 1666706550,
      "node_id": "PRRC_kwDOABII585jV-x2",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 51,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e27797600418ffc2d7ecf70134d7fcc778204d85",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "which order?",
      "created_at": "2024-07-05T11:42:24Z",
      "updated_at": "2024-07-05T12:20:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1666706550",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1666706550"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667779316",
      "pull_request_review_id": 2161937780,
      "id": 1667779316,
      "node_id": "PRRC_kwDOABII585jaEr0",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    /** Test whether adding a dependency between parent and child is valid and meaningful. */\n+    template<typename SetType>\n+    static bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // If child is already an ancestor of parent, the dependency would cause a cycle. Without\n+        // this condition, it would be possible for DepGraphFormatter to deserialize to a cyclic\n+        // graph.\n+        if (depgraph.Ancestors(parent)[child]) return false;\n+        // If child is already a descendant of parent, the dependency would be redundant. This is\n+        // an optimization whose goal is maximizing the probability to changes to the encoding map\n+        // to semantically distinct graphs.\n+        if (depgraph.Descendants(parent)[child]) return false;\n+        // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+        // that dependency will have been redundant if a dependency between parent and child is\n+        // added. This is also just an optimization.\n+        const auto& descendants = depgraph.Descendants(child);\n+        for (auto i : depgraph.Ancestors(parent)) {\n+            if (descendants.Overlaps(depgraph.Descendants(i))) {\n+                if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 160,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662824605,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No, the serializer is serializing the `this` object; the `rebuild` object represents what the deserializer already knows when it has deserialized up to whatever has been serialized already.",
      "created_at": "2024-07-07T22:41:16Z",
      "updated_at": "2024-07-07T22:41:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667779316",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667779316"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667979626",
      "pull_request_review_id": 2162243522,
      "id": 1667979626,
      "node_id": "PRRC_kwDOABII585ja1lq",
      "diff_hunk": "@@ -132,6 +132,7 @@ BITCOIN_CORE_H = \\\n   chainparamsseeds.h \\",
      "path": "src/Makefile.am",
      "position": 1,
      "original_position": 1,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2ab345e52c55590c489dcdc1a1945f123d692a44",
      "in_reply_to_id": 1661222360,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-08T04:36:09Z",
      "updated_at": "2024-07-08T04:36:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667979626",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667979626"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 132,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667980741",
      "pull_request_review_id": 2162245632,
      "id": 1667980741,
      "node_id": "PRRC_kwDOABII585ja13F",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;",
      "path": "src/cluster_linearize.h",
      "position": 49,
      "original_position": 43,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2ab345e52c55590c489dcdc1a1945f123d692a44",
      "in_reply_to_id": 1661239839,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "From the perspective of a `DepGraph`, transactions are identified by their position in the entry vector (which matches their position in the `Cluster` they came from). `DepGraph`'s equality tests whether every transaction in every position matches; there is nothing else it knows about.\r\n\r\nI've added a comment to `DepGraph::operator==` to indicate it's primarily for testing.",
      "created_at": "2024-07-08T04:38:28Z",
      "updated_at": "2024-07-08T04:38:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667980741",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667980741"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 49,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667980882",
      "pull_request_review_id": 2162245813,
      "id": 1667980882,
      "node_id": "PRRC_kwDOABII585ja15S",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: O(1) (amortized, due to resizing of backing vector).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();",
      "path": "src/cluster_linearize.h",
      "position": 138,
      "original_position": 130,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2ab345e52c55590c489dcdc1a1945f123d692a44",
      "in_reply_to_id": 1662746393,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added an `Assume` for that.",
      "created_at": "2024-07-08T04:38:39Z",
      "updated_at": "2024-07-08T04:38:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667980882",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667980882"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 138,
      "original_line": 138,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667980947",
      "pull_request_review_id": 2162245908,
      "id": 1667980947,
      "node_id": "PRRC_kwDOABII585ja16T",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 79,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662798441,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-08T04:38:45Z",
      "updated_at": "2024-07-08T04:38:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667980947",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667980947"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981357",
      "pull_request_review_id": 2162246612,
      "id": 1667981357,
      "node_id": "PRRC_kwDOABII585ja2At",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    /** Test whether adding a dependency between parent and child is valid and meaningful. */\n+    template<typename SetType>\n+    static bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // If child is already an ancestor of parent, the dependency would cause a cycle. Without\n+        // this condition, it would be possible for DepGraphFormatter to deserialize to a cyclic\n+        // graph.\n+        if (depgraph.Ancestors(parent)[child]) return false;\n+        // If child is already a descendant of parent, the dependency would be redundant. This is\n+        // an optimization whose goal is maximizing the probability to changes to the encoding map\n+        // to semantically distinct graphs.\n+        if (depgraph.Descendants(parent)[child]) return false;\n+        // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+        // that dependency will have been redundant if a dependency between parent and child is\n+        // added. This is also just an optimization.\n+        const auto& descendants = depgraph.Descendants(child);\n+        for (auto i : depgraph.Ancestors(parent)) {\n+            if (descendants.Overlaps(depgraph.Descendants(i))) {\n+                if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 176,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662822694,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've pushed this simplification; it works a lot different now, but `CanAddDependency`, `GetReducedParents`, and  `GetReducedChildren` are gone.",
      "created_at": "2024-07-08T04:39:27Z",
      "updated_at": "2024-07-08T04:39:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667981357",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981485",
      "pull_request_review_id": 2162246858,
      "id": 1667981485,
      "node_id": "PRRC_kwDOABII585ja2Ct",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 102,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662836077,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's gone.",
      "created_at": "2024-07-08T04:39:40Z",
      "updated_at": "2024-07-08T04:39:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667981485",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981485"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981720",
      "pull_request_review_id": 2162247252,
      "id": 1667981720,
      "node_id": "PRRC_kwDOABII585ja2GY",
      "diff_hunk": "@@ -0,0 +1,80 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <test/util/cluster_linearize.h>\n+#include <test/util/setup_common.h>\n+#include <util/bitset.h>\n+#include <util/strencodings.h>\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(cluster_linearize_tests, BasicTestingSetup)\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+template<typename SetType>\n+void TestDepGraphSerialization(const Cluster<SetType>& cluster, const std::string& hexenc)\n+{\n+    DepGraph depgraph(cluster);\n+\n+    // Test that depgraph has all the fees/sizes/parents required by cluster.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        BOOST_CHECK(depgraph.FeeRate(i) == cluster[i].first);\n+        for (ClusterIndex par : cluster[i].second) {\n+            BOOST_CHECK(depgraph.Ancestors(i)[par]);\n+            BOOST_CHECK(depgraph.Descendants(par)[i]);\n+        }\n+    }\n+\n+    // Run normal sanity checks on depgraph.\n+    SanityCheck(depgraph);\n+\n+    // Test that the serialization of depgraph matches hexenc.\n+    std::vector<unsigned char> encoding;\n+    VectorWriter writer(encoding, 0);\n+    writer << Using<DepGraphFormatter>(depgraph);\n+    BOOST_CHECK_EQUAL(HexStr(encoding), hexenc);\n+\n+    // Test that deserializing that encoding yields depgraph.\n+    SpanReader reader(encoding);\n+    DepGraph<SetType> depgraph_read;\n+    reader >> Using<DepGraphFormatter>(depgraph_read);\n+    BOOST_CHECK(depgraph == depgraph_read);\n+}\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(depgraph_ser_tests)\n+{\n+    // Empty cluster.\n+    TestDepGraphSerialization<TestBitSet>({}, \"00\");\n+\n+    // Transactions: A(fee=0,size=1).\n+    TestDepGraphSerialization<TestBitSet>({{{0, 1}, {}}}, \"010000\");\n+\n+    // Transactions: A(fee=42,size=11), B(fee=-13,size=7), B depends on A.\n+    TestDepGraphSerialization<TestBitSet>(\n+        {{{42, 11}, {}}, {{-13, 7}, {0}}},\n+        \"0b5407190100\");",
      "path": "src/test/cluster_linearize_tests.cpp",
      "position": null,
      "original_position": 64,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662861895,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "With the format change, I've documented every byte of the encoding in the tests here.",
      "created_at": "2024-07-08T04:40:07Z",
      "updated_at": "2024-07-08T04:40:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667981720",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981720"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981849",
      "pull_request_review_id": 2162247446,
      "id": 1667981849,
      "node_id": "PRRC_kwDOABII585ja2IZ",
      "diff_hunk": "@@ -0,0 +1,80 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <test/util/cluster_linearize.h>\n+#include <test/util/setup_common.h>\n+#include <util/bitset.h>\n+#include <util/strencodings.h>\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(cluster_linearize_tests, BasicTestingSetup)\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+template<typename SetType>\n+void TestDepGraphSerialization(const Cluster<SetType>& cluster, const std::string& hexenc)\n+{\n+    DepGraph depgraph(cluster);\n+\n+    // Test that depgraph has all the fees/sizes/parents required by cluster.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        BOOST_CHECK(depgraph.FeeRate(i) == cluster[i].first);\n+        for (ClusterIndex par : cluster[i].second) {\n+            BOOST_CHECK(depgraph.Ancestors(i)[par]);\n+            BOOST_CHECK(depgraph.Descendants(par)[i]);\n+        }\n+    }\n+\n+    // Run normal sanity checks on depgraph.\n+    SanityCheck(depgraph);\n+\n+    // Test that the serialization of depgraph matches hexenc.\n+    std::vector<unsigned char> encoding;\n+    VectorWriter writer(encoding, 0);\n+    writer << Using<DepGraphFormatter>(depgraph);\n+    BOOST_CHECK_EQUAL(HexStr(encoding), hexenc);\n+\n+    // Test that deserializing that encoding yields depgraph.\n+    SpanReader reader(encoding);\n+    DepGraph<SetType> depgraph_read;\n+    reader >> Using<DepGraphFormatter>(depgraph_read);\n+    BOOST_CHECK(depgraph == depgraph_read);\n+}\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(depgraph_ser_tests)\n+{\n+    // Empty cluster.\n+    TestDepGraphSerialization<TestBitSet>({}, \"00\");\n+\n+    // Transactions: A(fee=0,size=1).\n+    TestDepGraphSerialization<TestBitSet>({{{0, 1}, {}}}, \"010000\");\n+\n+    // Transactions: A(fee=42,size=11), B(fee=-13,size=7), B depends on A.\n+    TestDepGraphSerialization<TestBitSet>(\n+        {{{42, 11}, {}}, {{-13, 7}, {0}}},\n+        \"0b5407190100\");\n+\n+    // Transactions: A(64,128), B(128,256), C(1,1), C depends on A and B.\n+    TestDepGraphSerialization<TestBitSet>(\n+        {{{64, 128}, {}}, {{128, 256}, {}}, {{1, 1}, {0, 1}}},\n+        \"8000800081008100000102010100\");\n+\n+    // Transactions: A(-58,113), B(36,114), C(-59,115), D(37,116). Deps: B->A, C->A, D->C, in order",
      "path": "src/test/cluster_linearize_tests.cpp",
      "position": null,
      "original_position": 71,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662966890,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch, fixed.",
      "created_at": "2024-07-08T04:40:17Z",
      "updated_at": "2024-07-08T04:40:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667981849",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981849"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 71,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981943",
      "pull_request_review_id": 2162247601,
      "id": 1667981943,
      "node_id": "PRRC_kwDOABII585ja2J3",
      "diff_hunk": "@@ -5,6 +5,7 @@\n #ifndef BITCOIN_CLUSTER_LINEARIZE_H",
      "path": "src/cluster_linearize.h",
      "position": 5,
      "original_position": 1,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ca6f49dd0de718d1e29060e2ef2f0d6a48f7dcc4",
      "in_reply_to_id": 1664704882,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-08T04:40:25Z",
      "updated_at": "2024-07-08T04:40:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667981943",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981943"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 5,
      "original_line": 5,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667982100",
      "pull_request_review_id": 2162247783,
      "id": 1667982100,
      "node_id": "PRRC_kwDOABII585ja2MU",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 51,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e27797600418ffc2d7ecf70134d7fcc778204d85",
      "in_reply_to_id": 1666706550,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a comment.",
      "created_at": "2024-07-08T04:40:34Z",
      "updated_at": "2024-07-08T04:40:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667982100",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667982100"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668526162",
      "pull_request_review_id": 2118340933,
      "id": 1668526162,
      "node_id": "PRRC_kwDOABII585jc7BS",
      "diff_hunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/cluster_linearize.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    Cluster<TestBitSet> cluster(num_tx, std::pair{FeeFrac{0, 1}, TestBitSet{}});\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and depgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, TestBitSet::Size() * TestBitSet::Size()) {\n+        auto parent = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 1);\n+        auto child = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 2);\n+        child += (child >= parent);\n+        cluster[child].second.Set(parent);\n+        depgraph.AddDependency(parent, child);\n+        assert(depgraph.Ancestors(child)[parent]);\n+        assert(depgraph.Descendants(parent)[child]);\n+    }\n+    // Sanity check the result.\n+    SanityCheck(depgraph);\n+    // Verify that the resulting DepGraph matches one recomputed from the cluster.\n+    assert(DepGraph(cluster) == depgraph);\n+}\n+\n+FUZZ_TARGET(clusterlin_cluster_serialization)\n+{\n+    // Verify that any graph of transaction has its ancestry correctly computed by DepGraph, and if",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 48,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "4b1e978b2bafd9da564aa52d2ce64a723cf64036",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "4b1e978b2bafd9da564aa52d2ce64a723cf64036 nit:\r\n```suggestion\r\n    // Verify that any graph of transactions has its ancestry correctly computed by DepGraph, and if\r\n```",
      "created_at": "2024-07-08T12:21:40Z",
      "updated_at": "2024-07-08T15:34:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1668526162",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668526162"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668545670",
      "pull_request_review_id": 2118340933,
      "id": 1668545670,
      "node_id": "PRRC_kwDOABII585jc_yG",
      "diff_hunk": "@@ -163,6 +164,110 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone.\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called which will return a\n+ * SetInfo with the highest-feerate ancestor set that remains (an ancestor set is a single\n+ * transaction together with all its remaining ancestors).\n+ */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                Assume(!anc_feerate.IsEmpty());\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        Assume(select.IsSubsetOf(m_todo));",
      "path": "src/cluster_linearize.h",
      "position": 427,
      "original_position": 87,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "304d3cb23ba9f084b98f9f29b47e3dfbb61ca334",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "304d3cb23ba9f084b98f9f29b47e3dfbb61ca334\r\nmay be helpful context\r\n```suggestion\r\n        // Never MarkDone the same transaction more than once as this function\r\n        // blindly subtracts the transaction's feerate from m_ancestor_set_feerates\r\n        Assume(select.IsSubsetOf(m_todo));\r\n```",
      "created_at": "2024-07-08T12:33:11Z",
      "updated_at": "2024-07-08T15:34:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1668545670",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668545670"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 427,
      "original_line": 427,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668665030",
      "pull_request_review_id": 2118340933,
      "id": 1668665030,
      "node_id": "PRRC_kwDOABII585jdc7G",
      "diff_hunk": "@@ -163,6 +164,110 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone.\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called which will return a\n+ * SetInfo with the highest-feerate ancestor set that remains (an ancestor set is a single\n+ * transaction together with all its remaining ancestors).\n+ */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;",
      "path": "src/cluster_linearize.h",
      "position": 383,
      "original_position": 47,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "304d3cb23ba9f084b98f9f29b47e3dfbb61ca334",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For each of the `CandidateFinder`s, would it be helpful to expose a `AllDone()` function? Seems slightly inconvenient for the caller to separately keep track of `todo` for a `while(todo.Any())` loop. `FindCandidateSet()` Assumes that todo isn't empty, so we can't use that to query.",
      "created_at": "2024-07-08T13:44:59Z",
      "updated_at": "2024-07-08T15:34:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1668665030",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668665030"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 383,
      "original_line": 383,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668712676",
      "pull_request_review_id": 2163448624,
      "id": 1668712676,
      "node_id": "PRRC_kwDOABII585jdojk",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 75,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": 1649205112,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Actually, all this code is gone now.",
      "created_at": "2024-07-08T14:09:54Z",
      "updated_at": "2024-07-08T14:09:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1668712676",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668712676"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668716016",
      "pull_request_review_id": 2118340933,
      "id": 1668716016,
      "node_id": "PRRC_kwDOABII585jdpXw",
      "diff_hunk": "@@ -268,6 +288,155 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone().\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called to perform a search\n+ * over the set of topologically-valid subsets of that remainder, with a limit on how many\n+ * combinations are tried.\n+ */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster (which must\n+     *  be non-empty).\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept",
      "path": "src/cluster_linearize.h",
      "position": 519,
      "original_position": 90,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "5661fcdb15244bc6d602379c294276c7ec686505",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Note to reviewers: pseudocode for the function when first introduced in 5661fcdb15244bc6d602379c294276c7ec686505 can be found [here](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303#h-21-searching-6)",
      "created_at": "2024-07-08T14:11:26Z",
      "updated_at": "2024-07-08T15:34:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1668716016",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668716016"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 519,
      "original_line": 519,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668724062",
      "pull_request_review_id": 2118340933,
      "id": 1668724062,
      "node_id": "PRRC_kwDOABII585jdrVe",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions\n+                // that share ancestry with inc so far (which means only connected sets will be\n+                // considered).\n+                if (inc_none || inc.Overlaps(m_depgraph.Ancestors(pivot))) {\n+                    // Add a queue entry with pivot included.\n+                    SetInfo new_inc(m_depgraph, inc | (m_todo & m_depgraph.Ancestors(pivot)));\n+                    queue.emplace_back(new_inc.transactions, und - new_inc.transactions);\n+                    // Add a queue entry with pivot excluded.\n+                    queue.emplace_back(inc, und - m_depgraph.Descendants(pivot));\n+                    // Update statistics to account for the candidate new_inc.\n+                    if (new_inc.feerate > best.feerate) best = new_inc;\n+                    break;\n+                }\n+            }\n+        }\n+        return {std::move(best), max_iterations - iterations_left};",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 88,
      "original_position": 100,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649259334,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "And I suppose it's not problematic if it is optimal but didn't claim to be so?",
      "created_at": "2024-07-08T14:15:30Z",
      "updated_at": "2024-07-08T15:34:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1668724062",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668724062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669007098",
      "pull_request_review_id": 2163929984,
      "id": 1669007098,
      "node_id": "PRRC_kwDOABII585jewb6",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions\n+                // that share ancestry with inc so far (which means only connected sets will be\n+                // considered).\n+                if (inc_none || inc.Overlaps(m_depgraph.Ancestors(pivot))) {\n+                    // Add a queue entry with pivot included.\n+                    SetInfo new_inc(m_depgraph, inc | (m_todo & m_depgraph.Ancestors(pivot)));\n+                    queue.emplace_back(new_inc.transactions, und - new_inc.transactions);\n+                    // Add a queue entry with pivot excluded.\n+                    queue.emplace_back(inc, und - m_depgraph.Descendants(pivot));\n+                    // Update statistics to account for the candidate new_inc.\n+                    if (new_inc.feerate > best.feerate) best = new_inc;\n+                    break;\n+                }\n+            }\n+        }\n+        return {std::move(best), max_iterations - iterations_left};",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 88,
      "original_position": 100,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649259334,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm assuming that it's only used for stronger invariants checks in the fuzz/test harness",
      "created_at": "2024-07-08T17:15:03Z",
      "updated_at": "2024-07-08T17:15:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669007098",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669007098"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669189198",
      "pull_request_review_id": 2164222586,
      "id": 1669189198,
      "node_id": "PRRC_kwDOABII585jfc5O",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    /** Test whether adding a dependency between parent and child is valid and meaningful. */\n+    template<typename SetType>\n+    static bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // If child is already an ancestor of parent, the dependency would cause a cycle. Without\n+        // this condition, it would be possible for DepGraphFormatter to deserialize to a cyclic\n+        // graph.\n+        if (depgraph.Ancestors(parent)[child]) return false;\n+        // If child is already a descendant of parent, the dependency would be redundant. This is\n+        // an optimization whose goal is maximizing the probability to changes to the encoding map\n+        // to semantically distinct graphs.\n+        if (depgraph.Descendants(parent)[child]) return false;\n+        // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+        // that dependency will have been redundant if a dependency between parent and child is\n+        // added. This is also just an optimization.\n+        const auto& descendants = depgraph.Descendants(child);\n+        for (auto i : depgraph.Ancestors(parent)) {\n+            if (descendants.Overlaps(depgraph.Descendants(i))) {\n+                if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 160,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662824605,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This code is gone.",
      "created_at": "2024-07-08T19:38:30Z",
      "updated_at": "2024-07-08T19:38:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669189198",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669189198"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669280166",
      "pull_request_review_id": 2164363044,
      "id": 1669280166,
      "node_id": "PRRC_kwDOABII585jfzGm",
      "diff_hunk": "@@ -162,6 +163,100 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 88,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": 1639799588,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've changed it to \"Find the best (highest-feerate, smallest among those in case of a tie) ancestor set among the remaining transactions.\", because \"best\" is a bit more specific than highest-feerate.\r\n\r\nRegarding the side note: that rule in `BlockAssembler` is an optimization, as it avoids looking at child transactions with higher ancestor feerate, because the ancestors will have been picked earlier anyway. The same optimization could be made in `AncestorCandidateFinder`, but because it's an $\\mathcal{O}(n)$ algorithm that iterates over all transactions once anyway, there is nothing to be gained from doing so.",
      "created_at": "2024-07-08T20:40:14Z",
      "updated_at": "2024-07-08T20:40:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669280166",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669280166"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 339,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669281361",
      "pull_request_review_id": 2164364747,
      "id": 1669281361,
      "node_id": "PRRC_kwDOABII585jfzZR",
      "diff_hunk": "@@ -257,6 +277,145 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included (and its feerate). This must be a subset\n+             *  of m_todo, and be topologically valid (includes all in-m_todo ancestors of\n+             *  itself). */\n+            SetInfo<SetType> inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            SetType und;\n+\n+            /** Construct a new work item. */\n+            WorkItem(SetInfo<SetType>&& i, SetType&& u) noexcept :\n+                inc(std::move(i)), und(std::move(u)) {}\n+        };\n+\n+        /** The queue of work items. */\n+        std::vector<WorkItem> queue;\n+\n+        // Create an initial entry with m_todo as undecided. Also use it as best if not provided,\n+        // so that during the work processing loop below, and during the add_fn/split_fn calls, we\n+        // do not need to deal with the best=empty case.\n+        if (best.feerate.IsEmpty()) best = SetInfo(m_depgraph, m_todo);\n+        queue.emplace_back(SetInfo<SetType>{}, SetType{m_todo});\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iterations_left = max_iterations;\n+\n+        /** Internal function to add a work item.\n+         *\n+         * - inc: the \"inc\" value for the new work item",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 116,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": 1644451932,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added a comment that inc needs to be topological (a term which is defined in the `WorkItem` definition above).",
      "created_at": "2024-07-08T20:41:01Z",
      "updated_at": "2024-07-08T20:41:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669281361",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669281361"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669281468",
      "pull_request_review_id": 2164364940,
      "id": 1669281468,
      "node_id": "PRRC_kwDOABII585jfza8",
      "diff_hunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/cluster_linearize.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    Cluster<TestBitSet> cluster(num_tx, std::pair{FeeFrac{0, 1}, TestBitSet{}});\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and depgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, TestBitSet::Size() * TestBitSet::Size()) {\n+        auto parent = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 1);\n+        auto child = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 2);\n+        child += (child >= parent);\n+        cluster[child].second.Set(parent);\n+        depgraph.AddDependency(parent, child);\n+        assert(depgraph.Ancestors(child)[parent]);\n+        assert(depgraph.Descendants(parent)[child]);\n+    }\n+    // Sanity check the result.\n+    SanityCheck(depgraph);\n+    // Verify that the resulting DepGraph matches one recomputed from the cluster.\n+    assert(DepGraph(cluster) == depgraph);\n+}\n+\n+FUZZ_TARGET(clusterlin_cluster_serialization)\n+{\n+    // Verify that any graph of transaction has its ancestry correctly computed by DepGraph, and if",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 48,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "4b1e978b2bafd9da564aa52d2ce64a723cf64036",
      "in_reply_to_id": 1668526162,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-08T20:41:06Z",
      "updated_at": "2024-07-08T20:41:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669281468",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669281468"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669282068",
      "pull_request_review_id": 2164365793,
      "id": 1669282068,
      "node_id": "PRRC_kwDOABII585jfzkU",
      "diff_hunk": "@@ -163,6 +164,110 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone.\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called which will return a\n+ * SetInfo with the highest-feerate ancestor set that remains (an ancestor set is a single\n+ * transaction together with all its remaining ancestors).\n+ */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                Assume(!anc_feerate.IsEmpty());\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        Assume(select.IsSubsetOf(m_todo));",
      "path": "src/cluster_linearize.h",
      "position": 427,
      "original_position": 87,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "304d3cb23ba9f084b98f9f29b47e3dfbb61ca334",
      "in_reply_to_id": 1668545670,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added a short comment to the docstring of the function instead.",
      "created_at": "2024-07-08T20:41:30Z",
      "updated_at": "2024-07-08T20:41:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669282068",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669282068"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 427,
      "original_line": 427,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669283836",
      "pull_request_review_id": 2164368522,
      "id": 1669283836,
      "node_id": "PRRC_kwDOABII585jfz_8",
      "diff_hunk": "@@ -163,6 +164,110 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone.\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called which will return a\n+ * SetInfo with the highest-feerate ancestor set that remains (an ancestor set is a single\n+ * transaction together with all its remaining ancestors).\n+ */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;",
      "path": "src/cluster_linearize.h",
      "position": 383,
      "original_position": 47,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "304d3cb23ba9f084b98f9f29b47e3dfbb61ca334",
      "in_reply_to_id": 1668665030,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, good idea. Avoiding a separate copy `m_todo` in `Linearize` forced me to rewrite some of the code, which turned out to simplify the LIMO logic slightly.",
      "created_at": "2024-07-08T20:42:44Z",
      "updated_at": "2024-07-08T20:42:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669283836",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669283836"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 383,
      "original_line": 383,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669288946",
      "pull_request_review_id": 2164376301,
      "id": 1669288946,
      "node_id": "PRRC_kwDOABII585jf1Py",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions\n+                // that share ancestry with inc so far (which means only connected sets will be\n+                // considered).\n+                if (inc_none || inc.Overlaps(m_depgraph.Ancestors(pivot))) {\n+                    // Add a queue entry with pivot included.\n+                    SetInfo new_inc(m_depgraph, inc | (m_todo & m_depgraph.Ancestors(pivot)));\n+                    queue.emplace_back(new_inc.transactions, und - new_inc.transactions);\n+                    // Add a queue entry with pivot excluded.\n+                    queue.emplace_back(inc, und - m_depgraph.Descendants(pivot));\n+                    // Update statistics to account for the candidate new_inc.\n+                    if (new_inc.feerate > best.feerate) best = new_inc;\n+                    break;\n+                }\n+            }\n+        }\n+        return {std::move(best), max_iterations - iterations_left};",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 88,
      "original_position": 100,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649259334,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@glozow Indeed. Even if this function was changed to return an explicit `optimal`, it would remain quite possible that it returns the optimal without *knowing* it's optimal (because it's possible that the `best` passed in for example was already optimal, but it requires a ton of iterations to exhaust the search space to prove nothing better exists).\r\n\r\n@instagibbs Well I think we may want to cache in the mempool clusters whether or not the linearization for them is known to be optimal too, so that a hypothetical background cluster-improver thread could know to skip it.",
      "created_at": "2024-07-08T20:46:19Z",
      "updated_at": "2024-07-08T20:46:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669288946",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669288946"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1671088434",
      "pull_request_review_id": 2167121806,
      "id": 1671088434,
      "node_id": "PRRC_kwDOABII585jmsky",
      "diff_hunk": "@@ -452,6 +468,54 @@ class SearchCandidateFinder\n     }\n };\n \n+/** Find a linearization for a cluster.\n+ *\n+ * @param[in] depgraph        Dependency graph of the the cluster to be linearized.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 29,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "4e6e416fedd1b8eaadfc8e9fa02b99b22f8d8a11",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: s/the the/the/",
      "created_at": "2024-07-09T19:42:04Z",
      "updated_at": "2024-07-24T17:20:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1671088434",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1671088434"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 473,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1671191613",
      "pull_request_review_id": 2167425998,
      "id": 1671191613,
      "node_id": "PRRC_kwDOABII585jnFw9",
      "diff_hunk": "@@ -527,6 +563,24 @@ std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>\n \n         if (iterations_done_now == max_iterations_now) {\n             optimal = false;\n+            // If the search result is not (guaranteed to be) optimal, run intersections to make\n+            // sure we don't pick something that makes us unable to reach further diagram points\n+            // of the old linearization.\n+            if (best.transactions != best_prefix.transactions) {",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 95,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": 1652960236,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032",
      "created_at": "2024-07-09T20:20:05Z",
      "updated_at": "2024-07-09T20:20:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1671191613",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1671191613"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 687,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1671201334",
      "pull_request_review_id": 2167121806,
      "id": 1671201334,
      "node_id": "PRRC_kwDOABII585jnII2",
      "diff_hunk": "@@ -519,34 +529,64 @@ class SearchCandidateFinder\n     }\n };\n \n-/** Find a linearization for a cluster.\n+/** Find or improve a linearization for a cluster.\n  *\n- * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n- * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n- * @param[in] rng_seed        A random number seed to control search order. This prevents peers\n- *                            from predicting exactly which clusters would be hard for us to\n- *                            linearize.\n- * @return                    A pair of:\n- *                            - The resulting linearization.\n- *                            - A boolean indicating whether the result is guaranteed to be\n- *                              optimal.\n+ * @param[in] depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in] max_iterations     Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed           A random number seed to control search order. This prevents peers\n+ *                               from predicting exactly which clusters would be hard for us to\n+ *                               linearize.\n+ * @param[in] old_linearization  An existing linearization for the cluster, or empty.\n+ * @return                       A pair of:\n+ *                               - The resulting linearization. It is guaranteed to be at least as\n+ *                                 good (in the feerate diagram sense) as old_linearization.\n+ *                               - A boolean indicating whether the result is guaranteed to be\n+ *                                 optimal.\n  *\n  * Complexity: O(N * min(max_iterations + N, 2^N)) where N=depgraph.TxCount().\n  */\n template<typename SetType>\n-std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed) noexcept\n+std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed, Span<const ClusterIndex> old_linearization = {}) noexcept",
      "path": "src/cluster_linearize.h",
      "position": 684,
      "original_position": 53,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "750d52fa8df08b7dc13720d4d2ccbe0cf9e0f800",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Perhaps worth documenting that if an existing linearization is passed in, it must be topologically valid, or else the output of `Linearize` may not be topologically valid.",
      "created_at": "2024-07-09T20:29:27Z",
      "updated_at": "2024-07-24T17:20:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1671201334",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1671201334"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 684,
      "original_line": 684,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1672749601",
      "pull_request_review_id": 2169903436,
      "id": 1672749601,
      "node_id": "PRRC_kwDOABII585jtCIh",
      "diff_hunk": "@@ -0,0 +1,644 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/cluster_linearize.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+\n+/** A simple finder class for candidate sets.\n+ *\n+ * This class matches SearchCandidateFinder in interface and behavior, though with fewer\n+ * optimizations.\n+ */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Determine whether unlinearized transactions remain. */\n+    bool AllDone() const noexcept { return m_todo.None(); }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto split : und) {\n+                // If inc is empty, consider any split transaction. Otherwise only consider\n+                // transactions that share ancestry with inc so far (which means only connected\n+                // sets will be considered).\n+                if (inc_none || inc.Overlaps(m_depgraph.Ancestors(split))) {\n+                    // Add a queue entry with split included.\n+                    SetInfo new_inc(m_depgraph, inc | (m_todo & m_depgraph.Ancestors(split)));\n+                    queue.emplace_back(new_inc.transactions, und - new_inc.transactions);\n+                    // Add a queue entry with split excluded.\n+                    queue.emplace_back(inc, und - m_depgraph.Descendants(split));\n+                    // Update statistics to account for the candidate new_inc.\n+                    if (new_inc.feerate > best.feerate) best = new_inc;\n+                    break;\n+                }\n+            }\n+        }\n+        return {std::move(best), max_iterations - iterations_left};\n+    }\n+};\n+\n+/** A very simple finder class for optimal candidate sets, which tries every subset.\n+ *\n+ * It is even simpler than SimpleCandidateFinder, and is primarily included here to test the\n+ * correctness of SimpleCandidateFinder, which is then used to test the correctness of\n+ * SearchCandidateFinder.\n+ */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an ExhaustiveCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Determine whether unlinearized transactions remain. */\n+    bool AllDone() const noexcept { return m_todo.None(); }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple linearization algorithm.\n+ *\n+ * This matches Linearize() in interface and behavior, though with fewer optimizations, lacking\n+ * the ability to pass in an existing linearization, and using just SimpleCandidateFinder rather\n+ * than AncestorCandidateFinder and SearchCandidateFinder.\n+ */\n+template<typename SetType>\n+std::pair<std::vector<ClusterIndex>, bool> SimpleLinearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations)\n+{\n+    std::vector<ClusterIndex> linearization;\n+    SimpleCandidateFinder finder(depgraph);\n+    SetType todo = SetType::Fill(depgraph.TxCount());\n+    bool optimal = true;\n+    while (todo.Any()) {\n+        auto [candidate, iterations_done] = finder.FindCandidateSet(max_iterations);\n+        if (iterations_done == max_iterations) optimal = false;\n+        depgraph.AppendTopo(linearization, candidate.transactions);\n+        todo -= candidate.transactions;\n+        finder.MarkDone(candidate.transactions);\n+        max_iterations -= iterations_done;\n+    }\n+    return {std::move(linearization), optimal};\n+}\n+\n+/** Stitch connected components together in a DepGraph, guaranteeing its corresponding cluster is connected. */\n+template<typename BS>\n+void MakeConnected(DepGraph<BS>& depgraph)\n+{\n+    auto todo = BS::Fill(depgraph.TxCount());\n+    auto comp = depgraph.FindConnectedComponent(todo);\n+    Assume(depgraph.IsConnected(comp));\n+    todo -= comp;\n+    while (todo.Any()) {\n+        auto nextcomp = depgraph.FindConnectedComponent(todo);\n+        Assume(depgraph.IsConnected(nextcomp));\n+        depgraph.AddDependency(comp.Last(), nextcomp.First());\n+        todo -= nextcomp;\n+        comp = nextcomp;\n+    }\n+}\n+\n+/** Given a dependency graph, and a todo set, read a topological subset of todo from reader. */\n+template<typename SetType>\n+SetType ReadTopologicalSet(const DepGraph<SetType>& depgraph, const SetType& todo, SpanReader& reader)\n+{\n+    uint64_t mask{0};\n+    try {\n+        reader >> VARINT(mask);\n+    } catch(const std::ios_base::failure&) {}\n+    SetType ret;\n+    for (auto i : todo) {\n+        if (!ret[i]) {\n+            if (mask & 1) ret |= depgraph.Ancestors(i);\n+            mask >>= 1;\n+        }\n+    }\n+    return ret & todo;\n+}\n+\n+/** Given a dependency graph, construct any valid linearization for it, reading from a SpanReader. */\n+template<typename BS>\n+std::vector<ClusterIndex> ReadLinearization(const DepGraph<BS>& depgraph, SpanReader& reader)\n+{\n+    std::vector<ClusterIndex> linearization;\n+    TestBitSet todo = TestBitSet::Fill(depgraph.TxCount());\n+    // In every iteration one topologically-valid transaction is appended to linearization.\n+    while (todo.Any()) {\n+        // Compute the set of transactions with no not-yet-included ancestors.\n+        TestBitSet potential_next;\n+        for (auto j : todo) {\n+            if ((depgraph.Ancestors(j) & todo) == TestBitSet::Singleton(j)) {\n+                potential_next.Set(j);\n+            }\n+        }\n+        // There must always be one (otherwise there is a cycle in the graph).\n+        assert(potential_next.Any());\n+        // Read a number from reader, and interpret it as index into potential_next.\n+        uint64_t idx{0};\n+        try {\n+            reader >> VARINT(idx);\n+        } catch (const std::ios_base::failure&) {}\n+        idx %= potential_next.Count();\n+        // Find out which transaction that corresponds to.\n+        for (auto j : potential_next) {\n+            if (idx-- == 0) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 223,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "41e31ce727ebb80c083255f53e109fc413e2d39f",
      "in_reply_to_id": null,
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```\r\nRun clusterlin_chunking with args ['/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz', '-max_total_time=60']INFO: Running with entropic power schedule (0xFF, 100).\r\nINFO: Seed: 2800051321\r\nINFO: Loaded 1 modules   (625955 inline 8-bit counters): 625955 [0x556ead4c6938, 0x556ead55f65b), \r\nINFO: Loaded 1 PC tables (625955 PCs): 625955 [0x556ead55f660,0x556eadeec890), \r\nINFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes\r\nINFO: A corpus is not provided, starting from an empty corpus\r\n#2\tINITED cov: 101 ft: 102 corp: 1/1b exec/s: 0 rss: 112Mb\r\n\tNEW_FUNC[1/5]: 0x556eaa4369e0 in cluster_linearize::DepGraph<bitset_detail::IntBitSet<unsigned int>>::AddTransaction(FeeFrac const&) src/./cluster_linearize.h:134\r\n\tNEW_FUNC[2/5]: 0x556eaa437100 in cluster_linearize::DepGraph<bitset_detail::IntBitSet<unsigned int>>::Entry& std::vector<cluster_linearize::DepGraph<bitset_detail::IntBitSet<unsigned int>>::Entry, std::allocator<cluster_linearize::DepGraph<bitset_detail::IntBitSet<unsigned int>>::Entry>>::emplace_back<FeeFrac const&, bitset_detail::IntBitSet<unsigned int>, bitset_detail::IntBitSet<unsigned int>>(FeeFrac const&, bitset_detail::IntBitSet<unsigned int>&&, bitset_detail::IntBitSet<unsigned int>&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/vector.tcc:113\r\n#7\tNEW    cov: 130 ft: 137 corp: 2/3b lim: 4 exec/s: 0 rss: 112Mb L: 2/2 MS: 5 ChangeByte-CopyPart-ChangeBinInt-CrossOver-InsertByte-\r\n#8\tNEW    cov: 131 ft: 138 corp: 3/5b lim: 4 exec/s: 0 rss: 112Mb L: 2/2 MS: 1 InsertByte-\r\n#9\tNEW    cov: 132 ft: 139 corp: 4/7b lim: 4 exec/s: 0 rss: 112Mb L: 2/2 MS: 1 ChangeASCIIInt-\r\n#22\tNEW    cov: 132 ft: 143 corp: 5/10b lim: 4 exec/s: 0 rss: 112Mb L: 3/3 MS: 3 ChangeByte-ShuffleBytes-InsertByte-\r\n\tNEW_FUNC[1/3]: 0x556eaa1fb770 in void std::vector<unsigned int, std::allocator<unsigned int>>::_M_realloc_insert<unsigned int const&>(__gnu_cxx::__normal_iterator<unsigned int*, std::vector<unsigned int, std::allocator<unsigned int>>>, unsigned int const&) /usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/vector.tcc:453\r\n\tNEW_FUNC[2/3]: 0x556eaa1fbed0 in std::vector<unsigned int, std::allocator<unsigned int>>::_M_check_len(unsigned long, char const*) const /usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h:1897\r\n#27\tNEW    cov: 161 ft: 174 corp: 6/13b lim: 4 exec/s: 0 rss: 112Mb L: 3/3 MS: 5 ChangeBit-ChangeByte-CopyPart-CopyPart-ChangeByte-\r\n#36\tNEW    cov: 162 ft: 175 corp: 7/15b lim: 4 exec/s: 0 rss: 112Mb L: 2/3 MS: 4 ChangeBit-CrossOver-ChangeBit-ChangeBinInt-\r\n#44\tNEW    cov: 162 ft: 179 corp: 8/19b lim: 4 exec/s: 0 rss: 112Mb L: 4/4 MS: 3 ChangeBit-ChangeBit-CopyPart-\r\n#49\tNEW    cov: 162 ft: 180 corp: 9/23b lim: 4 exec/s: 0 rss: 112Mb L: 4/4 MS: 5 ShuffleBytes-CrossOver-ShuffleBytes-ChangeByte-ShuffleBytes-\r\n#52\tNEW    cov: 162 ft: 182 corp: 10/27b lim: 4 exec/s: 0 rss: 112Mb L: 4/4 MS: 3 InsertByte-CrossOver-CrossOver-\r\n#55\tNEW    cov: 173 ft: 196 corp: 11/31b lim: 4 exec/s: 0 rss: 112Mb L: 4/4 MS: 3 ChangeByte-CrossOver-CMP- DE: \"\\000\\000\\000\\000\"-\r\ntest/fuzz/cluster_linearize.cpp:223:20: runtime error: unsigned integer overflow: 0 - 1 cannot be represented in type 'uint64_t' (aka 'unsigned long')\r\n    #0 0x556eaa4203ed in std::vector<unsigned int, std::allocator<unsigned int>> (anonymous namespace)::ReadLinearization<bitset_detail::IntBitSet<unsigned int>>(cluster_linearize::DepGraph<bitset_detail::IntBitSet<unsigned int>> const&, SpanReader&) src/test/fuzz/cluster_linearize.cpp:223:20\r\n    #1 0x556eaa41e849 in clusterlin_chunking_fuzz_target(std::span<unsigned char const, 18446744073709551615ul>) src/test/fuzz/cluster_linearize.cpp:356:26\r\n    #2 0x556eaa96888d in std::function<void (std::span<unsigned char const, 18446744073709551615ul>)>::operator()(std::span<unsigned char const, 18446744073709551615ul>) const /usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h:591:9\r\n    #3 0x556eaa96888d in LLVMFuzzerTestOneInput src/test/fuzz/fuzz.cpp:209:5\r\n    #4 0x556eaa033534 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) (/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz+0x1c02534) (BuildId: 4f2fa2987d9f90b866b2491be1f80d23e1cce505)\r\n    #5 0x556eaa032c29 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) (/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz+0x1c01c29) (BuildId: 4f2fa2987d9f90b866b2491be1f80d23e1cce505)\r\n    #6 0x556eaa034415 in fuzzer::Fuzzer::MutateAndTestOne() (/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz+0x1c03415) (BuildId: 4f2fa2987d9f90b866b2491be1f80d23e1cce505)\r\n    #7 0x556eaa034f75 in fuzzer::Fuzzer::Loop(std::vector<fuzzer::SizedFile, std::allocator<fuzzer::SizedFile>>&) (/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz+0x1c03f75) (BuildId: 4f2fa2987d9f90b866b2491be1f80d23e1cce505)\r\n    #8 0x556eaa02224f in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz+0x1bf124f) (BuildId: 4f2fa2987d9f90b866b2491be1f80d23e1cce505)\r\n    #9 0x556eaa04c8d6 in main (/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz+0x1c1b8d6) (BuildId: 4f2fa2987d9f90b866b2491be1f80d23e1cce505)\r\n    #10 0x7fae2899a1c9  (/lib/x86_64-linux-gnu/libc.so.6+0x2a1c9) (BuildId: 08134323d00289185684a4cd177d202f39c2a5f3)\r\n    #11 0x7fae2899a28a in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2a28a) (BuildId: 08134323d00289185684a4cd177d202f39c2a5f3)\r\n    #12 0x556eaa017234 in _start (/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz+0x1be6234) (BuildId: 4f2fa2987d9f90b866b2491be1f80d23e1cce505)\r\n\r\nSUMMARY: UndefinedBehaviorSanitizer: unsigned-integer-overflow test/fuzz/cluster_linearize.cpp:223:20 \r\nMS: 4 ChangeByte-EraseBytes-CMP-CopyPart- DE: \"\\003\\000\"-; base unit: e5dc0d414ce7dc334d19fc3ca66d8e4d4272b8cd\r\n0x1,0x3,0x0,0x0,\r\n\\001\\003\\000\\000\r\nartifact_prefix='./'; Test unit written to ./crash-275df7aaf0e8504be8fb5e3fbcd9b1be65e65326\r\nBase64: AQMAAA==",
      "created_at": "2024-07-10T18:12:30Z",
      "updated_at": "2024-07-10T18:12:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1672749601",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1672749601"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1676094213",
      "pull_request_review_id": 2167121806,
      "id": 1676094213,
      "node_id": "PRRC_kwDOABII585j5ysF",
      "diff_hunk": "@@ -0,0 +1,145 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <test/util/cluster_linearize.h>\n+#include <test/util/setup_common.h>\n+#include <util/bitset.h>\n+#include <util/strencodings.h>\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(cluster_linearize_tests, BasicTestingSetup)\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+template<typename SetType>\n+void TestDepGraphSerialization(const Cluster<SetType>& cluster, const std::string& hexenc)\n+{\n+    DepGraph depgraph(cluster);\n+\n+    // Test that depgraph has all the fees/sizes/parents required by cluster.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        BOOST_CHECK(depgraph.FeeRate(i) == cluster[i].first);\n+        for (ClusterIndex par : cluster[i].second) {\n+            BOOST_CHECK(depgraph.Ancestors(i)[par]);\n+            BOOST_CHECK(depgraph.Descendants(par)[i]);\n+        }\n+    }\n+\n+    // Run normal sanity checks on depgraph.\n+    SanityCheck(depgraph);\n+\n+    // Test that the serialization of depgraph matches hexenc.\n+    std::vector<unsigned char> encoding;\n+    VectorWriter writer(encoding, 0);\n+    writer << Using<DepGraphFormatter>(depgraph);\n+    BOOST_CHECK_EQUAL(HexStr(encoding), hexenc);",
      "path": "src/test/cluster_linearize_tests.cpp",
      "position": 34,
      "original_position": 42,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Given that there's more than one valid serialization that will deserialize to the same graph, perhaps it's worth commenting something to that effect here?  (I guess we could also consider dropping this check and instead just checking that if we deserialize `hexenc` we get the same depgraph, but perhaps it's beneficial to check that what we think of as a canonical encoding is correct?)",
      "created_at": "2024-07-12T15:20:06Z",
      "updated_at": "2024-07-24T17:20:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1676094213",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1676094213"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 34,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1677594301",
      "pull_request_review_id": 2177326357,
      "id": 1677594301,
      "node_id": "PRRC_kwDOABII585j_g69",
      "diff_hunk": "@@ -0,0 +1,168 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 42,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "503af62cbab48733eea0aca8473239e1ad5f6403",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: I think this is obvious\r\n```suggestion\r\n```",
      "created_at": "2024-07-15T10:07:54Z",
      "updated_at": "2024-07-15T11:05:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1677594301",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1677594301"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1677606491",
      "pull_request_review_id": 2177326357,
      "id": 1677606491,
      "node_id": "PRRC_kwDOABII585j_j5b",
      "diff_hunk": "@@ -0,0 +1,168 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in the same order as the Cluster it was constructed from. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator (primarily for testing purposes). */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 91,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "503af62cbab48733eea0aca8473239e1ad5f6403",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: be explicit we are adding direct parents\r\n```suggestion\r\n        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\r\n            // Fill in fee, size\r\n            entries[i].feerate = cluster[i].first;\r\n            // Fill in direct parents as ancestors\r\n            entries[i].ancestors = cluster[i].second;\r\n            // Make sure transactions are ancestors of themselves.\r\n            entries[i].ancestors.Set(i);\r\n        }\r\n```",
      "created_at": "2024-07-15T10:19:13Z",
      "updated_at": "2024-07-15T11:05:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1677606491",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1677606491"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": 85,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1677650738",
      "pull_request_review_id": 2177326357,
      "id": 1677650738,
      "node_id": "PRRC_kwDOABII585j_usy",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, SetType::Singleton(new_idx), SetType::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.",
      "path": "src/cluster_linearize.h",
      "position": 151,
      "original_position": 141,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "06c600099abe129a5bb5c6a5a533018f03e51304",
      "in_reply_to_id": 1638465834,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "maybe just return early in that case and avoid the looping?",
      "created_at": "2024-07-15T11:01:51Z",
      "updated_at": "2024-07-15T11:05:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1677650738",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1677650738"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1677652342",
      "pull_request_review_id": 2177326357,
      "id": 1677652342,
      "node_id": "PRRC_kwDOABII585j_vF2",
      "diff_hunk": "@@ -0,0 +1,168 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in the same order as the Cluster it was constructed from. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator (primarily for testing purposes). */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: O(1) (amortized, due to resizing of backing vector).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        Assume(TxCount() < SetType::Size());\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, SetType::Singleton(new_idx), SetType::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.",
      "path": "src/cluster_linearize.h",
      "position": 151,
      "original_position": 142,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "503af62cbab48733eea0aca8473239e1ad5f6403",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should we return early if dependency already exist ?",
      "created_at": "2024-07-15T11:03:23Z",
      "updated_at": "2024-07-15T11:05:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1677652342",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1677652342"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678216187",
      "pull_request_review_id": 2178360431,
      "id": 1678216187,
      "node_id": "PRRC_kwDOABII585kB4v7",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * their correct position on deserialization.\n+ *\n+ * - For each transaction t in the DepGraph (in some topological order);\n+ *   - The size: VARINT(t.size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(t.fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for every parent p of t, in order of most recently serialized to least\n+ *     recently serialized:\n+ *     - VARINT(diff), where diff is the number of transactions between p and the previous parent\n+ *       (excluding transactions which are already known to be ancestors of t) which were not\n+ *       parents of t.\n+ *   - The position: VARINT(diff), where diff is the sum of the number of skipped transactions\n+ *     after the last parent, and the distance from the end of the transaction list where to insert\n+ *     t (distance=0 means at the very end, distance=1 means 1 before the end, etc). On\n+ *     deserialization, overflow here is interpreted as wrapping around.\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents emitted in reverse order compared to the transactions themselves? This\n+ *   naturally lets us skip parents-of-parents.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 1 bytes per transaction for dependencies in this case,\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** Construct a topological order to serialize the transactions in. */\n+        std::vector<ClusterIndex> topo_order(depgraph.TxCount());\n+        std::iota(topo_order.begin(), topo_order.end(), ClusterIndex{0});\n+        std::sort(topo_order.begin(), topo_order.end(), [&](ClusterIndex a, ClusterIndex b) {\n+            auto anc_a = depgraph.Ancestors(a).Count(), anc_b = depgraph.Ancestors(b).Count();\n+            if (anc_a != anc_b) return anc_a < anc_b;\n+            return a < b;\n+        });\n+\n+        /** Which transactions the deserializer already knows when it has deserialized what has\n+         *  has been serialized here so far, and in what order. */",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 107,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n         * been serialized here so far, and in what order. */\r\n```",
      "created_at": "2024-07-15T18:10:31Z",
      "updated_at": "2024-07-16T19:36:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1678216187",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678216187"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678263149",
      "pull_request_review_id": 2178360431,
      "id": 1678263149,
      "node_id": "PRRC_kwDOABII585kCENt",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * their correct position on deserialization.\n+ *\n+ * - For each transaction t in the DepGraph (in some topological order);\n+ *   - The size: VARINT(t.size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(t.fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for every parent p of t, in order of most recently serialized to least\n+ *     recently serialized:\n+ *     - VARINT(diff), where diff is the number of transactions between p and the previous parent\n+ *       (excluding transactions which are already known to be ancestors of t) which were not\n+ *       parents of t.\n+ *   - The position: VARINT(diff), where diff is the sum of the number of skipped transactions\n+ *     after the last parent, and the distance from the end of the transaction list where to insert\n+ *     t (distance=0 means at the very end, distance=1 means 1 before the end, etc). On\n+ *     deserialization, overflow here is interpreted as wrapping around.\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents emitted in reverse order compared to the transactions themselves? This\n+ *   naturally lets us skip parents-of-parents.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 1 bytes per transaction for dependencies in this case,\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** Construct a topological order to serialize the transactions in. */\n+        std::vector<ClusterIndex> topo_order(depgraph.TxCount());\n+        std::iota(topo_order.begin(), topo_order.end(), ClusterIndex{0});\n+        std::sort(topo_order.begin(), topo_order.end(), [&](ClusterIndex a, ClusterIndex b) {\n+            auto anc_a = depgraph.Ancestors(a).Count(), anc_b = depgraph.Ancestors(b).Count();\n+            if (anc_a != anc_b) return anc_a < anc_b;\n+            return a < b;\n+        });\n+\n+        /** Which transactions the deserializer already knows when it has deserialized what has\n+         *  has been serialized here so far, and in what order. */\n+        std::vector<ClusterIndex> rebuilt_order;\n+        rebuilt_order.reserve(depgraph.TxCount());\n+\n+        // Loop over the transactions in topological order.\n+        for (ClusterIndex topo_idx = 0; topo_idx < topo_order.size(); ++topo_idx) {\n+            /** Which depgraph index we are currently writing. */\n+            ClusterIndex idx = topo_order[topo_idx];\n+            // Write size, which must be larger than 0.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee, encoded as an unsigned varint (odd=negative, even=non-negative).\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            SetType written_parents;\n+            uint64_t diff = 0; //!< How many potential parent/child relations we have skipped over.\n+            for (ClusterIndex dep_dist = 0; dep_dist < topo_idx; ++dep_dist) {\n+                /** Which depgraph index we are currently considering as parent of idx. */\n+                ClusterIndex dep_idx = topo_order[topo_idx - 1 - dep_dist];\n+                // Ignore transactions which are already known to be ancestors.\n+                if (depgraph.Descendants(dep_idx).Overlaps(written_parents)) continue;\n+                if (depgraph.Ancestors(idx)[dep_idx]) {\n+                    // When an actual parent is encounted, encode how many non-parents were skipped\n+                    // before it.\n+                    s << VARINT(diff);\n+                    diff = 0;\n+                    written_parents.Set(dep_idx);\n+                } else {\n+                    // When a non-parent is encountered, increment the skip counter.\n+                    ++diff;\n+                }\n+            }\n+            // Write position information.\n+            ClusterIndex insert_distance = 0;\n+            while (insert_distance < rebuilt_order.size()) {\n+                // Loop to find how far from the end in rebuilt_order to insert.\n+                if (idx > *(rebuilt_order.end() - 1 - insert_distance)) break;\n+                ++insert_distance;\n+            }\n+            rebuilt_order.insert(rebuilt_order.end() - insert_distance, idx);\n+            s << VARINT(diff + insert_distance);",
      "path": "src/test/util/cluster_linearize.h",
      "position": 176,
      "original_position": 146,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is the remaining part of logic that is hard to intuit now that the rest is a lot simpler to follow. I believe it's correct due to the harness itself but...",
      "created_at": "2024-07-15T18:54:37Z",
      "updated_at": "2024-07-16T19:36:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1678263149",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678263149"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 176,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678277812",
      "pull_request_review_id": 2178360431,
      "id": 1678277812,
      "node_id": "PRRC_kwDOABII585kCHy0",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * their correct position on deserialization.\n+ *\n+ * - For each transaction t in the DepGraph (in some topological order);\n+ *   - The size: VARINT(t.size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(t.fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for every parent p of t, in order of most recently serialized to least\n+ *     recently serialized:\n+ *     - VARINT(diff), where diff is the number of transactions between p and the previous parent\n+ *       (excluding transactions which are already known to be ancestors of t) which were not\n+ *       parents of t.\n+ *   - The position: VARINT(diff), where diff is the sum of the number of skipped transactions\n+ *     after the last parent, and the distance from the end of the transaction list where to insert\n+ *     t (distance=0 means at the very end, distance=1 means 1 before the end, etc). On\n+ *     deserialization, overflow here is interpreted as wrapping around.\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents emitted in reverse order compared to the transactions themselves? This\n+ *   naturally lets us skip parents-of-parents.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 1 bytes per transaction for dependencies in this case,\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** Construct a topological order to serialize the transactions in. */\n+        std::vector<ClusterIndex> topo_order(depgraph.TxCount());\n+        std::iota(topo_order.begin(), topo_order.end(), ClusterIndex{0});\n+        std::sort(topo_order.begin(), topo_order.end(), [&](ClusterIndex a, ClusterIndex b) {\n+            auto anc_a = depgraph.Ancestors(a).Count(), anc_b = depgraph.Ancestors(b).Count();\n+            if (anc_a != anc_b) return anc_a < anc_b;\n+            return a < b;\n+        });\n+\n+        /** Which transactions the deserializer already knows when it has deserialized what has\n+         *  has been serialized here so far, and in what order. */\n+        std::vector<ClusterIndex> rebuilt_order;\n+        rebuilt_order.reserve(depgraph.TxCount());\n+\n+        // Loop over the transactions in topological order.\n+        for (ClusterIndex topo_idx = 0; topo_idx < topo_order.size(); ++topo_idx) {\n+            /** Which depgraph index we are currently writing. */\n+            ClusterIndex idx = topo_order[topo_idx];\n+            // Write size, which must be larger than 0.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee, encoded as an unsigned varint (odd=negative, even=non-negative).\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            SetType written_parents;\n+            uint64_t diff = 0; //!< How many potential parent/child relations we have skipped over.\n+            for (ClusterIndex dep_dist = 0; dep_dist < topo_idx; ++dep_dist) {\n+                /** Which depgraph index we are currently considering as parent of idx. */\n+                ClusterIndex dep_idx = topo_order[topo_idx - 1 - dep_dist];\n+                // Ignore transactions which are already known to be ancestors.\n+                if (depgraph.Descendants(dep_idx).Overlaps(written_parents)) continue;\n+                if (depgraph.Ancestors(idx)[dep_idx]) {\n+                    // When an actual parent is encounted, encode how many non-parents were skipped\n+                    // before it.\n+                    s << VARINT(diff);\n+                    diff = 0;\n+                    written_parents.Set(dep_idx);\n+                } else {\n+                    // When a non-parent is encountered, increment the skip counter.\n+                    ++diff;\n+                }\n+            }\n+            // Write position information.\n+            ClusterIndex insert_distance = 0;\n+            while (insert_distance < rebuilt_order.size()) {\n+                // Loop to find how far from the end in rebuilt_order to insert.\n+                if (idx > *(rebuilt_order.end() - 1 - insert_distance)) break;\n+                ++insert_distance;\n+            }\n+            rebuilt_order.insert(rebuilt_order.end() - insert_distance, idx);\n+            s << VARINT(diff + insert_distance);\n+        }\n+\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        /** The dependency graph which we deserialize into first, with transactions in\n+         *  topological serialization order, not original cluster order. */\n+        DepGraph<SetType> topo_depgraph;\n+        /** Mapping from cluster order to serialization order, used later to reconstruct the\n+         *  cluster order. */\n+        std::vector<ClusterIndex> reordering;\n+\n+        // Read transactions in topological order.\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            static_assert(0x3FFFFF >= 4000000);\n+            if (size == 0 || topo_depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as an unsigned varint (odd=negative, even=non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            static_assert(0xFFFFFFFFFFFFF > uint64_t{2} * 21000000 * 100000000);\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend topo_depgraph with the new transaction (at the end).\n+            auto topo_idx = topo_depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t diff = 0; //!< How many potential parents we have to skip.\n+            s >> VARINT(diff);\n+            for (ClusterIndex dep_dist = 0; dep_dist < topo_idx; ++dep_dist) {\n+                /** Which topo_depgraph index we are currently considering as parent of topo_idx. */\n+                ClusterIndex dep_topo_idx = topo_idx - 1 - dep_dist;\n+                // Ignore transactions which are already known ancestors of topo_idx.\n+                if (topo_depgraph.Descendants(dep_topo_idx)[topo_idx]) continue;\n+                if (diff == 0) {\n+                    // When the skip counter has reached 0, add an actual dependency.\n+                    topo_depgraph.AddDependency(dep_topo_idx, topo_idx);\n+                    // And read the number of skips after it.\n+                    s >> VARINT(diff);\n+                } else {\n+                    // Otherwise, dep_topo_idx is not a parent. Decrement and continue.\n+                    --diff;\n+                }\n+            }\n+            // Read position information, interpreting the remaining skip value as wrapping around.\n+            reordering.insert(reordering.end() - (diff % (reordering.size() + 1)), topo_idx);\n+        }\n+\n+        // Construct the original cluster order depgraph.\n+        depgraph = {};\n+        for (ClusterIndex idx = 0; idx < reordering.size(); ++idx) {\n+            // Add transactions to depgraph in the original cluster order.\n+            ClusterIndex topo_idx = reordering[idx];\n+            depgraph.AddTransaction(topo_depgraph.FeeRate(topo_idx));\n+        }\n+        for (ClusterIndex idx = 0; idx < reordering.size(); ++idx) {",
      "path": "src/test/util/cluster_linearize.h",
      "position": 245,
      "original_position": 208,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n        for (const auto topo_idx : reordering) {\r\n```",
      "created_at": "2024-07-15T19:09:42Z",
      "updated_at": "2024-07-16T19:36:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1678277812",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678277812"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 245,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678297762",
      "pull_request_review_id": 2178360431,
      "id": 1678297762,
      "node_id": "PRRC_kwDOABII585kCMqi",
      "diff_hunk": "@@ -163,6 +164,120 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone.\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called which will return a\n+ * SetInfo with the highest-feerate ancestor set that remains (an ancestor set is a single\n+ * transaction together with all its remaining ancestors).\n+ */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            /** The remaining ancestors for transaction i. */\n+            SetType anc_to_add = m_depgraph.Ancestors(i);\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                Assume(!anc_feerate.IsEmpty());\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            anc_feerate += m_depgraph.FeeRate(anc_to_add);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * The same transaction may not be MarkDone()'d twice.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        Assume(select.IsSubsetOf(m_todo));",
      "path": "src/cluster_linearize.h",
      "position": 427,
      "original_position": 90,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "3b632d417764d79a51158aaea68586486d3b1cee",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "mind if we also `Assume(select.Any())`? ",
      "created_at": "2024-07-15T19:30:57Z",
      "updated_at": "2024-07-16T19:36:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1678297762",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678297762"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 427,
      "original_line": 427,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678305787",
      "pull_request_review_id": 2178360431,
      "id": 1678305787,
      "node_id": "PRRC_kwDOABII585kCOn7",
      "diff_hunk": "@@ -278,6 +290,161 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone().\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called to perform a search\n+ * over the set of topologically-valid subsets of that remainder, with a limit on how many\n+ * combinations are tried.\n+ */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Check whether any unlinearized transactions remain. */\n+    bool AllDone() const noexcept\n+    {\n+        return m_todo.None();\n+    }\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *  Requires !AllDone().\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        Assume(!AllDone());\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included (and its feerate). This must be a subset\n+             *  of m_todo, and be topologically valid (includes all in-m_todo ancestors of\n+             *  itself). */\n+            SetInfo<SetType> inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            SetType und;\n+\n+            /** Construct a new work item. */\n+            WorkItem(SetInfo<SetType>&& i, SetType&& u) noexcept :\n+                inc(std::move(i)), und(std::move(u)) {}\n+        };\n+\n+        /** The queue of work items. */\n+        std::vector<WorkItem> queue;\n+\n+        // Create an initial entry with m_todo as undecided. Also use it as best if not provided,\n+        // so that during the work processing loop below, and during the add_fn/split_fn calls, we\n+        // do not need to deal with the best=empty case.\n+        if (best.feerate.IsEmpty()) best = SetInfo(m_depgraph, m_todo);\n+        queue.emplace_back(SetInfo<SetType>{}, SetType{m_todo});\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iterations_left = max_iterations;\n+\n+        /** Internal function to add a work item.\n+         *\n+         * - inc: the \"inc\" value for the new work item (must be topological).\n+         * - und: the \"und\" value for the new work item ((inc | und) must be topological).\n+         */\n+        auto add_fn = [&](SetInfo<SetType> inc, SetType und) noexcept {\n+            if (!inc.feerate.IsEmpty()) {\n+                // If inc's feerate is better than best's, remember it as our new best.\n+                if (inc.feerate > best.feerate) {\n+                    best = inc;\n+                }\n+            } else {\n+                Assume(inc.transactions.None());\n+            }\n+\n+            // Make sure there are undecided transactions left to split on.\n+            if (und.None()) return;\n+\n+            // Actually construct new work item on the queue.\n+            queue.emplace_back(std::move(inc), std::move(und));\n+        };\n+\n+        /** Internal process function. It takes an existing work item, and splits it in two: one\n+         *  with a particular transaction (and its ancestors) included, and one with that\n+         *  transaction (and its descendants) excluded. */\n+        auto split_fn = [&](WorkItem&& elem) noexcept {\n+            // Any queue element must have undecided transactions left, otherwise there is nothing\n+            // to explore anymore.\n+            Assume(elem.und.Any());\n+            // The included and undecided set are all subsets of m_todo.\n+            Assume(elem.inc.transactions.IsSubsetOf(m_todo) && elem.und.IsSubsetOf(m_todo));\n+            // Included transactions cannot be undecided.\n+            Assume(!elem.inc.transactions.Overlaps(elem.und));\n+\n+            const ClusterIndex first = elem.und.First();\n+\n+            // Add a work item corresponding to excluding the first undecided transaction.\n+            const auto& desc = m_depgraph.Descendants(first);\n+            add_fn(/*inc=*/elem.inc,\n+                   /*und=*/elem.und - desc);\n+\n+            // Add a work item corresponding to including the first undecided transaction.\n+            const auto anc = m_depgraph.Ancestors(first) & m_todo;\n+            add_fn(/*inc=*/elem.inc.Add(m_depgraph, anc),\n+                   /*und=*/elem.und - anc);\n+\n+            // Account for the performed split.\n+            --iterations_left;\n+        };\n+\n+        // Work processing loop.\n+        while (!queue.empty()) {\n+            if (!iterations_left) break;\n+            auto elem = queue.back();\n+            queue.pop_back();\n+            split_fn(std::move(elem));\n+        }\n+\n+        // Return the found best set and the number of iterations performed.\n+        return {std::move(best), max_iterations - iterations_left};\n+    }\n+\n+    /** Remove a subset of transactions from the cluster being linearized.\n+     *\n+     * Complexity: O(N) where N=done.Count().\n+     */\n+    void MarkDone(const SetType& done) noexcept",
      "path": "src/cluster_linearize.h",
      "position": 658,
      "original_position": 186,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "86ed02aeed138d421ec596b487e6954b25de332b",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "can we do same checks as https://github.com/bitcoin/bitcoin/pull/30126/commits/3b632d417764d79a51158aaea68586486d3b1cee#diff-1433c1fc4926a466291656ba67cf6b029523e4bd5da177ade812f25edf07343cR245 ?",
      "created_at": "2024-07-15T19:39:47Z",
      "updated_at": "2024-07-16T19:36:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1678305787",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678305787"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 658,
      "original_line": 658,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678309127",
      "pull_request_review_id": 2178360431,
      "id": 1678309127,
      "node_id": "PRRC_kwDOABII585kCPcH",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms (purely empircally determined).",
      "path": "src/bench/cluster_linearize.cpp",
      "position": null,
      "original_position": 30,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ad7aacebe424c0478dcc942258e3f56c5fc7f4bf",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "empircally",
      "created_at": "2024-07-15T19:43:14Z",
      "updated_at": "2024-07-16T19:36:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1678309127",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678309127"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678323146",
      "pull_request_review_id": 2178360431,
      "id": 1678323146,
      "node_id": "PRRC_kwDOABII585kCS3K",
      "diff_hunk": "@@ -351,7 +352,8 @@ class SearchCandidateFinder\n         };\n \n         /** The queue of work items. */\n-        std::vector<WorkItem> queue;\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));",
      "path": "src/cluster_linearize.h",
      "position": 548,
      "original_position": 14,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": 1651302872,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm unsure how this was addressed",
      "created_at": "2024-07-15T19:57:56Z",
      "updated_at": "2024-07-16T19:36:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1678323146",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678323146"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 548,
      "original_line": 548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678345364",
      "pull_request_review_id": 2178360431,
      "id": 1678345364,
      "node_id": "PRRC_kwDOABII585kCYSU",
      "diff_hunk": "@@ -253,6 +253,109 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Data structure encapsulating the chunking of a linearization, permitting removal of subsets. */\n+template<typename SetType>\n+class LinearizationChunking\n+{\n+    /** The depgraph this linearization is for. */\n+    const DepGraph<SetType>& m_depgraph;\n+\n+    /** The linearization we started from. */\n+    Span<const ClusterIndex> m_linearization;\n+\n+    /** Chunk sets and their feerates, of what remains of the linearization. */\n+    std::vector<SetInfo<SetType>> m_chunks;\n+\n+    /** Which transactions remain in the linearization. */\n+    SetType m_todo;\n+\n+    /** Fill the m_chunks variable, updating lin_done in the process. */",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 20,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e70ddafeb57e0a8fc317b44019e6a7c376e08d61",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "lin_done doesn't exist",
      "created_at": "2024-07-15T20:20:43Z",
      "updated_at": "2024-07-16T19:36:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1678345364",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678345364"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 317,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678356337",
      "pull_request_review_id": 2178360431,
      "id": 1678356337,
      "node_id": "PRRC_kwDOABII585kCa9x",
      "diff_hunk": "@@ -253,6 +253,109 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Data structure encapsulating the chunking of a linearization, permitting removal of subsets. */\n+template<typename SetType>\n+class LinearizationChunking\n+{\n+    /** The depgraph this linearization is for. */\n+    const DepGraph<SetType>& m_depgraph;\n+\n+    /** The linearization we started from. */\n+    Span<const ClusterIndex> m_linearization;\n+\n+    /** Chunk sets and their feerates, of what remains of the linearization. */\n+    std::vector<SetInfo<SetType>> m_chunks;\n+\n+    /** Which transactions remain in the linearization. */\n+    SetType m_todo;\n+\n+    /** Fill the m_chunks variable, updating lin_done in the process. */\n+    void BuildChunks() noexcept\n+    {\n+        // Caller must clear m_chunks.\n+        Assume(m_chunks.empty());\n+\n+        // Iterate over the remaining entries in m_linearization. This is effectively the same\n+        // algorithm as ChunkLinearization, but supports skipping parts of the linearization and\n+        // keeps track of the sets themselves instead of just their feerates.\n+        for (auto idx : m_linearization) {\n+            if (!m_todo[idx]) continue;\n+            // Start with an initial chunk containing just element idx.\n+            SetInfo add(m_depgraph, idx);\n+            // Absorb existing final chunks into add while they have lower feerate.\n+            while (!m_chunks.empty() && add.feerate >> m_chunks.back().feerate) {\n+                add |= m_chunks.back();\n+                m_chunks.pop_back();\n+            }\n+            // Remember new chunk.\n+            m_chunks.push_back(std::move(add));\n+        }\n+    }\n+\n+public:\n+    /** Initialize a LinearizationSubset object for a given length of linearization. */\n+    explicit LinearizationChunking(const DepGraph<SetType>& depgraph LIFETIMEBOUND, Span<const ClusterIndex> lin LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_linearization(lin)\n+    {\n+        // Mark everything in lin as todo still.\n+        for (auto i : m_linearization) m_todo.Set(i);\n+        // Compute the initial chunking.\n+        m_chunks.reserve(depgraph.TxCount());\n+        BuildChunks();\n+    }\n+\n+    /** Determine how many chunks remain in the linearization. */\n+    ClusterIndex ChunksLeft() const noexcept { return m_chunks.size(); }\n+\n+    /** Access a chunk. Chunk 0 is the highest-feerate prefix of what remains. */\n+    const SetInfo<SetType>& GetChunk(ClusterIndex n) const noexcept\n+    {\n+        Assume(n < m_chunks.size());\n+        return m_chunks[n];\n+    }\n+\n+    /** Remove some subset of transactions from the linearization. */\n+    void MarkDone(SetType subset) noexcept\n+    {\n+        Assume(subset.IsSubsetOf(m_todo));\n+        m_todo -= subset;\n+        // Rechunk what remains of m_linearization.\n+        m_chunks.clear();\n+        BuildChunks();\n+    }\n+\n+    /** Find the shortest intersection between subset and the prefixes of remaining chunks\n+     *  of the linearization that has a feerate not below best's.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 76,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e70ddafeb57e0a8fc317b44019e6a7c376e08d61",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "there's no \"best\" in this context",
      "created_at": "2024-07-15T20:31:33Z",
      "updated_at": "2024-07-16T19:36:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1678356337",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1678356337"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 391,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679251068",
      "pull_request_review_id": 2180007217,
      "id": 1679251068,
      "node_id": "PRRC_kwDOABII585kF1Z8",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * their correct position on deserialization.",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 41,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: typo\r\n```suggestion\r\n * before children), together with position information so transactions can be moved back to their\r\n * correct position on deserialization.\r\n ```",
      "created_at": "2024-07-16T11:48:37Z",
      "updated_at": "2024-07-16T21:35:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1679251068",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679251068"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": 40,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 41,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679851817",
      "pull_request_review_id": 2178360431,
      "id": 1679851817,
      "node_id": "PRRC_kwDOABII585kIIEp",
      "diff_hunk": "@@ -253,6 +253,109 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Data structure encapsulating the chunking of a linearization, permitting removal of subsets. */\n+template<typename SetType>\n+class LinearizationChunking\n+{\n+    /** The depgraph this linearization is for. */\n+    const DepGraph<SetType>& m_depgraph;\n+\n+    /** The linearization we started from. */\n+    Span<const ClusterIndex> m_linearization;\n+\n+    /** Chunk sets and their feerates, of what remains of the linearization. */\n+    std::vector<SetInfo<SetType>> m_chunks;\n+\n+    /** Which transactions remain in the linearization. */\n+    SetType m_todo;\n+\n+    /** Fill the m_chunks variable, updating lin_done in the process. */\n+    void BuildChunks() noexcept\n+    {\n+        // Caller must clear m_chunks.\n+        Assume(m_chunks.empty());\n+\n+        // Iterate over the remaining entries in m_linearization. This is effectively the same\n+        // algorithm as ChunkLinearization, but supports skipping parts of the linearization and\n+        // keeps track of the sets themselves instead of just their feerates.\n+        for (auto idx : m_linearization) {\n+            if (!m_todo[idx]) continue;\n+            // Start with an initial chunk containing just element idx.\n+            SetInfo add(m_depgraph, idx);\n+            // Absorb existing final chunks into add while they have lower feerate.\n+            while (!m_chunks.empty() && add.feerate >> m_chunks.back().feerate) {\n+                add |= m_chunks.back();\n+                m_chunks.pop_back();\n+            }\n+            // Remember new chunk.\n+            m_chunks.push_back(std::move(add));\n+        }\n+    }\n+\n+public:\n+    /** Initialize a LinearizationSubset object for a given length of linearization. */\n+    explicit LinearizationChunking(const DepGraph<SetType>& depgraph LIFETIMEBOUND, Span<const ClusterIndex> lin LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_linearization(lin)\n+    {\n+        // Mark everything in lin as todo still.\n+        for (auto i : m_linearization) m_todo.Set(i);\n+        // Compute the initial chunking.\n+        m_chunks.reserve(depgraph.TxCount());\n+        BuildChunks();\n+    }\n+\n+    /** Determine how many chunks remain in the linearization. */\n+    ClusterIndex ChunksLeft() const noexcept { return m_chunks.size(); }\n+\n+    /** Access a chunk. Chunk 0 is the highest-feerate prefix of what remains. */\n+    const SetInfo<SetType>& GetChunk(ClusterIndex n) const noexcept\n+    {\n+        Assume(n < m_chunks.size());\n+        return m_chunks[n];\n+    }\n+\n+    /** Remove some subset of transactions from the linearization. */\n+    void MarkDone(SetType subset) noexcept\n+    {\n+        Assume(subset.IsSubsetOf(m_todo));\n+        m_todo -= subset;\n+        // Rechunk what remains of m_linearization.\n+        m_chunks.clear();\n+        BuildChunks();\n+    }\n+\n+    /** Find the shortest intersection between subset and the prefixes of remaining chunks\n+     *  of the linearization that has a feerate not below best's.\n+     *\n+     * This is a crucial operation in guaranteeing improvements to linearizations. The set\n+     * returned by this function, when moved to the front of (what remains of) the linearization,\n+     * is guaranteed not to make the linearization worse.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 80,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e70ddafeb57e0a8fc317b44019e6a7c376e08d61",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n     * is guaranteed not to make the linearization worse at any point.\r\n```",
      "created_at": "2024-07-16T18:19:38Z",
      "updated_at": "2024-07-16T19:36:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1679851817",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679851817"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 395,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679854169",
      "pull_request_review_id": 2178360431,
      "id": 1679854169,
      "node_id": "PRRC_kwDOABII585kIIpZ",
      "diff_hunk": "@@ -253,6 +253,109 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Data structure encapsulating the chunking of a linearization, permitting removal of subsets. */\n+template<typename SetType>\n+class LinearizationChunking\n+{\n+    /** The depgraph this linearization is for. */\n+    const DepGraph<SetType>& m_depgraph;\n+\n+    /** The linearization we started from. */\n+    Span<const ClusterIndex> m_linearization;\n+\n+    /** Chunk sets and their feerates, of what remains of the linearization. */\n+    std::vector<SetInfo<SetType>> m_chunks;\n+\n+    /** Which transactions remain in the linearization. */\n+    SetType m_todo;\n+\n+    /** Fill the m_chunks variable, updating lin_done in the process. */\n+    void BuildChunks() noexcept\n+    {\n+        // Caller must clear m_chunks.\n+        Assume(m_chunks.empty());\n+\n+        // Iterate over the remaining entries in m_linearization. This is effectively the same\n+        // algorithm as ChunkLinearization, but supports skipping parts of the linearization and\n+        // keeps track of the sets themselves instead of just their feerates.\n+        for (auto idx : m_linearization) {\n+            if (!m_todo[idx]) continue;\n+            // Start with an initial chunk containing just element idx.\n+            SetInfo add(m_depgraph, idx);\n+            // Absorb existing final chunks into add while they have lower feerate.\n+            while (!m_chunks.empty() && add.feerate >> m_chunks.back().feerate) {\n+                add |= m_chunks.back();\n+                m_chunks.pop_back();\n+            }\n+            // Remember new chunk.\n+            m_chunks.push_back(std::move(add));\n+        }\n+    }\n+\n+public:\n+    /** Initialize a LinearizationSubset object for a given length of linearization. */\n+    explicit LinearizationChunking(const DepGraph<SetType>& depgraph LIFETIMEBOUND, Span<const ClusterIndex> lin LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_linearization(lin)\n+    {\n+        // Mark everything in lin as todo still.\n+        for (auto i : m_linearization) m_todo.Set(i);\n+        // Compute the initial chunking.\n+        m_chunks.reserve(depgraph.TxCount());\n+        BuildChunks();\n+    }\n+\n+    /** Determine how many chunks remain in the linearization. */\n+    ClusterIndex ChunksLeft() const noexcept { return m_chunks.size(); }",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 56,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e70ddafeb57e0a8fc317b44019e6a7c376e08d61",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nitty renaming\r\n```Suggestion\r\n    ClusterIndex NumChunksLeft() const noexcept { return m_chunks.size(); }\r\n```",
      "created_at": "2024-07-16T18:21:19Z",
      "updated_at": "2024-07-16T19:36:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1679854169",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679854169"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679874099",
      "pull_request_review_id": 2178360431,
      "id": 1679874099,
      "node_id": "PRRC_kwDOABII585kINgz",
      "diff_hunk": "@@ -253,6 +253,109 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Data structure encapsulating the chunking of a linearization, permitting removal of subsets. */\n+template<typename SetType>\n+class LinearizationChunking\n+{\n+    /** The depgraph this linearization is for. */\n+    const DepGraph<SetType>& m_depgraph;\n+\n+    /** The linearization we started from. */\n+    Span<const ClusterIndex> m_linearization;\n+\n+    /** Chunk sets and their feerates, of what remains of the linearization. */\n+    std::vector<SetInfo<SetType>> m_chunks;\n+\n+    /** Which transactions remain in the linearization. */\n+    SetType m_todo;\n+\n+    /** Fill the m_chunks variable, updating lin_done in the process. */\n+    void BuildChunks() noexcept\n+    {\n+        // Caller must clear m_chunks.\n+        Assume(m_chunks.empty());\n+\n+        // Iterate over the remaining entries in m_linearization. This is effectively the same\n+        // algorithm as ChunkLinearization, but supports skipping parts of the linearization and\n+        // keeps track of the sets themselves instead of just their feerates.\n+        for (auto idx : m_linearization) {\n+            if (!m_todo[idx]) continue;\n+            // Start with an initial chunk containing just element idx.\n+            SetInfo add(m_depgraph, idx);\n+            // Absorb existing final chunks into add while they have lower feerate.\n+            while (!m_chunks.empty() && add.feerate >> m_chunks.back().feerate) {\n+                add |= m_chunks.back();\n+                m_chunks.pop_back();\n+            }\n+            // Remember new chunk.\n+            m_chunks.push_back(std::move(add));\n+        }\n+    }\n+\n+public:\n+    /** Initialize a LinearizationSubset object for a given length of linearization. */\n+    explicit LinearizationChunking(const DepGraph<SetType>& depgraph LIFETIMEBOUND, Span<const ClusterIndex> lin LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_linearization(lin)\n+    {\n+        // Mark everything in lin as todo still.\n+        for (auto i : m_linearization) m_todo.Set(i);\n+        // Compute the initial chunking.\n+        m_chunks.reserve(depgraph.TxCount());\n+        BuildChunks();\n+    }\n+\n+    /** Determine how many chunks remain in the linearization. */\n+    ClusterIndex ChunksLeft() const noexcept { return m_chunks.size(); }\n+\n+    /** Access a chunk. Chunk 0 is the highest-feerate prefix of what remains. */\n+    const SetInfo<SetType>& GetChunk(ClusterIndex n) const noexcept\n+    {\n+        Assume(n < m_chunks.size());\n+        return m_chunks[n];\n+    }\n+\n+    /** Remove some subset of transactions from the linearization. */\n+    void MarkDone(SetType subset) noexcept\n+    {\n+        Assume(subset.IsSubsetOf(m_todo));\n+        m_todo -= subset;\n+        // Rechunk what remains of m_linearization.\n+        m_chunks.clear();\n+        BuildChunks();\n+    }\n+\n+    /** Find the shortest intersection between subset and the prefixes of remaining chunks\n+     *  of the linearization that has a feerate not below best's.\n+     *\n+     * This is a crucial operation in guaranteeing improvements to linearizations. The set\n+     * returned by this function, when moved to the front of (what remains of) the linearization,\n+     * is guaranteed not to make the linearization worse.\n+     *\n+     * See https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032 for background.\n+     */\n+    SetInfo<SetType> Intersect(const SetInfo<SetType>& subset) const noexcept\n+    {\n+        Assume(subset.transactions.IsSubsetOf(m_todo));\n+        SetInfo<SetType> accumulator;\n+        // Iterate over all chunks of the remaining linearization.\n+        for (ClusterIndex i = 0; i < ChunksLeft(); ++i) {\n+            // Find what (if any) intersection the chunk has with subset.\n+            const SetType to_add = GetChunk(i).transactions & subset.transactions;\n+            if (to_add.Any()) {\n+                // If adding that to accumulator makes us hit all of subset, we are done as no\n+                // shorter intersection with higher/equal feerate exists.\n+                accumulator.transactions |= to_add;\n+                if (accumulator.transactions == subset.transactions) break;\n+                // Otherwise update the accumulator feerate.\n+                accumulator.feerate += m_depgraph.FeeRate(to_add);\n+                // If that does result in something better, return that.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 99,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e70ddafeb57e0a8fc317b44019e6a7c376e08d61",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If there specific motivation for returning the accumulated value if it equals `subset`'s vs exceeds? IIUC either would maintain correctness of the move.",
      "created_at": "2024-07-16T18:31:26Z",
      "updated_at": "2024-07-16T19:36:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1679874099",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679874099"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 414,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679896517",
      "pull_request_review_id": 2178360431,
      "id": 1679896517,
      "node_id": "PRRC_kwDOABII585kIS_F",
      "diff_hunk": "@@ -496,6 +496,103 @@ FUZZ_TARGET(clusterlin_search_finder)\n     assert(anc_finder.AllDone());\n }\n \n+FUZZ_TARGET(clusterlin_linearization_chunking)\n+{\n+    // Verify the behavior of LinearizationChunking.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a topologically-valid subset of depgraph.\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    auto subset = SetInfo(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+    // Retrieve a valid linearization for depgraph.\n+    auto linearization = ReadLinearization(depgraph, reader);\n+\n+    // Construct a LinearizationChunking object, initially for the whole linearization.\n+    LinearizationChunking chunking(depgraph, linearization);\n+\n+    // Remove piece by piece of the linearization in the chunking object, and check various\n+    // properties at every step.\n+    while (todo.Any()) {\n+        assert(chunking.ChunksLeft() > 0);\n+\n+        // Construct linearization with just todo.\n+        std::vector<ClusterIndex> linearization_left;\n+        for (auto i : linearization) {\n+            if (todo[i]) linearization_left.push_back(i);\n+        }\n+\n+        // Compute the chunking for linearization_left.\n+        auto chunking_left = ChunkLinearization(depgraph, linearization_left);\n+\n+        // Verify that it matches the chunks of chunking.\n+        assert(chunking.ChunksLeft() == chunking_left.size());\n+        for (ClusterIndex i = 0; i < chunking.ChunksLeft(); ++i) {\n+            assert(chunking.GetChunk(i).feerate == chunking_left[i]);\n+        }\n+\n+        // Check consistency of chunking.\n+        TestBitSet combined;\n+        for (ClusterIndex i = 0; i < chunking.ChunksLeft(); ++i) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 47,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e70ddafeb57e0a8fc317b44019e6a7c376e08d61",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could also check that chunk feerate is dropping monotonically",
      "created_at": "2024-07-16T18:40:03Z",
      "updated_at": "2024-07-16T19:36:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1679896517",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679896517"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 582,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679922047",
      "pull_request_review_id": 2178360431,
      "id": 1679922047,
      "node_id": "PRRC_kwDOABII585kIZN_",
      "diff_hunk": "@@ -697,6 +714,9 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n         anc_finder.MarkDone(best.transactions);\n         if (anc_finder.AllDone()) break;\n         src_finder.MarkDone(best.transactions);\n+        if (old_chunking.ChunksLeft() > 0) {\n+            old_chunking.MarkDone(best.transactions);",
      "path": "src/cluster_linearize.h",
      "position": 734,
      "original_position": 76,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "f2193f70f8a88b7d4ca71f60d0debd5dcbaa7050",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could this just be done immediately after setting `best` here https://github.com/bitcoin/bitcoin/pull/30126/commits/f2193f70f8a88b7d4ca71f60d0debd5dcbaa7050#diff-1433c1fc4926a466291656ba67cf6b029523e4bd5da177ade812f25edf07343cR706 ?",
      "created_at": "2024-07-16T18:53:39Z",
      "updated_at": "2024-07-16T19:36:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1679922047",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679922047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 734,
      "original_line": 734,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679955057",
      "pull_request_review_id": 2178360431,
      "id": 1679955057,
      "node_id": "PRRC_kwDOABII585kIhRx",
      "diff_hunk": "@@ -320,6 +351,7 @@ FUZZ_TARGET(clusterlin_chunking)\n     try {\n         reader >> Using<DepGraphFormatter>(depgraph);\n     } catch (const std::ios_base::failure&) {}\n+    MakeConnected(depgraph);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 49,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "c192b30156ae41638291010b40b874479ea1943c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do we always want to make the graphs connected? Seems like a possible reduction in coverage?",
      "created_at": "2024-07-16T19:18:01Z",
      "updated_at": "2024-07-16T19:36:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1679955057",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679955057"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680152503",
      "pull_request_review_id": 2181446104,
      "id": 1680152503,
      "node_id": "PRRC_kwDOABII585kJRe3",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * their correct position on deserialization.\n+ *\n+ * - For each transaction t in the DepGraph (in some topological order);\n+ *   - The size: VARINT(t.size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(t.fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for every parent p of t, in order of most recently serialized to least\n+ *     recently serialized:\n+ *     - VARINT(diff), where diff is the number of transactions between p and the previous parent\n+ *       (excluding transactions which are already known to be ancestors of t) which were not\n+ *       parents of t.\n+ *   - The position: VARINT(diff), where diff is the sum of the number of skipped transactions\n+ *     after the last parent, and the distance from the end of the transaction list where to insert\n+ *     t (distance=0 means at the very end, distance=1 means 1 before the end, etc). On\n+ *     deserialization, overflow here is interpreted as wrapping around.\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents emitted in reverse order compared to the transactions themselves? This\n+ *   naturally lets us skip parents-of-parents.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 1 bytes per transaction for dependencies in this case,\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** Construct a topological order to serialize the transactions in. */\n+        std::vector<ClusterIndex> topo_order(depgraph.TxCount());\n+        std::iota(topo_order.begin(), topo_order.end(), ClusterIndex{0});\n+        std::sort(topo_order.begin(), topo_order.end(), [&](ClusterIndex a, ClusterIndex b) {\n+            auto anc_a = depgraph.Ancestors(a).Count(), anc_b = depgraph.Ancestors(b).Count();\n+            if (anc_a != anc_b) return anc_a < anc_b;\n+            return a < b;\n+        });\n+\n+        /** Which transactions the deserializer already knows when it has deserialized what has\n+         *  has been serialized here so far, and in what order. */",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 107,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": 1678216187,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-16T23:04:26Z",
      "updated_at": "2024-07-16T23:04:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680152503",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680152503"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680152672",
      "pull_request_review_id": 2181446352,
      "id": 1680152672,
      "node_id": "PRRC_kwDOABII585kJRhg",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * their correct position on deserialization.\n+ *\n+ * - For each transaction t in the DepGraph (in some topological order);\n+ *   - The size: VARINT(t.size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(t.fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for every parent p of t, in order of most recently serialized to least\n+ *     recently serialized:\n+ *     - VARINT(diff), where diff is the number of transactions between p and the previous parent\n+ *       (excluding transactions which are already known to be ancestors of t) which were not\n+ *       parents of t.\n+ *   - The position: VARINT(diff), where diff is the sum of the number of skipped transactions\n+ *     after the last parent, and the distance from the end of the transaction list where to insert\n+ *     t (distance=0 means at the very end, distance=1 means 1 before the end, etc). On\n+ *     deserialization, overflow here is interpreted as wrapping around.\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents emitted in reverse order compared to the transactions themselves? This\n+ *   naturally lets us skip parents-of-parents.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 1 bytes per transaction for dependencies in this case,\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** Construct a topological order to serialize the transactions in. */\n+        std::vector<ClusterIndex> topo_order(depgraph.TxCount());\n+        std::iota(topo_order.begin(), topo_order.end(), ClusterIndex{0});\n+        std::sort(topo_order.begin(), topo_order.end(), [&](ClusterIndex a, ClusterIndex b) {\n+            auto anc_a = depgraph.Ancestors(a).Count(), anc_b = depgraph.Ancestors(b).Count();\n+            if (anc_a != anc_b) return anc_a < anc_b;\n+            return a < b;\n+        });\n+\n+        /** Which transactions the deserializer already knows when it has deserialized what has\n+         *  has been serialized here so far, and in what order. */\n+        std::vector<ClusterIndex> rebuilt_order;\n+        rebuilt_order.reserve(depgraph.TxCount());\n+\n+        // Loop over the transactions in topological order.\n+        for (ClusterIndex topo_idx = 0; topo_idx < topo_order.size(); ++topo_idx) {\n+            /** Which depgraph index we are currently writing. */\n+            ClusterIndex idx = topo_order[topo_idx];\n+            // Write size, which must be larger than 0.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee, encoded as an unsigned varint (odd=negative, even=non-negative).\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            SetType written_parents;\n+            uint64_t diff = 0; //!< How many potential parent/child relations we have skipped over.\n+            for (ClusterIndex dep_dist = 0; dep_dist < topo_idx; ++dep_dist) {\n+                /** Which depgraph index we are currently considering as parent of idx. */\n+                ClusterIndex dep_idx = topo_order[topo_idx - 1 - dep_dist];\n+                // Ignore transactions which are already known to be ancestors.\n+                if (depgraph.Descendants(dep_idx).Overlaps(written_parents)) continue;\n+                if (depgraph.Ancestors(idx)[dep_idx]) {\n+                    // When an actual parent is encounted, encode how many non-parents were skipped\n+                    // before it.\n+                    s << VARINT(diff);\n+                    diff = 0;\n+                    written_parents.Set(dep_idx);\n+                } else {\n+                    // When a non-parent is encountered, increment the skip counter.\n+                    ++diff;\n+                }\n+            }\n+            // Write position information.\n+            ClusterIndex insert_distance = 0;\n+            while (insert_distance < rebuilt_order.size()) {\n+                // Loop to find how far from the end in rebuilt_order to insert.\n+                if (idx > *(rebuilt_order.end() - 1 - insert_distance)) break;\n+                ++insert_distance;\n+            }\n+            rebuilt_order.insert(rebuilt_order.end() - insert_distance, idx);\n+            s << VARINT(diff + insert_distance);\n+        }\n+\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        /** The dependency graph which we deserialize into first, with transactions in\n+         *  topological serialization order, not original cluster order. */\n+        DepGraph<SetType> topo_depgraph;\n+        /** Mapping from cluster order to serialization order, used later to reconstruct the\n+         *  cluster order. */\n+        std::vector<ClusterIndex> reordering;\n+\n+        // Read transactions in topological order.\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            static_assert(0x3FFFFF >= 4000000);\n+            if (size == 0 || topo_depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as an unsigned varint (odd=negative, even=non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            static_assert(0xFFFFFFFFFFFFF > uint64_t{2} * 21000000 * 100000000);\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend topo_depgraph with the new transaction (at the end).\n+            auto topo_idx = topo_depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t diff = 0; //!< How many potential parents we have to skip.\n+            s >> VARINT(diff);\n+            for (ClusterIndex dep_dist = 0; dep_dist < topo_idx; ++dep_dist) {\n+                /** Which topo_depgraph index we are currently considering as parent of topo_idx. */\n+                ClusterIndex dep_topo_idx = topo_idx - 1 - dep_dist;\n+                // Ignore transactions which are already known ancestors of topo_idx.\n+                if (topo_depgraph.Descendants(dep_topo_idx)[topo_idx]) continue;\n+                if (diff == 0) {\n+                    // When the skip counter has reached 0, add an actual dependency.\n+                    topo_depgraph.AddDependency(dep_topo_idx, topo_idx);\n+                    // And read the number of skips after it.\n+                    s >> VARINT(diff);\n+                } else {\n+                    // Otherwise, dep_topo_idx is not a parent. Decrement and continue.\n+                    --diff;\n+                }\n+            }\n+            // Read position information, interpreting the remaining skip value as wrapping around.\n+            reordering.insert(reordering.end() - (diff % (reordering.size() + 1)), topo_idx);\n+        }\n+\n+        // Construct the original cluster order depgraph.\n+        depgraph = {};\n+        for (ClusterIndex idx = 0; idx < reordering.size(); ++idx) {\n+            // Add transactions to depgraph in the original cluster order.\n+            ClusterIndex topo_idx = reordering[idx];\n+            depgraph.AddTransaction(topo_depgraph.FeeRate(topo_idx));\n+        }\n+        for (ClusterIndex idx = 0; idx < reordering.size(); ++idx) {",
      "path": "src/test/util/cluster_linearize.h",
      "position": 245,
      "original_position": 208,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": 1678277812,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The loop uses `idx` below, unfortunately.",
      "created_at": "2024-07-16T23:04:48Z",
      "updated_at": "2024-07-16T23:04:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680152672",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680152672"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 245,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680152726",
      "pull_request_review_id": 2181446436,
      "id": 1680152726,
      "node_id": "PRRC_kwDOABII585kJRiW",
      "diff_hunk": "@@ -163,6 +164,120 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone.\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called which will return a\n+ * SetInfo with the highest-feerate ancestor set that remains (an ancestor set is a single\n+ * transaction together with all its remaining ancestors).\n+ */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            /** The remaining ancestors for transaction i. */\n+            SetType anc_to_add = m_depgraph.Ancestors(i);\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                Assume(!anc_feerate.IsEmpty());\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            anc_feerate += m_depgraph.FeeRate(anc_to_add);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * The same transaction may not be MarkDone()'d twice.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        Assume(select.IsSubsetOf(m_todo));",
      "path": "src/cluster_linearize.h",
      "position": 427,
      "original_position": 90,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "3b632d417764d79a51158aaea68586486d3b1cee",
      "in_reply_to_id": 1678297762,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-16T23:04:55Z",
      "updated_at": "2024-07-16T23:04:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680152726",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680152726"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 427,
      "original_line": 427,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680152763",
      "pull_request_review_id": 2181446493,
      "id": 1680152763,
      "node_id": "PRRC_kwDOABII585kJRi7",
      "diff_hunk": "@@ -278,6 +290,161 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone().\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called to perform a search\n+ * over the set of topologically-valid subsets of that remainder, with a limit on how many\n+ * combinations are tried.\n+ */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Check whether any unlinearized transactions remain. */\n+    bool AllDone() const noexcept\n+    {\n+        return m_todo.None();\n+    }\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *  Requires !AllDone().\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        Assume(!AllDone());\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included (and its feerate). This must be a subset\n+             *  of m_todo, and be topologically valid (includes all in-m_todo ancestors of\n+             *  itself). */\n+            SetInfo<SetType> inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            SetType und;\n+\n+            /** Construct a new work item. */\n+            WorkItem(SetInfo<SetType>&& i, SetType&& u) noexcept :\n+                inc(std::move(i)), und(std::move(u)) {}\n+        };\n+\n+        /** The queue of work items. */\n+        std::vector<WorkItem> queue;\n+\n+        // Create an initial entry with m_todo as undecided. Also use it as best if not provided,\n+        // so that during the work processing loop below, and during the add_fn/split_fn calls, we\n+        // do not need to deal with the best=empty case.\n+        if (best.feerate.IsEmpty()) best = SetInfo(m_depgraph, m_todo);\n+        queue.emplace_back(SetInfo<SetType>{}, SetType{m_todo});\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iterations_left = max_iterations;\n+\n+        /** Internal function to add a work item.\n+         *\n+         * - inc: the \"inc\" value for the new work item (must be topological).\n+         * - und: the \"und\" value for the new work item ((inc | und) must be topological).\n+         */\n+        auto add_fn = [&](SetInfo<SetType> inc, SetType und) noexcept {\n+            if (!inc.feerate.IsEmpty()) {\n+                // If inc's feerate is better than best's, remember it as our new best.\n+                if (inc.feerate > best.feerate) {\n+                    best = inc;\n+                }\n+            } else {\n+                Assume(inc.transactions.None());\n+            }\n+\n+            // Make sure there are undecided transactions left to split on.\n+            if (und.None()) return;\n+\n+            // Actually construct new work item on the queue.\n+            queue.emplace_back(std::move(inc), std::move(und));\n+        };\n+\n+        /** Internal process function. It takes an existing work item, and splits it in two: one\n+         *  with a particular transaction (and its ancestors) included, and one with that\n+         *  transaction (and its descendants) excluded. */\n+        auto split_fn = [&](WorkItem&& elem) noexcept {\n+            // Any queue element must have undecided transactions left, otherwise there is nothing\n+            // to explore anymore.\n+            Assume(elem.und.Any());\n+            // The included and undecided set are all subsets of m_todo.\n+            Assume(elem.inc.transactions.IsSubsetOf(m_todo) && elem.und.IsSubsetOf(m_todo));\n+            // Included transactions cannot be undecided.\n+            Assume(!elem.inc.transactions.Overlaps(elem.und));\n+\n+            const ClusterIndex first = elem.und.First();\n+\n+            // Add a work item corresponding to excluding the first undecided transaction.\n+            const auto& desc = m_depgraph.Descendants(first);\n+            add_fn(/*inc=*/elem.inc,\n+                   /*und=*/elem.und - desc);\n+\n+            // Add a work item corresponding to including the first undecided transaction.\n+            const auto anc = m_depgraph.Ancestors(first) & m_todo;\n+            add_fn(/*inc=*/elem.inc.Add(m_depgraph, anc),\n+                   /*und=*/elem.und - anc);\n+\n+            // Account for the performed split.\n+            --iterations_left;\n+        };\n+\n+        // Work processing loop.\n+        while (!queue.empty()) {\n+            if (!iterations_left) break;\n+            auto elem = queue.back();\n+            queue.pop_back();\n+            split_fn(std::move(elem));\n+        }\n+\n+        // Return the found best set and the number of iterations performed.\n+        return {std::move(best), max_iterations - iterations_left};\n+    }\n+\n+    /** Remove a subset of transactions from the cluster being linearized.\n+     *\n+     * Complexity: O(N) where N=done.Count().\n+     */\n+    void MarkDone(const SetType& done) noexcept",
      "path": "src/cluster_linearize.h",
      "position": 658,
      "original_position": 186,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "86ed02aeed138d421ec596b487e6954b25de332b",
      "in_reply_to_id": 1678305787,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-16T23:05:01Z",
      "updated_at": "2024-07-16T23:05:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680152763",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680152763"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 658,
      "original_line": 658,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680154549",
      "pull_request_review_id": 2181449480,
      "id": 1680154549,
      "node_id": "PRRC_kwDOABII585kJR-1",
      "diff_hunk": "@@ -0,0 +1,168 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in the same order as the Cluster it was constructed from. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator (primarily for testing purposes). */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: O(1) (amortized, due to resizing of backing vector).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        Assume(TxCount() < SetType::Size());\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, SetType::Singleton(new_idx), SetType::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.",
      "path": "src/cluster_linearize.h",
      "position": 151,
      "original_position": 142,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "503af62cbab48733eea0aca8473239e1ad5f6403",
      "in_reply_to_id": 1677652342,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The function is just for testing, so it doesn't matter much, but sure, added.",
      "created_at": "2024-07-16T23:07:43Z",
      "updated_at": "2024-07-16T23:07:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680154549",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680154549"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680154751",
      "pull_request_review_id": 2181449847,
      "id": 1680154751,
      "node_id": "PRRC_kwDOABII585kJSB_",
      "diff_hunk": "@@ -0,0 +1,168 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in the same order as the Cluster it was constructed from. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator (primarily for testing purposes). */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 91,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "503af62cbab48733eea0aca8473239e1ad5f6403",
      "in_reply_to_id": 1677606491,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-16T23:07:53Z",
      "updated_at": "2024-07-16T23:07:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680154751",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680154751"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": 85,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680155259",
      "pull_request_review_id": 2181451178,
      "id": 1680155259,
      "node_id": "PRRC_kwDOABII585kJSJ7",
      "diff_hunk": "@@ -0,0 +1,168 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 42,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "503af62cbab48733eea0aca8473239e1ad5f6403",
      "in_reply_to_id": 1677594301,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fair enough, but style-wise I still like to have a comment on each function. I've expanded the comment a bit here to point out it's for testing.",
      "created_at": "2024-07-16T23:08:47Z",
      "updated_at": "2024-07-16T23:08:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680155259",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680155259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680157731",
      "pull_request_review_id": 2181455585,
      "id": 1680157731,
      "node_id": "PRRC_kwDOABII585kJSwj",
      "diff_hunk": "@@ -351,7 +352,8 @@ class SearchCandidateFinder\n         };\n \n         /** The queue of work items. */\n-        std::vector<WorkItem> queue;\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));",
      "path": "src/cluster_linearize.h",
      "position": 548,
      "original_position": 14,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": 1651302872,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's not clear to me what you're asking for. Are you asking what I changed to address this, or saying that it's still an issue, or saying that more explanatory comments are needed?",
      "created_at": "2024-07-16T23:12:31Z",
      "updated_at": "2024-07-16T23:12:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680157731",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680157731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 548,
      "original_line": 548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680159369",
      "pull_request_review_id": 2181458959,
      "id": 1680159369,
      "node_id": "PRRC_kwDOABII585kJTKJ",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, SetType::Singleton(new_idx), SetType::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.",
      "path": "src/cluster_linearize.h",
      "position": 151,
      "original_position": 141,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "06c600099abe129a5bb5c6a5a533018f03e51304",
      "in_reply_to_id": 1638465834,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@ismaelsadeeq Done.",
      "created_at": "2024-07-16T23:14:50Z",
      "updated_at": "2024-07-16T23:14:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680159369",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680159369"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680326042",
      "pull_request_review_id": 2181756907,
      "id": 1680326042,
      "node_id": "PRRC_kwDOABII585kJ72a",
      "diff_hunk": "@@ -253,6 +253,109 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Data structure encapsulating the chunking of a linearization, permitting removal of subsets. */\n+template<typename SetType>\n+class LinearizationChunking\n+{\n+    /** The depgraph this linearization is for. */\n+    const DepGraph<SetType>& m_depgraph;\n+\n+    /** The linearization we started from. */\n+    Span<const ClusterIndex> m_linearization;\n+\n+    /** Chunk sets and their feerates, of what remains of the linearization. */\n+    std::vector<SetInfo<SetType>> m_chunks;\n+\n+    /** Which transactions remain in the linearization. */\n+    SetType m_todo;\n+\n+    /** Fill the m_chunks variable, updating lin_done in the process. */\n+    void BuildChunks() noexcept\n+    {\n+        // Caller must clear m_chunks.\n+        Assume(m_chunks.empty());\n+\n+        // Iterate over the remaining entries in m_linearization. This is effectively the same\n+        // algorithm as ChunkLinearization, but supports skipping parts of the linearization and\n+        // keeps track of the sets themselves instead of just their feerates.\n+        for (auto idx : m_linearization) {\n+            if (!m_todo[idx]) continue;\n+            // Start with an initial chunk containing just element idx.\n+            SetInfo add(m_depgraph, idx);\n+            // Absorb existing final chunks into add while they have lower feerate.\n+            while (!m_chunks.empty() && add.feerate >> m_chunks.back().feerate) {\n+                add |= m_chunks.back();\n+                m_chunks.pop_back();\n+            }\n+            // Remember new chunk.\n+            m_chunks.push_back(std::move(add));\n+        }\n+    }\n+\n+public:\n+    /** Initialize a LinearizationSubset object for a given length of linearization. */\n+    explicit LinearizationChunking(const DepGraph<SetType>& depgraph LIFETIMEBOUND, Span<const ClusterIndex> lin LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_linearization(lin)\n+    {\n+        // Mark everything in lin as todo still.\n+        for (auto i : m_linearization) m_todo.Set(i);\n+        // Compute the initial chunking.\n+        m_chunks.reserve(depgraph.TxCount());\n+        BuildChunks();\n+    }\n+\n+    /** Determine how many chunks remain in the linearization. */\n+    ClusterIndex ChunksLeft() const noexcept { return m_chunks.size(); }\n+\n+    /** Access a chunk. Chunk 0 is the highest-feerate prefix of what remains. */\n+    const SetInfo<SetType>& GetChunk(ClusterIndex n) const noexcept\n+    {\n+        Assume(n < m_chunks.size());\n+        return m_chunks[n];\n+    }\n+\n+    /** Remove some subset of transactions from the linearization. */\n+    void MarkDone(SetType subset) noexcept\n+    {\n+        Assume(subset.IsSubsetOf(m_todo));\n+        m_todo -= subset;\n+        // Rechunk what remains of m_linearization.\n+        m_chunks.clear();\n+        BuildChunks();\n+    }\n+\n+    /** Find the shortest intersection between subset and the prefixes of remaining chunks\n+     *  of the linearization that has a feerate not below best's.\n+     *\n+     * This is a crucial operation in guaranteeing improvements to linearizations. The set\n+     * returned by this function, when moved to the front of (what remains of) the linearization,\n+     * is guaranteed not to make the linearization worse.\n+     *\n+     * See https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032 for background.\n+     */\n+    SetInfo<SetType> Intersect(const SetInfo<SetType>& subset) const noexcept\n+    {\n+        Assume(subset.transactions.IsSubsetOf(m_todo));\n+        SetInfo<SetType> accumulator;\n+        // Iterate over all chunks of the remaining linearization.\n+        for (ClusterIndex i = 0; i < ChunksLeft(); ++i) {\n+            // Find what (if any) intersection the chunk has with subset.\n+            const SetType to_add = GetChunk(i).transactions & subset.transactions;\n+            if (to_add.Any()) {\n+                // If adding that to accumulator makes us hit all of subset, we are done as no\n+                // shorter intersection with higher/equal feerate exists.\n+                accumulator.transactions |= to_add;\n+                if (accumulator.transactions == subset.transactions) break;\n+                // Otherwise update the accumulator feerate.\n+                accumulator.feerate += m_depgraph.FeeRate(to_add);\n+                // If that does result in something better, return that.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 99,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e70ddafeb57e0a8fc317b44019e6a7c376e08d61",
      "in_reply_to_id": 1679874099,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If `accumulator` is equal in feerate to `subset`, but smaller in size, it would be correct to either return `accumulator` (as done in the current code) or to continue the loop. Returning `subset` in this case would not be correct, as it's possible that a bigger intersection still has a higher feerate.\r\n\r\nIn general, I prefer returning the first (smallest) acceptable intersection because that is the least amount of iteration work, and it does not hurt quality (if a bigger intersection of higher feerate exists, we'll discover it in the next loop anyway).",
      "created_at": "2024-07-17T02:35:10Z",
      "updated_at": "2024-07-17T02:35:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680326042",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680326042"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 414,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680336040",
      "pull_request_review_id": 2181770828,
      "id": 1680336040,
      "node_id": "PRRC_kwDOABII585kJ-So",
      "diff_hunk": "@@ -697,6 +714,9 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n         anc_finder.MarkDone(best.transactions);\n         if (anc_finder.AllDone()) break;\n         src_finder.MarkDone(best.transactions);\n+        if (old_chunking.ChunksLeft() > 0) {\n+            old_chunking.MarkDone(best.transactions);",
      "path": "src/cluster_linearize.h",
      "position": 734,
      "original_position": 76,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "f2193f70f8a88b7d4ca71f60d0debd5dcbaa7050",
      "in_reply_to_id": 1679922047,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No, we need to invoke `MarkDone` even when the `iterations_done_now == max_iterations_now` condition is not satisfied.",
      "created_at": "2024-07-17T02:52:13Z",
      "updated_at": "2024-07-17T02:52:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680336040",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680336040"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 734,
      "original_line": 734,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680345658",
      "pull_request_review_id": 2181783198,
      "id": 1680345658,
      "node_id": "PRRC_kwDOABII585kKAo6",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * their correct position on deserialization.\n+ *\n+ * - For each transaction t in the DepGraph (in some topological order);\n+ *   - The size: VARINT(t.size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(t.fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for every parent p of t, in order of most recently serialized to least\n+ *     recently serialized:\n+ *     - VARINT(diff), where diff is the number of transactions between p and the previous parent\n+ *       (excluding transactions which are already known to be ancestors of t) which were not\n+ *       parents of t.\n+ *   - The position: VARINT(diff), where diff is the sum of the number of skipped transactions\n+ *     after the last parent, and the distance from the end of the transaction list where to insert\n+ *     t (distance=0 means at the very end, distance=1 means 1 before the end, etc). On\n+ *     deserialization, overflow here is interpreted as wrapping around.\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents emitted in reverse order compared to the transactions themselves? This\n+ *   naturally lets us skip parents-of-parents.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 1 bytes per transaction for dependencies in this case,\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** Construct a topological order to serialize the transactions in. */\n+        std::vector<ClusterIndex> topo_order(depgraph.TxCount());\n+        std::iota(topo_order.begin(), topo_order.end(), ClusterIndex{0});\n+        std::sort(topo_order.begin(), topo_order.end(), [&](ClusterIndex a, ClusterIndex b) {\n+            auto anc_a = depgraph.Ancestors(a).Count(), anc_b = depgraph.Ancestors(b).Count();\n+            if (anc_a != anc_b) return anc_a < anc_b;\n+            return a < b;\n+        });\n+\n+        /** Which transactions the deserializer already knows when it has deserialized what has\n+         *  has been serialized here so far, and in what order. */\n+        std::vector<ClusterIndex> rebuilt_order;\n+        rebuilt_order.reserve(depgraph.TxCount());\n+\n+        // Loop over the transactions in topological order.\n+        for (ClusterIndex topo_idx = 0; topo_idx < topo_order.size(); ++topo_idx) {\n+            /** Which depgraph index we are currently writing. */\n+            ClusterIndex idx = topo_order[topo_idx];\n+            // Write size, which must be larger than 0.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee, encoded as an unsigned varint (odd=negative, even=non-negative).\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            SetType written_parents;\n+            uint64_t diff = 0; //!< How many potential parent/child relations we have skipped over.\n+            for (ClusterIndex dep_dist = 0; dep_dist < topo_idx; ++dep_dist) {\n+                /** Which depgraph index we are currently considering as parent of idx. */\n+                ClusterIndex dep_idx = topo_order[topo_idx - 1 - dep_dist];\n+                // Ignore transactions which are already known to be ancestors.\n+                if (depgraph.Descendants(dep_idx).Overlaps(written_parents)) continue;\n+                if (depgraph.Ancestors(idx)[dep_idx]) {\n+                    // When an actual parent is encounted, encode how many non-parents were skipped\n+                    // before it.\n+                    s << VARINT(diff);\n+                    diff = 0;\n+                    written_parents.Set(dep_idx);\n+                } else {\n+                    // When a non-parent is encountered, increment the skip counter.\n+                    ++diff;\n+                }\n+            }\n+            // Write position information.\n+            ClusterIndex insert_distance = 0;\n+            while (insert_distance < rebuilt_order.size()) {\n+                // Loop to find how far from the end in rebuilt_order to insert.\n+                if (idx > *(rebuilt_order.end() - 1 - insert_distance)) break;\n+                ++insert_distance;\n+            }\n+            rebuilt_order.insert(rebuilt_order.end() - insert_distance, idx);\n+            s << VARINT(diff + insert_distance);",
      "path": "src/test/util/cluster_linearize.h",
      "position": 176,
      "original_position": 146,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": 1678263149,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Does looking at the documented serialization in the unit tests help? If not, I will add a worked-out example in more detail to the `DepGraphFormatter` documentation.",
      "created_at": "2024-07-17T03:04:30Z",
      "updated_at": "2024-07-17T03:04:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680345658",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680345658"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 176,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680345744",
      "pull_request_review_id": 2181783335,
      "id": 1680345744,
      "node_id": "PRRC_kwDOABII585kKAqQ",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms (purely empircally determined).",
      "path": "src/bench/cluster_linearize.cpp",
      "position": null,
      "original_position": 30,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "ad7aacebe424c0478dcc942258e3f56c5fc7f4bf",
      "in_reply_to_id": 1678309127,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-17T03:04:41Z",
      "updated_at": "2024-07-17T03:04:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680345744",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680345744"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680345825",
      "pull_request_review_id": 2181783435,
      "id": 1680345825,
      "node_id": "PRRC_kwDOABII585kKArh",
      "diff_hunk": "@@ -253,6 +253,109 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Data structure encapsulating the chunking of a linearization, permitting removal of subsets. */\n+template<typename SetType>\n+class LinearizationChunking\n+{\n+    /** The depgraph this linearization is for. */\n+    const DepGraph<SetType>& m_depgraph;\n+\n+    /** The linearization we started from. */\n+    Span<const ClusterIndex> m_linearization;\n+\n+    /** Chunk sets and their feerates, of what remains of the linearization. */\n+    std::vector<SetInfo<SetType>> m_chunks;\n+\n+    /** Which transactions remain in the linearization. */\n+    SetType m_todo;\n+\n+    /** Fill the m_chunks variable, updating lin_done in the process. */",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 20,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e70ddafeb57e0a8fc317b44019e6a7c376e08d61",
      "in_reply_to_id": 1678345364,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-17T03:04:50Z",
      "updated_at": "2024-07-17T03:04:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680345825",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680345825"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 317,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680345874",
      "pull_request_review_id": 2181783509,
      "id": 1680345874,
      "node_id": "PRRC_kwDOABII585kKAsS",
      "diff_hunk": "@@ -253,6 +253,109 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Data structure encapsulating the chunking of a linearization, permitting removal of subsets. */\n+template<typename SetType>\n+class LinearizationChunking\n+{\n+    /** The depgraph this linearization is for. */\n+    const DepGraph<SetType>& m_depgraph;\n+\n+    /** The linearization we started from. */\n+    Span<const ClusterIndex> m_linearization;\n+\n+    /** Chunk sets and their feerates, of what remains of the linearization. */\n+    std::vector<SetInfo<SetType>> m_chunks;\n+\n+    /** Which transactions remain in the linearization. */\n+    SetType m_todo;\n+\n+    /** Fill the m_chunks variable, updating lin_done in the process. */\n+    void BuildChunks() noexcept\n+    {\n+        // Caller must clear m_chunks.\n+        Assume(m_chunks.empty());\n+\n+        // Iterate over the remaining entries in m_linearization. This is effectively the same\n+        // algorithm as ChunkLinearization, but supports skipping parts of the linearization and\n+        // keeps track of the sets themselves instead of just their feerates.\n+        for (auto idx : m_linearization) {\n+            if (!m_todo[idx]) continue;\n+            // Start with an initial chunk containing just element idx.\n+            SetInfo add(m_depgraph, idx);\n+            // Absorb existing final chunks into add while they have lower feerate.\n+            while (!m_chunks.empty() && add.feerate >> m_chunks.back().feerate) {\n+                add |= m_chunks.back();\n+                m_chunks.pop_back();\n+            }\n+            // Remember new chunk.\n+            m_chunks.push_back(std::move(add));\n+        }\n+    }\n+\n+public:\n+    /** Initialize a LinearizationSubset object for a given length of linearization. */\n+    explicit LinearizationChunking(const DepGraph<SetType>& depgraph LIFETIMEBOUND, Span<const ClusterIndex> lin LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_linearization(lin)\n+    {\n+        // Mark everything in lin as todo still.\n+        for (auto i : m_linearization) m_todo.Set(i);\n+        // Compute the initial chunking.\n+        m_chunks.reserve(depgraph.TxCount());\n+        BuildChunks();\n+    }\n+\n+    /** Determine how many chunks remain in the linearization. */\n+    ClusterIndex ChunksLeft() const noexcept { return m_chunks.size(); }\n+\n+    /** Access a chunk. Chunk 0 is the highest-feerate prefix of what remains. */\n+    const SetInfo<SetType>& GetChunk(ClusterIndex n) const noexcept\n+    {\n+        Assume(n < m_chunks.size());\n+        return m_chunks[n];\n+    }\n+\n+    /** Remove some subset of transactions from the linearization. */\n+    void MarkDone(SetType subset) noexcept\n+    {\n+        Assume(subset.IsSubsetOf(m_todo));\n+        m_todo -= subset;\n+        // Rechunk what remains of m_linearization.\n+        m_chunks.clear();\n+        BuildChunks();\n+    }\n+\n+    /** Find the shortest intersection between subset and the prefixes of remaining chunks\n+     *  of the linearization that has a feerate not below best's.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 76,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e70ddafeb57e0a8fc317b44019e6a7c376e08d61",
      "in_reply_to_id": 1678356337,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-17T03:04:57Z",
      "updated_at": "2024-07-17T03:04:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680345874",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680345874"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 391,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680345931",
      "pull_request_review_id": 2181783596,
      "id": 1680345931,
      "node_id": "PRRC_kwDOABII585kKAtL",
      "diff_hunk": "@@ -253,6 +253,109 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Data structure encapsulating the chunking of a linearization, permitting removal of subsets. */\n+template<typename SetType>\n+class LinearizationChunking\n+{\n+    /** The depgraph this linearization is for. */\n+    const DepGraph<SetType>& m_depgraph;\n+\n+    /** The linearization we started from. */\n+    Span<const ClusterIndex> m_linearization;\n+\n+    /** Chunk sets and their feerates, of what remains of the linearization. */\n+    std::vector<SetInfo<SetType>> m_chunks;\n+\n+    /** Which transactions remain in the linearization. */\n+    SetType m_todo;\n+\n+    /** Fill the m_chunks variable, updating lin_done in the process. */\n+    void BuildChunks() noexcept\n+    {\n+        // Caller must clear m_chunks.\n+        Assume(m_chunks.empty());\n+\n+        // Iterate over the remaining entries in m_linearization. This is effectively the same\n+        // algorithm as ChunkLinearization, but supports skipping parts of the linearization and\n+        // keeps track of the sets themselves instead of just their feerates.\n+        for (auto idx : m_linearization) {\n+            if (!m_todo[idx]) continue;\n+            // Start with an initial chunk containing just element idx.\n+            SetInfo add(m_depgraph, idx);\n+            // Absorb existing final chunks into add while they have lower feerate.\n+            while (!m_chunks.empty() && add.feerate >> m_chunks.back().feerate) {\n+                add |= m_chunks.back();\n+                m_chunks.pop_back();\n+            }\n+            // Remember new chunk.\n+            m_chunks.push_back(std::move(add));\n+        }\n+    }\n+\n+public:\n+    /** Initialize a LinearizationSubset object for a given length of linearization. */\n+    explicit LinearizationChunking(const DepGraph<SetType>& depgraph LIFETIMEBOUND, Span<const ClusterIndex> lin LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_linearization(lin)\n+    {\n+        // Mark everything in lin as todo still.\n+        for (auto i : m_linearization) m_todo.Set(i);\n+        // Compute the initial chunking.\n+        m_chunks.reserve(depgraph.TxCount());\n+        BuildChunks();\n+    }\n+\n+    /** Determine how many chunks remain in the linearization. */\n+    ClusterIndex ChunksLeft() const noexcept { return m_chunks.size(); }\n+\n+    /** Access a chunk. Chunk 0 is the highest-feerate prefix of what remains. */\n+    const SetInfo<SetType>& GetChunk(ClusterIndex n) const noexcept\n+    {\n+        Assume(n < m_chunks.size());\n+        return m_chunks[n];\n+    }\n+\n+    /** Remove some subset of transactions from the linearization. */\n+    void MarkDone(SetType subset) noexcept\n+    {\n+        Assume(subset.IsSubsetOf(m_todo));\n+        m_todo -= subset;\n+        // Rechunk what remains of m_linearization.\n+        m_chunks.clear();\n+        BuildChunks();\n+    }\n+\n+    /** Find the shortest intersection between subset and the prefixes of remaining chunks\n+     *  of the linearization that has a feerate not below best's.\n+     *\n+     * This is a crucial operation in guaranteeing improvements to linearizations. The set\n+     * returned by this function, when moved to the front of (what remains of) the linearization,\n+     * is guaranteed not to make the linearization worse.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 80,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e70ddafeb57e0a8fc317b44019e6a7c376e08d61",
      "in_reply_to_id": 1679851817,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-17T03:05:04Z",
      "updated_at": "2024-07-17T03:05:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680345931",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680345931"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 395,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680345987",
      "pull_request_review_id": 2181783677,
      "id": 1680345987,
      "node_id": "PRRC_kwDOABII585kKAuD",
      "diff_hunk": "@@ -253,6 +253,109 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Data structure encapsulating the chunking of a linearization, permitting removal of subsets. */\n+template<typename SetType>\n+class LinearizationChunking\n+{\n+    /** The depgraph this linearization is for. */\n+    const DepGraph<SetType>& m_depgraph;\n+\n+    /** The linearization we started from. */\n+    Span<const ClusterIndex> m_linearization;\n+\n+    /** Chunk sets and their feerates, of what remains of the linearization. */\n+    std::vector<SetInfo<SetType>> m_chunks;\n+\n+    /** Which transactions remain in the linearization. */\n+    SetType m_todo;\n+\n+    /** Fill the m_chunks variable, updating lin_done in the process. */\n+    void BuildChunks() noexcept\n+    {\n+        // Caller must clear m_chunks.\n+        Assume(m_chunks.empty());\n+\n+        // Iterate over the remaining entries in m_linearization. This is effectively the same\n+        // algorithm as ChunkLinearization, but supports skipping parts of the linearization and\n+        // keeps track of the sets themselves instead of just their feerates.\n+        for (auto idx : m_linearization) {\n+            if (!m_todo[idx]) continue;\n+            // Start with an initial chunk containing just element idx.\n+            SetInfo add(m_depgraph, idx);\n+            // Absorb existing final chunks into add while they have lower feerate.\n+            while (!m_chunks.empty() && add.feerate >> m_chunks.back().feerate) {\n+                add |= m_chunks.back();\n+                m_chunks.pop_back();\n+            }\n+            // Remember new chunk.\n+            m_chunks.push_back(std::move(add));\n+        }\n+    }\n+\n+public:\n+    /** Initialize a LinearizationSubset object for a given length of linearization. */\n+    explicit LinearizationChunking(const DepGraph<SetType>& depgraph LIFETIMEBOUND, Span<const ClusterIndex> lin LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_linearization(lin)\n+    {\n+        // Mark everything in lin as todo still.\n+        for (auto i : m_linearization) m_todo.Set(i);\n+        // Compute the initial chunking.\n+        m_chunks.reserve(depgraph.TxCount());\n+        BuildChunks();\n+    }\n+\n+    /** Determine how many chunks remain in the linearization. */\n+    ClusterIndex ChunksLeft() const noexcept { return m_chunks.size(); }",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 56,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e70ddafeb57e0a8fc317b44019e6a7c376e08d61",
      "in_reply_to_id": 1679854169,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-17T03:05:11Z",
      "updated_at": "2024-07-17T03:05:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680345987",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680345987"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680346568",
      "pull_request_review_id": 2181784435,
      "id": 1680346568,
      "node_id": "PRRC_kwDOABII585kKA3I",
      "diff_hunk": "@@ -496,6 +496,103 @@ FUZZ_TARGET(clusterlin_search_finder)\n     assert(anc_finder.AllDone());\n }\n \n+FUZZ_TARGET(clusterlin_linearization_chunking)\n+{\n+    // Verify the behavior of LinearizationChunking.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a topologically-valid subset of depgraph.\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    auto subset = SetInfo(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+    // Retrieve a valid linearization for depgraph.\n+    auto linearization = ReadLinearization(depgraph, reader);\n+\n+    // Construct a LinearizationChunking object, initially for the whole linearization.\n+    LinearizationChunking chunking(depgraph, linearization);\n+\n+    // Remove piece by piece of the linearization in the chunking object, and check various\n+    // properties at every step.\n+    while (todo.Any()) {\n+        assert(chunking.ChunksLeft() > 0);\n+\n+        // Construct linearization with just todo.\n+        std::vector<ClusterIndex> linearization_left;\n+        for (auto i : linearization) {\n+            if (todo[i]) linearization_left.push_back(i);\n+        }\n+\n+        // Compute the chunking for linearization_left.\n+        auto chunking_left = ChunkLinearization(depgraph, linearization_left);\n+\n+        // Verify that it matches the chunks of chunking.\n+        assert(chunking.ChunksLeft() == chunking_left.size());\n+        for (ClusterIndex i = 0; i < chunking.ChunksLeft(); ++i) {\n+            assert(chunking.GetChunk(i).feerate == chunking_left[i]);\n+        }\n+\n+        // Check consistency of chunking.\n+        TestBitSet combined;\n+        for (ClusterIndex i = 0; i < chunking.ChunksLeft(); ++i) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 47,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e70ddafeb57e0a8fc317b44019e6a7c376e08d61",
      "in_reply_to_id": 1679896517,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, and added more consistency checks on top (chunks must be non-empty, match the highest-feerate remaining prefix, and be topological).",
      "created_at": "2024-07-17T03:06:20Z",
      "updated_at": "2024-07-17T03:06:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680346568",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680346568"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 582,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680347774",
      "pull_request_review_id": 2181786226,
      "id": 1680347774,
      "node_id": "PRRC_kwDOABII585kKBJ-",
      "diff_hunk": "@@ -320,6 +351,7 @@ FUZZ_TARGET(clusterlin_chunking)\n     try {\n         reader >> Using<DepGraphFormatter>(depgraph);\n     } catch (const std::ios_base::failure&) {}\n+    MakeConnected(depgraph);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 49,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "c192b30156ae41638291010b40b874479ea1943c",
      "in_reply_to_id": 1679955057,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good question.\r\n\r\nClusters, as intended to be used by the mempool/txgraph code, are always connected (if not, they'd be separate clusters), but nothing actually relies on this property, so all cluster_linearization tests should pass even with non-connecting clusters. I believe that earlier it was helpful to forcefully make all clusters for most fuzz tests connected, as this helped the fuzzer find extreme cases, though I have not tested this recently.\r\n\r\nThis is also the reason why this commit is in the PR to begin with. If it's controversial, I'm happy to just move it to #30286.",
      "created_at": "2024-07-17T03:08:57Z",
      "updated_at": "2024-07-17T03:08:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1680347774",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680347774"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681134991",
      "pull_request_review_id": 2183063694,
      "id": 1681134991,
      "node_id": "PRRC_kwDOABII585kNBWP",
      "diff_hunk": "@@ -253,6 +253,109 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Data structure encapsulating the chunking of a linearization, permitting removal of subsets. */\n+template<typename SetType>\n+class LinearizationChunking\n+{\n+    /** The depgraph this linearization is for. */\n+    const DepGraph<SetType>& m_depgraph;\n+\n+    /** The linearization we started from. */\n+    Span<const ClusterIndex> m_linearization;\n+\n+    /** Chunk sets and their feerates, of what remains of the linearization. */\n+    std::vector<SetInfo<SetType>> m_chunks;\n+\n+    /** Which transactions remain in the linearization. */\n+    SetType m_todo;\n+\n+    /** Fill the m_chunks variable, updating lin_done in the process. */\n+    void BuildChunks() noexcept\n+    {\n+        // Caller must clear m_chunks.\n+        Assume(m_chunks.empty());\n+\n+        // Iterate over the remaining entries in m_linearization. This is effectively the same\n+        // algorithm as ChunkLinearization, but supports skipping parts of the linearization and\n+        // keeps track of the sets themselves instead of just their feerates.\n+        for (auto idx : m_linearization) {\n+            if (!m_todo[idx]) continue;\n+            // Start with an initial chunk containing just element idx.\n+            SetInfo add(m_depgraph, idx);\n+            // Absorb existing final chunks into add while they have lower feerate.\n+            while (!m_chunks.empty() && add.feerate >> m_chunks.back().feerate) {\n+                add |= m_chunks.back();\n+                m_chunks.pop_back();\n+            }\n+            // Remember new chunk.\n+            m_chunks.push_back(std::move(add));\n+        }\n+    }\n+\n+public:\n+    /** Initialize a LinearizationSubset object for a given length of linearization. */\n+    explicit LinearizationChunking(const DepGraph<SetType>& depgraph LIFETIMEBOUND, Span<const ClusterIndex> lin LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_linearization(lin)\n+    {\n+        // Mark everything in lin as todo still.\n+        for (auto i : m_linearization) m_todo.Set(i);\n+        // Compute the initial chunking.\n+        m_chunks.reserve(depgraph.TxCount());\n+        BuildChunks();\n+    }\n+\n+    /** Determine how many chunks remain in the linearization. */\n+    ClusterIndex ChunksLeft() const noexcept { return m_chunks.size(); }\n+\n+    /** Access a chunk. Chunk 0 is the highest-feerate prefix of what remains. */\n+    const SetInfo<SetType>& GetChunk(ClusterIndex n) const noexcept\n+    {\n+        Assume(n < m_chunks.size());\n+        return m_chunks[n];\n+    }\n+\n+    /** Remove some subset of transactions from the linearization. */\n+    void MarkDone(SetType subset) noexcept\n+    {\n+        Assume(subset.IsSubsetOf(m_todo));\n+        m_todo -= subset;\n+        // Rechunk what remains of m_linearization.\n+        m_chunks.clear();\n+        BuildChunks();\n+    }\n+\n+    /** Find the shortest intersection between subset and the prefixes of remaining chunks\n+     *  of the linearization that has a feerate not below best's.\n+     *\n+     * This is a crucial operation in guaranteeing improvements to linearizations. The set\n+     * returned by this function, when moved to the front of (what remains of) the linearization,\n+     * is guaranteed not to make the linearization worse.\n+     *\n+     * See https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032 for background.\n+     */\n+    SetInfo<SetType> Intersect(const SetInfo<SetType>& subset) const noexcept\n+    {\n+        Assume(subset.transactions.IsSubsetOf(m_todo));\n+        SetInfo<SetType> accumulator;\n+        // Iterate over all chunks of the remaining linearization.\n+        for (ClusterIndex i = 0; i < ChunksLeft(); ++i) {\n+            // Find what (if any) intersection the chunk has with subset.\n+            const SetType to_add = GetChunk(i).transactions & subset.transactions;\n+            if (to_add.Any()) {\n+                // If adding that to accumulator makes us hit all of subset, we are done as no\n+                // shorter intersection with higher/equal feerate exists.\n+                accumulator.transactions |= to_add;\n+                if (accumulator.transactions == subset.transactions) break;\n+                // Otherwise update the accumulator feerate.\n+                accumulator.feerate += m_depgraph.FeeRate(to_add);\n+                // If that does result in something better, return that.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 99,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e70ddafeb57e0a8fc317b44019e6a7c376e08d61",
      "in_reply_to_id": 1679874099,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> returning subset in this case would not be correct, as it's possible that a bigger intersection still has a higher feerate.\r\n\r\nAh I had forgotten this fact, makes total sense because it doesn't hurt to just stop here. In fact I think it makes the logic simpler since you don't have to remember this match for later if you fail to find anything \"better\".",
      "created_at": "2024-07-17T14:13:26Z",
      "updated_at": "2024-07-17T14:33:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681134991",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681134991"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 414,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681140016",
      "pull_request_review_id": 2183072102,
      "id": 1681140016,
      "node_id": "PRRC_kwDOABII585kNCkw",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * their correct position on deserialization.\n+ *\n+ * - For each transaction t in the DepGraph (in some topological order);\n+ *   - The size: VARINT(t.size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(t.fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for every parent p of t, in order of most recently serialized to least\n+ *     recently serialized:\n+ *     - VARINT(diff), where diff is the number of transactions between p and the previous parent\n+ *       (excluding transactions which are already known to be ancestors of t) which were not\n+ *       parents of t.\n+ *   - The position: VARINT(diff), where diff is the sum of the number of skipped transactions\n+ *     after the last parent, and the distance from the end of the transaction list where to insert\n+ *     t (distance=0 means at the very end, distance=1 means 1 before the end, etc). On\n+ *     deserialization, overflow here is interpreted as wrapping around.\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents emitted in reverse order compared to the transactions themselves? This\n+ *   naturally lets us skip parents-of-parents.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 1 bytes per transaction for dependencies in this case,\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** Construct a topological order to serialize the transactions in. */\n+        std::vector<ClusterIndex> topo_order(depgraph.TxCount());\n+        std::iota(topo_order.begin(), topo_order.end(), ClusterIndex{0});\n+        std::sort(topo_order.begin(), topo_order.end(), [&](ClusterIndex a, ClusterIndex b) {\n+            auto anc_a = depgraph.Ancestors(a).Count(), anc_b = depgraph.Ancestors(b).Count();\n+            if (anc_a != anc_b) return anc_a < anc_b;\n+            return a < b;\n+        });\n+\n+        /** Which transactions the deserializer already knows when it has deserialized what has\n+         *  has been serialized here so far, and in what order. */\n+        std::vector<ClusterIndex> rebuilt_order;\n+        rebuilt_order.reserve(depgraph.TxCount());\n+\n+        // Loop over the transactions in topological order.\n+        for (ClusterIndex topo_idx = 0; topo_idx < topo_order.size(); ++topo_idx) {\n+            /** Which depgraph index we are currently writing. */\n+            ClusterIndex idx = topo_order[topo_idx];\n+            // Write size, which must be larger than 0.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee, encoded as an unsigned varint (odd=negative, even=non-negative).\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            SetType written_parents;\n+            uint64_t diff = 0; //!< How many potential parent/child relations we have skipped over.\n+            for (ClusterIndex dep_dist = 0; dep_dist < topo_idx; ++dep_dist) {\n+                /** Which depgraph index we are currently considering as parent of idx. */\n+                ClusterIndex dep_idx = topo_order[topo_idx - 1 - dep_dist];\n+                // Ignore transactions which are already known to be ancestors.\n+                if (depgraph.Descendants(dep_idx).Overlaps(written_parents)) continue;\n+                if (depgraph.Ancestors(idx)[dep_idx]) {\n+                    // When an actual parent is encounted, encode how many non-parents were skipped\n+                    // before it.\n+                    s << VARINT(diff);\n+                    diff = 0;\n+                    written_parents.Set(dep_idx);\n+                } else {\n+                    // When a non-parent is encountered, increment the skip counter.\n+                    ++diff;\n+                }\n+            }\n+            // Write position information.\n+            ClusterIndex insert_distance = 0;\n+            while (insert_distance < rebuilt_order.size()) {\n+                // Loop to find how far from the end in rebuilt_order to insert.\n+                if (idx > *(rebuilt_order.end() - 1 - insert_distance)) break;\n+                ++insert_distance;\n+            }\n+            rebuilt_order.insert(rebuilt_order.end() - insert_distance, idx);\n+            s << VARINT(diff + insert_distance);",
      "path": "src/test/util/cluster_linearize.h",
      "position": 176,
      "original_position": 146,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": 1678263149,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Don't go out of your way for now, this may just be a mental block for myself only. I worked out some examples myself and it works, I just can't mentally model the skipping somehow.",
      "created_at": "2024-07-17T14:16:44Z",
      "updated_at": "2024-07-17T14:16:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681140016",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681140016"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 176,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681159878",
      "pull_request_review_id": 2183104706,
      "id": 1681159878,
      "node_id": "PRRC_kwDOABII585kNHbG",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * their correct position on deserialization.\n+ *\n+ * - For each transaction t in the DepGraph (in some topological order);\n+ *   - The size: VARINT(t.size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(t.fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for every parent p of t, in order of most recently serialized to least\n+ *     recently serialized:\n+ *     - VARINT(diff), where diff is the number of transactions between p and the previous parent\n+ *       (excluding transactions which are already known to be ancestors of t) which were not\n+ *       parents of t.\n+ *   - The position: VARINT(diff), where diff is the sum of the number of skipped transactions\n+ *     after the last parent, and the distance from the end of the transaction list where to insert\n+ *     t (distance=0 means at the very end, distance=1 means 1 before the end, etc). On\n+ *     deserialization, overflow here is interpreted as wrapping around.\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents emitted in reverse order compared to the transactions themselves? This\n+ *   naturally lets us skip parents-of-parents.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 1 bytes per transaction for dependencies in this case,\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** Construct a topological order to serialize the transactions in. */\n+        std::vector<ClusterIndex> topo_order(depgraph.TxCount());\n+        std::iota(topo_order.begin(), topo_order.end(), ClusterIndex{0});\n+        std::sort(topo_order.begin(), topo_order.end(), [&](ClusterIndex a, ClusterIndex b) {\n+            auto anc_a = depgraph.Ancestors(a).Count(), anc_b = depgraph.Ancestors(b).Count();\n+            if (anc_a != anc_b) return anc_a < anc_b;\n+            return a < b;\n+        });\n+\n+        /** Which transactions the deserializer already knows when it has deserialized what has\n+         *  has been serialized here so far, and in what order. */\n+        std::vector<ClusterIndex> rebuilt_order;\n+        rebuilt_order.reserve(depgraph.TxCount());\n+\n+        // Loop over the transactions in topological order.\n+        for (ClusterIndex topo_idx = 0; topo_idx < topo_order.size(); ++topo_idx) {\n+            /** Which depgraph index we are currently writing. */\n+            ClusterIndex idx = topo_order[topo_idx];\n+            // Write size, which must be larger than 0.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee, encoded as an unsigned varint (odd=negative, even=non-negative).\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            SetType written_parents;\n+            uint64_t diff = 0; //!< How many potential parent/child relations we have skipped over.\n+            for (ClusterIndex dep_dist = 0; dep_dist < topo_idx; ++dep_dist) {\n+                /** Which depgraph index we are currently considering as parent of idx. */\n+                ClusterIndex dep_idx = topo_order[topo_idx - 1 - dep_dist];\n+                // Ignore transactions which are already known to be ancestors.\n+                if (depgraph.Descendants(dep_idx).Overlaps(written_parents)) continue;\n+                if (depgraph.Ancestors(idx)[dep_idx]) {\n+                    // When an actual parent is encounted, encode how many non-parents were skipped\n+                    // before it.\n+                    s << VARINT(diff);\n+                    diff = 0;\n+                    written_parents.Set(dep_idx);\n+                } else {\n+                    // When a non-parent is encountered, increment the skip counter.\n+                    ++diff;\n+                }\n+            }\n+            // Write position information.\n+            ClusterIndex insert_distance = 0;\n+            while (insert_distance < rebuilt_order.size()) {\n+                // Loop to find how far from the end in rebuilt_order to insert.\n+                if (idx > *(rebuilt_order.end() - 1 - insert_distance)) break;\n+                ++insert_distance;\n+            }\n+            rebuilt_order.insert(rebuilt_order.end() - insert_distance, idx);\n+            s << VARINT(diff + insert_distance);\n+        }\n+\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        /** The dependency graph which we deserialize into first, with transactions in\n+         *  topological serialization order, not original cluster order. */\n+        DepGraph<SetType> topo_depgraph;\n+        /** Mapping from cluster order to serialization order, used later to reconstruct the\n+         *  cluster order. */\n+        std::vector<ClusterIndex> reordering;\n+\n+        // Read transactions in topological order.\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            static_assert(0x3FFFFF >= 4000000);\n+            if (size == 0 || topo_depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as an unsigned varint (odd=negative, even=non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            static_assert(0xFFFFFFFFFFFFF > uint64_t{2} * 21000000 * 100000000);\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend topo_depgraph with the new transaction (at the end).\n+            auto topo_idx = topo_depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t diff = 0; //!< How many potential parents we have to skip.\n+            s >> VARINT(diff);\n+            for (ClusterIndex dep_dist = 0; dep_dist < topo_idx; ++dep_dist) {\n+                /** Which topo_depgraph index we are currently considering as parent of topo_idx. */\n+                ClusterIndex dep_topo_idx = topo_idx - 1 - dep_dist;\n+                // Ignore transactions which are already known ancestors of topo_idx.\n+                if (topo_depgraph.Descendants(dep_topo_idx)[topo_idx]) continue;\n+                if (diff == 0) {\n+                    // When the skip counter has reached 0, add an actual dependency.\n+                    topo_depgraph.AddDependency(dep_topo_idx, topo_idx);\n+                    // And read the number of skips after it.\n+                    s >> VARINT(diff);\n+                } else {\n+                    // Otherwise, dep_topo_idx is not a parent. Decrement and continue.\n+                    --diff;\n+                }\n+            }\n+            // Read position information, interpreting the remaining skip value as wrapping around.\n+            reordering.insert(reordering.end() - (diff % (reordering.size() + 1)), topo_idx);\n+        }\n+\n+        // Construct the original cluster order depgraph.\n+        depgraph = {};\n+        for (ClusterIndex idx = 0; idx < reordering.size(); ++idx) {\n+            // Add transactions to depgraph in the original cluster order.\n+            ClusterIndex topo_idx = reordering[idx];\n+            depgraph.AddTransaction(topo_depgraph.FeeRate(topo_idx));\n+        }\n+        for (ClusterIndex idx = 0; idx < reordering.size(); ++idx) {",
      "path": "src/test/util/cluster_linearize.h",
      "position": 245,
      "original_position": 208,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": 1678277812,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "oh whoops, wrong one. I meant for the loop above!",
      "created_at": "2024-07-17T14:28:43Z",
      "updated_at": "2024-07-17T14:28:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681159878",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681159878"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 245,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681165800",
      "pull_request_review_id": 2183114395,
      "id": 1681165800,
      "node_id": "PRRC_kwDOABII585kNI3o",
      "diff_hunk": "@@ -320,6 +351,7 @@ FUZZ_TARGET(clusterlin_chunking)\n     try {\n         reader >> Using<DepGraphFormatter>(depgraph);\n     } catch (const std::ios_base::failure&) {}\n+    MakeConnected(depgraph);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 49,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "c192b30156ae41638291010b40b874479ea1943c",
      "in_reply_to_id": 1679955057,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm not particularly bothered by it for the reasons you mentioned. I'll let others weigh in.",
      "created_at": "2024-07-17T14:32:01Z",
      "updated_at": "2024-07-17T14:32:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681165800",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681165800"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681170920",
      "pull_request_review_id": 2183122576,
      "id": 1681170920,
      "node_id": "PRRC_kwDOABII585kNKHo",
      "diff_hunk": "@@ -351,7 +352,8 @@ class SearchCandidateFinder\n         };\n \n         /** The queue of work items. */\n-        std::vector<WorkItem> queue;\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));",
      "path": "src/cluster_linearize.h",
      "position": 548,
      "original_position": 14,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": 1651302872,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> The way the bound was computed was inaccurate; I have fixed that\r\n\r\nI'm unsure where the mis-estimate was or how it was fixed.",
      "created_at": "2024-07-17T14:35:08Z",
      "updated_at": "2024-07-17T14:35:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681170920",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681170920"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 548,
      "original_line": 548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681178728",
      "pull_request_review_id": 2183136164,
      "id": 1681178728,
      "node_id": "PRRC_kwDOABII585kNMBo",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * their correct position on deserialization.\n+ *\n+ * - For each transaction t in the DepGraph (in some topological order);\n+ *   - The size: VARINT(t.size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(t.fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for every parent p of t, in order of most recently serialized to least\n+ *     recently serialized:\n+ *     - VARINT(diff), where diff is the number of transactions between p and the previous parent\n+ *       (excluding transactions which are already known to be ancestors of t) which were not\n+ *       parents of t.\n+ *   - The position: VARINT(diff), where diff is the sum of the number of skipped transactions\n+ *     after the last parent, and the distance from the end of the transaction list where to insert\n+ *     t (distance=0 means at the very end, distance=1 means 1 before the end, etc). On\n+ *     deserialization, overflow here is interpreted as wrapping around.\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents emitted in reverse order compared to the transactions themselves? This\n+ *   naturally lets us skip parents-of-parents.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 1 bytes per transaction for dependencies in this case,\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** Construct a topological order to serialize the transactions in. */\n+        std::vector<ClusterIndex> topo_order(depgraph.TxCount());\n+        std::iota(topo_order.begin(), topo_order.end(), ClusterIndex{0});\n+        std::sort(topo_order.begin(), topo_order.end(), [&](ClusterIndex a, ClusterIndex b) {\n+            auto anc_a = depgraph.Ancestors(a).Count(), anc_b = depgraph.Ancestors(b).Count();\n+            if (anc_a != anc_b) return anc_a < anc_b;\n+            return a < b;\n+        });\n+\n+        /** Which transactions the deserializer already knows when it has deserialized what has\n+         *  has been serialized here so far, and in what order. */\n+        std::vector<ClusterIndex> rebuilt_order;\n+        rebuilt_order.reserve(depgraph.TxCount());\n+\n+        // Loop over the transactions in topological order.\n+        for (ClusterIndex topo_idx = 0; topo_idx < topo_order.size(); ++topo_idx) {\n+            /** Which depgraph index we are currently writing. */\n+            ClusterIndex idx = topo_order[topo_idx];\n+            // Write size, which must be larger than 0.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee, encoded as an unsigned varint (odd=negative, even=non-negative).\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            SetType written_parents;\n+            uint64_t diff = 0; //!< How many potential parent/child relations we have skipped over.\n+            for (ClusterIndex dep_dist = 0; dep_dist < topo_idx; ++dep_dist) {\n+                /** Which depgraph index we are currently considering as parent of idx. */\n+                ClusterIndex dep_idx = topo_order[topo_idx - 1 - dep_dist];\n+                // Ignore transactions which are already known to be ancestors.\n+                if (depgraph.Descendants(dep_idx).Overlaps(written_parents)) continue;\n+                if (depgraph.Ancestors(idx)[dep_idx]) {\n+                    // When an actual parent is encounted, encode how many non-parents were skipped\n+                    // before it.\n+                    s << VARINT(diff);\n+                    diff = 0;\n+                    written_parents.Set(dep_idx);\n+                } else {\n+                    // When a non-parent is encountered, increment the skip counter.\n+                    ++diff;\n+                }\n+            }\n+            // Write position information.\n+            ClusterIndex insert_distance = 0;\n+            while (insert_distance < rebuilt_order.size()) {\n+                // Loop to find how far from the end in rebuilt_order to insert.\n+                if (idx > *(rebuilt_order.end() - 1 - insert_distance)) break;\n+                ++insert_distance;\n+            }\n+            rebuilt_order.insert(rebuilt_order.end() - insert_distance, idx);\n+            s << VARINT(diff + insert_distance);",
      "path": "src/test/util/cluster_linearize.h",
      "position": 176,
      "original_position": 146,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": 1678263149,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Let me try to explain here. If it helps you, that may be a reason to incorporate it as a comment.\r\n\r\nOverall the serialization format consists of:\r\n* For each transaction:\r\n  * VARINT(size)\r\n  * VARINT(fee)\r\n  * List of VARINTs that are the number of skipped options (see below), encoding dependencies and position.\r\n* VARINT(0)\r\n\r\nLet's say you have a 7-transaction cluster, consisting of transactions F,A,C,B,G,E,D, but serialized in order A,B,C,D,E,F,G, because that's a topological ordering. By the time G gets serialized, what has been serialized already represents the cluster F,A,C,B,E,D (in that order). Let's say G has B and E as parents, and that E depends on C.\r\n\r\nThink of the skip-VARINTs as encoding the following:\r\n\r\n```\r\n[G->F] [G->E] [G->D] [G->B] [G->A] [...,D,G] [...,E,G,D] [...,B,G,E,...] [...,C,G,B,...] ...\r\n        ####          ####                                #############\r\n<-1-->        <-1-->        <-------------3------------>\r\n```\r\n\r\nThus the encoded \"skip\" VARINTs are, in order: 1, 1, 3. No further VARINT is needed after the 3, because there can only be one insertion position for G. Also note that `[G->C]` is not included in the list, as it is implied by the included `G->E` and `E->C` that came before it\r\n\r\n\r\n",
      "created_at": "2024-07-17T14:39:45Z",
      "updated_at": "2024-07-17T14:39:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681178728",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681178728"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 176,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681266250",
      "pull_request_review_id": 2183284736,
      "id": 1681266250,
      "node_id": "PRRC_kwDOABII585kNhZK",
      "diff_hunk": "@@ -351,7 +352,8 @@ class SearchCandidateFinder\n         };\n \n         /** The queue of work items. */\n-        std::vector<WorkItem> queue;\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));",
      "path": "src/cluster_linearize.h",
      "position": 548,
      "original_position": 14,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": 1651302872,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The current condition (for using DFS) is:\r\n\r\n```c++\r\nwhile (queue.size() - 1 + queue.front().und.Count() > queue.capacity()) {\r\n```\r\n\r\nIn the original version of this PR it was:\r\n\r\n```c++\r\nconst auto queuesize_for_front = queue.capacity() - queue.front().und.Count();\r\n...\r\nwhile (queue.size() > queuesize_for_front) {\r\n```\r\n\r\nThere is an offset 1 difference between the two; it didn't take into account that choosing BFS would first delete an entry from the queue before adding new ones.",
      "created_at": "2024-07-17T15:31:47Z",
      "updated_at": "2024-07-17T15:31:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681266250",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681266250"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 548,
      "original_line": 548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681267687",
      "pull_request_review_id": 2183286991,
      "id": 1681267687,
      "node_id": "PRRC_kwDOABII585kNhvn",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * their correct position on deserialization.\n+ *\n+ * - For each transaction t in the DepGraph (in some topological order);\n+ *   - The size: VARINT(t.size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(t.fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for every parent p of t, in order of most recently serialized to least\n+ *     recently serialized:\n+ *     - VARINT(diff), where diff is the number of transactions between p and the previous parent\n+ *       (excluding transactions which are already known to be ancestors of t) which were not\n+ *       parents of t.\n+ *   - The position: VARINT(diff), where diff is the sum of the number of skipped transactions\n+ *     after the last parent, and the distance from the end of the transaction list where to insert\n+ *     t (distance=0 means at the very end, distance=1 means 1 before the end, etc). On\n+ *     deserialization, overflow here is interpreted as wrapping around.\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents emitted in reverse order compared to the transactions themselves? This\n+ *   naturally lets us skip parents-of-parents.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 1 bytes per transaction for dependencies in this case,\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** Construct a topological order to serialize the transactions in. */\n+        std::vector<ClusterIndex> topo_order(depgraph.TxCount());\n+        std::iota(topo_order.begin(), topo_order.end(), ClusterIndex{0});\n+        std::sort(topo_order.begin(), topo_order.end(), [&](ClusterIndex a, ClusterIndex b) {\n+            auto anc_a = depgraph.Ancestors(a).Count(), anc_b = depgraph.Ancestors(b).Count();\n+            if (anc_a != anc_b) return anc_a < anc_b;\n+            return a < b;\n+        });\n+\n+        /** Which transactions the deserializer already knows when it has deserialized what has\n+         *  has been serialized here so far, and in what order. */\n+        std::vector<ClusterIndex> rebuilt_order;\n+        rebuilt_order.reserve(depgraph.TxCount());\n+\n+        // Loop over the transactions in topological order.\n+        for (ClusterIndex topo_idx = 0; topo_idx < topo_order.size(); ++topo_idx) {\n+            /** Which depgraph index we are currently writing. */\n+            ClusterIndex idx = topo_order[topo_idx];\n+            // Write size, which must be larger than 0.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee, encoded as an unsigned varint (odd=negative, even=non-negative).\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            SetType written_parents;\n+            uint64_t diff = 0; //!< How many potential parent/child relations we have skipped over.\n+            for (ClusterIndex dep_dist = 0; dep_dist < topo_idx; ++dep_dist) {\n+                /** Which depgraph index we are currently considering as parent of idx. */\n+                ClusterIndex dep_idx = topo_order[topo_idx - 1 - dep_dist];\n+                // Ignore transactions which are already known to be ancestors.\n+                if (depgraph.Descendants(dep_idx).Overlaps(written_parents)) continue;\n+                if (depgraph.Ancestors(idx)[dep_idx]) {\n+                    // When an actual parent is encounted, encode how many non-parents were skipped\n+                    // before it.\n+                    s << VARINT(diff);\n+                    diff = 0;\n+                    written_parents.Set(dep_idx);\n+                } else {\n+                    // When a non-parent is encountered, increment the skip counter.\n+                    ++diff;\n+                }\n+            }\n+            // Write position information.\n+            ClusterIndex insert_distance = 0;\n+            while (insert_distance < rebuilt_order.size()) {\n+                // Loop to find how far from the end in rebuilt_order to insert.\n+                if (idx > *(rebuilt_order.end() - 1 - insert_distance)) break;\n+                ++insert_distance;\n+            }\n+            rebuilt_order.insert(rebuilt_order.end() - insert_distance, idx);\n+            s << VARINT(diff + insert_distance);",
      "path": "src/test/util/cluster_linearize.h",
      "position": 176,
      "original_position": 146,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": 1678263149,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yes this was very insightful, thank you",
      "created_at": "2024-07-17T15:32:47Z",
      "updated_at": "2024-07-17T15:32:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681267687",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681267687"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 176,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681676666",
      "pull_request_review_id": 2183948520,
      "id": 1681676666,
      "node_id": "PRRC_kwDOABII585kPFl6",
      "diff_hunk": "@@ -112,6 +127,23 @@ void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n     });\n }\n \n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort/LIMO.",
      "path": "src/bench/cluster_linearize.cpp",
      "position": null,
      "original_position": 42,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2003bb8a279c8891e55bab190ca36f0c6c8697ea",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "this isn't making the trivial linear graph",
      "created_at": "2024-07-17T20:17:09Z",
      "updated_at": "2024-07-17T20:17:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681676666",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681676666"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681678886",
      "pull_request_review_id": 2183951716,
      "id": 1681678886,
      "node_id": "PRRC_kwDOABII585kPGIm",
      "diff_hunk": "@@ -112,6 +127,23 @@ void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n     });\n }\n \n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort/LIMO.\n+ *\n+ * Its goal is measuring how much time improving a linearization may take without any search\n+ * iterations, similar to the previous function.\n+ */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCaseLIMO(ClusterIndex ntx, benchmark::Bench& bench)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 161,
      "original_position": 48,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2003bb8a279c8891e55bab190ca36f0c6c8697ea",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why is this benchmark \"LIMO\" but not `BenchLinearizeNoItersWorstCaseAnc`?",
      "created_at": "2024-07-17T20:18:34Z",
      "updated_at": "2024-07-17T20:18:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681678886",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681678886"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 161,
      "original_line": 161,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681682373",
      "pull_request_review_id": 2183957817,
      "id": 1681682373,
      "node_id": "PRRC_kwDOABII585kPG_F",
      "diff_hunk": "@@ -323,9 +331,21 @@ class LinearizationChunking\n         Assume(subset.Any());\n         Assume(subset.IsSubsetOf(m_todo));\n         m_todo -= subset;\n-        // Rechunk what remains of m_linearization.\n-        m_chunks.clear();\n-        BuildChunks();\n+        if (GetChunk(0).transactions == subset) {",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 58,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "faf8a3bdd3f9cf795f197b413f94b8e2d0905fd9",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "re: `clusterlin: optimize rechunking in LinearizationChunking`\r\n\r\nbenchmark doesn't seem to show much improvement for this change. I understood this as purely an efficiency improvement which should be reflected in bench results?\r\n\r\n",
      "created_at": "2024-07-17T20:20:52Z",
      "updated_at": "2024-07-17T20:20:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681682373",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681682373"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 334,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681705464",
      "pull_request_review_id": 2183991314,
      "id": 1681705464,
      "node_id": "PRRC_kwDOABII585kPMn4",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * their correct position on deserialization.\n+ *\n+ * - For each transaction t in the DepGraph (in some topological order);\n+ *   - The size: VARINT(t.size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(t.fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for every parent p of t, in order of most recently serialized to least\n+ *     recently serialized:\n+ *     - VARINT(diff), where diff is the number of transactions between p and the previous parent\n+ *       (excluding transactions which are already known to be ancestors of t) which were not\n+ *       parents of t.\n+ *   - The position: VARINT(diff), where diff is the sum of the number of skipped transactions\n+ *     after the last parent, and the distance from the end of the transaction list where to insert\n+ *     t (distance=0 means at the very end, distance=1 means 1 before the end, etc). On\n+ *     deserialization, overflow here is interpreted as wrapping around.\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents emitted in reverse order compared to the transactions themselves? This\n+ *   naturally lets us skip parents-of-parents.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 1 bytes per transaction for dependencies in this case,\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** Construct a topological order to serialize the transactions in. */\n+        std::vector<ClusterIndex> topo_order(depgraph.TxCount());\n+        std::iota(topo_order.begin(), topo_order.end(), ClusterIndex{0});\n+        std::sort(topo_order.begin(), topo_order.end(), [&](ClusterIndex a, ClusterIndex b) {\n+            auto anc_a = depgraph.Ancestors(a).Count(), anc_b = depgraph.Ancestors(b).Count();\n+            if (anc_a != anc_b) return anc_a < anc_b;\n+            return a < b;\n+        });\n+\n+        /** Which transactions the deserializer already knows when it has deserialized what has\n+         *  has been serialized here so far, and in what order. */\n+        std::vector<ClusterIndex> rebuilt_order;\n+        rebuilt_order.reserve(depgraph.TxCount());\n+\n+        // Loop over the transactions in topological order.\n+        for (ClusterIndex topo_idx = 0; topo_idx < topo_order.size(); ++topo_idx) {\n+            /** Which depgraph index we are currently writing. */\n+            ClusterIndex idx = topo_order[topo_idx];\n+            // Write size, which must be larger than 0.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee, encoded as an unsigned varint (odd=negative, even=non-negative).\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            SetType written_parents;\n+            uint64_t diff = 0; //!< How many potential parent/child relations we have skipped over.\n+            for (ClusterIndex dep_dist = 0; dep_dist < topo_idx; ++dep_dist) {\n+                /** Which depgraph index we are currently considering as parent of idx. */\n+                ClusterIndex dep_idx = topo_order[topo_idx - 1 - dep_dist];\n+                // Ignore transactions which are already known to be ancestors.\n+                if (depgraph.Descendants(dep_idx).Overlaps(written_parents)) continue;\n+                if (depgraph.Ancestors(idx)[dep_idx]) {\n+                    // When an actual parent is encounted, encode how many non-parents were skipped\n+                    // before it.\n+                    s << VARINT(diff);\n+                    diff = 0;\n+                    written_parents.Set(dep_idx);\n+                } else {\n+                    // When a non-parent is encountered, increment the skip counter.\n+                    ++diff;\n+                }\n+            }\n+            // Write position information.\n+            ClusterIndex insert_distance = 0;\n+            while (insert_distance < rebuilt_order.size()) {\n+                // Loop to find how far from the end in rebuilt_order to insert.\n+                if (idx > *(rebuilt_order.end() - 1 - insert_distance)) break;\n+                ++insert_distance;\n+            }\n+            rebuilt_order.insert(rebuilt_order.end() - insert_distance, idx);\n+            s << VARINT(diff + insert_distance);",
      "path": "src/test/util/cluster_linearize.h",
      "position": 176,
      "original_position": 146,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": 1678263149,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I have incorporated something like this into the DepGraphFormatter comment.",
      "created_at": "2024-07-17T20:38:49Z",
      "updated_at": "2024-07-17T20:38:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681705464",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681705464"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 176,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681705729",
      "pull_request_review_id": 2183991784,
      "id": 1681705729,
      "node_id": "PRRC_kwDOABII585kPMsB",
      "diff_hunk": "@@ -253,6 +253,109 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Data structure encapsulating the chunking of a linearization, permitting removal of subsets. */\n+template<typename SetType>\n+class LinearizationChunking\n+{\n+    /** The depgraph this linearization is for. */\n+    const DepGraph<SetType>& m_depgraph;\n+\n+    /** The linearization we started from. */\n+    Span<const ClusterIndex> m_linearization;\n+\n+    /** Chunk sets and their feerates, of what remains of the linearization. */\n+    std::vector<SetInfo<SetType>> m_chunks;\n+\n+    /** Which transactions remain in the linearization. */\n+    SetType m_todo;\n+\n+    /** Fill the m_chunks variable, updating lin_done in the process. */\n+    void BuildChunks() noexcept\n+    {\n+        // Caller must clear m_chunks.\n+        Assume(m_chunks.empty());\n+\n+        // Iterate over the remaining entries in m_linearization. This is effectively the same\n+        // algorithm as ChunkLinearization, but supports skipping parts of the linearization and\n+        // keeps track of the sets themselves instead of just their feerates.\n+        for (auto idx : m_linearization) {\n+            if (!m_todo[idx]) continue;\n+            // Start with an initial chunk containing just element idx.\n+            SetInfo add(m_depgraph, idx);\n+            // Absorb existing final chunks into add while they have lower feerate.\n+            while (!m_chunks.empty() && add.feerate >> m_chunks.back().feerate) {\n+                add |= m_chunks.back();\n+                m_chunks.pop_back();\n+            }\n+            // Remember new chunk.\n+            m_chunks.push_back(std::move(add));\n+        }\n+    }\n+\n+public:\n+    /** Initialize a LinearizationSubset object for a given length of linearization. */\n+    explicit LinearizationChunking(const DepGraph<SetType>& depgraph LIFETIMEBOUND, Span<const ClusterIndex> lin LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_linearization(lin)\n+    {\n+        // Mark everything in lin as todo still.\n+        for (auto i : m_linearization) m_todo.Set(i);\n+        // Compute the initial chunking.\n+        m_chunks.reserve(depgraph.TxCount());\n+        BuildChunks();\n+    }\n+\n+    /** Determine how many chunks remain in the linearization. */\n+    ClusterIndex ChunksLeft() const noexcept { return m_chunks.size(); }\n+\n+    /** Access a chunk. Chunk 0 is the highest-feerate prefix of what remains. */\n+    const SetInfo<SetType>& GetChunk(ClusterIndex n) const noexcept\n+    {\n+        Assume(n < m_chunks.size());\n+        return m_chunks[n];\n+    }\n+\n+    /** Remove some subset of transactions from the linearization. */\n+    void MarkDone(SetType subset) noexcept\n+    {\n+        Assume(subset.IsSubsetOf(m_todo));\n+        m_todo -= subset;\n+        // Rechunk what remains of m_linearization.\n+        m_chunks.clear();\n+        BuildChunks();\n+    }\n+\n+    /** Find the shortest intersection between subset and the prefixes of remaining chunks\n+     *  of the linearization that has a feerate not below best's.\n+     *\n+     * This is a crucial operation in guaranteeing improvements to linearizations. The set\n+     * returned by this function, when moved to the front of (what remains of) the linearization,\n+     * is guaranteed not to make the linearization worse.\n+     *\n+     * See https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032 for background.\n+     */\n+    SetInfo<SetType> Intersect(const SetInfo<SetType>& subset) const noexcept\n+    {\n+        Assume(subset.transactions.IsSubsetOf(m_todo));\n+        SetInfo<SetType> accumulator;\n+        // Iterate over all chunks of the remaining linearization.\n+        for (ClusterIndex i = 0; i < ChunksLeft(); ++i) {\n+            // Find what (if any) intersection the chunk has with subset.\n+            const SetType to_add = GetChunk(i).transactions & subset.transactions;\n+            if (to_add.Any()) {\n+                // If adding that to accumulator makes us hit all of subset, we are done as no\n+                // shorter intersection with higher/equal feerate exists.\n+                accumulator.transactions |= to_add;\n+                if (accumulator.transactions == subset.transactions) break;\n+                // Otherwise update the accumulator feerate.\n+                accumulator.feerate += m_depgraph.FeeRate(to_add);\n+                // If that does result in something better, return that.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 99,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "e70ddafeb57e0a8fc317b44019e6a7c376e08d61",
      "in_reply_to_id": 1679874099,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I have added a comment to explain this briefly.",
      "created_at": "2024-07-17T20:39:04Z",
      "updated_at": "2024-07-17T20:39:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681705729",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681705729"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 414,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681706300",
      "pull_request_review_id": 2183992753,
      "id": 1681706300,
      "node_id": "PRRC_kwDOABII585kPM08",
      "diff_hunk": "@@ -320,6 +351,7 @@ FUZZ_TARGET(clusterlin_chunking)\n     try {\n         reader >> Using<DepGraphFormatter>(depgraph);\n     } catch (const std::ios_base::failure&) {}\n+    MakeConnected(depgraph);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 49,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "c192b30156ae41638291010b40b874479ea1943c",
      "in_reply_to_id": 1679955057,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I have moved the connected-component logic, together with its (now optional) usage to #30286.",
      "created_at": "2024-07-17T20:39:33Z",
      "updated_at": "2024-07-17T20:39:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681706300",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681706300"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681706478",
      "pull_request_review_id": 2183993059,
      "id": 1681706478,
      "node_id": "PRRC_kwDOABII585kPM3u",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * their correct position on deserialization.",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 41,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": 1679251068,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-17T20:39:40Z",
      "updated_at": "2024-07-17T20:39:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681706478",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681706478"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": 40,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 41,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681706944",
      "pull_request_review_id": 2183993732,
      "id": 1681706944,
      "node_id": "PRRC_kwDOABII585kPM_A",
      "diff_hunk": "@@ -112,6 +127,23 @@ void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n     });\n }\n \n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort/LIMO.",
      "path": "src/bench/cluster_linearize.cpp",
      "position": null,
      "original_position": 42,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2003bb8a279c8891e55bab190ca36f0c6c8697ea",
      "in_reply_to_id": 1681676666,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-17T20:39:52Z",
      "updated_at": "2024-07-17T20:39:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681706944",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681706944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681707363",
      "pull_request_review_id": 2183994296,
      "id": 1681707363,
      "node_id": "PRRC_kwDOABII585kPNFj",
      "diff_hunk": "@@ -112,6 +127,23 @@ void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n     });\n }\n \n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort/LIMO.\n+ *\n+ * Its goal is measuring how much time improving a linearization may take without any search\n+ * iterations, similar to the previous function.\n+ */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCaseLIMO(ClusterIndex ntx, benchmark::Bench& bench)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 161,
      "original_position": 48,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2003bb8a279c8891e55bab190ca36f0c6c8697ea",
      "in_reply_to_id": 1681678886,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't understand this comment.",
      "created_at": "2024-07-17T20:40:09Z",
      "updated_at": "2024-07-17T20:40:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681707363",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681707363"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 161,
      "original_line": 161,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681707992",
      "pull_request_review_id": 2183995118,
      "id": 1681707992,
      "node_id": "PRRC_kwDOABII585kPNPY",
      "diff_hunk": "@@ -323,9 +331,21 @@ class LinearizationChunking\n         Assume(subset.Any());\n         Assume(subset.IsSubsetOf(m_todo));\n         m_todo -= subset;\n-        // Rechunk what remains of m_linearization.\n-        m_chunks.clear();\n-        BuildChunks();\n+        if (GetChunk(0).transactions == subset) {",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 58,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "faf8a3bdd3f9cf795f197b413f94b8e2d0905fd9",
      "in_reply_to_id": 1681682373,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I have moved this optimization (it is indeed supposed to be one) to #30286.",
      "created_at": "2024-07-17T20:40:33Z",
      "updated_at": "2024-07-17T20:40:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681707992",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681707992"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 334,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681708231",
      "pull_request_review_id": 2183995476,
      "id": 1681708231,
      "node_id": "PRRC_kwDOABII585kPNTH",
      "diff_hunk": "@@ -0,0 +1,255 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * their correct position on deserialization.\n+ *\n+ * - For each transaction t in the DepGraph (in some topological order);\n+ *   - The size: VARINT(t.size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(t.fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for every parent p of t, in order of most recently serialized to least\n+ *     recently serialized:\n+ *     - VARINT(diff), where diff is the number of transactions between p and the previous parent\n+ *       (excluding transactions which are already known to be ancestors of t) which were not\n+ *       parents of t.\n+ *   - The position: VARINT(diff), where diff is the sum of the number of skipped transactions\n+ *     after the last parent, and the distance from the end of the transaction list where to insert\n+ *     t (distance=0 means at the very end, distance=1 means 1 before the end, etc). On\n+ *     deserialization, overflow here is interpreted as wrapping around.\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents emitted in reverse order compared to the transactions themselves? This\n+ *   naturally lets us skip parents-of-parents.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 1 bytes per transaction for dependencies in this case,\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** Construct a topological order to serialize the transactions in. */\n+        std::vector<ClusterIndex> topo_order(depgraph.TxCount());\n+        std::iota(topo_order.begin(), topo_order.end(), ClusterIndex{0});\n+        std::sort(topo_order.begin(), topo_order.end(), [&](ClusterIndex a, ClusterIndex b) {\n+            auto anc_a = depgraph.Ancestors(a).Count(), anc_b = depgraph.Ancestors(b).Count();\n+            if (anc_a != anc_b) return anc_a < anc_b;\n+            return a < b;\n+        });\n+\n+        /** Which transactions the deserializer already knows when it has deserialized what has\n+         *  has been serialized here so far, and in what order. */\n+        std::vector<ClusterIndex> rebuilt_order;\n+        rebuilt_order.reserve(depgraph.TxCount());\n+\n+        // Loop over the transactions in topological order.\n+        for (ClusterIndex topo_idx = 0; topo_idx < topo_order.size(); ++topo_idx) {\n+            /** Which depgraph index we are currently writing. */\n+            ClusterIndex idx = topo_order[topo_idx];\n+            // Write size, which must be larger than 0.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee, encoded as an unsigned varint (odd=negative, even=non-negative).\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            SetType written_parents;\n+            uint64_t diff = 0; //!< How many potential parent/child relations we have skipped over.\n+            for (ClusterIndex dep_dist = 0; dep_dist < topo_idx; ++dep_dist) {\n+                /** Which depgraph index we are currently considering as parent of idx. */\n+                ClusterIndex dep_idx = topo_order[topo_idx - 1 - dep_dist];\n+                // Ignore transactions which are already known to be ancestors.\n+                if (depgraph.Descendants(dep_idx).Overlaps(written_parents)) continue;\n+                if (depgraph.Ancestors(idx)[dep_idx]) {\n+                    // When an actual parent is encounted, encode how many non-parents were skipped\n+                    // before it.\n+                    s << VARINT(diff);\n+                    diff = 0;\n+                    written_parents.Set(dep_idx);\n+                } else {\n+                    // When a non-parent is encountered, increment the skip counter.\n+                    ++diff;\n+                }\n+            }\n+            // Write position information.\n+            ClusterIndex insert_distance = 0;\n+            while (insert_distance < rebuilt_order.size()) {\n+                // Loop to find how far from the end in rebuilt_order to insert.\n+                if (idx > *(rebuilt_order.end() - 1 - insert_distance)) break;\n+                ++insert_distance;\n+            }\n+            rebuilt_order.insert(rebuilt_order.end() - insert_distance, idx);\n+            s << VARINT(diff + insert_distance);\n+        }\n+\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        /** The dependency graph which we deserialize into first, with transactions in\n+         *  topological serialization order, not original cluster order. */\n+        DepGraph<SetType> topo_depgraph;\n+        /** Mapping from cluster order to serialization order, used later to reconstruct the\n+         *  cluster order. */\n+        std::vector<ClusterIndex> reordering;\n+\n+        // Read transactions in topological order.\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            static_assert(0x3FFFFF >= 4000000);\n+            if (size == 0 || topo_depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as an unsigned varint (odd=negative, even=non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            static_assert(0xFFFFFFFFFFFFF > uint64_t{2} * 21000000 * 100000000);\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend topo_depgraph with the new transaction (at the end).\n+            auto topo_idx = topo_depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t diff = 0; //!< How many potential parents we have to skip.\n+            s >> VARINT(diff);\n+            for (ClusterIndex dep_dist = 0; dep_dist < topo_idx; ++dep_dist) {\n+                /** Which topo_depgraph index we are currently considering as parent of topo_idx. */\n+                ClusterIndex dep_topo_idx = topo_idx - 1 - dep_dist;\n+                // Ignore transactions which are already known ancestors of topo_idx.\n+                if (topo_depgraph.Descendants(dep_topo_idx)[topo_idx]) continue;\n+                if (diff == 0) {\n+                    // When the skip counter has reached 0, add an actual dependency.\n+                    topo_depgraph.AddDependency(dep_topo_idx, topo_idx);\n+                    // And read the number of skips after it.\n+                    s >> VARINT(diff);\n+                } else {\n+                    // Otherwise, dep_topo_idx is not a parent. Decrement and continue.\n+                    --diff;\n+                }\n+            }\n+            // Read position information, interpreting the remaining skip value as wrapping around.\n+            reordering.insert(reordering.end() - (diff % (reordering.size() + 1)), topo_idx);\n+        }\n+\n+        // Construct the original cluster order depgraph.\n+        depgraph = {};\n+        for (ClusterIndex idx = 0; idx < reordering.size(); ++idx) {\n+            // Add transactions to depgraph in the original cluster order.\n+            ClusterIndex topo_idx = reordering[idx];\n+            depgraph.AddTransaction(topo_depgraph.FeeRate(topo_idx));\n+        }\n+        for (ClusterIndex idx = 0; idx < reordering.size(); ++idx) {",
      "path": "src/test/util/cluster_linearize.h",
      "position": 245,
      "original_position": 208,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": 1678277812,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done!",
      "created_at": "2024-07-17T20:40:45Z",
      "updated_at": "2024-07-17T20:40:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1681708231",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681708231"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 245,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1683029030",
      "pull_request_review_id": 2186148119,
      "id": 1683029030,
      "node_id": "PRRC_kwDOABII585kUPwm",
      "diff_hunk": "@@ -112,6 +127,23 @@ void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n     });\n }\n \n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort/LIMO.\n+ *\n+ * Its goal is measuring how much time improving a linearization may take without any search\n+ * iterations, similar to the previous function.\n+ */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCaseLIMO(ClusterIndex ntx, benchmark::Bench& bench)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 161,
      "original_position": 48,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2003bb8a279c8891e55bab190ca36f0c6c8697ea",
      "in_reply_to_id": 1681678886,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Both benchmarks are doing LIMO with ancestor sort, right? The only difference is in cluster shape.",
      "created_at": "2024-07-18T15:13:13Z",
      "updated_at": "2024-07-18T15:13:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1683029030",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1683029030"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 161,
      "original_line": 161,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1683032146",
      "pull_request_review_id": 2186152842,
      "id": 1683032146,
      "node_id": "PRRC_kwDOABII585kUQhS",
      "diff_hunk": "@@ -112,6 +127,23 @@ void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n     });\n }\n \n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort/LIMO.\n+ *\n+ * Its goal is measuring how much time improving a linearization may take without any search\n+ * iterations, similar to the previous function.\n+ */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCaseLIMO(ClusterIndex ntx, benchmark::Bench& bench)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 161,
      "original_position": 48,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2003bb8a279c8891e55bab190ca36f0c6c8697ea",
      "in_reply_to_id": 1681678886,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The \"ANC\" one is testing a scenario that is a worst-case for ancestor sort (but is trivial for the LIMO aspect), the \"LIMO\" one is testing a scenario that is a worst-case for LIMO (but is trivial for the ancestor sorting aspect).",
      "created_at": "2024-07-18T15:14:54Z",
      "updated_at": "2024-07-18T15:14:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1683032146",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1683032146"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 161,
      "original_line": 161,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1683034976",
      "pull_request_review_id": 2186160220,
      "id": 1683034976,
      "node_id": "PRRC_kwDOABII585kURNg",
      "diff_hunk": "@@ -112,6 +127,23 @@ void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n     });\n }\n \n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort/LIMO.\n+ *\n+ * Its goal is measuring how much time improving a linearization may take without any search\n+ * iterations, similar to the previous function.\n+ */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCaseLIMO(ClusterIndex ntx, benchmark::Bench& bench)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 161,
      "original_position": 48,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2003bb8a279c8891e55bab190ca36f0c6c8697ea",
      "in_reply_to_id": 1681678886,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ah, parsing the name wrong basically, thanks",
      "created_at": "2024-07-18T15:16:48Z",
      "updated_at": "2024-07-18T15:16:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1683034976",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1683034976"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 161,
      "original_line": 161,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684218549",
      "pull_request_review_id": 2187965242,
      "id": 1684218549,
      "node_id": "PRRC_kwDOABII585kYyK1",
      "diff_hunk": "@@ -166,6 +167,121 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone.\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called which will return a\n+ * SetInfo with the highest-feerate ancestor set that remains (an ancestor set is a single\n+ * transaction together with all its remaining ancestors).\n+ */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            /** The remaining ancestors for transaction i. */\n+            SetType anc_to_add = m_depgraph.Ancestors(i);\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                Assume(!anc_feerate.IsEmpty());\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            anc_feerate += m_depgraph.FeeRate(anc_to_add);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * The same transaction may not be MarkDone()'d twice.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        Assume(select.Any());\n+        Assume(select.IsSubsetOf(m_todo));\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Check whether any unlinearized transactions remain. */\n+    bool AllDone() const noexcept\n+    {\n+        return m_todo.None();\n+    }\n+\n+    /** Find the best (highest-feerate, smallest among those in case of a tie) ancestor set\n+     *  among the remaining transactions. Requires !AllDone().\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;",
      "path": "src/cluster_linearize.h",
      "position": 451,
      "original_position": 114,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "48f086eb624a5371b846e908b4702b28726465fa",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        Assume(!AllDone());\r\n        std::optional<ClusterIndex> best;\r\n```",
      "created_at": "2024-07-19T11:08:55Z",
      "updated_at": "2024-07-19T12:40:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1684218549",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684218549"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 451,
      "original_line": 451,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684250867",
      "pull_request_review_id": 2187965242,
      "id": 1684250867,
      "node_id": "PRRC_kwDOABII585kY6Dz",
      "diff_hunk": "@@ -178,3 +294,102 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n     }\n     assert(anc_finder.AllDone());\n }\n+\n+static constexpr auto MAX_SIMPLE_ITERATIONS = 300000;\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        assert(!src_finder.AllDone());\n+        assert(!smp_finder.AllDone());\n+        assert(!exh_finder.AllDone());\n+        assert(!anc_finder.AllDone());\n+\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 444,
      "original_position": 184,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1949b516cbff482797befe350c58915c8dc721d3",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: typo\r\n```suggestion\r\n        // Perform equality checks only if SearchCandidateFinder claims an optimal result.\r\n\t\r\nComment\r\n\r\n```",
      "created_at": "2024-07-19T11:41:29Z",
      "updated_at": "2024-07-19T12:40:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1684250867",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684250867"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 444,
      "original_line": 444,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684253359",
      "pull_request_review_id": 2187965242,
      "id": 1684253359,
      "node_id": "PRRC_kwDOABII585kY6qv",
      "diff_hunk": "@@ -178,3 +294,102 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n     }\n     assert(anc_finder.AllDone());\n }\n+\n+static constexpr auto MAX_SIMPLE_ITERATIONS = 300000;\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        assert(!src_finder.AllDone());\n+        assert(!smp_finder.AllDone());\n+        assert(!exh_finder.AllDone());\n+        assert(!anc_finder.AllDone());\n+\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(MAX_SIMPLE_ITERATIONS);\n+            assert(found.feerate >= simple.feerate);\n+            if (simple_iters < MAX_SIMPLE_ITERATIONS) {\n+                assert(found.feerate == simple.feerate);\n+            }\n+\n+            // Compare with AncestorCandidateFinder;\n+            auto anc = anc_finder.FindCandidateSet();\n+            assert(found.feerate >= anc.feerate);\n+\n+            // If todo isn't too big, also compare with ExhaustiveCandidateFinder.\n+            if (todo.Count() <= 12) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 459,
      "original_position": 198,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1949b516cbff482797befe350c58915c8dc721d3",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "why is 12 selected here, does this implies that the optimal search done with `todo.Count()` > 12 using `SearchCandidateFinder` and `SimpleCandidateFinder` are not optimal we can do better with exhaustive search?",
      "created_at": "2024-07-19T11:43:57Z",
      "updated_at": "2024-07-19T12:40:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1684253359",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684253359"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 459,
      "original_line": 459,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684261836",
      "pull_request_review_id": 2187965242,
      "id": 1684261836,
      "node_id": "PRRC_kwDOABII585kY8vM",
      "diff_hunk": "@@ -184,10 +184,23 @@ struct SetInfo\n     /** Construct a SetInfo for a specified set and feerate. */",
      "path": "src/cluster_linearize.h",
      "position": 203,
      "original_position": 1,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "6fdb3d07d4350b0d93bda5765ea1053c29866c0a",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Add  span include here and the tests\r\n```\r\n#include <span.h>\r\n```",
      "created_at": "2024-07-19T11:52:07Z",
      "updated_at": "2024-07-19T12:40:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1684261836",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684261836"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 203,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684491008",
      "pull_request_review_id": 2182496612,
      "id": 1684491008,
      "node_id": "PRRC_kwDOABII585kZ0sA",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 39,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "a53b7eb82c30a8a6ce460d7f51773c559645b0d1",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "a53b7eb82c3: nitty nit\r\n```suggestion\r\n * The serialization format outputs information about transactions in a topological order (parents\r\n```",
      "created_at": "2024-07-19T14:43:33Z",
      "updated_at": "2024-07-19T17:02:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1684491008",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684491008"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684495081",
      "pull_request_review_id": 2182496612,
      "id": 1684495081,
      "node_id": "PRRC_kwDOABII585kZ1rp",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * correct position on deserialization.\n+ *\n+ * - For each transaction t in the DepGraph (in some topological order);\n+ *   - The size: VARINT(t.size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(t.fee)), see below for SignedToUnsigned.\n+ *   - For each direct dependency:\n+ *     - VARINT(skip)\n+ *   - The position of t in the cluster: VARINT(skip)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * The list of skip values encodes the dependencies of t, as well as its position in the cluster.\n+ * Each skip value is the number of possibilities that were available, but were not taken. These\n+ * possibilities are, in order:\n+ * - For each previous transaction in the graph, in reverse serialization order, whether it is a\n+ *   direct parent of t (but excluding transactions which are already implied to be dependencies\n+ *   by parent relations that were serialized before it).\n+ * - The various insertion positions in the cluster, from the very end of the cluster, to the\n+ *   front.\n+ *\n+ * Let's say you have a 7-transaction cluster, consisting of transactions F,A,C,B,G,E,D, but\n+ * serialized in order A,B,C,D,E,F,G, because that happens to be a topological ordering. By the\n+ * time G gets serialized, what has been serialized already represents the cluster F,A,C,B,E,D (in\n+ * that order). G has B and E as direct parents, and E depends on C.\n+ *\n+ * In this case, the possitibilities are, in order:",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 65,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "a53b7eb82c30a8a6ce460d7f51773c559645b0d1",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n * In this case, the possibilities are, in order:\r\n```",
      "created_at": "2024-07-19T14:45:55Z",
      "updated_at": "2024-07-19T17:02:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1684495081",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684495081"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684577252",
      "pull_request_review_id": 2188570658,
      "id": 1684577252,
      "node_id": "PRRC_kwDOABII585kaJvk",
      "diff_hunk": "@@ -178,3 +294,102 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n     }\n     assert(anc_finder.AllDone());\n }\n+\n+static constexpr auto MAX_SIMPLE_ITERATIONS = 300000;\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        assert(!src_finder.AllDone());\n+        assert(!smp_finder.AllDone());\n+        assert(!exh_finder.AllDone());\n+        assert(!anc_finder.AllDone());\n+\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 444,
      "original_position": 184,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1949b516cbff482797befe350c58915c8dc721d3",
      "in_reply_to_id": 1684250867,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not a typo. There can be multiple distinct optimal linearizations; we just check for optimality, not that it is actually identical to the exhaustive solutions.",
      "created_at": "2024-07-19T15:56:38Z",
      "updated_at": "2024-07-19T15:56:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1684577252",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684577252"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 444,
      "original_line": 444,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684658967",
      "pull_request_review_id": 2182496612,
      "id": 1684658967,
      "node_id": "PRRC_kwDOABII585kadsX",
      "diff_hunk": "@@ -0,0 +1,738 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator (primarily for for testing purposes). */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in the same order as the Cluster it was constructed from. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator (primarily for testing purposes). */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            // Fill in fee and size.\n+            entries[i].feerate = cluster[i].first;\n+            // Fill in direct parents as ancestors.\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: O(1) (amortized, due to resizing of backing vector).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        Assume(TxCount() < SetType::Size());\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, SetType::Singleton(new_idx), SetType::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // Bail out if dependency is already implied.\n+        if (entries[child].ancestors[parent]) return;\n+        // To each ancestor of the parent, add as descendants the descendants of the child.\n+        const auto& chl_des = entries[child].descendants;\n+        for (auto anc_of_par : Ancestors(parent)) {\n+            entries[anc_of_par].descendants |= chl_des;\n+        }\n+        // To each descendant of the child, add as ancestors the ancestors of the parent.\n+        const auto& par_anc = entries[parent].ancestors;\n+        for (auto dec_of_chl : Descendants(child)) {\n+            entries[dec_of_chl].ancestors |= par_anc;\n+        }\n+    }\n+\n+    /** Compute the aggregate feerate of a set of nodes in this graph.\n+     *\n+     * Complexity: O(N) where N=elems.Count().\n+     **/\n+    FeeFrac FeeRate(const SetType& elems) const noexcept\n+    {\n+        FeeFrac ret;\n+        for (auto pos : elems) ret += entries[pos].feerate;\n+        return ret;\n+    }\n+\n+    /** Append the entries of select to list in a topologically valid order.\n+     *\n+     * Complexity: O(select.Count() * log(select.Count())).\n+     */\n+    void AppendTopo(std::vector<ClusterIndex>& list, const SetType& select) const noexcept\n+    {\n+        ClusterIndex old_len = list.size();\n+        for (auto i : select) list.push_back(i);\n+        std::sort(list.begin() + old_len, list.end(), [&](ClusterIndex a, ClusterIndex b) noexcept {\n+            const auto a_anc_count = entries[a].ancestors.Count();\n+            const auto b_anc_count = entries[b].ancestors.Count();\n+            if (a_anc_count != b_anc_count) return a_anc_count < b_anc_count;\n+            return a < b;\n+        });\n+    }\n+};\n+\n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for the empty set. */\n+    SetInfo() noexcept = default;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a given transaction in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, ClusterIndex pos) noexcept :\n+        transactions(SetType::Singleton(pos)), feerate(depgraph.FeeRate(pos)) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Add the transactions of other to this SetInfo (no overlap allowed). */\n+    SetInfo& operator|=(const SetInfo& other) noexcept\n+    {\n+        Assume(!transactions.Overlaps(other.transactions));\n+        transactions |= other.transactions;\n+        feerate += other.feerate;\n+        return *this;\n+    }\n+\n+    /** Construct a new SetInfo equal to this, with more transactions added (which may overlap\n+     *  with the existing transactions in the SetInfo). */\n+    [[nodiscard]] SetInfo Add(const DepGraph<SetType>& depgraph, const SetType& txn) const noexcept\n+    {\n+        return {transactions | txn, feerate + depgraph.FeeRate(txn - transactions)};\n+    }\n+\n+    /** Swap two SetInfo objects. */\n+    friend void swap(SetInfo& a, SetInfo& b) noexcept\n+    {\n+        swap(a.transactions, b.transactions);\n+        swap(a.feerate, b.feerate);\n+    }\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Compute the feerates of the chunks of the part of linearization that remains in todo. */\n+template<typename SetType>\n+std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<const ClusterIndex> linearization) noexcept\n+{\n+    std::vector<FeeFrac> ret;\n+    for (ClusterIndex i : linearization) {\n+        /** The new chunk to be added, initially a singleton. */\n+        auto new_chunk = depgraph.FeeRate(i);\n+        // As long as the new chunk has a higher feerate than the last chunk so far, absorb it.\n+        while (!ret.empty() && new_chunk >> ret.back()) {\n+            new_chunk += ret.back();\n+            ret.pop_back();\n+        }\n+        // Actually move that new chunk into the chunking.\n+        ret.push_back(std::move(new_chunk));\n+    }\n+    return ret;\n+}\n+\n+/** Data structure encapsulating the chunking of a linearization, permitting removal of subsets. */\n+template<typename SetType>\n+class LinearizationChunking\n+{\n+    /** The depgraph this linearization is for. */\n+    const DepGraph<SetType>& m_depgraph;\n+\n+    /** The linearization we started from. */\n+    Span<const ClusterIndex> m_linearization;\n+\n+    /** Chunk sets and their feerates, of what remains of the linearization. */\n+    std::vector<SetInfo<SetType>> m_chunks;\n+\n+    /** Which transactions remain in the linearization. */\n+    SetType m_todo;\n+\n+    /** Fill the m_chunks variable. */\n+    void BuildChunks() noexcept\n+    {\n+        // Caller must clear m_chunks.\n+        Assume(m_chunks.empty());\n+\n+        // Iterate over the entries in m_linearization. This is effectively the same\n+        // algorithm as ChunkLinearization, but supports skipping parts of the linearization and\n+        // keeps track of the sets themselves instead of just their feerates.\n+        for (auto idx : m_linearization) {\n+            if (!m_todo[idx]) continue;\n+            // Start with an initial chunk containing just element idx.\n+            SetInfo add(m_depgraph, idx);\n+            // Absorb existing final chunks into add while they have lower feerate.\n+            while (!m_chunks.empty() && add.feerate >> m_chunks.back().feerate) {\n+                add |= m_chunks.back();\n+                m_chunks.pop_back();\n+            }\n+            // Remember new chunk.\n+            m_chunks.push_back(std::move(add));\n+        }\n+    }\n+\n+public:\n+    /** Initialize a LinearizationSubset object for a given length of linearization. */\n+    explicit LinearizationChunking(const DepGraph<SetType>& depgraph LIFETIMEBOUND, Span<const ClusterIndex> lin LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_linearization(lin)\n+    {\n+        // Mark everything in lin as todo still.\n+        for (auto i : m_linearization) m_todo.Set(i);\n+        // Compute the initial chunking.\n+        m_chunks.reserve(depgraph.TxCount());\n+        BuildChunks();\n+    }\n+\n+    /** Determine how many chunks remain in the linearization. */\n+    ClusterIndex NumChunksLeft() const noexcept { return m_chunks.size(); }\n+\n+    /** Access a chunk. Chunk 0 is the highest-feerate prefix of what remains. */\n+    const SetInfo<SetType>& GetChunk(ClusterIndex n) const noexcept\n+    {\n+        Assume(n < m_chunks.size());\n+        return m_chunks[n];\n+    }\n+\n+    /** Remove some subset of transactions from the linearization. */\n+    void MarkDone(SetType subset) noexcept\n+    {\n+        Assume(subset.Any());\n+        Assume(subset.IsSubsetOf(m_todo));\n+        m_todo -= subset;\n+        // Rechunk what remains of m_linearization.\n+        m_chunks.clear();\n+        BuildChunks();\n+    }\n+\n+    /** Find the shortest intersection between subset and the prefixes of remaining chunks\n+     *  of the linearization that has a feerate not below subset's.\n+     *\n+     * This is a crucial operation in guaranteeing improvements to linearizations. If subset has\n+     * a feerate not below GetChunk(0)'s, then moving Intersect(subset) to the front of (what\n+     * remains of) the linearization is guaranteed not to make it worse at any point.\n+     *\n+     * See https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032 for background.\n+     */\n+    SetInfo<SetType> Intersect(const SetInfo<SetType>& subset) const noexcept\n+    {\n+        Assume(subset.transactions.IsSubsetOf(m_todo));\n+        SetInfo<SetType> accumulator;\n+        // Iterate over all chunks of the remaining linearization.\n+        for (ClusterIndex i = 0; i < NumChunksLeft(); ++i) {\n+            // Find what (if any) intersection the chunk has with subset.\n+            const SetType to_add = GetChunk(i).transactions & subset.transactions;\n+            if (to_add.Any()) {\n+                // If adding that to accumulator makes us hit all of subset, we are done as no\n+                // shorter intersection with higher/equal feerate exists.\n+                accumulator.transactions |= to_add;\n+                if (accumulator.transactions == subset.transactions) break;\n+                // Otherwise update the accumulator feerate.\n+                accumulator.feerate += m_depgraph.FeeRate(to_add);\n+                // If that does result in something better, or something with the same feerate but\n+                // smaller, return that. Even if a longer, higher-feerate intersection exists, it\n+                // does not hurt to return the shorter one (the remainder of the longer intersection\n+                // will generally be found in the next call to Intersect, but even if not, it is not\n+                // required for the improvement guarantee this function makes).\n+                if (!(accumulator.feerate << subset.feerate)) return accumulator;\n+            }\n+        }\n+        return subset;\n+    }\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone.\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called which will return a\n+ * SetInfo with the highest-feerate ancestor set that remains (an ancestor set is a single\n+ * transaction together with all its remaining ancestors).\n+ */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            /** The remaining ancestors for transaction i. */\n+            SetType anc_to_add = m_depgraph.Ancestors(i);\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                Assume(!anc_feerate.IsEmpty());\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            anc_feerate += m_depgraph.FeeRate(anc_to_add);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * The same transaction may not be MarkDone()'d twice.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        Assume(select.Any());\n+        Assume(select.IsSubsetOf(m_todo));\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Check whether any unlinearized transactions remain. */\n+    bool AllDone() const noexcept\n+    {\n+        return m_todo.None();\n+    }\n+\n+    /** Find the best (highest-feerate, smallest among those in case of a tie) ancestor set\n+     *  among the remaining transactions. Requires !AllDone().\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {\n+                Assume(!m_ancestor_set_feerates[i].IsEmpty());\n+                if (!(m_ancestor_set_feerates[i] > m_ancestor_set_feerates[*best])) continue;\n+            }\n+            best = i;\n+        }\n+        Assume(best.has_value());\n+        return {m_depgraph.Ancestors(*best) & m_todo, m_ancestor_set_feerates[*best]};\n+    }\n+};\n+\n+/** Class encapsulating the state needed to perform search for good candidate sets.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone().\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called to perform a search\n+ * over the set of topologically-valid subsets of that remainder, with a limit on how many\n+ * combinations are tried.\n+ */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal RNG. */\n+    InsecureRandomContext m_rng;\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     * @param[in] rng_seed   A random seed to control the search order.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND, uint64_t rng_seed) noexcept :\n+        m_rng(rng_seed),\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Check whether any unlinearized transactions remain. */\n+    bool AllDone() const noexcept\n+    {\n+        return m_todo.None();\n+    }\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *  Requires !AllDone().\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        Assume(!AllDone());\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included (and its feerate). This must be a subset\n+             *  of m_todo, and be topologically valid (includes all in-m_todo ancestors of\n+             *  itself). */\n+            SetInfo<SetType> inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            SetType und;\n+\n+            /** Construct a new work item. */\n+            WorkItem(SetInfo<SetType>&& i, SetType&& u) noexcept :\n+                inc(std::move(i)), und(std::move(u)) {}\n+\n+            /** Swap two WorkItems. */\n+            void Swap(WorkItem& other) noexcept\n+            {\n+                swap(inc, other.inc);\n+                swap(und, other.und);\n+            }\n+        };\n+\n+        /** The queue of work items. */\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));\n+\n+        // Create an initial entry with m_todo as undecided. Also use it as best if not provided,\n+        // so that during the work processing loop below, and during the add_fn/split_fn calls, we\n+        // do not need to deal with the best=empty case.\n+        if (best.feerate.IsEmpty()) best = SetInfo(m_depgraph, m_todo);\n+        queue.emplace_back(SetInfo<SetType>{}, SetType{m_todo});\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iterations_left = max_iterations;\n+\n+        /** Internal function to add a work item.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 557,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "6160ccf9b4327649e9bb0293fba630a10b3befc3",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: maybe something like \"explore and add a work item if there are any transactions left to split on\" ?",
      "created_at": "2024-07-19T16:58:54Z",
      "updated_at": "2024-07-19T17:02:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1684658967",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684658967"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 557,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684698131",
      "pull_request_review_id": 2188777974,
      "id": 1684698131,
      "node_id": "PRRC_kwDOABII585kanQT",
      "diff_hunk": "@@ -166,6 +167,121 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone.\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called which will return a\n+ * SetInfo with the highest-feerate ancestor set that remains (an ancestor set is a single\n+ * transaction together with all its remaining ancestors).\n+ */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            /** The remaining ancestors for transaction i. */\n+            SetType anc_to_add = m_depgraph.Ancestors(i);\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                Assume(!anc_feerate.IsEmpty());\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            anc_feerate += m_depgraph.FeeRate(anc_to_add);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * The same transaction may not be MarkDone()'d twice.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        Assume(select.Any());\n+        Assume(select.IsSubsetOf(m_todo));\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Check whether any unlinearized transactions remain. */\n+    bool AllDone() const noexcept\n+    {\n+        return m_todo.None();\n+    }\n+\n+    /** Find the best (highest-feerate, smallest among those in case of a tie) ancestor set\n+     *  among the remaining transactions. Requires !AllDone().\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;",
      "path": "src/cluster_linearize.h",
      "position": 451,
      "original_position": 114,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "48f086eb624a5371b846e908b4702b28726465fa",
      "in_reply_to_id": 1684218549,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-19T17:34:44Z",
      "updated_at": "2024-07-19T17:34:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1684698131",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684698131"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 451,
      "original_line": 451,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684698616",
      "pull_request_review_id": 2188778812,
      "id": 1684698616,
      "node_id": "PRRC_kwDOABII585kanX4",
      "diff_hunk": "@@ -178,3 +294,102 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n     }\n     assert(anc_finder.AllDone());\n }\n+\n+static constexpr auto MAX_SIMPLE_ITERATIONS = 300000;\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        assert(!src_finder.AllDone());\n+        assert(!smp_finder.AllDone());\n+        assert(!exh_finder.AllDone());\n+        assert(!anc_finder.AllDone());\n+\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(MAX_SIMPLE_ITERATIONS);\n+            assert(found.feerate >= simple.feerate);\n+            if (simple_iters < MAX_SIMPLE_ITERATIONS) {\n+                assert(found.feerate == simple.feerate);\n+            }\n+\n+            // Compare with AncestorCandidateFinder;\n+            auto anc = anc_finder.FindCandidateSet();\n+            assert(found.feerate >= anc.feerate);\n+\n+            // If todo isn't too big, also compare with ExhaustiveCandidateFinder.\n+            if (todo.Count() <= 12) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 459,
      "original_position": 198,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1949b516cbff482797befe350c58915c8dc721d3",
      "in_reply_to_id": 1684253359,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We don't invoke ExhaustiveCandidateFinder for larger clusters because it just gets too computationally expensive to do so. I've added a comment to clarify this.",
      "created_at": "2024-07-19T17:35:20Z",
      "updated_at": "2024-07-19T17:35:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1684698616",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684698616"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 459,
      "original_line": 459,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684698702",
      "pull_request_review_id": 2188778924,
      "id": 1684698702,
      "node_id": "PRRC_kwDOABII585kanZO",
      "diff_hunk": "@@ -184,10 +184,23 @@ struct SetInfo\n     /** Construct a SetInfo for a specified set and feerate. */",
      "path": "src/cluster_linearize.h",
      "position": 203,
      "original_position": 1,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "6fdb3d07d4350b0d93bda5765ea1053c29866c0a",
      "in_reply_to_id": 1684261836,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-19T17:35:25Z",
      "updated_at": "2024-07-19T17:35:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1684698702",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684698702"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 203,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684698780",
      "pull_request_review_id": 2188779062,
      "id": 1684698780,
      "node_id": "PRRC_kwDOABII585kanac",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 39,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "a53b7eb82c30a8a6ce460d7f51773c559645b0d1",
      "in_reply_to_id": 1684491008,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-19T17:35:31Z",
      "updated_at": "2024-07-19T17:35:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1684698780",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684698780"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684698872",
      "pull_request_review_id": 2188779195,
      "id": 1684698872,
      "node_id": "PRRC_kwDOABII585kanb4",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <numeric>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format outputs information about transaction in a topological order (parents\n+ * before children), together with position information so transactions can be moved back to their\n+ * correct position on deserialization.\n+ *\n+ * - For each transaction t in the DepGraph (in some topological order);\n+ *   - The size: VARINT(t.size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(t.fee)), see below for SignedToUnsigned.\n+ *   - For each direct dependency:\n+ *     - VARINT(skip)\n+ *   - The position of t in the cluster: VARINT(skip)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * The list of skip values encodes the dependencies of t, as well as its position in the cluster.\n+ * Each skip value is the number of possibilities that were available, but were not taken. These\n+ * possibilities are, in order:\n+ * - For each previous transaction in the graph, in reverse serialization order, whether it is a\n+ *   direct parent of t (but excluding transactions which are already implied to be dependencies\n+ *   by parent relations that were serialized before it).\n+ * - The various insertion positions in the cluster, from the very end of the cluster, to the\n+ *   front.\n+ *\n+ * Let's say you have a 7-transaction cluster, consisting of transactions F,A,C,B,G,E,D, but\n+ * serialized in order A,B,C,D,E,F,G, because that happens to be a topological ordering. By the\n+ * time G gets serialized, what has been serialized already represents the cluster F,A,C,B,E,D (in\n+ * that order). G has B and E as direct parents, and E depends on C.\n+ *\n+ * In this case, the possitibilities are, in order:",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 65,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "a53b7eb82c30a8a6ce460d7f51773c559645b0d1",
      "in_reply_to_id": 1684495081,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-19T17:35:36Z",
      "updated_at": "2024-07-19T17:35:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1684698872",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684698872"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684698968",
      "pull_request_review_id": 2188779373,
      "id": 1684698968,
      "node_id": "PRRC_kwDOABII585kandY",
      "diff_hunk": "@@ -0,0 +1,738 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator (primarily for for testing purposes). */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in the same order as the Cluster it was constructed from. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator (primarily for testing purposes). */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            // Fill in fee and size.\n+            entries[i].feerate = cluster[i].first;\n+            // Fill in direct parents as ancestors.\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: O(1) (amortized, due to resizing of backing vector).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        Assume(TxCount() < SetType::Size());\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, SetType::Singleton(new_idx), SetType::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // Bail out if dependency is already implied.\n+        if (entries[child].ancestors[parent]) return;\n+        // To each ancestor of the parent, add as descendants the descendants of the child.\n+        const auto& chl_des = entries[child].descendants;\n+        for (auto anc_of_par : Ancestors(parent)) {\n+            entries[anc_of_par].descendants |= chl_des;\n+        }\n+        // To each descendant of the child, add as ancestors the ancestors of the parent.\n+        const auto& par_anc = entries[parent].ancestors;\n+        for (auto dec_of_chl : Descendants(child)) {\n+            entries[dec_of_chl].ancestors |= par_anc;\n+        }\n+    }\n+\n+    /** Compute the aggregate feerate of a set of nodes in this graph.\n+     *\n+     * Complexity: O(N) where N=elems.Count().\n+     **/\n+    FeeFrac FeeRate(const SetType& elems) const noexcept\n+    {\n+        FeeFrac ret;\n+        for (auto pos : elems) ret += entries[pos].feerate;\n+        return ret;\n+    }\n+\n+    /** Append the entries of select to list in a topologically valid order.\n+     *\n+     * Complexity: O(select.Count() * log(select.Count())).\n+     */\n+    void AppendTopo(std::vector<ClusterIndex>& list, const SetType& select) const noexcept\n+    {\n+        ClusterIndex old_len = list.size();\n+        for (auto i : select) list.push_back(i);\n+        std::sort(list.begin() + old_len, list.end(), [&](ClusterIndex a, ClusterIndex b) noexcept {\n+            const auto a_anc_count = entries[a].ancestors.Count();\n+            const auto b_anc_count = entries[b].ancestors.Count();\n+            if (a_anc_count != b_anc_count) return a_anc_count < b_anc_count;\n+            return a < b;\n+        });\n+    }\n+};\n+\n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for the empty set. */\n+    SetInfo() noexcept = default;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a given transaction in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, ClusterIndex pos) noexcept :\n+        transactions(SetType::Singleton(pos)), feerate(depgraph.FeeRate(pos)) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Add the transactions of other to this SetInfo (no overlap allowed). */\n+    SetInfo& operator|=(const SetInfo& other) noexcept\n+    {\n+        Assume(!transactions.Overlaps(other.transactions));\n+        transactions |= other.transactions;\n+        feerate += other.feerate;\n+        return *this;\n+    }\n+\n+    /** Construct a new SetInfo equal to this, with more transactions added (which may overlap\n+     *  with the existing transactions in the SetInfo). */\n+    [[nodiscard]] SetInfo Add(const DepGraph<SetType>& depgraph, const SetType& txn) const noexcept\n+    {\n+        return {transactions | txn, feerate + depgraph.FeeRate(txn - transactions)};\n+    }\n+\n+    /** Swap two SetInfo objects. */\n+    friend void swap(SetInfo& a, SetInfo& b) noexcept\n+    {\n+        swap(a.transactions, b.transactions);\n+        swap(a.feerate, b.feerate);\n+    }\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Compute the feerates of the chunks of the part of linearization that remains in todo. */\n+template<typename SetType>\n+std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<const ClusterIndex> linearization) noexcept\n+{\n+    std::vector<FeeFrac> ret;\n+    for (ClusterIndex i : linearization) {\n+        /** The new chunk to be added, initially a singleton. */\n+        auto new_chunk = depgraph.FeeRate(i);\n+        // As long as the new chunk has a higher feerate than the last chunk so far, absorb it.\n+        while (!ret.empty() && new_chunk >> ret.back()) {\n+            new_chunk += ret.back();\n+            ret.pop_back();\n+        }\n+        // Actually move that new chunk into the chunking.\n+        ret.push_back(std::move(new_chunk));\n+    }\n+    return ret;\n+}\n+\n+/** Data structure encapsulating the chunking of a linearization, permitting removal of subsets. */\n+template<typename SetType>\n+class LinearizationChunking\n+{\n+    /** The depgraph this linearization is for. */\n+    const DepGraph<SetType>& m_depgraph;\n+\n+    /** The linearization we started from. */\n+    Span<const ClusterIndex> m_linearization;\n+\n+    /** Chunk sets and their feerates, of what remains of the linearization. */\n+    std::vector<SetInfo<SetType>> m_chunks;\n+\n+    /** Which transactions remain in the linearization. */\n+    SetType m_todo;\n+\n+    /** Fill the m_chunks variable. */\n+    void BuildChunks() noexcept\n+    {\n+        // Caller must clear m_chunks.\n+        Assume(m_chunks.empty());\n+\n+        // Iterate over the entries in m_linearization. This is effectively the same\n+        // algorithm as ChunkLinearization, but supports skipping parts of the linearization and\n+        // keeps track of the sets themselves instead of just their feerates.\n+        for (auto idx : m_linearization) {\n+            if (!m_todo[idx]) continue;\n+            // Start with an initial chunk containing just element idx.\n+            SetInfo add(m_depgraph, idx);\n+            // Absorb existing final chunks into add while they have lower feerate.\n+            while (!m_chunks.empty() && add.feerate >> m_chunks.back().feerate) {\n+                add |= m_chunks.back();\n+                m_chunks.pop_back();\n+            }\n+            // Remember new chunk.\n+            m_chunks.push_back(std::move(add));\n+        }\n+    }\n+\n+public:\n+    /** Initialize a LinearizationSubset object for a given length of linearization. */\n+    explicit LinearizationChunking(const DepGraph<SetType>& depgraph LIFETIMEBOUND, Span<const ClusterIndex> lin LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_linearization(lin)\n+    {\n+        // Mark everything in lin as todo still.\n+        for (auto i : m_linearization) m_todo.Set(i);\n+        // Compute the initial chunking.\n+        m_chunks.reserve(depgraph.TxCount());\n+        BuildChunks();\n+    }\n+\n+    /** Determine how many chunks remain in the linearization. */\n+    ClusterIndex NumChunksLeft() const noexcept { return m_chunks.size(); }\n+\n+    /** Access a chunk. Chunk 0 is the highest-feerate prefix of what remains. */\n+    const SetInfo<SetType>& GetChunk(ClusterIndex n) const noexcept\n+    {\n+        Assume(n < m_chunks.size());\n+        return m_chunks[n];\n+    }\n+\n+    /** Remove some subset of transactions from the linearization. */\n+    void MarkDone(SetType subset) noexcept\n+    {\n+        Assume(subset.Any());\n+        Assume(subset.IsSubsetOf(m_todo));\n+        m_todo -= subset;\n+        // Rechunk what remains of m_linearization.\n+        m_chunks.clear();\n+        BuildChunks();\n+    }\n+\n+    /** Find the shortest intersection between subset and the prefixes of remaining chunks\n+     *  of the linearization that has a feerate not below subset's.\n+     *\n+     * This is a crucial operation in guaranteeing improvements to linearizations. If subset has\n+     * a feerate not below GetChunk(0)'s, then moving Intersect(subset) to the front of (what\n+     * remains of) the linearization is guaranteed not to make it worse at any point.\n+     *\n+     * See https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032 for background.\n+     */\n+    SetInfo<SetType> Intersect(const SetInfo<SetType>& subset) const noexcept\n+    {\n+        Assume(subset.transactions.IsSubsetOf(m_todo));\n+        SetInfo<SetType> accumulator;\n+        // Iterate over all chunks of the remaining linearization.\n+        for (ClusterIndex i = 0; i < NumChunksLeft(); ++i) {\n+            // Find what (if any) intersection the chunk has with subset.\n+            const SetType to_add = GetChunk(i).transactions & subset.transactions;\n+            if (to_add.Any()) {\n+                // If adding that to accumulator makes us hit all of subset, we are done as no\n+                // shorter intersection with higher/equal feerate exists.\n+                accumulator.transactions |= to_add;\n+                if (accumulator.transactions == subset.transactions) break;\n+                // Otherwise update the accumulator feerate.\n+                accumulator.feerate += m_depgraph.FeeRate(to_add);\n+                // If that does result in something better, or something with the same feerate but\n+                // smaller, return that. Even if a longer, higher-feerate intersection exists, it\n+                // does not hurt to return the shorter one (the remainder of the longer intersection\n+                // will generally be found in the next call to Intersect, but even if not, it is not\n+                // required for the improvement guarantee this function makes).\n+                if (!(accumulator.feerate << subset.feerate)) return accumulator;\n+            }\n+        }\n+        return subset;\n+    }\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone.\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called which will return a\n+ * SetInfo with the highest-feerate ancestor set that remains (an ancestor set is a single\n+ * transaction together with all its remaining ancestors).\n+ */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            /** The remaining ancestors for transaction i. */\n+            SetType anc_to_add = m_depgraph.Ancestors(i);\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                Assume(!anc_feerate.IsEmpty());\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            anc_feerate += m_depgraph.FeeRate(anc_to_add);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * The same transaction may not be MarkDone()'d twice.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        Assume(select.Any());\n+        Assume(select.IsSubsetOf(m_todo));\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Check whether any unlinearized transactions remain. */\n+    bool AllDone() const noexcept\n+    {\n+        return m_todo.None();\n+    }\n+\n+    /** Find the best (highest-feerate, smallest among those in case of a tie) ancestor set\n+     *  among the remaining transactions. Requires !AllDone().\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {\n+                Assume(!m_ancestor_set_feerates[i].IsEmpty());\n+                if (!(m_ancestor_set_feerates[i] > m_ancestor_set_feerates[*best])) continue;\n+            }\n+            best = i;\n+        }\n+        Assume(best.has_value());\n+        return {m_depgraph.Ancestors(*best) & m_todo, m_ancestor_set_feerates[*best]};\n+    }\n+};\n+\n+/** Class encapsulating the state needed to perform search for good candidate sets.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone().\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called to perform a search\n+ * over the set of topologically-valid subsets of that remainder, with a limit on how many\n+ * combinations are tried.\n+ */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal RNG. */\n+    InsecureRandomContext m_rng;\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     * @param[in] rng_seed   A random seed to control the search order.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND, uint64_t rng_seed) noexcept :\n+        m_rng(rng_seed),\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Check whether any unlinearized transactions remain. */\n+    bool AllDone() const noexcept\n+    {\n+        return m_todo.None();\n+    }\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *  Requires !AllDone().\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        Assume(!AllDone());\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included (and its feerate). This must be a subset\n+             *  of m_todo, and be topologically valid (includes all in-m_todo ancestors of\n+             *  itself). */\n+            SetInfo<SetType> inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            SetType und;\n+\n+            /** Construct a new work item. */\n+            WorkItem(SetInfo<SetType>&& i, SetType&& u) noexcept :\n+                inc(std::move(i)), und(std::move(u)) {}\n+\n+            /** Swap two WorkItems. */\n+            void Swap(WorkItem& other) noexcept\n+            {\n+                swap(inc, other.inc);\n+                swap(und, other.und);\n+            }\n+        };\n+\n+        /** The queue of work items. */\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));\n+\n+        // Create an initial entry with m_todo as undecided. Also use it as best if not provided,\n+        // so that during the work processing loop below, and during the add_fn/split_fn calls, we\n+        // do not need to deal with the best=empty case.\n+        if (best.feerate.IsEmpty()) best = SetInfo(m_depgraph, m_todo);\n+        queue.emplace_back(SetInfo<SetType>{}, SetType{m_todo});\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iterations_left = max_iterations;\n+\n+        /** Internal function to add a work item.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 557,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "6160ccf9b4327649e9bb0293fba630a10b3befc3",
      "in_reply_to_id": 1684658967,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Did something like that.",
      "created_at": "2024-07-19T17:35:43Z",
      "updated_at": "2024-07-19T17:35:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1684698968",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684698968"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 557,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684699167",
      "pull_request_review_id": 2188779651,
      "id": 1684699167,
      "node_id": "PRRC_kwDOABII585kangf",
      "diff_hunk": "@@ -112,6 +127,23 @@ void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n     });\n }\n \n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort/LIMO.\n+ *\n+ * Its goal is measuring how much time improving a linearization may take without any search\n+ * iterations, similar to the previous function.\n+ */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCaseLIMO(ClusterIndex ntx, benchmark::Bench& bench)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 161,
      "original_position": 48,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2003bb8a279c8891e55bab190ca36f0c6c8697ea",
      "in_reply_to_id": 1681678886,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added a comment to clarify.",
      "created_at": "2024-07-19T17:35:55Z",
      "updated_at": "2024-07-19T17:35:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1684699167",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684699167"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 161,
      "original_line": 161,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1686776442",
      "pull_request_review_id": 2191951101,
      "id": 1686776442,
      "node_id": "PRRC_kwDOABII585kiip6",
      "diff_hunk": "@@ -505,6 +505,123 @@ FUZZ_TARGET(clusterlin_search_finder)\n     assert(anc_finder.AllDone());\n }\n \n+FUZZ_TARGET(clusterlin_linearization_chunking)\n+{\n+    // Verify the behavior of LinearizationChunking.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a topologically-valid subset of depgraph.\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    auto subset = SetInfo(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+    // Retrieve a valid linearization for depgraph.\n+    auto linearization = ReadLinearization(depgraph, reader);\n+\n+    // Construct a LinearizationChunking object, initially for the whole linearization.\n+    LinearizationChunking chunking(depgraph, linearization);\n+\n+    // Remove piece by piece of the linearization in the chunking object, and check various",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2597f096afde07d9c7f6466c0970a73947562be3",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "2597f096afde07d9c7f6466c0970a73947562be3\r\n\r\nnit: found this comment hard to parse. \"Remove transactions from the chunking object, and check various...\" ?",
      "created_at": "2024-07-22T15:52:18Z",
      "updated_at": "2024-07-23T16:38:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1686776442",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1686776442"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 529,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1687853218",
      "pull_request_review_id": 2191951101,
      "id": 1687853218,
      "node_id": "PRRC_kwDOABII585kmpii",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Question: I whiteboarded what this graph + the decision tree looks like to try to understand what makes this a hard graph. Do I understand correctly that\r\n- Within this PR, the feerates of transactions in the graph have no impact on how many iterations `SearchCandidateFinder` might run, since all work items are considered as long as they are topological.\r\n- The feerates of the parent+child transactions {4..n-1} become important after #30286's optimizations that rule out transactions/branches that can't lead to better feerates.\r\n\r\n(I'm not suggesting that you change anything here, just hoping to clarify my understanding as I haven't looked very deeply at #30286 yet.)",
      "created_at": "2024-07-23T10:54:41Z",
      "updated_at": "2024-07-23T16:38:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1687853218",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1687853218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688134395",
      "pull_request_review_id": 2191951101,
      "id": 1688134395,
      "node_id": "PRRC_kwDOABII585knuL7",
      "diff_hunk": "@@ -505,6 +505,123 @@ FUZZ_TARGET(clusterlin_search_finder)\n     assert(anc_finder.AllDone());\n }\n \n+FUZZ_TARGET(clusterlin_linearization_chunking)\n+{\n+    // Verify the behavior of LinearizationChunking.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a topologically-valid subset of depgraph.\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    auto subset = SetInfo(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+    // Retrieve a valid linearization for depgraph.\n+    auto linearization = ReadLinearization(depgraph, reader);\n+\n+    // Construct a LinearizationChunking object, initially for the whole linearization.\n+    LinearizationChunking chunking(depgraph, linearization);\n+\n+    // Remove piece by piece of the linearization in the chunking object, and check various\n+    // properties at every step.\n+    while (todo.Any()) {\n+        assert(chunking.NumChunksLeft() > 0);\n+\n+        // Construct linearization with just todo.\n+        std::vector<ClusterIndex> linearization_left;\n+        for (auto i : linearization) {\n+            if (todo[i]) linearization_left.push_back(i);\n+        }\n+\n+        // Compute the chunking for linearization_left.\n+        auto chunking_left = ChunkLinearization(depgraph, linearization_left);\n+\n+        // Verify that it matches the feerates of the chunks of chunking.\n+        assert(chunking.NumChunksLeft() == chunking_left.size());\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            assert(chunking.GetChunk(i).feerate == chunking_left[i]);\n+        }\n+\n+        // Check consistency of chunking.\n+        TestBitSet combined;\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            const auto& chunk_info = chunking.GetChunk(i);\n+            // Chunks must be non-empty.\n+            assert(chunk_info.transactions.Any());\n+            // Chunk feerates must be monotonically non-increasing.\n+            if (i > 0) assert(!(chunk_info.feerate >> chunking.GetChunk(i - 1).feerate));\n+            // Chunks must be a subset of what is left of the linearization.\n+            assert(chunk_info.transactions.IsSubsetOf(todo));\n+            // Chunks' claimed feerates must match their transactions' aggregate feerate.\n+            assert(depgraph.FeeRate(chunk_info.transactions) == chunk_info.feerate);\n+            // Chunks must be the highest-feerate remaining prefix.\n+            SetInfo<TestBitSet> accumulator, best;\n+            for (auto i : linearization) {\n+                if (todo[i] && !combined[i]) {\n+                    accumulator |= SetInfo(depgraph, i);\n+                    if (best.feerate.IsEmpty() || accumulator.feerate > best.feerate) {\n+                        best = accumulator;\n+                    }\n+                }\n+            }\n+            assert(best.transactions == chunk_info.transactions);\n+            assert(best.feerate == chunk_info.feerate);\n+            // Chunks cannot overlap.\n+            assert(!chunk_info.transactions.Overlaps(combined));\n+            combined |= chunk_info.transactions;\n+            // Chunks must be topological.\n+            for (auto idx : chunk_info.transactions) {\n+                assert((depgraph.Ancestors(idx) & todo).IsSubsetOf(combined));\n+            }\n+        }\n+        assert(combined == todo);\n+\n+        // Verify the expected properties of LinearizationChunking::Intersect:\n+        auto intersect = chunking.Intersect(subset);\n+        // - Intersecting again doesn't change the result.\n+        assert(chunking.Intersect(intersect) == intersect);\n+        // - The intersection is topological.\n+        TestBitSet intersect_anc;\n+        for (auto idx : intersect.transactions) {\n+            intersect_anc |= (depgraph.Ancestors(idx) & todo);\n+        }\n+        assert(intersect.transactions == intersect_anc);\n+        // - The claimed intersection feerate matches its transactions.\n+        assert(intersect.feerate == depgraph.FeeRate(intersect.transactions));\n+        // - The intersection may only be empty if its input is empty.\n+        assert(intersect.transactions.Any() == subset.transactions.Any());\n+        // - The intersection feerate must be as high as the input.\n+        assert(intersect.feerate >= subset.feerate);\n+        // - No non-empty intersection between the intersection and a prefix of the chunks of the\n+        //   remainder of the linearization may be better than the intersection.\n+        TestBitSet prefix;\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            prefix |= chunking.GetChunk(i).transactions;\n+            auto reintersect = SetInfo(depgraph, prefix & intersect.transactions);\n+            if (!reintersect.feerate.IsEmpty()) {\n+                assert(reintersect.feerate <= intersect.feerate);\n+            }\n+        }\n+\n+        // Find a subset to remove from linearization.\n+        auto done = ReadTopologicalSet(depgraph, todo, reader);\n+        if (done.None()) {\n+            // We need to remove a non-empty subset, so fall back to the unlinearized ancestors of\n+            // the first transaction in todo if done is empty.\n+            done = depgraph.Ancestors(todo.First()) & todo;\n+        }\n+        todo -= done;\n+        chunking.MarkDone(done);\n+        subset = SetInfo(depgraph, subset.transactions - done);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 599,
      "original_position": 115,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2597f096afde07d9c7f6466c0970a73947562be3",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There wouldn't be any problem with resetting `subset = SetInfo(depgraph, ReadTopologicalSet(depgraph, todo, reader));` here, right?",
      "created_at": "2024-07-23T14:08:03Z",
      "updated_at": "2024-07-23T16:38:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1688134395",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688134395"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 599,
      "original_line": 599,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688140732",
      "pull_request_review_id": 2191951101,
      "id": 1688140732,
      "node_id": "PRRC_kwDOABII585knvu8",
      "diff_hunk": "@@ -505,6 +505,123 @@ FUZZ_TARGET(clusterlin_search_finder)\n     assert(anc_finder.AllDone());\n }\n \n+FUZZ_TARGET(clusterlin_linearization_chunking)\n+{\n+    // Verify the behavior of LinearizationChunking.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a topologically-valid subset of depgraph.\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    auto subset = SetInfo(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+    // Retrieve a valid linearization for depgraph.\n+    auto linearization = ReadLinearization(depgraph, reader);\n+\n+    // Construct a LinearizationChunking object, initially for the whole linearization.\n+    LinearizationChunking chunking(depgraph, linearization);\n+\n+    // Remove piece by piece of the linearization in the chunking object, and check various\n+    // properties at every step.\n+    while (todo.Any()) {\n+        assert(chunking.NumChunksLeft() > 0);\n+\n+        // Construct linearization with just todo.\n+        std::vector<ClusterIndex> linearization_left;\n+        for (auto i : linearization) {\n+            if (todo[i]) linearization_left.push_back(i);\n+        }\n+\n+        // Compute the chunking for linearization_left.\n+        auto chunking_left = ChunkLinearization(depgraph, linearization_left);\n+\n+        // Verify that it matches the feerates of the chunks of chunking.\n+        assert(chunking.NumChunksLeft() == chunking_left.size());\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            assert(chunking.GetChunk(i).feerate == chunking_left[i]);\n+        }\n+\n+        // Check consistency of chunking.\n+        TestBitSet combined;\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            const auto& chunk_info = chunking.GetChunk(i);\n+            // Chunks must be non-empty.\n+            assert(chunk_info.transactions.Any());\n+            // Chunk feerates must be monotonically non-increasing.\n+            if (i > 0) assert(!(chunk_info.feerate >> chunking.GetChunk(i - 1).feerate));\n+            // Chunks must be a subset of what is left of the linearization.\n+            assert(chunk_info.transactions.IsSubsetOf(todo));\n+            // Chunks' claimed feerates must match their transactions' aggregate feerate.\n+            assert(depgraph.FeeRate(chunk_info.transactions) == chunk_info.feerate);\n+            // Chunks must be the highest-feerate remaining prefix.\n+            SetInfo<TestBitSet> accumulator, best;\n+            for (auto i : linearization) {\n+                if (todo[i] && !combined[i]) {\n+                    accumulator |= SetInfo(depgraph, i);\n+                    if (best.feerate.IsEmpty() || accumulator.feerate > best.feerate) {\n+                        best = accumulator;\n+                    }\n+                }\n+            }\n+            assert(best.transactions == chunk_info.transactions);\n+            assert(best.feerate == chunk_info.feerate);\n+            // Chunks cannot overlap.\n+            assert(!chunk_info.transactions.Overlaps(combined));\n+            combined |= chunk_info.transactions;\n+            // Chunks must be topological.\n+            for (auto idx : chunk_info.transactions) {\n+                assert((depgraph.Ancestors(idx) & todo).IsSubsetOf(combined));\n+            }\n+        }\n+        assert(combined == todo);\n+\n+        // Verify the expected properties of LinearizationChunking::Intersect:\n+        auto intersect = chunking.Intersect(subset);\n+        // - Intersecting again doesn't change the result.\n+        assert(chunking.Intersect(intersect) == intersect);\n+        // - The intersection is topological.\n+        TestBitSet intersect_anc;\n+        for (auto idx : intersect.transactions) {\n+            intersect_anc |= (depgraph.Ancestors(idx) & todo);\n+        }\n+        assert(intersect.transactions == intersect_anc);\n+        // - The claimed intersection feerate matches its transactions.\n+        assert(intersect.feerate == depgraph.FeeRate(intersect.transactions));\n+        // - The intersection may only be empty if its input is empty.\n+        assert(intersect.transactions.Any() == subset.transactions.Any());\n+        // - The intersection feerate must be as high as the input.\n+        assert(intersect.feerate >= subset.feerate);\n+        // - No non-empty intersection between the intersection and a prefix of the chunks of the\n+        //   remainder of the linearization may be better than the intersection.\n+        TestBitSet prefix;\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            prefix |= chunking.GetChunk(i).transactions;\n+            auto reintersect = SetInfo(depgraph, prefix & intersect.transactions);\n+            if (!reintersect.feerate.IsEmpty()) {\n+                assert(reintersect.feerate <= intersect.feerate);\n+            }\n+        }",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 588,
      "original_position": 104,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2597f096afde07d9c7f6466c0970a73947562be3",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I suppose this is the same as `chunking.Intersect(intersect)` except without exiting early?",
      "created_at": "2024-07-23T14:11:47Z",
      "updated_at": "2024-07-23T16:38:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1688140732",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688140732"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 579,
      "original_start_line": 599,
      "start_side": "RIGHT",
      "line": 588,
      "original_line": 588,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688448049",
      "pull_request_review_id": 2194614888,
      "id": 1688448049,
      "node_id": "PRRC_kwDOABII585ko6wx",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": 1687853218,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, the current `SearchCandidateFinder` in this PR effectively searches over *every* topologically valid subset of the cluster (if the `max_iterations` limit is sufficiently high), which means that among other things the feerates don't actually matter. It has a few other weirdnesses:\r\n* The randomization of the search order in this PR is mostly irrelevant (but still included so that the interface of `Linearize` is stable after this PR).\r\n* The `SimpleCandidateFinder` in the fuzz tests is actually more efficient (for now) than `SearchCandidateFinder`, because it only considers *connected* topologically valid subsets. This isn't done in `SearchCandidateFinder` because a much more important optimization follows in #30286 that conflicts with it, but one might wonder why it's not done here.\r\n* There are probably topologies that are *for now* worse for `SearchCandidateFinder` than the implemented one in terms of *number* of iterations required, but the benchmark is about cost per iteration rather than number of iterations, and I prefer being able to keep the benchmark stable throughout the optimizations.",
      "created_at": "2024-07-23T17:28:09Z",
      "updated_at": "2024-07-24T13:33:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1688448049",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688448049"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688468495",
      "pull_request_review_id": 2194649981,
      "id": 1688468495,
      "node_id": "PRRC_kwDOABII585ko_wP",
      "diff_hunk": "@@ -505,6 +505,123 @@ FUZZ_TARGET(clusterlin_search_finder)\n     assert(anc_finder.AllDone());\n }\n \n+FUZZ_TARGET(clusterlin_linearization_chunking)\n+{\n+    // Verify the behavior of LinearizationChunking.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a topologically-valid subset of depgraph.\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    auto subset = SetInfo(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+    // Retrieve a valid linearization for depgraph.\n+    auto linearization = ReadLinearization(depgraph, reader);\n+\n+    // Construct a LinearizationChunking object, initially for the whole linearization.\n+    LinearizationChunking chunking(depgraph, linearization);\n+\n+    // Remove piece by piece of the linearization in the chunking object, and check various\n+    // properties at every step.\n+    while (todo.Any()) {\n+        assert(chunking.NumChunksLeft() > 0);\n+\n+        // Construct linearization with just todo.\n+        std::vector<ClusterIndex> linearization_left;\n+        for (auto i : linearization) {\n+            if (todo[i]) linearization_left.push_back(i);\n+        }\n+\n+        // Compute the chunking for linearization_left.\n+        auto chunking_left = ChunkLinearization(depgraph, linearization_left);\n+\n+        // Verify that it matches the feerates of the chunks of chunking.\n+        assert(chunking.NumChunksLeft() == chunking_left.size());\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            assert(chunking.GetChunk(i).feerate == chunking_left[i]);\n+        }\n+\n+        // Check consistency of chunking.\n+        TestBitSet combined;\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            const auto& chunk_info = chunking.GetChunk(i);\n+            // Chunks must be non-empty.\n+            assert(chunk_info.transactions.Any());\n+            // Chunk feerates must be monotonically non-increasing.\n+            if (i > 0) assert(!(chunk_info.feerate >> chunking.GetChunk(i - 1).feerate));\n+            // Chunks must be a subset of what is left of the linearization.\n+            assert(chunk_info.transactions.IsSubsetOf(todo));\n+            // Chunks' claimed feerates must match their transactions' aggregate feerate.\n+            assert(depgraph.FeeRate(chunk_info.transactions) == chunk_info.feerate);\n+            // Chunks must be the highest-feerate remaining prefix.\n+            SetInfo<TestBitSet> accumulator, best;\n+            for (auto i : linearization) {\n+                if (todo[i] && !combined[i]) {\n+                    accumulator |= SetInfo(depgraph, i);\n+                    if (best.feerate.IsEmpty() || accumulator.feerate > best.feerate) {\n+                        best = accumulator;\n+                    }\n+                }\n+            }\n+            assert(best.transactions == chunk_info.transactions);\n+            assert(best.feerate == chunk_info.feerate);\n+            // Chunks cannot overlap.\n+            assert(!chunk_info.transactions.Overlaps(combined));\n+            combined |= chunk_info.transactions;\n+            // Chunks must be topological.\n+            for (auto idx : chunk_info.transactions) {\n+                assert((depgraph.Ancestors(idx) & todo).IsSubsetOf(combined));\n+            }\n+        }\n+        assert(combined == todo);\n+\n+        // Verify the expected properties of LinearizationChunking::Intersect:\n+        auto intersect = chunking.Intersect(subset);\n+        // - Intersecting again doesn't change the result.\n+        assert(chunking.Intersect(intersect) == intersect);\n+        // - The intersection is topological.\n+        TestBitSet intersect_anc;\n+        for (auto idx : intersect.transactions) {\n+            intersect_anc |= (depgraph.Ancestors(idx) & todo);\n+        }\n+        assert(intersect.transactions == intersect_anc);\n+        // - The claimed intersection feerate matches its transactions.\n+        assert(intersect.feerate == depgraph.FeeRate(intersect.transactions));\n+        // - The intersection may only be empty if its input is empty.\n+        assert(intersect.transactions.Any() == subset.transactions.Any());\n+        // - The intersection feerate must be as high as the input.\n+        assert(intersect.feerate >= subset.feerate);\n+        // - No non-empty intersection between the intersection and a prefix of the chunks of the\n+        //   remainder of the linearization may be better than the intersection.\n+        TestBitSet prefix;\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            prefix |= chunking.GetChunk(i).transactions;\n+            auto reintersect = SetInfo(depgraph, prefix & intersect.transactions);\n+            if (!reintersect.feerate.IsEmpty()) {\n+                assert(reintersect.feerate <= intersect.feerate);\n+            }\n+        }",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 588,
      "original_position": 104,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2597f096afde07d9c7f6466c0970a73947562be3",
      "in_reply_to_id": 1688140732,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's similar, but not actually the same, because it isn't testing the exact result of `LinearizationChunking::Intersect`, but testing the *properties* it has we care about for LIMO/Merging to work (feerate of output is as high as feerate of input, and no intersection with a chunk prefix is better). Specifically, if you replace `LinearizationChunking::Intersect` with something that returns the highest-feerate intersection (rather than the first intersection) which has as high feerate as the input, or if you make it consider every *linearization* prefix (rather than just chunk prefixes), this test still works fine.\r\n\r\nAnother difference is that the test here recomputes the full intersection feerate every time rather than incrementally computing it.",
      "created_at": "2024-07-23T17:45:01Z",
      "updated_at": "2024-07-23T17:45:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1688468495",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688468495"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 579,
      "original_start_line": 599,
      "start_side": "RIGHT",
      "line": 588,
      "original_line": 588,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688471698",
      "pull_request_review_id": 2194657869,
      "id": 1688471698,
      "node_id": "PRRC_kwDOABII585kpAiS",
      "diff_hunk": "@@ -505,6 +505,123 @@ FUZZ_TARGET(clusterlin_search_finder)\n     assert(anc_finder.AllDone());\n }\n \n+FUZZ_TARGET(clusterlin_linearization_chunking)\n+{\n+    // Verify the behavior of LinearizationChunking.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a topologically-valid subset of depgraph.\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    auto subset = SetInfo(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+    // Retrieve a valid linearization for depgraph.\n+    auto linearization = ReadLinearization(depgraph, reader);\n+\n+    // Construct a LinearizationChunking object, initially for the whole linearization.\n+    LinearizationChunking chunking(depgraph, linearization);\n+\n+    // Remove piece by piece of the linearization in the chunking object, and check various\n+    // properties at every step.\n+    while (todo.Any()) {\n+        assert(chunking.NumChunksLeft() > 0);\n+\n+        // Construct linearization with just todo.\n+        std::vector<ClusterIndex> linearization_left;\n+        for (auto i : linearization) {\n+            if (todo[i]) linearization_left.push_back(i);\n+        }\n+\n+        // Compute the chunking for linearization_left.\n+        auto chunking_left = ChunkLinearization(depgraph, linearization_left);\n+\n+        // Verify that it matches the feerates of the chunks of chunking.\n+        assert(chunking.NumChunksLeft() == chunking_left.size());\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            assert(chunking.GetChunk(i).feerate == chunking_left[i]);\n+        }\n+\n+        // Check consistency of chunking.\n+        TestBitSet combined;\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            const auto& chunk_info = chunking.GetChunk(i);\n+            // Chunks must be non-empty.\n+            assert(chunk_info.transactions.Any());\n+            // Chunk feerates must be monotonically non-increasing.\n+            if (i > 0) assert(!(chunk_info.feerate >> chunking.GetChunk(i - 1).feerate));\n+            // Chunks must be a subset of what is left of the linearization.\n+            assert(chunk_info.transactions.IsSubsetOf(todo));\n+            // Chunks' claimed feerates must match their transactions' aggregate feerate.\n+            assert(depgraph.FeeRate(chunk_info.transactions) == chunk_info.feerate);\n+            // Chunks must be the highest-feerate remaining prefix.\n+            SetInfo<TestBitSet> accumulator, best;\n+            for (auto i : linearization) {\n+                if (todo[i] && !combined[i]) {\n+                    accumulator |= SetInfo(depgraph, i);\n+                    if (best.feerate.IsEmpty() || accumulator.feerate > best.feerate) {\n+                        best = accumulator;\n+                    }\n+                }\n+            }\n+            assert(best.transactions == chunk_info.transactions);\n+            assert(best.feerate == chunk_info.feerate);\n+            // Chunks cannot overlap.\n+            assert(!chunk_info.transactions.Overlaps(combined));\n+            combined |= chunk_info.transactions;\n+            // Chunks must be topological.\n+            for (auto idx : chunk_info.transactions) {\n+                assert((depgraph.Ancestors(idx) & todo).IsSubsetOf(combined));\n+            }\n+        }\n+        assert(combined == todo);\n+\n+        // Verify the expected properties of LinearizationChunking::Intersect:\n+        auto intersect = chunking.Intersect(subset);\n+        // - Intersecting again doesn't change the result.\n+        assert(chunking.Intersect(intersect) == intersect);\n+        // - The intersection is topological.\n+        TestBitSet intersect_anc;\n+        for (auto idx : intersect.transactions) {\n+            intersect_anc |= (depgraph.Ancestors(idx) & todo);\n+        }\n+        assert(intersect.transactions == intersect_anc);\n+        // - The claimed intersection feerate matches its transactions.\n+        assert(intersect.feerate == depgraph.FeeRate(intersect.transactions));\n+        // - The intersection may only be empty if its input is empty.\n+        assert(intersect.transactions.Any() == subset.transactions.Any());\n+        // - The intersection feerate must be as high as the input.\n+        assert(intersect.feerate >= subset.feerate);\n+        // - No non-empty intersection between the intersection and a prefix of the chunks of the\n+        //   remainder of the linearization may be better than the intersection.\n+        TestBitSet prefix;\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            prefix |= chunking.GetChunk(i).transactions;\n+            auto reintersect = SetInfo(depgraph, prefix & intersect.transactions);\n+            if (!reintersect.feerate.IsEmpty()) {\n+                assert(reintersect.feerate <= intersect.feerate);\n+            }\n+        }\n+\n+        // Find a subset to remove from linearization.\n+        auto done = ReadTopologicalSet(depgraph, todo, reader);\n+        if (done.None()) {\n+            // We need to remove a non-empty subset, so fall back to the unlinearized ancestors of\n+            // the first transaction in todo if done is empty.\n+            done = depgraph.Ancestors(todo.First()) & todo;\n+        }\n+        todo -= done;\n+        chunking.MarkDone(done);\n+        subset = SetInfo(depgraph, subset.transactions - done);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 599,
      "original_position": 115,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2597f096afde07d9c7f6466c0970a73947562be3",
      "in_reply_to_id": 1688134395,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It should work, but wouldn't be testing the exact same thing (because the remaining part of a `LinearizationChunking` isn't required to be topological, and in practice it'll generally be the opposite: the full cluster with a topological subset removed).",
      "created_at": "2024-07-23T17:47:36Z",
      "updated_at": "2024-07-23T17:47:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1688471698",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688471698"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 599,
      "original_line": 599,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688479676",
      "pull_request_review_id": 2194674710,
      "id": 1688479676,
      "node_id": "PRRC_kwDOABII585kpCe8",
      "diff_hunk": "@@ -505,6 +505,123 @@ FUZZ_TARGET(clusterlin_search_finder)\n     assert(anc_finder.AllDone());\n }\n \n+FUZZ_TARGET(clusterlin_linearization_chunking)\n+{\n+    // Verify the behavior of LinearizationChunking.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a topologically-valid subset of depgraph.\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    auto subset = SetInfo(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+    // Retrieve a valid linearization for depgraph.\n+    auto linearization = ReadLinearization(depgraph, reader);\n+\n+    // Construct a LinearizationChunking object, initially for the whole linearization.\n+    LinearizationChunking chunking(depgraph, linearization);\n+\n+    // Remove piece by piece of the linearization in the chunking object, and check various",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2597f096afde07d9c7f6466c0970a73947562be3",
      "in_reply_to_id": 1686776442,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Will do if I retouch.",
      "created_at": "2024-07-23T17:54:04Z",
      "updated_at": "2024-07-23T17:54:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1688479676",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688479676"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 529,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688552973",
      "pull_request_review_id": 2167121806,
      "id": 1688552973,
      "node_id": "PRRC_kwDOABII585kpUYN",
      "diff_hunk": "@@ -294,6 +295,20 @@ void SanityCheck(const DepGraph<SetType>& depgraph)\n     }\n }\n \n+/** Perform a sanity check on a linearization. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph, Span<const ClusterIndex> linearization)\n+{\n+    // Check completeness.\n+    assert(linearization.size() == depgraph.TxCount());\n+    TestBitSet done;\n+    for (auto i : linearization) {\n+        // Check topology and lack of duplicates.\n+        assert((depgraph.Ancestors(i) - done) == TestBitSet::Singleton(i));",
      "path": "src/test/util/cluster_linearize.h",
      "position": 346,
      "original_position": 21,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "a26618fbb38de4ff55e9c6fc02d9c2f910907f27",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We could consider checking that the entries in `linearization` are all in the expected range [0, depGraph.TxCount()), to avoid a crash here if a garbage linearization were passed in?",
      "created_at": "2024-07-23T18:56:06Z",
      "updated_at": "2024-07-24T17:20:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1688552973",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688552973"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 346,
      "original_line": 346,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688658743",
      "pull_request_review_id": 2194985365,
      "id": 1688658743,
      "node_id": "PRRC_kwDOABII585kpuM3",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": 1687853218,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "FWIW, this is what the clusters should look like:\r\n\r\nOdd (mentally swap T4 and T6):\r\n\r\n```mermaid\r\ngraph BT\r\nT0[\"T0: 1/2\"];T1[\"T1: 14/2\"];T2[\"T2: 6/1\"];T3[\"T3: 5/1\"];T4[\"T4: 7/1\"];\r\nT5[\"T5: 5/1\"];T6[\"T6: 7/1\"];T7[\"T7: 5/1\"];T8[\"T8: 7/1\"];T9[\"T9: 5/1\"];\r\nT10[\"T10: 7/1\"];\r\nT1-->T0;T1-->T2;T3-->T2;T4-->T3;T4-->T5;T6-->T5;T4-->T7;T8-->T7;T4-->T9;T10-->T9;\r\n```\r\n\r\nEven (mentally swap T3 and T5):\r\n\r\n```mermaid\r\ngraph BT\r\nT0[\"T0: 1\"];T1[\"T1: 3\"];T2[\"T2: 1\"];T3[\"T3: 4\"];T4[\"T4: 0\"];T5[\"T5: 4\"];\r\nT6[\"T6: 0\"]; T7[\"T7: 4\"];T8[\"T8: 0\"];T9[\"T9: 4\"];\r\nT1-->T0;T2-->T0;T3-->T2;T3-->T4;T5-->T4;T3-->T6;T7-->T6;T3-->T8;T9-->T8;\r\n```\r\n\r\n",
      "created_at": "2024-07-23T20:14:35Z",
      "updated_at": "2024-07-25T14:14:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1688658743",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1688658743"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1689639934",
      "pull_request_review_id": 2196528986,
      "id": 1689639934,
      "node_id": "PRRC_kwDOABII585ktdv-",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": 1687853218,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Matches my diagrams. Thanks for the additional context! :+1: ",
      "created_at": "2024-07-24T11:55:28Z",
      "updated_at": "2024-07-24T11:55:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1689639934",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1689639934"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690139736",
      "pull_request_review_id": 2167121806,
      "id": 1690139736,
      "node_id": "PRRC_kwDOABII585kvXxY",
      "diff_hunk": "@@ -505,6 +505,123 @@ FUZZ_TARGET(clusterlin_search_finder)\n     assert(anc_finder.AllDone());\n }\n \n+FUZZ_TARGET(clusterlin_linearization_chunking)\n+{\n+    // Verify the behavior of LinearizationChunking.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a topologically-valid subset of depgraph.\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    auto subset = SetInfo(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+    // Retrieve a valid linearization for depgraph.\n+    auto linearization = ReadLinearization(depgraph, reader);\n+\n+    // Construct a LinearizationChunking object, initially for the whole linearization.\n+    LinearizationChunking chunking(depgraph, linearization);\n+\n+    // Remove piece by piece of the linearization in the chunking object, and check various\n+    // properties at every step.\n+    while (todo.Any()) {\n+        assert(chunking.NumChunksLeft() > 0);\n+\n+        // Construct linearization with just todo.\n+        std::vector<ClusterIndex> linearization_left;\n+        for (auto i : linearization) {\n+            if (todo[i]) linearization_left.push_back(i);\n+        }\n+\n+        // Compute the chunking for linearization_left.\n+        auto chunking_left = ChunkLinearization(depgraph, linearization_left);\n+\n+        // Verify that it matches the feerates of the chunks of chunking.\n+        assert(chunking.NumChunksLeft() == chunking_left.size());\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            assert(chunking.GetChunk(i).feerate == chunking_left[i]);\n+        }\n+\n+        // Check consistency of chunking.\n+        TestBitSet combined;\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            const auto& chunk_info = chunking.GetChunk(i);\n+            // Chunks must be non-empty.\n+            assert(chunk_info.transactions.Any());\n+            // Chunk feerates must be monotonically non-increasing.\n+            if (i > 0) assert(!(chunk_info.feerate >> chunking.GetChunk(i - 1).feerate));\n+            // Chunks must be a subset of what is left of the linearization.\n+            assert(chunk_info.transactions.IsSubsetOf(todo));\n+            // Chunks' claimed feerates must match their transactions' aggregate feerate.\n+            assert(depgraph.FeeRate(chunk_info.transactions) == chunk_info.feerate);\n+            // Chunks must be the highest-feerate remaining prefix.\n+            SetInfo<TestBitSet> accumulator, best;\n+            for (auto i : linearization) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 59,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2597f096afde07d9c7f6466c0970a73947562be3",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe a different variable here would be better, since `i` is already used in the outer loop?",
      "created_at": "2024-07-24T16:49:54Z",
      "updated_at": "2024-07-24T17:20:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1690139736",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690139736"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 563,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690385057",
      "pull_request_review_id": 2197706374,
      "id": 1690385057,
      "node_id": "PRRC_kwDOABII585kwTqh",
      "diff_hunk": "@@ -505,6 +505,123 @@ FUZZ_TARGET(clusterlin_search_finder)\n     assert(anc_finder.AllDone());\n }\n \n+FUZZ_TARGET(clusterlin_linearization_chunking)\n+{\n+    // Verify the behavior of LinearizationChunking.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a topologically-valid subset of depgraph.\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    auto subset = SetInfo(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+    // Retrieve a valid linearization for depgraph.\n+    auto linearization = ReadLinearization(depgraph, reader);\n+\n+    // Construct a LinearizationChunking object, initially for the whole linearization.\n+    LinearizationChunking chunking(depgraph, linearization);\n+\n+    // Remove piece by piece of the linearization in the chunking object, and check various",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2597f096afde07d9c7f6466c0970a73947562be3",
      "in_reply_to_id": 1686776442,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-24T20:27:31Z",
      "updated_at": "2024-07-24T20:27:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1690385057",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690385057"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 529,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690385537",
      "pull_request_review_id": 2197707050,
      "id": 1690385537,
      "node_id": "PRRC_kwDOABII585kwTyB",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": 1687853218,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added the mermaid code as comments to the benchmark.",
      "created_at": "2024-07-24T20:27:59Z",
      "updated_at": "2024-07-24T20:27:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1690385537",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690385537"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690385632",
      "pull_request_review_id": 2197707178,
      "id": 1690385632,
      "node_id": "PRRC_kwDOABII585kwTzg",
      "diff_hunk": "@@ -452,6 +468,54 @@ class SearchCandidateFinder\n     }\n };\n \n+/** Find a linearization for a cluster.\n+ *\n+ * @param[in] depgraph        Dependency graph of the the cluster to be linearized.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 29,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "4e6e416fedd1b8eaadfc8e9fa02b99b22f8d8a11",
      "in_reply_to_id": 1671088434,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-24T20:28:05Z",
      "updated_at": "2024-07-24T20:28:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1690385632",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690385632"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 473,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690385744",
      "pull_request_review_id": 2197707377,
      "id": 1690385744,
      "node_id": "PRRC_kwDOABII585kwT1Q",
      "diff_hunk": "@@ -519,34 +529,64 @@ class SearchCandidateFinder\n     }\n };\n \n-/** Find a linearization for a cluster.\n+/** Find or improve a linearization for a cluster.\n  *\n- * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n- * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n- * @param[in] rng_seed        A random number seed to control search order. This prevents peers\n- *                            from predicting exactly which clusters would be hard for us to\n- *                            linearize.\n- * @return                    A pair of:\n- *                            - The resulting linearization.\n- *                            - A boolean indicating whether the result is guaranteed to be\n- *                              optimal.\n+ * @param[in] depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in] max_iterations     Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed           A random number seed to control search order. This prevents peers\n+ *                               from predicting exactly which clusters would be hard for us to\n+ *                               linearize.\n+ * @param[in] old_linearization  An existing linearization for the cluster, or empty.\n+ * @return                       A pair of:\n+ *                               - The resulting linearization. It is guaranteed to be at least as\n+ *                                 good (in the feerate diagram sense) as old_linearization.\n+ *                               - A boolean indicating whether the result is guaranteed to be\n+ *                                 optimal.\n  *\n  * Complexity: O(N * min(max_iterations + N, 2^N)) where N=depgraph.TxCount().\n  */\n template<typename SetType>\n-std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed) noexcept\n+std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed, Span<const ClusterIndex> old_linearization = {}) noexcept",
      "path": "src/cluster_linearize.h",
      "position": 684,
      "original_position": 53,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "750d52fa8df08b7dc13720d4d2ccbe0cf9e0f800",
      "in_reply_to_id": 1671201334,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-24T20:28:12Z",
      "updated_at": "2024-07-24T20:28:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1690385744",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690385744"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 684,
      "original_line": 684,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690386555",
      "pull_request_review_id": 2197708656,
      "id": 1690386555,
      "node_id": "PRRC_kwDOABII585kwUB7",
      "diff_hunk": "@@ -0,0 +1,145 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <test/util/cluster_linearize.h>\n+#include <test/util/setup_common.h>\n+#include <util/bitset.h>\n+#include <util/strencodings.h>\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(cluster_linearize_tests, BasicTestingSetup)\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+template<typename SetType>\n+void TestDepGraphSerialization(const Cluster<SetType>& cluster, const std::string& hexenc)\n+{\n+    DepGraph depgraph(cluster);\n+\n+    // Test that depgraph has all the fees/sizes/parents required by cluster.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        BOOST_CHECK(depgraph.FeeRate(i) == cluster[i].first);\n+        for (ClusterIndex par : cluster[i].second) {\n+            BOOST_CHECK(depgraph.Ancestors(i)[par]);\n+            BOOST_CHECK(depgraph.Descendants(par)[i]);\n+        }\n+    }\n+\n+    // Run normal sanity checks on depgraph.\n+    SanityCheck(depgraph);\n+\n+    // Test that the serialization of depgraph matches hexenc.\n+    std::vector<unsigned char> encoding;\n+    VectorWriter writer(encoding, 0);\n+    writer << Using<DepGraphFormatter>(depgraph);\n+    BOOST_CHECK_EQUAL(HexStr(encoding), hexenc);",
      "path": "src/test/cluster_linearize_tests.cpp",
      "position": 34,
      "original_position": 42,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "1492194c5fc83aa48c049bde4ecf8a110b8207e3",
      "in_reply_to_id": 1676094213,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added comments explaining this, and also moved the \"test correspondence between Cluster and DepGraph\" to a new `VerifyDepGraphFromCluster` function that's invoked in both the unit and fuzz tests.",
      "created_at": "2024-07-24T20:29:01Z",
      "updated_at": "2024-07-24T20:29:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1690386555",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690386555"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 34,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690386667",
      "pull_request_review_id": 2197708840,
      "id": 1690386667,
      "node_id": "PRRC_kwDOABII585kwUDr",
      "diff_hunk": "@@ -294,6 +295,20 @@ void SanityCheck(const DepGraph<SetType>& depgraph)\n     }\n }\n \n+/** Perform a sanity check on a linearization. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph, Span<const ClusterIndex> linearization)\n+{\n+    // Check completeness.\n+    assert(linearization.size() == depgraph.TxCount());\n+    TestBitSet done;\n+    for (auto i : linearization) {\n+        // Check topology and lack of duplicates.\n+        assert((depgraph.Ancestors(i) - done) == TestBitSet::Singleton(i));",
      "path": "src/test/util/cluster_linearize.h",
      "position": 346,
      "original_position": 21,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "a26618fbb38de4ff55e9c6fc02d9c2f910907f27",
      "in_reply_to_id": 1688552973,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-24T20:29:09Z",
      "updated_at": "2024-07-24T20:29:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1690386667",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690386667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 346,
      "original_line": 346,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690386739",
      "pull_request_review_id": 2197708974,
      "id": 1690386739,
      "node_id": "PRRC_kwDOABII585kwUEz",
      "diff_hunk": "@@ -505,6 +505,123 @@ FUZZ_TARGET(clusterlin_search_finder)\n     assert(anc_finder.AllDone());\n }\n \n+FUZZ_TARGET(clusterlin_linearization_chunking)\n+{\n+    // Verify the behavior of LinearizationChunking.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a topologically-valid subset of depgraph.\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    auto subset = SetInfo(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+    // Retrieve a valid linearization for depgraph.\n+    auto linearization = ReadLinearization(depgraph, reader);\n+\n+    // Construct a LinearizationChunking object, initially for the whole linearization.\n+    LinearizationChunking chunking(depgraph, linearization);\n+\n+    // Remove piece by piece of the linearization in the chunking object, and check various\n+    // properties at every step.\n+    while (todo.Any()) {\n+        assert(chunking.NumChunksLeft() > 0);\n+\n+        // Construct linearization with just todo.\n+        std::vector<ClusterIndex> linearization_left;\n+        for (auto i : linearization) {\n+            if (todo[i]) linearization_left.push_back(i);\n+        }\n+\n+        // Compute the chunking for linearization_left.\n+        auto chunking_left = ChunkLinearization(depgraph, linearization_left);\n+\n+        // Verify that it matches the feerates of the chunks of chunking.\n+        assert(chunking.NumChunksLeft() == chunking_left.size());\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            assert(chunking.GetChunk(i).feerate == chunking_left[i]);\n+        }\n+\n+        // Check consistency of chunking.\n+        TestBitSet combined;\n+        for (ClusterIndex i = 0; i < chunking.NumChunksLeft(); ++i) {\n+            const auto& chunk_info = chunking.GetChunk(i);\n+            // Chunks must be non-empty.\n+            assert(chunk_info.transactions.Any());\n+            // Chunk feerates must be monotonically non-increasing.\n+            if (i > 0) assert(!(chunk_info.feerate >> chunking.GetChunk(i - 1).feerate));\n+            // Chunks must be a subset of what is left of the linearization.\n+            assert(chunk_info.transactions.IsSubsetOf(todo));\n+            // Chunks' claimed feerates must match their transactions' aggregate feerate.\n+            assert(depgraph.FeeRate(chunk_info.transactions) == chunk_info.feerate);\n+            // Chunks must be the highest-feerate remaining prefix.\n+            SetInfo<TestBitSet> accumulator, best;\n+            for (auto i : linearization) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 59,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "2597f096afde07d9c7f6466c0970a73947562be3",
      "in_reply_to_id": 1690139736,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-24T20:29:14Z",
      "updated_at": "2024-07-24T20:29:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1690386739",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1690386739"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 563,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691152128",
      "pull_request_review_id": 2198818298,
      "id": 1691152128,
      "node_id": "PRRC_kwDOABII585kzO8A",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": 1687853218,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah I didn't notice this yesterday - I think you may have swapped odd and even? Same in the commented mermaid diagram code just added.",
      "created_at": "2024-07-25T09:39:07Z",
      "updated_at": "2024-07-25T09:39:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1691152128",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691152128"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691238319",
      "pull_request_review_id": 2198957705,
      "id": 1691238319,
      "node_id": "PRRC_kwDOABII585kzj-v",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": 1687853218,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@glozow I don't think so.",
      "created_at": "2024-07-25T10:43:38Z",
      "updated_at": "2024-07-25T10:43:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1691238319",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691238319"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691281014",
      "pull_request_review_id": 2199026607,
      "id": 1691281014,
      "node_id": "PRRC_kwDOABII585kzuZ2",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": 1687853218,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hm, I was confused because when I was looking at the code, I expected the branch with `depgraph.AddDependency(i, 4)` to have lots of T4-->Tx in its diagram. And the branch with `depgraph.AddDependency(i, 3)` to have lots of T3-->Tx.\r\n\r\n{T0...T9} is 10 transactions, and {T0...T10} is 11 transactions. Am I missing something?",
      "created_at": "2024-07-25T11:21:41Z",
      "updated_at": "2024-07-25T11:21:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1691281014",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691281014"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691293586",
      "pull_request_review_id": 2199046816,
      "id": 1691293586,
      "node_id": "PRRC_kwDOABII585kzxeS",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": 1687853218,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Errr, yes, you're right of course!\r\n\r\nThe odd and even are correct, but the mermaid code for the two are swapped.",
      "created_at": "2024-07-25T11:32:29Z",
      "updated_at": "2024-07-25T11:32:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1691293586",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691293586"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691300770",
      "pull_request_review_id": 2199058320,
      "id": 1691300770,
      "node_id": "PRRC_kwDOABII585kzzOi",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": 1687853218,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Whew, so not wholly unmeritorious.",
      "created_at": "2024-07-25T11:39:01Z",
      "updated_at": "2024-07-25T11:39:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1691300770",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691300770"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691305266",
      "pull_request_review_id": 2199065606,
      "id": 1691305266,
      "node_id": "PRRC_kwDOABII585kz0Uy",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": 1687853218,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, not totally without merit.\r\n\r\nActually, I don't understand at all what is going on. The \"// Odd cluster size.\" code constructs a graph with an odd number of transactions, and the \"// Even cluster size.\" constructs one with an even number. Further, the mermaid code's fees/sizes matches the corresponding code, but does not match the transaction counts?!",
      "created_at": "2024-07-25T11:43:04Z",
      "updated_at": "2024-07-25T11:43:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1691305266",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691305266"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691340097",
      "pull_request_review_id": 2199125028,
      "id": 1691340097,
      "node_id": "PRRC_kwDOABII585kz81B",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": 1687853218,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sigh! I believe this was the problem: it was constructing the intended-to-be-even-sized graph with an odd number of transactions and vice verse:\r\n\r\n```diff\r\ndiff --git a/src/bench/cluster_linearize.cpp b/src/bench/cluster_linearize.cpp\r\nindex ddd7c6a7a61..3ebcc383bb4 100644\r\n--- a/src/bench/cluster_linearize.cpp\r\n+++ b/src/bench/cluster_linearize.cpp\r\n@@ -33,10 +33,10 @@ DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\r\n {\r\n     DepGraph<SetType> depgraph;\r\n     for (ClusterIndex i = 0; i < ntx; ++i) {\r\n-        if (ntx & 1) {\r\n-            // Odd cluster size.\r\n+        if ((ntx & 1) == 0) {\r\n+            // Even cluster size.\r\n             //\r\n-            // Mermaid diagram code for the resulting cluster for 9 transactions:\r\n+            // Mermaid diagram code for the resulting cluster for 10 transactions:\r\n             // ```mermaid\r\n             // graph BT\r\n             // T0[\"T0: 1/2\"];T1[\"T1: 14/2\"];T2[\"T2: 6/1\"];T3[\"T3: 5/1\"];T4[\"T4: 7/1\"];\r\n@@ -62,9 +62,9 @@ DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\r\n                 depgraph.AddDependency(i, 4);\r\n             }\r\n         } else {\r\n-            // Even cluster size.\r\n+            // Odd cluster size.\r\n             //\r\n-            // Mermaid diagram code for the resulting cluster for 10 transactions:\r\n+            // Mermaid diagram code for the resulting cluster for 11 transactions:\r\n             // ```mermaid\r\n             // graph BT\r\n             // T0[\"T0: 1\"];T1[\"T1: 3\"];T2[\"T2: 1\"];T3[\"T3: 4\"];T4[\"T4: 1\"];T5[\"T5: 4\"];\r\n```",
      "created_at": "2024-07-25T12:13:26Z",
      "updated_at": "2024-07-25T12:13:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1691340097",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691340097"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691416836",
      "pull_request_review_id": 2199254557,
      "id": 1691416836,
      "node_id": "PRRC_kwDOABII585k0PkE",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": 1687853218,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sorry, no, the original code was right, and there is more mixed up in the diagrams. Sorry...",
      "created_at": "2024-07-25T13:10:07Z",
      "updated_at": "2024-07-25T13:10:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1691416836",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691416836"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691423677",
      "pull_request_review_id": 2199265853,
      "id": 1691423677,
      "node_id": "PRRC_kwDOABII585k0RO9",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": 1687853218,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Are we meant to end with a child, not a parent? And the pairs are supposed to be cpfps?",
      "created_at": "2024-07-25T13:14:53Z",
      "updated_at": "2024-07-25T13:15:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1691423677",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691423677"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691443552",
      "pull_request_review_id": 2199307170,
      "id": 1691443552,
      "node_id": "PRRC_kwDOABII585k0WFg",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": 1687853218,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've updated the diagrams higher up in the thread to match the actual code (both had several errors...). Let me verify whether they also actually have the complexity properties I claim they have, and then I'll do a push to fix it. Sorry for the mess.",
      "created_at": "2024-07-25T13:27:24Z",
      "updated_at": "2024-07-25T13:27:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1691443552",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691443552"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691531221",
      "pull_request_review_id": 2199450431,
      "id": 1691531221,
      "node_id": "PRRC_kwDOABII585k0rfV",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. The best ancestor set is always the topmost\n+ *  remaining transaction, whose removal requires updating all remaining transactions' ancestor\n+ *  set feerates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// known algorithms (purely empirically determined).\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)",
      "path": "src/bench/cluster_linearize.cpp",
      "position": 47,
      "original_position": 32,
      "commit_id": "647fa37cdbadbeebba147ca6b24e138559cffaaf",
      "original_commit_id": "896b52337be5765cb3a7d3f0458475f2f8e2cb3a",
      "in_reply_to_id": 1687853218,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ok, pushed.",
      "created_at": "2024-07-25T14:17:38Z",
      "updated_at": "2024-07-25T14:17:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1691531221",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1691531221"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": 44,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    }
  ]
}