{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061",
    "id": 2391882324,
    "node_id": "PR_kwDOABII586OkTpU",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/32061",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/32061.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/32061.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/d48c18b88c64839fd48647a8bb10db4fa266f3e9",
    "number": 32061,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Replace libevent with our own HTTP and socket-handling implementation",
    "user": {
      "login": "pinheadmz",
      "id": 2084648,
      "node_id": "MDQ6VXNlcjIwODQ2NDg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pinheadmz",
      "html_url": "https://github.com/pinheadmz",
      "followers_url": "https://api.github.com/users/pinheadmz/followers",
      "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
      "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
      "repos_url": "https://api.github.com/users/pinheadmz/repos",
      "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
      "type": "User",
      "site_admin": false,
      "name": null,
      "patch_url": null
    },
    "body": "This is a major component of [removing libevent as a dependency of the project](https://github.com/bitcoin/bitcoin/issues/31194), by replacing the HTTP server used for RPC and REST with one implemented entirely within the Bitcoin Core codebase. The new `HTTPServer` class runs its own I/O thread, handling socket connections with code based on #30988, but tailored specifically for HTTP.\r\n\r\nSome functional tests were added in #32408 to cover libevent behaviors that remain consistent with this branch. \r\n\r\nCommit strategy:\r\n- Implement a few helper functions for strings, timestamps, etc needed by HTTP protocol\r\n- Isolate the existing libevent-based HTTP server in a namespace `http_libevent`\r\n- Implement HTTP in a new namespace `http_bitcoin` (classes like `HTTPRequest`, `HTTPClient`, etc...)\r\n- Switch bitcoind from the libevent server to the new server\r\n- Clean up (delete `http_libevent`)\r\n\r\nI am currently seeing about a 10% speed up in the functional tests on my own arm/macos machine.\r\n\r\n## Integration testing:\r\n\r\nI am testing the new HTTP server by forking projects that integrate with bitcoin via HTTP and running their integration tests with bitcoind built from this branch (on Github actions). I will continue adding integrations over time, and re-running these CI tests as this branch gets rebased:\r\n\r\n- [NodeJS `rpc-bitcoin`](https://github.com/pinheadmz/rpc-bitcoin/pull/1)\r\n- [electrs](https://github.com/pinheadmz/electrs/pull/1)\r\n- [lnd](https://github.com/pinheadmz/lnd/pull/1)\r\n- [eclair](https://github.com/pinheadmz/eclair/pull/1)\r\n- [corepc](https://github.com/pinheadmz/corepc/pull/1)\r\n- [bitcoinjs-lib](https://github.com/pinheadmz/bitcoinjs-lib/pull/1)",
    "labels": [
      {
        "id": 98279177,
        "node_id": "MDU6TGFiZWw5ODI3OTE3Nw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/RPC/REST/ZMQ",
        "name": "RPC/REST/ZMQ",
        "color": "0052cc",
        "default": false
      }
    ],
    "created_at": "2025-03-13T19:32:14Z",
    "updated_at": "2026-02-13T13:02:18Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "f1034addbacedc2f9269e07839c0819605bb64ed",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "pinheadmz:http-rewrite-13march2025",
      "ref": "http-rewrite-13march2025",
      "sha": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 61248407,
        "node_id": "MDEwOlJlcG9zaXRvcnk2MTI0ODQwNw==",
        "name": "bitcoin",
        "full_name": "pinheadmz/bitcoin",
        "owner": {
          "login": "pinheadmz",
          "id": 2084648,
          "node_id": "MDQ6VXNlcjIwODQ2NDg=",
          "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/pinheadmz",
          "html_url": "https://github.com/pinheadmz",
          "followers_url": "https://api.github.com/users/pinheadmz/followers",
          "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
          "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
          "repos_url": "https://api.github.com/users/pinheadmz/repos",
          "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
          "type": "User",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/pinheadmz/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/pinheadmz/bitcoin",
        "archive_url": "https://api.github.com/repos/pinheadmz/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/pinheadmz/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/pinheadmz/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/pinheadmz/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/pinheadmz/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/pinheadmz/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/pinheadmz/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/pinheadmz/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/pinheadmz/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/pinheadmz/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/pinheadmz/bitcoin/events",
        "forks_url": "https://api.github.com/repos/pinheadmz/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/pinheadmz/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/pinheadmz/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/pinheadmz/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/pinheadmz/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/pinheadmz/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/pinheadmz/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/pinheadmz/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/pinheadmz/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/pinheadmz/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/pinheadmz/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/pinheadmz/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/pinheadmz/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:pinheadmz/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/pinheadmz/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/pinheadmz/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/pinheadmz/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/pinheadmz/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/pinheadmz/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/pinheadmz/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/pinheadmz/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/pinheadmz/bitcoin/hooks",
        "svn_url": "https://github.com/pinheadmz/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 1,
        "stargazers_count": 3,
        "watchers_count": 3,
        "size": 295429,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-02-12T16:32:29Z",
        "created_at": "2016-06-15T23:48:20Z",
        "updated_at": "2025-09-26T10:10:12Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "07b924775e4ff5dbfb9f2e7549fd13db8ec5c61b",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 38898,
        "stargazers_count": 88089,
        "watchers_count": 88089,
        "size": 303667,
        "default_branch": "master",
        "open_issues_count": 727,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-02-13T11:34:52Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2026-02-13T13:01:05Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 1955,
    "deletions": 630,
    "changed_files": 19,
    "commits": 25,
    "review_comments": 157,
    "comments": 27
  },
  "events": [
    {
      "event": "commented",
      "id": 2722486916,
      "node_id": "IC_kwDOABII586iRdqE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2722486916",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T19:32:18Z",
      "updated_at": "2026-02-12T16:33:31Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32061.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [laanwj](https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-2724599518), [fjahr](https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-2725685034), [w0xlt](https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-2813801840), [furszy](https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-3578582144) |\n| Stale ACK | [romanz](https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2969148112), [vasild](https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-3180206398) |\n\nIf your review is incorrectly listed, please copy-paste <code>&lt;!--meta-tag:bot-skip--&gt;</code> into the comment that the bot should ignore.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#34411](https://github.com/bitcoin/bitcoin/pull/34411) ([POC] Full Libevent removal by fanquake)\n* [#33689](https://github.com/bitcoin/bitcoin/pull/33689) (http: replace WorkQueue and single threads handling for ThreadPool by furszy)\n* [#32297](https://github.com/bitcoin/bitcoin/pull/32297) (bitcoin-cli: Add -ipcconnect option by ryanofsky)\n* [#31929](https://github.com/bitcoin/bitcoin/pull/31929) (http: Make server shutdown more robust by hodlinator)\n* [#26812](https://github.com/bitcoin/bitcoin/pull/26812) (test: add end-to-end tests for CConnman and PeerManager by vasild)\n* [#26022](https://github.com/bitcoin/bitcoin/pull/26022) (Add util::ResultPtr class by ryanofsky)\n* [#25665](https://github.com/bitcoin/bitcoin/pull/25665) (refactor: Add util::Result failure types and ability to merge result values by ryanofsky)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->\n### LLM Linter (âœ¨ experimental)\n\n\n\nPossible typos and grammar issues:\n\n- Unrecoverbale -> Unrecoverable [spelling error in comment; could cause momentary confusion]\n- datasent -> data sent [missing space / concatenated words in comment; minor typo impacting readability]\n\n\n\n\nPossible places where comparison-specific test macros should replace generic comparisons:\n\n- src/test/httpserver_tests.cpp: BOOST_CHECK_THROW(req.LoadHeaders(reader), std::runtime_error) -> Replace with BOOST_CHECK_EXCEPTION(req.LoadHeaders(reader), std::runtime_error, HasReason{\"HTTP header missing colon (:)\"}\n\n\n\n<sup>2026-02-12 16:33:30</sup>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-2722486916",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "convert_to_draft",
      "id": 16748542816,
      "node_id": "CTDE_lADOABII586t8FMgzwAAAAPmSntg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16748542816",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T19:37:02Z"
    },
    {
      "event": "labeled",
      "id": 16749188787,
      "node_id": "LE_lADOABII586t8FMgzwAAAAPmVFaz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16749188787",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T20:29:33Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2722620721,
      "node_id": "IC_kwDOABII586iR-Ux",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2722620721",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T20:29:34Z",
      "updated_at": "2025-03-13T20:29:34Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/38735177073</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-2722620721",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "labeled",
      "id": 16768803020,
      "node_id": "LE_lADOABII586t8FMgzwAAAAPnf6DM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16768803020",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-14T09:17:51Z",
      "label": {
        "name": "RPC/REST/ZMQ",
        "color": "0052cc"
      }
    },
    {
      "event": "commented",
      "id": 2724599518,
      "node_id": "IC_kwDOABII586iZhbe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2724599518",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-14T12:52:30Z",
      "updated_at": "2025-03-14T12:52:30Z",
      "author_association": "MEMBER",
      "body": "Concept ACK, nice work",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-2724599518",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "commented",
      "id": 2724787234,
      "node_id": "IC_kwDOABII586iaPQi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2724787234",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-14T13:57:43Z",
      "updated_at": "2025-03-14T13:57:43Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-2724787234",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "commented",
      "id": 2725685034,
      "node_id": "IC_kwDOABII586idqcq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2725685034",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-14T20:29:05Z",
      "updated_at": "2025-03-14T20:29:05Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nMy understanding from the low-level networking discussion at CoreDev was that this wouldn't build on top of sockman. I guess the devil is in the details but can you address that in what sense the current approach follows what was discussed there? Thanks!",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-2725685034",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "commented",
      "id": 2726033041,
      "node_id": "IC_kwDOABII586ie_aR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2726033041",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-15T00:03:45Z",
      "updated_at": "2025-03-15T00:03:45Z",
      "author_association": "MEMBER",
      "body": "> My understanding from the low-level networking discussion at CoreDev was that this wouldn't build on top of sockman. I guess the devil is in the details but can you address that in what sense the current approach follows what was discussed there? Thanks!\r\n\r\nSure, by coredev I had already written most of this implementation (based on sockman) but the performance was bad, and that was part of the motivation behind the deep-dive talk. However, by the end of the week I had reviewed that code in person with smart attendees and not only improved the performance of my code but started to improve performance vs master branch as well! Those updates came in the days just after the deep-dive discussion.\r\n\r\nSOME kind of sockman is needed to replace libevent. The one @vasild  wrote does actually seem to work well for this purpose as well as for p2p, and it would be \"nice\" to only have to maintain one I/O loop structure in bitcoind. @theuni is investigating how a sockman for http could be optimized if it had no other purpose, and I think that is the kind of feedback that will help us decide which path to take.\r\n\r\n",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-2726033041",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "mentioned",
      "id": 16782346824,
      "node_id": "MEE_lADOABII586t8FMgzwAAAAPoTkpI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16782346824",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-15T00:03:46Z"
    },
    {
      "event": "subscribed",
      "id": 16782346826,
      "node_id": "SE_lADOABII586t8FMgzwAAAAPoTkpK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16782346826",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-15T00:03:46Z"
    },
    {
      "event": "mentioned",
      "id": 16782346830,
      "node_id": "MEE_lADOABII586t8FMgzwAAAAPoTkpO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16782346830",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-15T00:03:46Z"
    },
    {
      "event": "subscribed",
      "id": 16782346835,
      "node_id": "SE_lADOABII586t8FMgzwAAAAPoTkpT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16782346835",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-15T00:03:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16844975202,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAPsCexi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16844975202",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "640f38f6e44bdead2d47efa4471a34b5013c173c",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/640f38f6e44bdead2d47efa4471a34b5013c173c",
      "created_at": "2025-03-18T19:27:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16845246523,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAPsDhA7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16845246523",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "49784b396938c0ca582c1cbf21227fde2dad0e92",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/49784b396938c0ca582c1cbf21227fde2dad0e92",
      "created_at": "2025-03-18T19:44:41Z"
    },
    {
      "event": "commented",
      "id": 2736442775,
      "node_id": "IC_kwDOABII586jGs2X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2736442775",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T12:22:15Z",
      "updated_at": "2025-03-19T12:22:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "> SOME kind of sockman is needed to replace libevent ... it would be \"nice\" to only have to maintain one I/O loop structure in bitcoind.\r\n\r\n:100: ",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-2736442775",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16878383639,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAPuB7IX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16878383639",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "8de6cf02039783f84876869f7c442cb036b60022",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/8de6cf02039783f84876869f7c442cb036b60022",
      "created_at": "2025-03-19T20:13:51Z"
    },
    {
      "event": "labeled",
      "id": 16899582189,
      "node_id": "LE_lADOABII586t8FMgzwAAAAPvSyjt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16899582189",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T10:09:16Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16914708514,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAPwMfgi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16914708514",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "44a2317892518a52d7af93220a182e73c8d6e294",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/44a2317892518a52d7af93220a182e73c8d6e294",
      "created_at": "2025-03-20T16:56:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16914860259,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAPwNEjj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16914860259",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "0c7d573dd8f9b91106da2306d257928ed4809315",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/0c7d573dd8f9b91106da2306d257928ed4809315",
      "created_at": "2025-03-20T17:06:40Z"
    },
    {
      "event": "unlabeled",
      "id": 16916392545,
      "node_id": "UNLE_lADOABII586t8FMgzwAAAAPwS6ph",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16916392545",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T18:54:07Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16919849846,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAPwgGt2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16919849846",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "04fe4baf5ed76dd31b70fbeeebd0609c7abde024",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/04fe4baf5ed76dd31b70fbeeebd0609c7abde024",
      "created_at": "2025-03-21T00:34:22Z"
    },
    {
      "event": "labeled",
      "id": 16964052665,
      "node_id": "LE_lADOABII586t8FMgzwAAAAPzIua5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16964052665",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-24T22:30:42Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17043070627,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAP32J6j",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17043070627",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "bfcd833820e0f5baa432be4a292f2f2a7bcc4c1e",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/bfcd833820e0f5baa432be4a292f2f2a7bcc4c1e",
      "created_at": "2025-03-29T12:48:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17046430018,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAP4C-FC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17046430018",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "8ae826be90985d76dc702d09fb36a78c0bd8dd89",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/8ae826be90985d76dc702d09fb36a78c0bd8dd89",
      "created_at": "2025-03-29T23:24:50Z"
    },
    {
      "event": "unlabeled",
      "id": 17046573809,
      "node_id": "UNLE_lADOABII586t8FMgzwAAAAP4DhLx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17046573809",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-30T00:41:07Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 17046644650,
      "node_id": "UNLE_lADOABII586t8FMgzwAAAAP4Dyeq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17046644650",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-30T01:21:13Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17049750477,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAP4PovN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17049750477",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "11d80d4187afaa101de989330fa1982cd019cfa8",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/11d80d4187afaa101de989330fa1982cd019cfa8",
      "created_at": "2025-03-31T01:04:54Z"
    },
    {
      "event": "commented",
      "id": 2765788869,
      "node_id": "IC_kwDOABII586k2pbF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2765788869",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-31T10:18:26Z",
      "updated_at": "2025-03-31T10:18:26Z",
      "author_association": "MEMBER",
      "body": "I rebased this branch on a single squashed commit from #30988 essentially just cherry-picking `sockman.{h,cpp}` by @vasild and leaving out the p2p refactor. This will make rebase maintenance on master a lot easier by reducing conflicting scope, and hopefully also makes review easier. It also means to some extent this PR can be merged independently of #30988,  and also gives @theuni some room to rewrite a specific HTTP sockman if a more efficient purpose-focused module can be written. (Will update PR description in a moment)\r\n\r\nI've finally gotten all CI to pass so I'm going to mark this PR as ready for review as I move on to integration testing with all the bitcoin client libraries I can find!",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-2765788869",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "mentioned",
      "id": 17054719727,
      "node_id": "MEE_lADOABII586t8FMgzwAAAAP4il7v",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17054719727",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-31T10:18:27Z"
    },
    {
      "event": "subscribed",
      "id": 17054719744,
      "node_id": "SE_lADOABII586t8FMgzwAAAAP4il8A",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17054719744",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-31T10:18:27Z"
    },
    {
      "event": "mentioned",
      "id": 17054719763,
      "node_id": "MEE_lADOABII586t8FMgzwAAAAP4il8T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17054719763",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-31T10:18:27Z"
    },
    {
      "event": "subscribed",
      "id": 17054719773,
      "node_id": "SE_lADOABII586t8FMgzwAAAAP4il8d",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17054719773",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-31T10:18:27Z"
    },
    {
      "event": "ready_for_review",
      "id": 17054752759,
      "node_id": "RFRE_lADOABII586t8FMgzwAAAAP4it_3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17054752759",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-31T10:21:06Z"
    },
    {
      "event": "renamed",
      "id": 17054756647,
      "node_id": "RTE_lADOABII586t8FMgzwAAAAP4iu8n",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17054756647",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-31T10:21:21Z",
      "rename": {
        "from": "[draft] Replace libevent with our own HTTP and socket-handling implementation",
        "to": "Replace libevent with our own HTTP and socket-handling implementation"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17119289148,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAP8Y588",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17119289148",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "a225633e34f6ad1207d9bc60a2c1f3f0c74edb40",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/a225633e34f6ad1207d9bc60a2c1f3f0c74edb40",
      "created_at": "2025-04-03T19:13:20Z"
    },
    {
      "event": "commented",
      "id": 2776706841,
      "node_id": "IC_kwDOABII586lgS8Z",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2776706841",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-03T19:14:55Z",
      "updated_at": "2025-04-03T19:14:55Z",
      "author_association": "MEMBER",
      "body": "rebase to a225633e34 includes a new test for \"pipelining\" HTTP requests (thanks @theuni for pointing out this oversight) and also adds a queue of requests to each HTTPClient to ensure requests are processed in series, in the order they were received.",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-2776706841",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "mentioned",
      "id": 17119311189,
      "node_id": "MEE_lADOABII586t8FMgzwAAAAP8Y_VV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17119311189",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-03T19:14:56Z"
    },
    {
      "event": "subscribed",
      "id": 17119311210,
      "node_id": "SE_lADOABII586t8FMgzwAAAAP8Y_Vq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17119311210",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-03T19:14:56Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17119346499,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAP8ZH9D",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17119346499",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "6a6285d268fc387db7dcaaeae736ac5ca502392d",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/6a6285d268fc387db7dcaaeae736ac5ca502392d",
      "created_at": "2025-04-03T19:17:47Z"
    },
    {
      "event": "labeled",
      "id": 17121496965,
      "node_id": "LE_lADOABII586t8FMgzwAAAAP8hU-F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17121496965",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-03T22:42:25Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 17124454598,
      "node_id": "UNLE_lADOABII586t8FMgzwAAAAP8snDG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17124454598",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-04T06:04:32Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2813801840,
      "node_id": "IC_kwDOABII586ntzVw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2813801840",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-17T19:06:30Z",
      "updated_at": "2025-04-17T19:06:30Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK. ",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-2813801840",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "reviewed",
      "id": 2780581749,
      "node_id": "PRR_kwDOABII586lvE91",
      "url": null,
      "actor": null,
      "commit_id": "6a6285d268fc387db7dcaaeae736ac5ca502392d",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-04-21T05:52:35Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2780581749",
      "submitted_at": "2025-04-21T05:52:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "reviewed",
      "id": 2780602792,
      "node_id": "PRR_kwDOABII586lvKGo",
      "url": null,
      "actor": null,
      "commit_id": "6a6285d268fc387db7dcaaeae736ac5ca502392d",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-04-21T06:46:51Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2780602792",
      "submitted_at": "2025-04-21T06:46:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "reviewed",
      "id": 2780672873,
      "node_id": "PRR_kwDOABII586lvbNp",
      "url": null,
      "actor": null,
      "commit_id": "6a6285d268fc387db7dcaaeae736ac5ca502392d",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-04-21T16:06:44Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2780672873",
      "submitted_at": "2025-04-21T16:06:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "reviewed",
      "id": 2781691846,
      "node_id": "PRR_kwDOABII586lzT_G",
      "url": null,
      "actor": null,
      "commit_id": "6a6285d268fc387db7dcaaeae736ac5ca502392d",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-04-21T16:14:19Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2781691846",
      "submitted_at": "2025-04-21T16:14:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "reviewed",
      "id": 2797567891,
      "node_id": "PRR_kwDOABII586mv3-T",
      "url": null,
      "actor": null,
      "commit_id": "6a6285d268fc387db7dcaaeae736ac5ca502392d",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-04-27T09:36:22Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2797567891",
      "submitted_at": "2025-04-27T09:36:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "reviewed",
      "id": 2797582544,
      "node_id": "PRR_kwDOABII586mv7jQ",
      "url": null,
      "actor": null,
      "commit_id": "6a6285d268fc387db7dcaaeae736ac5ca502392d",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-04-27T11:04:55Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2797582544",
      "submitted_at": "2025-04-27T11:04:55Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "reviewed",
      "id": 2797634240,
      "node_id": "PRR_kwDOABII586mwILA",
      "url": null,
      "actor": null,
      "commit_id": "6a6285d268fc387db7dcaaeae736ac5ca502392d",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-04-27T13:00:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "LGTM, many thanks!\r\nAdded some comments/suggestions above :)",
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2797634240",
      "submitted_at": "2025-04-27T13:00:33Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17452828383,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAQQRQbf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17452828383",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/7d301184016a3f59c2e363dff631263cdbe21da0",
      "created_at": "2025-04-29T11:04:32Z"
    },
    {
      "event": "reviewed",
      "id": 2799390114,
      "node_id": "PRR_kwDOABII586m202i",
      "url": null,
      "actor": null,
      "commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-04-29T13:23:20Z",
      "author_association": "MEMBER",
      "body": "Thanks so much for the great review @romanz I took most of your suggestions, there's still an open question about `m_recv_buffer` but I really appreciate all your attention to string copying!",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2799390114",
      "submitted_at": "2025-04-29T13:23:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "commented",
      "id": 2848493348,
      "node_id": "IC_kwDOABII586pyI8k",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2848493348",
      "actor": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-03T07:54:16Z",
      "updated_at": "2025-05-03T07:54:16Z",
      "author_association": "CONTRIBUTOR",
      "body": "tACK https://github.com/bitcoin/bitcoin/commit/7d301184016a3f59c2e363dff631263cdbe21da0\r\n\r\nTested with both [electrs](https://github.com/romanz/electrs) and [bindex](https://github.com/romanz/bindex-rs).",
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-2848493348",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "review_requested",
      "id": 17507193219,
      "node_id": "RRE_lADOABII586t8FMgzwAAAAQTgpGD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17507193219",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-03T07:54:21Z",
      "requested_reviewer": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 17507193235,
      "node_id": "RRE_lADOABII586t8FMgzwAAAAQTgpGT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17507193235",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-03T07:54:21Z",
      "requested_reviewer": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 17507193255,
      "node_id": "RRE_lADOABII586t8FMgzwAAAAQTgpGn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17507193255",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-03T07:54:22Z",
      "requested_reviewer": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 2842608359,
      "node_id": "PRR_kwDOABII586pbsLn",
      "url": null,
      "actor": null,
      "commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-05-15T13:57:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "Posting review midway. Reviewed up to and including 144a777f86 `string: add CaseInsensitiveComparator`. I like that the PR starts with some new tests to enforce correct behavior.",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2842608359",
      "submitted_at": "2025-05-15T13:57:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "review_requested",
      "id": 17672863896,
      "node_id": "RRE_lADOABII586t8FMgzwAAAAQdYoCY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17672863896",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-15T13:57:42Z",
      "requested_reviewer": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 2846448811,
      "node_id": "PRR_kwDOABII586pqVyr",
      "url": null,
      "actor": null,
      "commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-05-16T14:44:48Z",
      "author_association": "CONTRIBUTOR",
      "body": "Posting review midway. Reviewed up to and including e95c6f5b6511ae35141b1e440e1f22e1004d3de6 `http: Implement HTTPHeaders class`",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2846448811",
      "submitted_at": "2025-05-16T14:44:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "review_requested",
      "id": 17690244547,
      "node_id": "RRE_lADOABII586t8FMgzwAAAAQea7XD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17690244547",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-16T14:44:53Z",
      "requested_reviewer": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "labeled",
      "id": 17730623431,
      "node_id": "LE_lADOABII586t8FMgzwAAAAQg09fH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17730623431",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-20T09:40:24Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2860857095,
      "node_id": "PRR_kwDOABII586qhTcH",
      "url": null,
      "actor": null,
      "commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-05-22T14:57:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "Posting review midway. Reviewed up to and including 980a9cd3d38abd0e0da85363056a2be6098d3919 `http: read requests from connected clients`.",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2860857095",
      "submitted_at": "2025-05-22T14:57:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "review_requested",
      "id": 17774348037,
      "node_id": "RRE_lADOABII586t8FMgzwAAAAQjbwcF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17774348037",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-22T14:57:08Z",
      "requested_reviewer": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 2899730748,
      "node_id": "PRR_kwDOABII586s1mE8",
      "url": null,
      "actor": null,
      "commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-05T14:02:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "Posting review midway. Reviewed up to and including b90f808e30 `http: disconnect after idle timeout (-rpcservertimeout)`",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2899730748",
      "submitted_at": "2025-06-05T14:02:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "review_requested",
      "id": 18002225054,
      "node_id": "RRE_lADOABII586t8FMgzwAAAAQxBCee",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18002225054",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-05T14:02:50Z",
      "requested_reviewer": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 2903739719,
      "node_id": "PRR_kwDOABII586tE41H",
      "url": null,
      "actor": null,
      "commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-06T07:17:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "Approach ACK 7d301184016a3f59c2e363dff631263cdbe21da0",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2903739719",
      "submitted_at": "2025-06-06T07:17:36Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "referenced",
      "id": 18062078269,
      "node_id": "REFE_lADOABII586t8FMgzwAAAAQ0lXE9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18062078269",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "d978a43d054d8a24e41d71b3aaad598ac41d0233",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d978a43d054d8a24e41d71b3aaad598ac41d0233",
      "created_at": "2025-06-09T20:08:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18255142221,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAARAF11N",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18255142221",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "e66712d4d3eb95cfd3beefc92c7888de9b65da38",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/e66712d4d3eb95cfd3beefc92c7888de9b65da38",
      "created_at": "2025-06-21T01:49:29Z"
    },
    {
      "event": "unlabeled",
      "id": 18255165201,
      "node_id": "UNLE_lADOABII586t8FMgzwAAAARAF7cR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18255165201",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-21T01:58:38Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 18255345949,
      "node_id": "LE_lADOABII586t8FMgzwAAAARAGnkd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18255345949",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-21T02:50:55Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2993271943,
      "node_id": "IC_kwDOABII586yabSH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2993271943",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-21T02:50:56Z",
      "updated_at": "2025-06-21T02:50:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Task `fuzzer,address,undefined,integer, no depends`: https://github.com/bitcoin/bitcoin/runs/44516172178</sub>\n<sub>LLM reason (âœ¨ experimental): The CI failure is caused by a runtime error due to an implicit integer sign change detected by the sanitizer during fuzzing.</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-2993271943",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18257758535,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAARAP0lH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18257758535",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "aa89c97173c7d637c9a90b005c2c55ada998e94f",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/aa89c97173c7d637c9a90b005c2c55ada998e94f",
      "created_at": "2025-06-21T16:41:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18259292230,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAARAVrBG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18259292230",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "cdb13c92c74d893d766c75f7aabc0350d7a3c15d",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/cdb13c92c74d893d766c75f7aabc0350d7a3c15d",
      "created_at": "2025-06-22T00:13:31Z"
    },
    {
      "event": "unlabeled",
      "id": 18259450906,
      "node_id": "UNLE_lADOABII586t8FMgzwAAAARAWRwa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18259450906",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-22T01:11:14Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18262840738,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAARAjNWi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18262840738",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "created_at": "2025-06-22T21:46:01Z"
    },
    {
      "event": "reviewed",
      "id": 2936787243,
      "node_id": "PRR_kwDOABII586vC9Er",
      "url": null,
      "actor": null,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-22T23:20:53Z",
      "author_association": "MEMBER",
      "body": "Rebased to address comments by @vasild.\r\n\r\nAlso switched from https://github.com/bitcoin/bitcoin/pull/30988 (\"Split CConnman\") to https://github.com/bitcoin/bitcoin/pull/32747 (\"SockMan lite\") for the back end.\r\n\r\nThat also included a rebase on master where #32408 was merged, cherry picking some commits from this PR.",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2936787243",
      "submitted_at": "2025-06-22T23:20:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "commented",
      "id": 3016379665,
      "node_id": "IC_kwDOABII586zyk0R",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3016379665",
      "actor": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-29T07:37:14Z",
      "updated_at": "2025-06-29T07:58:13Z",
      "author_association": "CONTRIBUTOR",
      "body": "Low-latency HTTP request benchmark improvement - compared with https://github.com/bitcoin/bitcoin/pull/32541#discussion_r2169518557's taking ~130ms per request:\r\n```\r\n$ ab -k -c 1 -n 100000 http://localhost:8332/rest/txfromblock/000000000000000000017bfd05b5fa367a424c4a565a4baf7950d9e8605df8ec-5000.bin\r\n\r\nDocument Path:          /rest/txfromblock/000000000000000000017bfd05b5fa367a424c4a565a4baf7950d9e8605df8ec-5000.bin\r\nDocument Length:        234 bytes\r\n\r\nConcurrency Level:      1\r\nTime taken for tests:   11.554 seconds\r\nComplete requests:      100000\r\nFailed requests:        0\r\nKeep-Alive requests:    100000\r\nTotal transferred:      31700000 bytes\r\nHTML transferred:       23400000 bytes\r\nRequests per second:    8655.35 [#/sec] (mean)\r\nTime per request:       0.116 [ms] (mean)\r\nTime per request:       0.116 [ms] (mean, across all concurrent requests)\r\nTransfer rate:          2679.44 [Kbytes/sec] received\r\n```",
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3016379665",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "commented",
      "id": 3016428956,
      "node_id": "IC_kwDOABII586zyw2c",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3016428956",
      "actor": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-29T08:50:05Z",
      "updated_at": "2025-06-29T08:50:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "The latency of 404 response has improved too:\r\n```\r\n$ ab -k -c 1 -n 100000 http://localhost:8332/rest/\r\n...\r\nTime taken for tests:   2.876 seconds\r\nComplete requests:      100000\r\nFailed requests:        0\r\nNon-2xx responses:      100000\r\nKeep-Alive requests:    100000\r\nTotal transferred:      9500000 bytes\r\nHTML transferred:       0 bytes\r\nRequests per second:    34774.44 [#/sec] (mean)\r\nTime per request:       0.029 [ms] (mean)\r\nTransfer rate:          3226.14 [Kbytes/sec] received\r\n```\r\n\r\n`master` branch:\r\n```\r\n$ ab -k -c 1 -n 100000 http://localhost:8332/rest/\r\n...\r\nTime taken for tests:   3.805 seconds\r\nComplete requests:      100000\r\nFailed requests:        0\r\nNon-2xx responses:      100000\r\nKeep-Alive requests:    100000\r\nTotal transferred:      11400000 bytes\r\nHTML transferred:       0 bytes\r\nRequests per second:    26277.76 [#/sec] (mean)\r\nTime per request:       0.038 [ms] (mean)\r\nTransfer rate:          2925.45 [Kbytes/sec] received\r\n```",
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3016428956",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "reviewed",
      "id": 2969148112,
      "node_id": "PRR_kwDOABII586w-ZrQ",
      "url": null,
      "actor": null,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-29T08:53:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "Tested ACK e531a7cd2c",
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-2969148112",
      "submitted_at": "2025-06-29T08:53:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "review_requested",
      "id": 18373242869,
      "node_id": "RRE_lADOABII586t8FMgzwAAAARHIW_1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18373242869",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-29T08:53:27Z",
      "requested_reviewer": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "labeled",
      "id": 18515787406,
      "node_id": "LE_lADOABII586t8FMgzwAAAARPoH6O",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18515787406",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-08T01:57:12Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 3011050697,
      "node_id": "PRR_kwDOABII586zePzJ",
      "url": null,
      "actor": null,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-11T16:32:04Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-3011050697",
      "submitted_at": "2025-07-11T16:32:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "reviewed",
      "id": 3180206398,
      "node_id": "PRR_kwDOABII5869jhk-",
      "url": null,
      "actor": null,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-03T13:20:45Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK e531a7cd2c17dfb8d075d02865dbc25f8a832b3a\r\n\r\nAll my suggestions above have been addressed or some reasoning has been given why not.",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-3180206398",
      "submitted_at": "2025-09-03T13:20:45Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21047057972,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAATmgJ40",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21047057972",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "8c81bdf2532aa1c61e25d367a480ce3aa71362ca",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/8c81bdf2532aa1c61e25d367a480ce3aa71362ca",
      "created_at": "2025-11-19T16:01:12Z"
    },
    {
      "event": "commented",
      "id": 3553506888,
      "node_id": "IC_kwDOABII587TzjZI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3553506888",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-19T16:03:30Z",
      "updated_at": "2025-11-19T16:03:30Z",
      "author_association": "MEMBER",
      "body": "Push to 8c81bdf2532aa1c61e25d367a480ce3aa71362ca:\r\n\r\n- Rebase on #32747 which has gotten lots of good feedback, and is also rebased on master\r\n- Fix four nits from @vasild \r\n\r\nThis push is mainly for a CI sanity check, then I'm going to put it in draft while I refactor for @theuni main feedback which will be removing the sockman abstraction and implementing the I/O loop directly in `HTTPServer`",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3553506888",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "mentioned",
      "id": 21047126306,
      "node_id": "MEE_lADOABII586t8FMgzwAAAATmgaki",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21047126306",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-19T16:03:31Z"
    },
    {
      "event": "subscribed",
      "id": 21047126353,
      "node_id": "SE_lADOABII586t8FMgzwAAAATmgalR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21047126353",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-19T16:03:32Z"
    },
    {
      "event": "mentioned",
      "id": 21047126400,
      "node_id": "MEE_lADOABII586t8FMgzwAAAATmgamA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21047126400",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-19T16:03:32Z"
    },
    {
      "event": "subscribed",
      "id": 21047126434,
      "node_id": "SE_lADOABII586t8FMgzwAAAATmgami",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21047126434",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-19T16:03:32Z"
    },
    {
      "event": "convert_to_draft",
      "id": 21047130831,
      "node_id": "CTDE_lADOABII586t8FMgzwAAAATmgbrP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21047130831",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-19T16:03:43Z"
    },
    {
      "event": "unlabeled",
      "id": 21048249879,
      "node_id": "UNLE_lADOABII586t8FMgzwAAAATmks4X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21048249879",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-19T16:49:17Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 21048909957,
      "node_id": "LE_lADOABII586t8FMgzwAAAATmnOCF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21048909957",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-19T17:19:44Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 3553845053,
      "node_id": "IC_kwDOABII587T0189",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3553845053",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-19T17:19:52Z",
      "updated_at": "2025-11-19T17:19:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Task `previous releases`: https://github.com/bitcoin/bitcoin/actions/runs/19507786228/job/55838856410</sub>\n<sub>LLM reason (âœ¨ experimental): Compiler error: -Werror type-limits flags fail the build (comparison always false in strencodings.h), causing CI failure.</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3553845053",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "commented",
      "id": 3554122176,
      "node_id": "IC_kwDOABII587T15nA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3554122176",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-19T18:35:26Z",
      "updated_at": "2025-11-19T18:35:26Z",
      "author_association": "CONTRIBUTOR",
      "body": "re: https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3553506888\r\n\r\n> This push is mainly for a CI sanity check, then I'm going to put it in draft while I refactor for @theuni main feedback which will be removing the sockman abstraction and implementing the I/O loop directly in `HTTPServer`\r\n\r\nI agree with theuni it should make this PR easier to review and simpler if current sockman functionality ([sockman.cpp](https://github.com/pinheadmz/bitcoin/blob/8c81bdf2532aa1c61e25d367a480ce3aa71362ca/src/common/sockman.cpp)) is folded into HTTP code, since sockman's current sending interface and use of int ids don't seem very convenient for supporting HTTP.\r\n\r\nI could imagine this changing in the future though. If sockman provided a way to wake the event loop (https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-3549076531) it could work nicely for HTTP. Also in theory, other unused sockman functionality like the ability to listen on i2p or tor hidden service addresses could be potentially useful, if for example you had a node at home and wanted an easy way for a mobile app to be able to connect to it from anywhere.\r\n\r\nI guess I'm saying it probably does make sense for sockman and HTTP code to part ways for simplicity and ease-of-review, but I could imagine them being reconciled at some point later. And we might want to reconsider the situation if #30988 makes more progress.",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3554122176",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "mentioned",
      "id": 21050455174,
      "node_id": "MEE_lADOABII586t8FMgzwAAAATmtHSG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21050455174",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-19T18:35:27Z"
    },
    {
      "event": "subscribed",
      "id": 21050455247,
      "node_id": "SE_lADOABII586t8FMgzwAAAATmtHTP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21050455247",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-19T18:35:28Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21171978713,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAATt8sHZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21171978713",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "20f5f6c4447efe0688efd3478789f63479374d30",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/20f5f6c4447efe0688efd3478789f63479374d30",
      "created_at": "2025-11-25T18:59:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21177958948,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAATuTgIk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21177958948",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "ec474d283cb959c3be115b4a3a5d9607e06329d2",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/ec474d283cb959c3be115b4a3a5d9607e06329d2",
      "created_at": "2025-11-26T01:03:00Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21179904776,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAATua7MI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21179904776",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "4c7bdb8aec3f1fa385f3010e1d9995783353ba14",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/4c7bdb8aec3f1fa385f3010e1d9995783353ba14",
      "created_at": "2025-11-26T02:11:41Z"
    },
    {
      "event": "unlabeled",
      "id": 21181762565,
      "node_id": "UNLE_lADOABII586t8FMgzwAAAATuiAwF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21181762565",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-26T03:21:28Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "ready_for_review",
      "id": 21192667461,
      "node_id": "RFRE_lADOABII586t8FMgzwAAAATvLnFF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21192667461",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-26T11:02:02Z"
    },
    {
      "event": "commented",
      "id": 3580788520,
      "node_id": "IC_kwDOABII587Vbn8o",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3580788520",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-26T11:02:50Z",
      "updated_at": "2025-11-26T11:02:50Z",
      "author_association": "MEMBER",
      "body": "Ok this PR is back up for review. It is divorced from SockMan, and the I/O loop is now implemented inside `HTTPServer` itself.",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3580788520",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21252955854,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAATyxl7O",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21252955854",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "8106ac5d0f71fbd6445810f0f6388b36a7191b72",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/8106ac5d0f71fbd6445810f0f6388b36a7191b72",
      "created_at": "2025-11-29T18:54:22Z"
    },
    {
      "event": "commented",
      "id": 3591868282,
      "node_id": "IC_kwDOABII587WF496",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3591868282",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-29T18:55:07Z",
      "updated_at": "2025-11-29T18:55:07Z",
      "author_association": "MEMBER",
      "body": "push to 8106ac5d0f71fbd6445810f0f6388b36a7191b72:\r\n- multiple nits and suggestions taken from corecheck / sonarcloud",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3591868282",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21273617557,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAT0AaSV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21273617557",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "5f6842030a4d82b81d640f1109c543dabd0938ef",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/5f6842030a4d82b81d640f1109c543dabd0938ef",
      "created_at": "2025-12-01T11:34:36Z"
    },
    {
      "event": "commented",
      "id": 3596044151,
      "node_id": "IC_kwDOABII587WV0d3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3596044151",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T11:35:12Z",
      "updated_at": "2025-12-01T11:35:12Z",
      "author_association": "MEMBER",
      "body": "Push to 5f6842030a4d82b81d640f1109c543dabd0938ef:\r\n- More nits and suggestions from Sonarcloud",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3596044151",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "labeled",
      "id": 21308509899,
      "node_id": "LE_lADOABII586t8FMgzwAAAAT2Fg7L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21308509899",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T15:01:55Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21314538091,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAT2cgpr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21314538091",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "22ec2f95eecddd5dc6ea53f670f232a7e425a8d0",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/22ec2f95eecddd5dc6ea53f670f232a7e425a8d0",
      "created_at": "2025-12-02T19:00:05Z"
    },
    {
      "event": "commented",
      "id": 3603546302,
      "node_id": "IC_kwDOABII587WycC-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3603546302",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T19:01:41Z",
      "updated_at": "2025-12-02T19:01:41Z",
      "author_association": "MEMBER",
      "body": "push to 22ec2f95eecddd5dc6ea53f670f232a7e425a8d0:\r\n- fix conflicts with master, which were all logging fixes from https://github.com/bitcoin/bitcoin/pull/33960",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3603546302",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "unlabeled",
      "id": 21315227060,
      "node_id": "UNLE_lADOABII586t8FMgzwAAAAT2fI20",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21315227060",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T19:36:10Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 21510039315,
      "node_id": "LE_lADOABII586t8FMgzwAAAAUCGScT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21510039315",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-11T17:35:19Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 3578582144,
      "node_id": "PRR_kwDOABII587VTNSA",
      "url": null,
      "actor": null,
      "commit_id": "22ec2f95eecddd5dc6ea53f670f232a7e425a8d0",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-15T14:45:28Z",
      "author_association": "MEMBER",
      "body": "Concept ACK. libevent has been a source of issues in the past.\r\nAlso, the 10% speed up mentioned in the PR description is promising. I assume that was measured on the previous approach, so it would be nice to benchmark it again with the new one.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-3578582144",
      "submitted_at": "2025-12-15T14:45:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21648596245,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAUKW10V",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21648596245",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "625088468a3f2f1438fd71d1b87210e16904fa58",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/625088468a3f2f1438fd71d1b87210e16904fa58",
      "created_at": "2025-12-18T16:51:56Z"
    },
    {
      "event": "commented",
      "id": 3671216043,
      "node_id": "IC_kwDOABII587a0k-r",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3671216043",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-18T16:55:22Z",
      "updated_at": "2025-12-18T16:55:22Z",
      "author_association": "MEMBER",
      "body": "push to 625088468a3f2f1438fd71d1b87210e16904fa58:\r\n\r\n- Fix conflicts with master, mostly `LogDebug()` conflicts from #29641\r\n- Silent conflict with a test added in #33657 since the new URL parsing is more tolerant",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3671216043",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "unlabeled",
      "id": 21649341223,
      "node_id": "UNLE_lADOABII586t8FMgzwAAAAUKZrsn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21649341223",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-18T17:27:43Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 3612461816,
      "node_id": "PRR_kwDOABII587XUcr4",
      "url": null,
      "actor": null,
      "commit_id": "625088468a3f2f1438fd71d1b87210e16904fa58",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-25T17:38:30Z",
      "author_association": "CONTRIBUTOR",
      "body": "Reviewed until 6d5aa51abd7e0ca935d0f016d7350c89edc38c38 . What do you think about splitting off the first 6 commits into it's own pull (up to and including the line reader). I think these could be reviewed quickly and maybe give you some progress. These should me mergable and completely independent of other changes like #33689 . Speaking of, could you make clear if you would prefer that to be reviewed first and do you consider these changes here to be blocked by it? I am asking because I saw your a-c-k there...",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-3612461816",
      "submitted_at": "2025-12-25T17:38:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "commented",
      "id": 3691629461,
      "node_id": "IC_kwDOABII587cCcuV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3691629461",
      "actor": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-25T17:38:44Z",
      "updated_at": "2025-12-25T20:28:44Z",
      "author_association": "CONTRIBUTOR",
      "body": "Nice performance improvement in low-latency requests (requesting a non-existing header):\r\n```\r\n$ ab -k -c 1 -n 100000 http://localhost:8332/rest/headers/0000000000000000000000000000000000000000000000000000000000000000.bin\r\n\r\nDocument Length:        0 bytes\r\n\r\nConcurrency Level:      1\r\nComplete requests:      100000\r\nFailed requests:        0\r\nKeep-Alive requests:    100000\r\nTotal transferred:      10200000 bytes\r\nHTML transferred:       0 bytes\r\n```\r\n| | commit | avg duration |\r\n| - | - | - |\r\n| this PR     | 625088468a | 25 us |\r\n| base | 09a1fa190e | 32 us |\r\n",
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3691629461",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21908395278,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAUZ15UO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21908395278",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "63a9487dc3f1667b66a711ee43ec3c5a6ff181fc",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/63a9487dc3f1667b66a711ee43ec3c5a6ff181fc",
      "created_at": "2026-01-07T21:21:11Z"
    },
    {
      "event": "reviewed",
      "id": 3636265629,
      "node_id": "PRR_kwDOABII587YvQKd",
      "url": null,
      "actor": null,
      "commit_id": "63a9487dc3f1667b66a711ee43ec3c5a6ff181fc",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-07T23:00:20Z",
      "author_association": "MEMBER",
      "body": "Push to 63a9487dc3f1667b66a711ee43ec3c5a6ff181fc:\r\n\r\nAddress review feedback from @fjahr on first 6 commits, changes included renaming functions and rewording commit messages for better clarity. I plan on opening a new PR with just these 6 commits shortly, some of that code can also be consumed by #34158 ",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-3636265629",
      "submitted_at": "2026-01-07T23:00:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "reviewed",
      "id": 3639386661,
      "node_id": "PRR_kwDOABII587Y7KIl",
      "url": null,
      "actor": null,
      "commit_id": "63a9487dc3f1667b66a711ee43ec3c5a6ff181fc",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-08T14:24:03Z",
      "author_association": "CONTRIBUTOR",
      "body": "nit-picking a bit more on LineReader edge cases :) Looking forward to the separate PR!",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-3639386661",
      "submitted_at": "2026-01-08T14:24:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21951173310,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAUcZFK-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21951173310",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "b6afd81f58f5aabb20fb02924a3e259670d6b3ab",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/b6afd81f58f5aabb20fb02924a3e259670d6b3ab",
      "created_at": "2026-01-09T16:23:09Z"
    },
    {
      "event": "reviewed",
      "id": 3640027158,
      "node_id": "PRR_kwDOABII587Y9mgW",
      "url": null,
      "actor": null,
      "commit_id": "b6afd81f58f5aabb20fb02924a3e259670d6b3ab",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-09T18:12:02Z",
      "author_association": "MEMBER",
      "body": "Push to b6afd81f58:\r\n\r\nAddress feedback from @fjahr about `LineReader()`, fix edge-case handling.\r\nAt this point I'm going to split off the first 6 commits to a new PR and we can focus review there instead. \r\n\r\nThe new PR is https://github.com/bitcoin/bitcoin/pull/34242",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-3640027158",
      "submitted_at": "2026-01-09T17:38:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "referenced",
      "id": 22241518036,
      "node_id": "REFE_lADOABII586t8FMgzwAAAAUtsqHU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22241518036",
      "actor": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "0871e104a26d0e0a9da3c01d96c44ea50937806b",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0871e104a26d0e0a9da3c01d96c44ea50937806b",
      "created_at": "2026-01-23T12:25:49Z"
    },
    {
      "event": "labeled",
      "id": 22243326771,
      "node_id": "LE_lADOABII586t8FMgzwAAAAUtzjsz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22243326771",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-23T13:52:49Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 22251082471,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAUuRJLn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22251082471",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "3002fbe0d97243d3534a53240d5574d0d4194bba",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/3002fbe0d97243d3534a53240d5574d0d4194bba",
      "created_at": "2026-01-23T19:32:55Z"
    },
    {
      "event": "unlabeled",
      "id": 22252281965,
      "node_id": "UNLE_lADOABII586t8FMgzwAAAAUuVuBt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22252281965",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-23T20:38:44Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 3792328384,
      "node_id": "IC_kwDOABII587iClbA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3792328384",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-23T20:43:41Z",
      "updated_at": "2026-01-23T20:43:41Z",
      "author_association": "MEMBER",
      "body": "push to 3002fbe0d9:\r\n- Rebase on master and drop the commits merged into #34242 ",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3792328384",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "reviewed",
      "id": 3701930019,
      "node_id": "PRR_kwDOABII587cpvgj",
      "url": null,
      "actor": null,
      "commit_id": "3002fbe0d97243d3534a53240d5574d0d4194bba",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-24T22:14:34Z",
      "author_association": "CONTRIBUTOR",
      "body": "Still kind working on getting a good hold of the big picture but leaving a few questions/comments I had along the way.\r\n\r\nCurious if this would be a good project for differential fuzzing between the two different http servers. Did that already come up anywhere @pinheadmz ?",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-3701930019",
      "submitted_at": "2026-01-24T22:14:34Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "commented",
      "id": 3800392736,
      "node_id": "IC_kwDOABII587ihWQg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3800392736",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-26T16:07:13Z",
      "updated_at": "2026-01-26T16:07:13Z",
      "author_association": "MEMBER",
      "body": "@fjahr great idea about differential fuzzing, I'll get started on that",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3800392736",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "mentioned",
      "id": 22293358173,
      "node_id": "MEE_lADOABII586t8FMgzwAAAAUwyaZd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22293358173",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-26T16:07:15Z"
    },
    {
      "event": "subscribed",
      "id": 22293358202,
      "node_id": "SE_lADOABII586t8FMgzwAAAAUwyaZ6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22293358202",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-26T16:07:15Z"
    },
    {
      "event": "commented",
      "id": 3825126581,
      "node_id": "IC_kwDOABII587j_sy1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3825126581",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-30T18:41:21Z",
      "updated_at": "2026-01-30T18:41:21Z",
      "author_association": "MEMBER",
      "body": "I've started fuzzing this branch using [Fuzzamoto](https://dergoegge.github.io/fuzzamoto/) and plenty of assistance from @brunoerg SO far just crash-test fuzzing, differential fuzzing will come later. Luckily for me fuzzing the HTTP server is one of the example scenarios built in to the program ;-) I ran it for about a day without crashes, and generate a coverage report:\r\n\r\nhttps://thebitcoinblockclock.com/demo/http_coverage_output/coverage-report/coverage/bitcoin/src/httpserver.cpp.html\r\n\r\nNow that I have the workflow figured out, I'll run a lot more",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3825126581",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "mentioned",
      "id": 22414919637,
      "node_id": "MEE_lADOABII586t8FMgzwAAAAU4CIfV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22414919637",
      "actor": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-30T18:41:22Z"
    },
    {
      "event": "subscribed",
      "id": 22414919662,
      "node_id": "SE_lADOABII586t8FMgzwAAAAU4CIfu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22414919662",
      "actor": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-30T18:41:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 22449248047,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAU6FFcv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22449248047",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "c4b3f6971ef0faf27ca250c109eaca35af53a6f7",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/c4b3f6971ef0faf27ca250c109eaca35af53a6f7",
      "created_at": "2026-02-01T22:01:32Z"
    },
    {
      "event": "reviewed",
      "id": 3730014021,
      "node_id": "PRR_kwDOABII587eU39F",
      "url": null,
      "actor": null,
      "commit_id": "c4b3f6971ef0faf27ca250c109eaca35af53a6f7",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-02-02T00:30:46Z",
      "author_association": "MEMBER",
      "body": "Push to c4b3f6971ef0faf27ca250c109eaca35af53a6f7\r\n\r\nAddress review from @fjahr including a few medium-sized approach changes.\r\n\r\n- Switch `HTTPHeaders.m_map` from `unordered_map` to `vector<pair<string string>>`. To allow duplicate field-names and be less protocol-restrictive, like libevent.\r\n    - `Find` and `Remove` are now `FindFirst` and `RemoveFirst`\r\n    - Moved around string utilities including a partial revert of #34242 \r\n- Reject empty field names in headers\r\n- Reject invalid http versions\r\n- Wait 30 seconds for graceful client disconnection during shutdown\r\n    - TODO: still needs an extra test that hangs forever on master\r\n\r\nnits:\r\n- Remove trailing `\\n` from log messages\r\n- Use `constexpr`\r\n- Prefer `BOOST_CHECK_EXCEPTION` with error messages over `BOOST_THROW`\r\n- Add more edge cases in unit tests\r\n",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-3730014021",
      "submitted_at": "2026-02-02T00:30:46Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    },
    {
      "event": "referenced",
      "id": 22710252431,
      "node_id": "REFE_lADOABII586t8FMgzwAAAAVJovOP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22710252431",
      "actor": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "4a05825a3f3993b8e402a7c18e2bc04f6d287e96",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4a05825a3f3993b8e402a7c18e2bc04f6d287e96",
      "created_at": "2026-02-11T17:04:49Z"
    },
    {
      "event": "labeled",
      "id": 22712234116,
      "node_id": "LE_lADOABII586t8FMgzwAAAAVJwTCE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22712234116",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-11T18:18:11Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk1NDFhMTc5ZmIzOWI0OTI0N2E1ZjRlNGMyYWQzNTU3N2YxY2NkMWY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9541a179fb39b49247a5f4e4c2ad35577f1ccd1f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9541a179fb39b49247a5f4e4c2ad35577f1ccd1f",
      "tree": {
        "sha": "b5f2eeae2fab0a0ad1efd05bf2185ca580af9d9a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b5f2eeae2fab0a0ad1efd05bf2185ca580af9d9a"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree b5f2eeae2fab0a0ad1efd05bf2185ca580af9d9a\nparent 07b924775e4ff5dbfb9f2e7549fd13db8ec5c61b\nauthor Matthew Zipkin <pinheadmz@pm.me> 1769880032 -0500\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909336 -0500\n\nstring: replace AsciiCaseInsensitiveKeyEqual with CaseInsensitiveEqual\n\nThis reverts commit eea38787b9be99c3f192cb83fc18358397e4ab52 from PR #34242\n\nWe do not need comparators for an unordered_map for HTTPHeaders, we just\nneed a simple, locale-independent, ascii-only compare function for\na vector of key-value pairs of strings.\n\nWe have CaseInsensitiveEqual already in test utils, this commit moves\nit to the strencodings module for use in the application code.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7pgACgkQ5+KYS2KJ\nyTq/Rg/+IrSZHeQMr7l07MOUIytEsw6GAagFwmDfx0GwX40+JKa2VF9blrNxFI5q\nePkd64lp9bSrrd7ouO6aVNlO6fglmYUAZyCpUqKzZd61Onnvtft1zqL1aBjCUcIZ\nsnCOJ7UQNyXrm6eHPYN4ZVZiqv5iFnTTYD7e6cTygJIAdrPF5ommWF3ePke4rh2S\nHGI/9+h5xu0WOjtoTOL4XkNvaWWHwXPlguZEzUlIrIWxwt32PE4yn0gZ5EUaoVt5\nc/N/tEjE5nqvt8gfOcI/EmKxz782oTqb2FX9y/ARYarGWeR9N/AoFzHBlFDjaJxZ\nejWGT+vkfILlHsX1cASOomTfNfHHoRFtyiySdOtL8NERas3eMQw/NFH/9NGnf/gX\nugaTiVpF4hbAh104+cfD4Cc4DukhV314pOAeASVzHuDNgGN+wQfRAbxxSQkJyvK1\nIIH5PWj+Avx1OOGvxUz4fCuIyElQjvpHmU/7FkffH7bVpjyYErxOHEpB0sPt+q2P\n7FCTCmJtbToEVg9S4eCnSqx7aTqNI7zHudrxeTr2O+wPgflQiZL4amzPExPkuwle\nORuW5UeM+bexDoqrvgwPn2QxQl/lH0gdlKkAMBkHVcCtGhkQan893or2ISznrrli\nRXc1GX8BWlt+R1VafyWoxPc5Q7U9K56DDzINUitKYBmi21GAMBo=\n=rhsE\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/07b924775e4ff5dbfb9f2e7549fd13db8ec5c61b",
          "sha": "07b924775e4ff5dbfb9f2e7549fd13db8ec5c61b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/07b924775e4ff5dbfb9f2e7549fd13db8ec5c61b"
        }
      ],
      "message": "string: replace AsciiCaseInsensitiveKeyEqual with CaseInsensitiveEqual\n\nThis reverts commit eea38787b9be99c3f192cb83fc18358397e4ab52 from PR #34242\n\nWe do not need comparators for an unordered_map for HTTPHeaders, we just\nneed a simple, locale-independent, ascii-only compare function for\na vector of key-value pairs of strings.\n\nWe have CaseInsensitiveEqual already in test utils, this commit moves\nit to the strencodings module for use in the application code.",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:36Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-01-31T17:20:32Z"
      },
      "sha": "9541a179fb39b49247a5f4e4c2ad35577f1ccd1f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDUxY2UwYjYwNzE5MWQ2ZTM3Mzk3M2I0NDU5YTUzN2NhMDdmNGYxMzc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/51ce0b607191d6e373973b4459a537ca07f4f137",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/51ce0b607191d6e373973b4459a537ca07f4f137",
      "tree": {
        "sha": "87828346391120a253317334fe2fd24e206d68b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/87828346391120a253317334fe2fd24e206d68b7"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 87828346391120a253317334fe2fd24e206d68b7\nparent 9541a179fb39b49247a5f4e4c2ad35577f1ccd1f\nauthor Matthew Zipkin <pinheadmz@pm.me> 1727713734 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909341 -0500\n\nhttp: enclose libevent-dependent code in a namespace\n\nThis commit is a no-op to isolate HTTP methods and objects that\ndepend on libevent. Following commits will add replacement objects\nand methods in a new namespace for testing and review before\nswitching over the server.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p0ACgkQ5+KYS2KJ\nyTonCA//VMGT3MzYpQSoiGE+4ivNEinHBksTb3wa+mSBjY9DxxFh9iI11hPuVYY1\ntypF1+zn45AvW3Bt/eGIfb01XRDYjvlX0H/ffnVj4QP9GxE+uni81GcdBdyiuKmR\nOh49v9JonZjwyF8wW6HDU0ao8LNItVRch1R0ERg2kUZQ4EmMexA2GWrRGlzTG4Ec\niXS9nfHMDQkPhHJBXHSwbsxebnV2lVrjFVZeSQPDtRQJEiL5GREQBpg2oYCu7NES\nk+dvcGjceEWXB2LxgxmCb8uoitZ/XGmPpoBBfGmElgdwqEOtv4rRCnZxrZVHHXse\ncd8dwFeK/dRL3EptCp3tQHDaPaEOb3M3pCX3iD8wroc2TGN26Ij9DUGBsRR0Q+pa\nnN0sQ9svZM2tJB3WV77E0kvIbzcdF9n5NqvLoc01mgN9YAPKRc1vy3ZNksMH1IRB\nNn9IliBPhTBwsiy8q5d+Dy35uSLaSLb/YUHrLbegelg8Fk4FhC+LDYLYDdRxsiy9\ncKFL3CDupSI8t/qdB/9AmiIqjVIZwU/jqN6ZxpSqX8ijvN2e3rxf/F5v1ylBulJe\nH1VgC8CgnrTxOYWlzRuHQw6+JhSoUEJMdzIbP03X5fNfF0fzifq4ZjSzMCzljVmp\nSWol/beLdyFWzBqnJjYtwYBKuXf0n4NS3b2kX8fUusWy2Tqlqhk=\n=HakA\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9541a179fb39b49247a5f4e4c2ad35577f1ccd1f",
          "sha": "9541a179fb39b49247a5f4e4c2ad35577f1ccd1f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9541a179fb39b49247a5f4e4c2ad35577f1ccd1f"
        }
      ],
      "message": "http: enclose libevent-dependent code in a namespace\n\nThis commit is a no-op to isolate HTTP methods and objects that\ndepend on libevent. Following commits will add replacement objects\nand methods in a new namespace for testing and review before\nswitching over the server.",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:41Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2024-09-30T16:28:54Z"
      },
      "sha": "51ce0b607191d6e373973b4459a537ca07f4f137"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGZiYjg0NGYxNmI1NjM2N2IyMGI3Yjk4ZDM5ODk1ZmM1MzY0Nzk4ZTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fbb844f16b56367b20b7b98d39895fc5364798e5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/fbb844f16b56367b20b7b98d39895fc5364798e5",
      "tree": {
        "sha": "89135596d79e50a459c8dd4c064655c65b4869ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/89135596d79e50a459c8dd4c064655c65b4869ea"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 89135596d79e50a459c8dd4c064655c65b4869ea\nparent 51ce0b607191d6e373973b4459a537ca07f4f137\nauthor Matthew Zipkin <pinheadmz@pm.me> 1727716949 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909341 -0500\n\nhttp: Implement HTTPHeaders class\n\nsee:\nhttps://www.rfc-editor.org/rfc/rfc2616#section-4.2\nhttps://www.rfc-editor.org/rfc/rfc7231#section-5\nhttps://www.rfc-editor.org/rfc/rfc7231#section-7\nhttps://httpwg.org/specs/rfc9111.html#header.field.definitions\n\nThis commit also moves StringToBuffer to test/util/str\nsince it is now used in more than one test.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p0ACgkQ5+KYS2KJ\nyTrNmhAA2e9UszyffmYNNpb7GwCcuzycnojkGRdgyARW0xhFiUbILZbmDN8e+GC5\nCZo7YWN793sJRewQgEPrWj9z/SvYgnf4AuHOdSXlynAq6KS9Y5RKnOr168uZuYvc\nFAMqIjjilsW1AhCM55wY5gxy2S92ZnuO3jPN9Efsi78zOo9Vy7WJSsFmW4KQ0hGu\nKlsXhUfCsgaHmCMdxUmHOZ3owcRO7ehYqFC6qfu83NmJe8EzQwCMRfETkMLfP3v0\nBeUXUqo8YgjpDSjqF4ihMDrHRDypcb2nq+w2zYqL9w2pPvDMIQyh+EmU+O0LR+az\n5e6tkY7GvsjThB2PfAZhCh/VN4tSw3Mg7LKSCZR1SNUNsatO4bb7gjWUuyhUF4HP\n1oy03+1/jR71OEv1XxvlWualPbytMrw8Fdh+fHhf7+gdvYGT29WV3YR7mUi7F5Ye\n0O9mjASXpXE1VuN/1HDmAZSVAZaqGon5SgTKrKxFLef7NWafAK0mHL/aGTWG09D2\nxRuNSgFFQktXr3p3MbxGRIBDCXtx0lWGelXhZj0ZSB/1i6mucK+I3Q/AjjDp86oa\nAl/zlkvDpyjTKotdq9Q9G4TgQhcnAMNgjxQmVkoKE3T1UaRyg+CwDasE8fvkTXbN\nv+ttJcLcAMqYIMy1OIqJIUN8pzhWE2HC5wA2qQ2P4+SaWtO4OQQ=\n=WnOv\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/51ce0b607191d6e373973b4459a537ca07f4f137",
          "sha": "51ce0b607191d6e373973b4459a537ca07f4f137",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/51ce0b607191d6e373973b4459a537ca07f4f137"
        }
      ],
      "message": "http: Implement HTTPHeaders class\n\nsee:\nhttps://www.rfc-editor.org/rfc/rfc2616#section-4.2\nhttps://www.rfc-editor.org/rfc/rfc7231#section-5\nhttps://www.rfc-editor.org/rfc/rfc7231#section-7\nhttps://httpwg.org/specs/rfc9111.html#header.field.definitions\n\nThis commit also moves StringToBuffer to test/util/str\nsince it is now used in more than one test.",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:41Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2024-09-30T17:22:29Z"
      },
      "sha": "fbb844f16b56367b20b7b98d39895fc5364798e5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDMxZTg5YzYxOGUxODQ5NGNiMjNhMmI2MTExNTEzYzk0NDJlYjg2YmM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/31e89c618e18494cb23a2b6111513c9442eb86bc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/31e89c618e18494cb23a2b6111513c9442eb86bc",
      "tree": {
        "sha": "3d5770c026093aefb43874dc70c622daf5db9326",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3d5770c026093aefb43874dc70c622daf5db9326"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 3d5770c026093aefb43874dc70c622daf5db9326\nparent fbb844f16b56367b20b7b98d39895fc5364798e5\nauthor Matthew Zipkin <pinheadmz@pm.me> 1729090626 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909342 -0500\n\nhttp: Implement HTTPResponse class\n\nHTTP Response message:\nhttps://datatracker.ietf.org/doc/html/rfc1945#section-6\n\nStatus line (first line of response):\nhttps://datatracker.ietf.org/doc/html/rfc1945#section-6.1\n\nStatus code definitions:\nhttps://datatracker.ietf.org/doc/html/rfc1945#section-9\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p4ACgkQ5+KYS2KJ\nyTrc1A/+Ltm3p3Xpv7BKdVYHLLG/ujwlzcCWc6pv4i2lvMj4b7+96uqS8VjUHcfa\nYBKDDRPxTCfdUw2uZjwwlFDd3nb8kYVD6/9rts1p1pLDgp/hmyiqeZLWpeTgtKPE\nCcwnCqXiX7r5lHMfLdHuYtt8kzu0k3Vi2w0G1Rxc1hK9+JVqoi5RRXtIpU1ZdASh\noOc18NfIyykSFD7if7PvJBVti0Y014LFGXR5Iwdsy8TZ/QEIRBhGhqivaIRKzpG+\nZruaqKHMO5DOqZQaKyO+xxK/Bo9QNmg+ocjyRLN20idqnZlxANxtaph+IbMcvUbt\nXMl0G7ADpHwUte4iSIIokNylhM3vmvWF6+ViWUYyo6Y2PKQWAcrLqPZhEGvqnSRU\nYd4b1CYCY9GehVG3uYyU7LpQJhh2vzXuArWd/gumkR3PonRUq6JOifKPaS8Uve8v\nYV74mgAqoccH+PL+QAjqDTPDcitiURG91Ekc6u/DsyccKLOv3zZHQlkHgYRYPXsT\n/7o//ct6B+GFh0ja5mwy6Ae4RuugSI8aLrD59z4JIjiYGe99WcBeV3LuuspiAvZH\nO5Ih7+KWA5dklS3nyEGf87dKU1uTljPFfbXIpinTni77Vp6lAom1gucd9fj31vOx\nkU0+XcAEolnUL4muAB5Vxkw4NuMGha664rsyYG145ApF1ot76nU=\n=6zr6\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fbb844f16b56367b20b7b98d39895fc5364798e5",
          "sha": "fbb844f16b56367b20b7b98d39895fc5364798e5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/fbb844f16b56367b20b7b98d39895fc5364798e5"
        }
      ],
      "message": "http: Implement HTTPResponse class\n\nHTTP Response message:\nhttps://datatracker.ietf.org/doc/html/rfc1945#section-6\n\nStatus line (first line of response):\nhttps://datatracker.ietf.org/doc/html/rfc1945#section-6.1\n\nStatus code definitions:\nhttps://datatracker.ietf.org/doc/html/rfc1945#section-9",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:42Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2024-10-16T14:57:06Z"
      },
      "sha": "31e89c618e18494cb23a2b6111513c9442eb86bc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU1ZmMxNWI0MDM1ZTU1OTQ2NDJjMmZlYjZmZTVhZGE3NjJkZDM1NTA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/55fc15b4035e5594642c2feb6fe5ada762dd3550",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/55fc15b4035e5594642c2feb6fe5ada762dd3550",
      "tree": {
        "sha": "063cdbdbdb8bfa2aec84c85f1b34a4e31e263678",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/063cdbdbdb8bfa2aec84c85f1b34a4e31e263678"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 063cdbdbdb8bfa2aec84c85f1b34a4e31e263678\nparent 31e89c618e18494cb23a2b6111513c9442eb86bc\nauthor Matthew Zipkin <pinheadmz@pm.me> 1729102725 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909342 -0500\n\nhttp: Implement HTTPRequest class\n\nHTTP Request message:\nhttps://datatracker.ietf.org/doc/html/rfc1945#section-5\n\nRequest Line aka Control Line aka first line:\nhttps://datatracker.ietf.org/doc/html/rfc1945#section-5.1\n\nSee message_read_status() in libevent http.c for how\n`MORE_DATA_EXPECTED` is handled there\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p4ACgkQ5+KYS2KJ\nyTrwWRAAmSqqFYZJjA+nIaPjaZZlv2MHEXHqDElH767yMJ0WW75/VJeU9whMhWKr\nyd82R/s6h/yOr/DIUD1d2x3NTqouervJs/nB3P8rKQSjIvMWcVyEb/Hym753B0uQ\nLm6FClEBrFYyBokIkUWVVWeG8TfyZur+rbpOKcryAM6HRwLouF8TF4FVEsUQfWkW\nInvLC9q3K9s1SLKKQl2jiGzzz1RBuWMSfbhX9Eawfao+4IZNB+UbSBWS3TghrfqL\nTjZYrFD5dUu6g/B3Vi2alcgBlX7snXfUrGxCxylPJ37CQS41sFSSUaOYpnMnIX8I\njH25S/HscQNEDLJ/cQmKtPFIzgI6b16stz6LEFkTfXXNkbiCEIHEz4Zvz+3dJEEW\nVjDVrvz2lxkvuaifoZu9Su5j6/8Drf+kYRO8UiXG3F+O5XVrYX5xSzraUdBk5vZC\nLAcl1NJCJANc3Cyf3ymZGpkfY1Zf8ImxYUVtLGwtrjqmlKBDlxL92apKC888J1xv\n/1G9DLEuWc2pGNMOwbctxv84WQQYFppn1g5O0Vr5giSgdFfYbEZl3QbL0zs/ekpo\njj/h8uH27ouXuy37sJHl12AFWsa3qr2QwBSwejFR9tEHnxa6SSuNaJ5ePzcRhLHa\n2FTn5bzRPrZiGGiWmHCm+mPEbCg7gAC66iP2gtgaCqWsYjt5T7Y=\n=1PY+\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/31e89c618e18494cb23a2b6111513c9442eb86bc",
          "sha": "31e89c618e18494cb23a2b6111513c9442eb86bc",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/31e89c618e18494cb23a2b6111513c9442eb86bc"
        }
      ],
      "message": "http: Implement HTTPRequest class\n\nHTTP Request message:\nhttps://datatracker.ietf.org/doc/html/rfc1945#section-5\n\nRequest Line aka Control Line aka first line:\nhttps://datatracker.ietf.org/doc/html/rfc1945#section-5.1\n\nSee message_read_status() in libevent http.c for how\n`MORE_DATA_EXPECTED` is handled there",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:42Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2024-10-16T18:18:45Z"
      },
      "sha": "55fc15b4035e5594642c2feb6fe5ada762dd3550"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGRiZDIwN2UzMmM2ZjhhMzEwNDg3ZDY5YmU1NzlkZmVhMTIwYzkwZDk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dbd207e32c6f8a310487d69be579dfea120c90d9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/dbd207e32c6f8a310487d69be579dfea120c90d9",
      "tree": {
        "sha": "760c6bc9ad9ef2e33a71e4a7ab14c3d2c1ca4bf9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/760c6bc9ad9ef2e33a71e4a7ab14c3d2c1ca4bf9"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 760c6bc9ad9ef2e33a71e4a7ab14c3d2c1ca4bf9\nparent 55fc15b4035e5594642c2feb6fe5ada762dd3550\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749059576 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909342 -0500\n\nhttp: Introduce HTTPServer class and implement binding to listening socket\n\nIntroduce a new low-level socket managing class `HTTPServer`.\n\nBindAndStartListening() was copied from CConnMan's BindListenPort()\nin net.cpp and modernized.\n\nUnit-test it with a new class `SocketTestingSetup` which mocks\n`CreateSock()` and will enable mock client I/O in future commits.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p4ACgkQ5+KYS2KJ\nyToV5w//Q1UOZw7wxOuTUCxVCG6avNmqbNH1W7V0RvE4rqgaLFumH1v4k63x8dsa\naMcBDAkjaQIR9xFj/dJnBJZAu1ZGT5JWAKDzVsou0i3NFRqS+DMxwIZf7RqwK8DE\ntKbfo7yzQIOZ18cW8SvB+eUVh3AdunM9EXA+xdhAO0tAQjZa8k6wnAW3lG7+BaYP\nZnZx9lx+ZUt0gJfgB4i/OESKPsn+yGvTmUJk3U29l1H4kG0Dq9G372SbtGn2QHFU\nZ1YLGL5tKQkY/m4zh9ful+5rOqDRo/k8DlsXCUXOpHFbi9k876Wb73c47jdf5sKX\nrhj69lZhkFzUFpIJhFvkWVlAFmr7PqM5iwxCky/VT3NNpy+RQ7v9EWLb9hgZfy4H\np1d7AONefTQiCjO/JAUNteXCH5VWXYrONpojNAQo59uWP1RYQWdz2Drppv/3LXny\nEhdZE9TNUVtWV3xnLqocL73RgqIAVeQUfKZCxG71PKlcmBWHsKT3NAD4sZUdHDbv\n/BR1YvBYK14809cUJs/GyiRQ50ROnCfwFZPYR3aZ9yT7LCEgvBcIMDtRPcteZts5\nF9VFTXwIuIQXScbBfMcwBzpj55ZM8gf3x2twZOZ8srRzFGMqCjvtnYbEdUyUbbQK\nRPzbWEtWdKL0OfmI0fs7DlAJImsp5OUTqSg1M9tYOZ/dhFPYX/4=\n=s8r2\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/55fc15b4035e5594642c2feb6fe5ada762dd3550",
          "sha": "55fc15b4035e5594642c2feb6fe5ada762dd3550",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/55fc15b4035e5594642c2feb6fe5ada762dd3550"
        }
      ],
      "message": "http: Introduce HTTPServer class and implement binding to listening socket\n\nIntroduce a new low-level socket managing class `HTTPServer`.\n\nBindAndStartListening() was copied from CConnMan's BindListenPort()\nin net.cpp and modernized.\n\nUnit-test it with a new class `SocketTestingSetup` which mocks\n`CreateSock()` and will enable mock client I/O in future commits.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:42Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-04T17:52:56Z"
      },
      "sha": "dbd207e32c6f8a310487d69be579dfea120c90d9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU1NGRjMGRiMzY4ZmU1NDNhZWMwN2FlM2MzN2NlNjQ3Nzk5NDhlYWI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e54dc0db368fe543aec07ae3c37ce64779948eab",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e54dc0db368fe543aec07ae3c37ce64779948eab",
      "tree": {
        "sha": "e73405529abb3c6beb4516b1a16584c88c640c8b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e73405529abb3c6beb4516b1a16584c88c640c8b"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e73405529abb3c6beb4516b1a16584c88c640c8b\nparent dbd207e32c6f8a310487d69be579dfea120c90d9\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749060853 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909342 -0500\n\nHTTPServer: implement and test AcceptConnection()\n\nAcceptConnection() is mostly copied from CConmann in net.cpp\nand then modernized.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p4ACgkQ5+KYS2KJ\nyTrdJA//RL1z//TF0c1hBtg5XP1E6fIL74uD3v16Aca89rwAeDDNDHNB4NjHI+hG\n+75FGro3bzuzG6o1+F4WQ+Jm8oG9/AsBQuJLX/iC6p6YHApMkACz/D1fYas7oJLB\nfa3G0WC5Q0hx0sMZSXRSPr3keIFW7B1XWcgFVnNrT2QAesV7NH/cf5LhXy/dVF/J\n4ye/dAdLoTiUqBBl27rBG+dhPm1tqInDl3ElLhG/FhwCNyj0NiUPjJO6jVnx6fLs\nInNPyh+5eTmqb9W8uoLH9NnU6koEd8i4OwiZIGyWrQbVPi6bYW0sSNsYlgRJYjlM\nucCi/NoBcFFF5fmKuRjZ5VV7yXAdVWMk0sKQBWuFZDiZZGeIyQGoGsCSkD/Q7qAW\ngdluMHWnsoncy9erkKZZfM3/w1VdiaY8Ak6Mu5aFxrFzqEEQhpcbKd617IGgwFcQ\nxXChRrDqRQ/ply4CCOysRdYAu045kV36FHldowEOntzFxtWydoeaFvx1pCuE0CHB\nc7Uqm88X9buHHCOrTkvJG0Oo/n9EXKsuPNHnkp76OomEKA4MUXXtodyEOdTPYRi4\nSnbdQjDUIGttUIeQzYy8A8pP3Yf+IS/jYK3RfKRGEtb97SR1sb37E62IsBT01k0P\nlEMc3KaGbHertoKIxHGVPm5I6qhpUg7iR+NpGFUaikBRbwb6W0M=\n=ZFGr\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dbd207e32c6f8a310487d69be579dfea120c90d9",
          "sha": "dbd207e32c6f8a310487d69be579dfea120c90d9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/dbd207e32c6f8a310487d69be579dfea120c90d9"
        }
      ],
      "message": "HTTPServer: implement and test AcceptConnection()\n\nAcceptConnection() is mostly copied from CConmann in net.cpp\nand then modernized.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:42Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-04T18:14:13Z"
      },
      "sha": "e54dc0db368fe543aec07ae3c37ce64779948eab"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQ2ZDhkOGE4NzVmZDAxYzc0MmVmNzczMmRjN2Q4N2JlN2NmM2IxNmU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d6d8d8a875fd01c742ef7732dc7d87be7cf3b16e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d6d8d8a875fd01c742ef7732dc7d87be7cf3b16e",
      "tree": {
        "sha": "6d3e7230b6de24d0ef29130c8f11fde567a12ce2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6d3e7230b6de24d0ef29130c8f11fde567a12ce2"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 6d3e7230b6de24d0ef29130c8f11fde567a12ce2\nparent e54dc0db368fe543aec07ae3c37ce64779948eab\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749061156 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909342 -0500\n\nHTTPServer: generate sequential Ids for each newly accepted connection\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p4ACgkQ5+KYS2KJ\nyTpDWw//d42zUjNUnR3LK7nLyDkrdefpzlirUzJ3dGOq668p5Xcc9JJ76vUSWiK5\nm/vYXMSrxA192ZHB3GT0JNU8SgXO/JkVP9Of+NadfWe8qWWq07kKWd+KiTbJn7QG\nlNlmq9KJFqubmhqmITLo2oESzEvzzVCajxhGmrs43nR11UlexyXYHid34jpYLYU3\ntoQ0IV56LCkB/67UbAGzURU0yMaMHpJDtZYkouEMfZiIFrii6uZs4D353143y1/i\np1Br/Glh6DzcrPvrkB5U3xT8W0uTcoYPiNzsa5/eM/WgQB9BmCz+Blfm0+CkO1MN\nvEdZgfR9d2f/OzSz4ow5ueoDw1qMiyYQloQ65DS+AJCEO2Vc0VnOWuKXKlsjMhBY\nREpAQ12FHvDWQEHHepZqvLRRSPoGsMeu1fiuWtObmNalryOP6CJ3/zP4Iql3F2cQ\nQ16HLF+jrKsoLRMWus3/j999QL9ADKJThCGOkI462cMQXI6WJhM8CrLjkq7gxT3e\niXLPsnW415UpVlA8fdXzsQ1zPi/xzo5wqHWT6C/LvdGBSUPySH+qBW1Pe9EMl0Mu\no7WDbKVwVtI+SMALXhsTUN8Z/i9fcFls2Fq9zjqbA4Tl88uIDPY+UvDKjnJtG3Ih\n6FPQod8hTDrkLE15hPHlMWguiSdku9qGqUZ6KrAza2uEkNZOarw=\n=CUpI\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e54dc0db368fe543aec07ae3c37ce64779948eab",
          "sha": "e54dc0db368fe543aec07ae3c37ce64779948eab",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e54dc0db368fe543aec07ae3c37ce64779948eab"
        }
      ],
      "message": "HTTPServer: generate sequential Ids for each newly accepted connection\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:42Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-04T18:19:16Z"
      },
      "sha": "d6d8d8a875fd01c742ef7732dc7d87be7cf3b16e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGUwZGJkYWYwOGY1OGRlYjU0MzJmOTQzODdmYTI1ZGMwYTAzMzYzNjg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e0dbdaf08f58deb5432f94387fa25dc0a0336368",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e0dbdaf08f58deb5432f94387fa25dc0a0336368",
      "tree": {
        "sha": "865996ffd5d6fa2e0cbbbf93decb55b2be0f470c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/865996ffd5d6fa2e0cbbbf93decb55b2be0f470c"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 865996ffd5d6fa2e0cbbbf93decb55b2be0f470c\nparent d6d8d8a875fd01c742ef7732dc7d87be7cf3b16e\nauthor Matthew Zipkin <pinheadmz@pm.me> 1763580302 -0500\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909342 -0500\n\nhttp: Introduce HTTPClient class\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p4ACgkQ5+KYS2KJ\nyTqBhhAAqwmcC7q8JaI/TFASqqIGj+rQ4BNXIIU5JwS/Xr3OTlDhpywV5uCI2SdE\nszgjeR6BVnH9e7CgiTxJkJ3GyDwXRCdmdpuUi/cnob5cBKFNLdxpjpdxNh4f9BBi\n3/gBTSGSehn0No7UaGCcF9TTnd4vQk0JB1FdTsuOvKDrMlWESPllPXNG7yqvtI+w\n2rXaXI+XcBcDtowgixpuqnjrUcVLgW6XpMcCXcK0FfnwJJbcKTfxCla4ErYMr7eF\nBKy8k20ybxJ7W+L9pag+QSkRQon3TK6e7NSl5S5GkMFCYgdklUOTLgvipevZHk4s\nAI26ZOEyCOS9y3K3sp3Q0x0p/Riz1tGJet+vNK4IXaBHw0tnhkFNaqEuFMvk3JY6\ngpN0DrvOEWpx/n2LSWixZ3Sualbg/I/dE0UE+P4PJ0sdKcstW2xn0QJs9lf3KkeI\nwckB8iFLCvf0h+slvo44RszLP0QyitnlFScAhnG15IXa4tjFCQFwxQZ8ekZWLW8z\nHJfu6+sfMpBh8JfMVenzN1RZSrfa4N3ZQU5I8N8FMUYn+TEbsKRTIHtrFXXIQ1+a\nnr/jfPohB8XTPyhm4MarK9BSk87MBNWckCKzuyDIjeWHQfvMaIqc+9FDkXf2RXFM\nAbr8lgWuQqE+mwbT6xqi4AZCDQ2e9K7iZt4Uuy81zBkf//p/AsY=\n=Ib5p\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d6d8d8a875fd01c742ef7732dc7d87be7cf3b16e",
          "sha": "d6d8d8a875fd01c742ef7732dc7d87be7cf3b16e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d6d8d8a875fd01c742ef7732dc7d87be7cf3b16e"
        }
      ],
      "message": "http: Introduce HTTPClient class",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:42Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-11-19T19:25:02Z"
      },
      "sha": "e0dbdaf08f58deb5432f94387fa25dc0a0336368"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGY4MzRlNmM3NjI4N2I0ZmUyYTIxZjRhMDQzYmViMWE0ZmUyNWFkYzM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f834e6c76287b4fe2a21f4a043beb1a4fe25adc3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f834e6c76287b4fe2a21f4a043beb1a4fe25adc3",
      "tree": {
        "sha": "b7d48d6a359e37cd079153de4a5af3a90e9de09a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b7d48d6a359e37cd079153de4a5af3a90e9de09a"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree b7d48d6a359e37cd079153de4a5af3a90e9de09a\nparent e0dbdaf08f58deb5432f94387fa25dc0a0336368\nauthor Matthew Zipkin <pinheadmz@pm.me> 1749754636 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909342 -0500\n\nHTTPServer: start an I/O loop in a new thread and accept connections\n\nSocket handling methods are copied from CConnMan:\n\n`CConnman::GenerateWaitSockets()`\n`CConnman::SocketHandlerListening()`\n`CConnman::ThreadSocketHandler()` and `CConnman::SocketHandler()` are combined into ThreadSocketHandler()`.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIyBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p4ACgkQ5+KYS2KJ\nyTrXJg/4nKx9ZRooqsiA9rLMTQSnNsMbHPSsbVNq2SE1S1qRZrwLyMEzMrinxwQP\ncoH/oi8IwZFgoGjMNn6vKnS5Xr8yWP9duRMJ9LbFBOFtkyX40xFiqnhnP1fhO8C1\n55qZTtubut00jaUL9UtisyIaJxJDg856Nih5YfFVOrBJUAtHlS3+LxNmv0eMbptb\nNNcX+B1OuOWvZXfa+fKqjoRrB9pOWM9SsLXTVj2+nHbAWeEsfmQRk8AjRjVIRSYe\nSsfU7oLj2zUoSJ6PoxID/9SBt1NYVm99cKENel04qq2E89HFQLKv770ZNkHFtf3E\n/sUDV7VXOVbn4E3I+KLrGu6gcPDh+/Km7kA58uxF20fo4zYlGAyKeKZyvG3N5wKu\nCOccS7P00UeShDlpd/X+/aAS9uBrZsyHmTahRJDkJ56xAQlU8TEJb8boseP4tf+f\naqfOt88E45dETAUGdiPXdkNRZgwQY7j1bd/bmcaPEEsBSkpYCeSuBblQ6FMLSa/i\nWFrPnX+RxkCLUTY+uWqI9fn9KH3Eh0fUanwcMJqZ1QLhYqkknaCnM6jaIzxY8TfB\nVpGq7vszT6qjA2d4UQWL/IUzyDDodh7Kz6f03pc9rYbUlczZJOOpAIL11p16ga6y\noQBx/FeN+VQ0tWhUy/tipNgqRVjQBzFF62/6CE3J2noGebpHeA==\n=k4lQ\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e0dbdaf08f58deb5432f94387fa25dc0a0336368",
          "sha": "e0dbdaf08f58deb5432f94387fa25dc0a0336368",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e0dbdaf08f58deb5432f94387fa25dc0a0336368"
        }
      ],
      "message": "HTTPServer: start an I/O loop in a new thread and accept connections\n\nSocket handling methods are copied from CConnMan:\n\n`CConnman::GenerateWaitSockets()`\n`CConnman::SocketHandlerListening()`\n`CConnman::ThreadSocketHandler()` and `CConnman::SocketHandler()` are combined into ThreadSocketHandler()`.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:42Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-06-12T18:57:16Z"
      },
      "sha": "f834e6c76287b4fe2a21f4a043beb1a4fe25adc3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU4NTMzNzEwZmM0ZTE0NjRiMTI0ZTVkODQ1ZDJmYTliNzlkZWQzOWY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/58533710fc4e1464b124e5d845d2fa9b79ded39f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/58533710fc4e1464b124e5d845d2fa9b79ded39f",
      "tree": {
        "sha": "8356f135e910bdade9b1022538136b936ea5a818",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8356f135e910bdade9b1022538136b936ea5a818"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 8356f135e910bdade9b1022538136b936ea5a818\nparent f834e6c76287b4fe2a21f4a043beb1a4fe25adc3\nauthor Matthew Zipkin <pinheadmz@pm.me> 1730396059 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909342 -0500\n\nHTTPServer: read requests from connected clients\n\n`SocketHandlerConnected()` adapted from CConnman\n\nTesting this requires adding a new feature to the SocketTestingSetup,\ninserting a \"request\" payload into the mock client that connects\nto us.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p4ACgkQ5+KYS2KJ\nyTpaXhAAxY+ALbHZIreViL2t/baViUKCUc1Etj1kl7dtNFP7GsS7B2aA8QSb5TEx\nYojJ/dl20Yzvlot41YERuXXEE3OeAlf7uuw1DGrJvjYb2MqXX9Co3wMGzb38gMGj\nQsldHheInv1WJq7RATbdXdpI30Dr8Ea3gm7uyqG9rTihoHQzgjJVdQQ9UD/Y3YFg\nwbZVvVyweZEAe9IoHzWybo1XOOqpZ1wozBS+qj+wjDdDBINPpgyEjD+CI1sufqDt\nZEMp4RySmCvQBq4Fdy3GkRHmFF6YWOUgL7Uq5rk2pXNAvDsdBP7IBgAmWC/PtWB2\n+qOewVcqfM1GP6yWko0VN6MHzqE2EZLYAZBDCc4WZXCX5WWQpEvTLj495cSBLRUU\nfO8pv+7eqi4ZbbIugwvXdQhSf/hv1mkOF0rZsOuanSUYhFgphitF0OrYBv6aBA9P\nvS9fTquNeKBiXbUzEJoz3G+VgiU15SScPfG0P0zOmYp9XwFb9nsD2lK2wS6OMs+n\n1NPrmkk/k3dsvknbUr4SMoP4tVEfWV/OElG4jqQu8LLkg3/VAPhw4j9FZwomSZ6F\nWrEzw0vcJxPiWAyrjXcDkhnTij7wW0zPlMvXRMt3mUeFjDtuUdcLHRWeWQb2x+Eu\nWzAWy7V2ADxNOFQqK+5ZwrdxBnuzKR7bnZFQ3NTwdHpeuJXvr6I=\n=sOXq\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f834e6c76287b4fe2a21f4a043beb1a4fe25adc3",
          "sha": "f834e6c76287b4fe2a21f4a043beb1a4fe25adc3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f834e6c76287b4fe2a21f4a043beb1a4fe25adc3"
        }
      ],
      "message": "HTTPServer: read requests from connected clients\n\n`SocketHandlerConnected()` adapted from CConnman\n\nTesting this requires adding a new feature to the SocketTestingSetup,\ninserting a \"request\" payload into the mock client that connects\nto us.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:42Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2024-10-31T17:34:19Z"
      },
      "sha": "58533710fc4e1464b124e5d845d2fa9b79ded39f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGRkNzczOWEyNWFiMTMxODJhNDExMzAzODMzMTE3OTZkOWY2MzNiOWE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dd7739a25ab13182a41130383311796d9f633b9a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/dd7739a25ab13182a41130383311796d9f633b9a",
      "tree": {
        "sha": "4d197198c5dc281e912207849681573527f8bacb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4d197198c5dc281e912207849681573527f8bacb"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 4d197198c5dc281e912207849681573527f8bacb\nparent 58533710fc4e1464b124e5d845d2fa9b79ded39f\nauthor Matthew Zipkin <pinheadmz@pm.me> 1741805491 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909342 -0500\n\nHTTPserver: support \"chunked\" Transfer-Encoding\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p4ACgkQ5+KYS2KJ\nyTounw//be42vEhtKpmBPVmYzP7Gb/sgGOMi2YxfrMUlWLG10BQOtEPnFc9IU4DQ\nIKLebraDsFK8TbCxqkZd1m5JgiptC7lyK8ynvFCAM3r7FuNfTcJ86Uys/Uno2JVk\nOFKl2bvzkh9uxPgSxPmRpdcgfr55riFFrYZcFbla7+QmfIvoNfRYUFZkZRzxs5vQ\n0q2HHNNeRIP1/TUfLoKZtzMBrsx29LlJnQlTo1Y2EHEKUztfLw0eoIHLR+jYBUlu\nIQG9VkITECWyVakf9g3ySRZzlJPhGqx/Hhf0MpZBBS3fsLQnl/piXyu+OmOKOZjn\nGwv/neeZ/VRPH77Ah8fJO4OmjXG6Mky0HYLetFbeJ/CDnm3LfxOZWJyeXFEBJMYx\nB5rWusM/mpF+rVxu/74A90//dPi/47/A2boiedvmVRfP2/itefe/jQqk0ou83g/w\n0FVsIyM3h6k6FVg7S6kVWfAbrXC1Xpq1JzMfko5kjI6JtgAMpNzrSd0UtcZgu+IA\nl6O/IHJ0wcTVBkWP1tlhKCLYLtPV0kdF8J4OzbgkNTRPUerfFJgnUN5TZbljOO5Z\nohIv5eq6RPzIAWfYb2XGOdPtC8gIAyaiV6Kp0emeAi8KO40IwxWRJHrjhmJLEmgl\nVoAZXUndmTBQS32pm6Kf5ar2FlwH/sr6IYAmJSENcH0PnY4T5iU=\n=pms7\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/58533710fc4e1464b124e5d845d2fa9b79ded39f",
          "sha": "58533710fc4e1464b124e5d845d2fa9b79ded39f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/58533710fc4e1464b124e5d845d2fa9b79ded39f"
        }
      ],
      "message": "HTTPserver: support \"chunked\" Transfer-Encoding",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:42Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-03-12T18:51:31Z"
      },
      "sha": "dd7739a25ab13182a41130383311796d9f633b9a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGFhMjc0ZGI3NTU1MWM2YzU2ZGMyMTc1Mjg1Y2M3MjZjMWIxYzM3Yjg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/aa274db75551c6c56dc2175285cc726c1b1c37b8",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/aa274db75551c6c56dc2175285cc726c1b1c37b8",
      "tree": {
        "sha": "df204b0fc4e40af4e865f5c0466eddaa20f599e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/df204b0fc4e40af4e865f5c0466eddaa20f599e6"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree df204b0fc4e40af4e865f5c0466eddaa20f599e6\nparent dd7739a25ab13182a41130383311796d9f633b9a\nauthor Matthew Zipkin <pinheadmz@pm.me> 1733878975 -0500\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909342 -0500\n\nHTTPServer: compose and send replies to connected clients\n\nSockets-touching bits copied and adapted from `CConnman::SocketSendData()`\n\nTesting this requires adding a new feature to the SocketTestingSetup,\nreturning the DynSock I/O pipes from the mock socket so the received\ndata can be checked.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p4ACgkQ5+KYS2KJ\nyTpFVhAAmvi2s6XWXhfsS59eQ41R9X3xe+8pvM6LXItIpWGcy8g63xpbx4RruDWr\n7+28sx6qFHM/Jyyl5byvQ1SOqWtzO1vhDCl+Wgecfev4n4R/0j5Hz6ILRkuLuDBi\nD6B49lh4YW9TNTarhk4x4lCKJlZijPPZwCD828CLnGAomex1zVq4h0pSfGMbfHX8\nUj0Sk3d9GocRg2NhFcFvMTVMTF1ppJZX7TmurYQV6jXEK10ly5qqPrnb8NLWH4TE\nbR/RcpGeSXWGyTpaOpPqLlFDDU+dekBJyuRx7Qmgn82ErrcbgpkCc3QOt3bMHff4\nriyivMJLakONZZeWMt42KOzQhiPutKmzj417Rxqn8JWKIS1V+nM/areA8Yze6DdS\nGj1IuG7VbRjRdVwDFNOU5fUe0kslL1IEQ85xBQNMdrJ7ePQSdNd/NsLUxrO/5mM5\no0RdQvBHBMo1qGlb6OF4QNEeJwN2RKV0t1J6vsSc2YrH4ciwOBY2F+mUOvbzfbnu\nbJ1MTdxnwME0OqihRwPQ/CGqbk2gIOYWnqsJ4XOwviN1aDFEc+JZtBGN75qEdZ6A\nxbjSIGW7n/dJ3q+TK8nJ4npzTGNjU1/yoR4RcM9RwEF6XtUvL/pl79BlQ3Wk23a1\nFxS3dR6tm8vvoUKUZfskhqSTJz5m/WKCm8SeuvbrKiS5jxFCuw0=\n=mh0m\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dd7739a25ab13182a41130383311796d9f633b9a",
          "sha": "dd7739a25ab13182a41130383311796d9f633b9a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/dd7739a25ab13182a41130383311796d9f633b9a"
        }
      ],
      "message": "HTTPServer: compose and send replies to connected clients\n\nSockets-touching bits copied and adapted from `CConnman::SocketSendData()`\n\nTesting this requires adding a new feature to the SocketTestingSetup,\nreturning the DynSock I/O pipes from the mock socket so the received\ndata can be checked.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:42Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2024-12-11T01:02:55Z"
      },
      "sha": "aa274db75551c6c56dc2175285cc726c1b1c37b8"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDlkNzIwOWZlMTk0NTM4ODhjNzA3N2NmMjE0YWJjZjJlNmQyNGY4MDg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9d7209fe19453888c7077cf214abcf2e6d24f808",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9d7209fe19453888c7077cf214abcf2e6d24f808",
      "tree": {
        "sha": "0537c0c37098596914e8ec4e843baa03a6f872a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0537c0c37098596914e8ec4e843baa03a6f872a5"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 0537c0c37098596914e8ec4e843baa03a6f872a5\nparent aa274db75551c6c56dc2175285cc726c1b1c37b8\nauthor Matthew Zipkin <pinheadmz@pm.me> 1741033247 -0500\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909343 -0500\n\nHTTPServer: disconnect clients\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p8ACgkQ5+KYS2KJ\nyTqQHw//ZAL1FAKz5aazgoYRRT5DfGKm20qsWcaSS3+m118BDh02QWOQdvUJAWU8\nfdnrDX/bDIq3vAJuJN+6Rc0x7kPShWMUJUEdR7i4h3PlJ4o0iG5zkjLPndQY0ioC\nWzX5kNozQ03rPTweO6m0Td3W9COgzys0WI6PavTL7ApC2D9WPlv2SZy8rq8/Krz1\njphSFP50S8nnI6CoWpe/gl/MBXQb82f3H4GJ03FN7Gm500GOuII5Pw0+ayHD20TV\n/lWDoavn8BJysMk4WK+fA5OMg7XrKgVdm3JeDFRi9qsdS9tJP0+1H04LDyy1M3Oe\nz419oGQyorzuYTIiEzsdya4l4VBNLVcrDMTqNG90x9gZApiGmZrmCYGuzD2TZvjP\n/ObbxxPZAivyZSvmb04OR+iRIdL1mqdz7sR8XSRj31Lg2KiSCcL2gclE8xGovk0r\nK+iZDQB1H+Vl9olkztZqlGqiFqyDtY2pX81HeJzQ4ezI9nYfS1hFyxZuWnoQBDlX\naR0BXodoD3RsLNagZKn3Ch/GoOeTHiw+NCi3vjr0WbvWKbj/vOE6M8JgqROBU5vY\njnwJnmemEsTLHAHKew3uKmvSxW1R5P4F/TRFpxFgcSvrCnqvZD83UfLJwB0V9Yzo\nJhE5G81JyPo6K0hmhQbmW1OJzz5A/0ZGVyA70ZdiRWeU1NvhXDg=\n=DH3s\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/aa274db75551c6c56dc2175285cc726c1b1c37b8",
          "sha": "aa274db75551c6c56dc2175285cc726c1b1c37b8",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/aa274db75551c6c56dc2175285cc726c1b1c37b8"
        }
      ],
      "message": "HTTPServer: disconnect clients",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:43Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-03-03T20:20:47Z"
      },
      "sha": "9d7209fe19453888c7077cf214abcf2e6d24f808"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGY4NDg0OTdhMDMzNjA5NDQwNGQxYWYxMmY2NTg2ZDM0OWJmYzc3NGM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f848497a0336094404d1af12f6586d349bfc774c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f848497a0336094404d1af12f6586d349bfc774c",
      "tree": {
        "sha": "ce62254383f1e4b54ac413ea3e2512797bb01c93",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ce62254383f1e4b54ac413ea3e2512797bb01c93"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree ce62254383f1e4b54ac413ea3e2512797bb01c93\nparent 9d7209fe19453888c7077cf214abcf2e6d24f808\nauthor Matthew Zipkin <pinheadmz@pm.me> 1740855101 -0500\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909343 -0500\n\nAllow http workers to send data optimistically as an optimization\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p8ACgkQ5+KYS2KJ\nyTrOlA/+PcUUHprLeKDkauWf1LHNtuI98cJ0S/iXj4e9sFhSfP3GJn5HrqWS614Z\nZNbln+dvfjd547OzOsRe1GTkeM+vucMt4kx4012kxZDSe6BMBISjyfr6vhTI/Yh0\nuZbnpmk6hJcERPw3grohtxPCR81XCajl2lROtrjM4sNapBDf2SNEW/NbJ/yzXG38\nXViabK6DxHHcxeOff1lt6LTMZpELzLoLedbaYVFq0Wu/xXC8BnjysA2c6UwyTtnx\nhT0ngQ1VlyJzC8YsCeIq/yOt3aEb3lbsxco9BoUi6aGULid8OuvY2xV886OZ/AfH\n33NIKD8iwdPpwSow8g0Ai2Sc6o5od6iJRZCdW6xlZmjNIMhoki8/FaXgc5VsSG6A\nsVzh9x5+HwONqKI9yeUJS0UpGT+AoHx3Fm5ilimQ8NLElcSo5Abu2ebgMqyeCB2W\nwzbiDf2nn0zAH0cYCqZD4ZZ73pHcKKvW0YNFbBSZiBvgpefO7VzikltJizUGppV4\ni/pvOCGpT2oxLXQjoXF6EPoPhW+CQ5yoieSElNUTgd8E95r7s2UxxphGcN7USgwa\nG5PeG9oQpTwyx020QP1l61jOmDI/4n/CvWYuZ780wVj4h6yUN/jK+xK7RpgR47n+\naNTrppwv0XUbDpb4WzlLPMKPbfg3KBc4zjMExJtkbEfC5bSVreQ=\n=xrIZ\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9d7209fe19453888c7077cf214abcf2e6d24f808",
          "sha": "9d7209fe19453888c7077cf214abcf2e6d24f808",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9d7209fe19453888c7077cf214abcf2e6d24f808"
        }
      ],
      "message": "Allow http workers to send data optimistically as an optimization",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:43Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-03-01T18:51:41Z"
      },
      "sha": "f848497a0336094404d1af12f6586d349bfc774c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDg4MDk5YmQ0YzhkZmE0NmU0ODExZDg0ZjFiZThjZTkxOGE2MTgwYjI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/88099bd4c8dfa46e4811d84f1be8ce918a6180b2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/88099bd4c8dfa46e4811d84f1be8ce918a6180b2",
      "tree": {
        "sha": "97b663c4e31a3c455cb7eff1b53943f1c6bc680d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/97b663c4e31a3c455cb7eff1b53943f1c6bc680d"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 97b663c4e31a3c455cb7eff1b53943f1c6bc680d\nparent f848497a0336094404d1af12f6586d349bfc774c\nauthor Matthew Zipkin <pinheadmz@pm.me> 1743697722 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909343 -0500\n\nHTTPServer: use a queue to pipeline requests from each connected client\n\nSee https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n\n> A server MAY process a sequence of pipelined requests in\n  parallel if they all have safe methods (Section 4.2.1 of [RFC7231]),\n  but it MUST send the corresponding responses in the same order that\n  the requests were received.\n\nWe choose NOT to process requests in parallel. They are executed in\nthe order recevied as well as responded to in the order received.\nThis prevents race conditions where old state may get sent in response\nto requests that are very quick to process but were requested later on\nin the queue.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p8ACgkQ5+KYS2KJ\nyTpNrg/+LywjWfQYSGRdV+eXNAo4MmVt4ZBKyhcD1GHv+MW0RlSw1jEzTtAKL3uJ\nbr/mEs/LAiv0ekFhLedkYuP8XsKYlVOUoBjkrUttkaGMEmQvpUyx4vdpDxRnRHlZ\nMclY2cQu1vFv2dX7YBga6VXe89EUQ7rmk6CtEYb2+Hrtt2BQKVPsYevMdkVlF2Rn\n1wZY9MlHx4nefKQWZu9WmUvtuN4BgfMc9MJGG8GcXRq7u2uNonaA/1PikPfmCphK\n3aGFb5pb6Eg/rTs/QLVD67wiJ9rU8GdASId1OlPlP3YjYR3UDKrExd9H6fxqLZSp\nnUmScNXFgXPVYaJLYYg1VdydaQyOL4GXEXfSXw8ISW4mEAOUbV3Q3pPx7SATc/Z0\nGI3cKldNxVz9oH1TN9OyZNMdWpmnWRK3Y9/HLQERvF/9oXis0gBroX3BG79KjK0g\ni7c70xBeajl7Ntykov+4+TL0apLIEr7YJrwkjvh7/sfp5FIYiLciDDpagSmkicu6\nec+RZsic1FtAuHcvU+8PbUneoc9rwgxJZ3ZYpthlI9O94EfHBw13fZAaUZc4evNu\nHiwAks4Pw+6t5nHkVHpP1KWaPNL4w/kHr4jSvjI1j+WuwlGyaZvp9xNSRexU4meK\naIiZ6w0s3ZmGmzvmJZ3lZH9t6iNo1K6SV+pwfFvm3aA3EYdjlRg=\n=Q9ja\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f848497a0336094404d1af12f6586d349bfc774c",
          "sha": "f848497a0336094404d1af12f6586d349bfc774c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f848497a0336094404d1af12f6586d349bfc774c"
        }
      ],
      "message": "HTTPServer: use a queue to pipeline requests from each connected client\n\nSee https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n\n> A server MAY process a sequence of pipelined requests in\n  parallel if they all have safe methods (Section 4.2.1 of [RFC7231]),\n  but it MUST send the corresponding responses in the same order that\n  the requests were received.\n\nWe choose NOT to process requests in parallel. They are executed in\nthe order recevied as well as responded to in the order received.\nThis prevents race conditions where old state may get sent in response\nto requests that are very quick to process but were requested later on\nin the queue.",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:43Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-04-03T16:28:42Z"
      },
      "sha": "88099bd4c8dfa46e4811d84f1be8ce918a6180b2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk0MTVjZjZkM2VkMzc2N2ZiZjRhMzkyYWFhNzY4ODg2MzllNzVjNDU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9415cf6d3ed3767fbf4a392aaa76888639e75c45",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9415cf6d3ed3767fbf4a392aaa76888639e75c45",
      "tree": {
        "sha": "54f3f5d44b4fc7ddc465f0a7205964b70f90bcac",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/54f3f5d44b4fc7ddc465f0a7205964b70f90bcac"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 54f3f5d44b4fc7ddc465f0a7205964b70f90bcac\nparent 88099bd4c8dfa46e4811d84f1be8ce918a6180b2\nauthor Matthew Zipkin <pinheadmz@pm.me> 1733941291 -0500\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909343 -0500\n\ndefine HTTP request methods at module level outside of class\n\nThis is a refactor to prepare for matching the API of HTTPRequest\ndefinitions in both namespaces http_bitcoin and http_libevent. In\nparticular, to provide a consistent return type for GetRequestMethod()\nin both classes.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p8ACgkQ5+KYS2KJ\nyToMjQ/8C2ramjF03LHlsx8LvOGiWk8h/irXgIwLUh5n79lk93ZYhwJX9iYPVTBJ\n+cri9DMiJheL45piFNqB+SEwP5VzCX8MYihkOnxAORu8kuwAIU6QcES567BFKhyV\n0IUZqxwRy9eazjnFgaFi1VvUsdWbdYibo0cEfxH0PFH6hmgEJ32KSwUS/hPFbpUB\nzucOS8ITznB/65qpxn1sLAzmESEpvV8NW25XORuK5s/WVSbMa3oqLuNelqNhZguk\njnK/YY5QWG8z2Sk1hhtIJrNA5MST16QGJcxduVKO7/JsksoWsIL/2/6ZrHeRhc5E\nVEminDryFEdosNEMZxjIQ5wzNBus1b0+rg8d2+kwiQLxMyNzWdQOhcOGxcAHlDIm\nyWWMpOisUy6/mcc1fW26LgEUY7Uvx/bfZd2T5NSex2zeRFjbUYEqFWqQcM+gSldz\nC+enZzt9aiJyldEuv6xFXEPbct25k5u0HDWdXYNs7oGjzIXoAxJPFti8eUXRg4LR\noICjsNKtUa/jlRznVey5M6SAIpo+0duLvP2H76Hwo0sju0GMG8mY7ixMKug7ceVX\nXuZcv3Cvjk42CzVY4UuAZ24tuQHo6kbmHkPj+b+O5ncMnVFa9sZnsNmBoAG7GHkT\n+1q/3ZkFkETU05Vbt9/aSr7CxDhMLrJ39cX6lEhqBkLU5ynq3NU=\n=2s0i\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/88099bd4c8dfa46e4811d84f1be8ce918a6180b2",
          "sha": "88099bd4c8dfa46e4811d84f1be8ce918a6180b2",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/88099bd4c8dfa46e4811d84f1be8ce918a6180b2"
        }
      ],
      "message": "define HTTP request methods at module level outside of class\n\nThis is a refactor to prepare for matching the API of HTTPRequest\ndefinitions in both namespaces http_bitcoin and http_libevent. In\nparticular, to provide a consistent return type for GetRequestMethod()\nin both classes.",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:43Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2024-12-11T18:21:31Z"
      },
      "sha": "9415cf6d3ed3767fbf4a392aaa76888639e75c45"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDlhMmRlNzE0ZmVjMmM1NTVkMzM1NzI2MDBhZjczOTIwMzU1YmE3Zjg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9a2de714fec2c555d33572600af73920355ba7f8",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9a2de714fec2c555d33572600af73920355ba7f8",
      "tree": {
        "sha": "12fb1d7c6c79c51ce892500754d7b782612abe6b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/12fb1d7c6c79c51ce892500754d7b782612abe6b"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 12fb1d7c6c79c51ce892500754d7b782612abe6b\nparent 9415cf6d3ed3767fbf4a392aaa76888639e75c45\nauthor Matthew Zipkin <pinheadmz@pm.me> 1734021892 -0500\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909343 -0500\n\nAdd helper methods to HTTPRequest to match original API\n\nThese methods are called by http_request_cb() and are present in the\noriginal http_libevent::HTTPRequest.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p8ACgkQ5+KYS2KJ\nyTpKzA/+OkFxAd9SeNjAyu+qCqn3Ls7rvX3Nb72Vl6ev0+xmPnAn3bPEmBVYY6DL\ncUSptp202aoclPVz/dWMziMcUjN05aU9J3e4pu4iPiur32vG1Ah9FjwCrOgOXdeK\nF1MaTiRLA55RrH/t4DrdUzzSNLJYMkpCDSLK+ZBl1Npsx6ejVPmEm9YXEo/WPSEh\nCjZVSOOrwAh7SmtWwAtVh1dUdTVsldVqpxE3c25BbDR7q0vDn99NczP9ZRXeXwFh\ndSyuLFDP9pEgx72EKwcmZq6SqQ4p57N88rCaCH/jAInu65HcJXcRDtb18sJb7p9S\nudpKhbND8Va1ScHJPxSF09YIfdDkrdkUKDKLyMrY8Apvb1e93WyulND6oZXt5Lo8\np7XPvG5iD5/z/No2d+rt1wHnu90/ADskBEwgjaIFzS64A1tpn4uo43dki+k1Dqcj\nMa2tBsaEmsQiTd2B4m82IIPFKJ7tkG26DoVK6sbBlU/7RaF+xBBvNOoiin5vIFbC\nsu8+GppwhPpr1FDWyuGjeGXicrdhlbSicfpj0fTkZr0MXMeKxzdN43aZSMB0yGKi\nMghKvMopxMF6gCG2pSxwiOH2hCL3LdoBjp+17BNnp+udmm6pK3/fPcE+mu+lrch3\nirMJ7l+HIxf09y2ydzsEcdbAfu6Urc7/n7v44BiRB2Btu0o0Ypc=\n=uQ0v\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9415cf6d3ed3767fbf4a392aaa76888639e75c45",
          "sha": "9415cf6d3ed3767fbf4a392aaa76888639e75c45",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9415cf6d3ed3767fbf4a392aaa76888639e75c45"
        }
      ],
      "message": "Add helper methods to HTTPRequest to match original API\n\nThese methods are called by http_request_cb() and are present in the\noriginal http_libevent::HTTPRequest.",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:43Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2024-12-12T16:44:52Z"
      },
      "sha": "9a2de714fec2c555d33572600af73920355ba7f8"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ1Y2JlOTZlNjE0MDVhOGZjZWRkNDM1YWE1OGZkZGNlMGFlODk3OGI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/45cbe96e61405a8fcedd435aa58fddce0ae8978b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/45cbe96e61405a8fcedd435aa58fddce0ae8978b",
      "tree": {
        "sha": "3242f8564e38caf0819ef4fcc74952809756e232",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3242f8564e38caf0819ef4fcc74952809756e232"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 3242f8564e38caf0819ef4fcc74952809756e232\nparent 9a2de714fec2c555d33572600af73920355ba7f8\nauthor Matthew Zipkin <pinheadmz@pm.me> 1734036925 -0500\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909343 -0500\n\nrefactor: split http_request_cb into libevent callback and dispatch\n\nThe original function is passed to libevent as a callback when HTTP\nrequests are received and processed. It wrapped the libevent request\nobject in a http_libevent::HTTPRequest and then handed that off to\nbitcoin for basic checks and finally dispatch to worker threads.\n\nIn this commit we split the function after the\nhttp_libevent::HTTPRequest is created, and pass that object to a new\nfunction that maintains the logic of checking and dispatching.\n\nThis will be the merge point for http_libevent and http_bitcoin,\nwhere HTTPRequest objects from either namespace have the same\ndownstream lifecycle.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p8ACgkQ5+KYS2KJ\nyTpvPQ/+I1vpdOCHiQgrWbnLayR6Updknybz3ikS2vJUe30PA53oUp3EwMRjXZxZ\nC20R0UE4uH2DWRGfM9H3+2IgZYw+chCbCKxvZPsAOAOgbq6oDRZ1qVCuGIcpHpyE\nEXkPFtaI7KvDa11Snoizb04AL2h/iyU+7hsOGXYsUJ8I0ch9Plbf4fGGfUpLmUaA\nVP995wrM7njRQ2fxTU3VXQarwJcEwwYUb71PuHakOmmp6JQ+LE1htBcZ3g9qKL5a\nyNr4RVfJq2xgl3crN7p31HK3wIW8qxNSgvMDjvSHZWvzCUmLmD1WJjjiWazbNPv6\nwykicAmR7+0oFs/oI5wlI1H95+D4jOWd3moMGGJxGfPqKkXGMxT9MyJPwAlCfWKb\nC+DvsC7TSL0+hfK/51PdwWPidDHtkJyHHJjMBEHmEb7KyHNR/Qc3oGfI1erGfeEu\nqAu+L820hEYwwmU1eJxPfvgGd8bSsirGYYWKUGvcD9/6b4jbKn02AfbnsguHg7GN\njIFRupBypNI1Ci0vHPj7Qzccd4ZfNSJhURt3eOK5OqHRRvtekPOI/5ygz/K3nkxQ\ntiw/ckdrquKxjZ+aeCj+r/YuIpnhrsm78uyUWb32lALAsqCbTsfl7u14thNo5IiB\nKf0UDw1uxxTOI8ihbMAu+z8KVZQe8d+aoj1CNEpgb4sjH4fXAVk=\n=CqKY\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9a2de714fec2c555d33572600af73920355ba7f8",
          "sha": "9a2de714fec2c555d33572600af73920355ba7f8",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9a2de714fec2c555d33572600af73920355ba7f8"
        }
      ],
      "message": "refactor: split http_request_cb into libevent callback and dispatch\n\nThe original function is passed to libevent as a callback when HTTP\nrequests are received and processed. It wrapped the libevent request\nobject in a http_libevent::HTTPRequest and then handed that off to\nbitcoin for basic checks and finally dispatch to worker threads.\n\nIn this commit we split the function after the\nhttp_libevent::HTTPRequest is created, and pass that object to a new\nfunction that maintains the logic of checking and dispatching.\n\nThis will be the merge point for http_libevent and http_bitcoin,\nwhere HTTPRequest objects from either namespace have the same\ndownstream lifecycle.",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:43Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2024-12-12T20:55:25Z"
      },
      "sha": "45cbe96e61405a8fcedd435aa58fddce0ae8978b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk0NTkwMzk0ZDdjMGFlNTRhNTFjZmE2ODcyNzFmNDExOWZmOWIwZGM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/94590394d7c0ae54a51cfa687271f4119ff9b0dc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/94590394d7c0ae54a51cfa687271f4119ff9b0dc",
      "tree": {
        "sha": "2dfc88dda3cbc3712733c5cc5886fa6d7e48bd06",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2dfc88dda3cbc3712733c5cc5886fa6d7e48bd06"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 2dfc88dda3cbc3712733c5cc5886fa6d7e48bd06\nparent 45cbe96e61405a8fcedd435aa58fddce0ae8978b\nauthor Matthew Zipkin <pinheadmz@pm.me> 1736969196 -0500\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770909343 -0500\n\nrefactor: split HTTPBindAddresses into config parse and libevent setup\n\nThe original function was already naturally split into two chunks:\nFirst, we parse and validate the users' RPC configuration for IPs and\nports. Next we bind libevent's http server to the appropriate\nendpoints.\n\nThis commit splits these chunks into two separate functions, leaving\nthe argument parsing in the common space of the module and moving the\nlibevent-specific binding into the http_libevent namespace.\n\nA future commit will implement http_bitcoin::HTTPBindAddresses to\nbind the validate list of endpoints by the new HTTP server.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN7p8ACgkQ5+KYS2KJ\nyTqv1g//VvkKvjEFfUkoBnkc9X4bUnqD9fZKM144SVjwY5SjEAj5xKBNUFzclz1Z\n58uGpcLDx+Sw1A6P1NZ05m4pwQOZgTRVC78+Nxhm3WJ3rPcXbSjCEiVhkX3y2nUS\n7HwiDnsfbg+nxoj+2l98yNcyzBYDU3JZXPNyAeUE4Ru3Iqvew6wkJNqZbcBPXQGS\nyeoYOjOTPc/5w8SF+skynPDcgdwdCd8RgbHfe1n8PUBvBXuU1yP/KBl+hmmRkkHY\nyO4pSO3ThBwTqJ5xEnbmnWj94EczQk99CkCYoQpF6b0veE6K8JQykTJ5jo0SLUZV\nY8WmAnKVWVQXPs749LbLpYjc9pLhqxmqSDalsCcbzzeTiBKt38pNaWl2pnQe9h7d\nEFxvdMqHM9Ujz/1lXxj1CmqSpFcbu6ok3twHd6AtEskPQ3QSlfwndXBTn3f7lsT0\n8CAhCzcaZJasBddnsy5f301c+3+jjB65EP2/u0Dvlt15yuutyKCNhXMIbNiNTQC2\nDmEG6Dgo8NGMqMYcOaPgZe+36DUYF1/8U44+1kR7zL0AZljfatCvRsfCUlUihE7q\npqtGOZWImi8H86tUAJWlcnENNkm/2zsgL6IkkkO0EsmY9eB/E2oQhXKsV4u7hVSZ\nNGcmnSlu9KF+KoKVPij9fm/ksgnyVXG4bkN9FmFo8rv9cYGJAcM=\n=xV9C\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/45cbe96e61405a8fcedd435aa58fddce0ae8978b",
          "sha": "45cbe96e61405a8fcedd435aa58fddce0ae8978b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/45cbe96e61405a8fcedd435aa58fddce0ae8978b"
        }
      ],
      "message": "refactor: split HTTPBindAddresses into config parse and libevent setup\n\nThe original function was already naturally split into two chunks:\nFirst, we parse and validate the users' RPC configuration for IPs and\nports. Next we bind libevent's http server to the appropriate\nendpoints.\n\nThis commit splits these chunks into two separate functions, leaving\nthe argument parsing in the common space of the module and moving the\nlibevent-specific binding into the http_libevent namespace.\n\nA future commit will implement http_bitcoin::HTTPBindAddresses to\nbind the validate list of endpoints by the new HTTP server.",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T15:15:43Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-01-15T19:26:36Z"
      },
      "sha": "94590394d7c0ae54a51cfa687271f4119ff9b0dc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDAyY2UyYjBlODNiYTYyNmJiMjQ4NjE1N2M2YWZmODA1ZWQ0MzBjYzg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/02ce2b0e83ba626bb2486157c6aff805ed430cc8",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/02ce2b0e83ba626bb2486157c6aff805ed430cc8",
      "tree": {
        "sha": "312e72ef6db00a2d073597f9ca492d09154f70f3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/312e72ef6db00a2d073597f9ca492d09154f70f3"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 312e72ef6db00a2d073597f9ca492d09154f70f3\nparent 94590394d7c0ae54a51cfa687271f4119ff9b0dc\nauthor Matthew Zipkin <pinheadmz@pm.me> 1736972256 -0500\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770912266 -0500\n\nHTTPServer: implement control methods to match legacy API\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN+goACgkQ5+KYS2KJ\nyTqkFQ/+PPfGzl33IndUktH3ZYj41p1rB87FFGBKEEb79dCmhzoBntdEDXwkx8L6\n08CAuJGJ+xmh0HJ8+saSiTHO01SpelGcFPfGihusi4GHcUJdFP7O1YSx9ydHFaYa\nbp7znHY5klimiT/DuX1BokEcy/uY0EgRld3fzl+RwP9vZKJPSjXTY12KLmrv1TNd\nCD9s/TZldcIvsSDKr/iHd+zrC17hbjL3zg1OLd6rUkggrnmvlXAIoSmgc1LlIhwY\n0Y0VSJvrpDdGM5ipifYsxqkPAu2Cey3is53BhIde95trdGq98RxpjtrK+25RAZ3g\nWl6ycxCh5+xgj9FinyI3rUON0ABcfNWJtFl/4WsU9eJGaqoxMaas7m1I2QjQ1Maa\nsVLFXacqCFresDl8iZALHg6ryornrr8n+8v25yjKUWduyh5QorLvz9b7VytomhE0\nfxofUatBK4wwzB8pDD7og1b999ORxHdzGDm0KobMH1ApGYUOpA3I8PUeM/ZXliGr\n0tURF+gon5vV+0+HLZ9/Nw70sh38HIEAZcpwR4iKaqEEasKGBmLWIQc9SEp0eVO8\nl+0szFvJKvn+oQQTTvXcRulkgA1DU/wnI5MuWdeg33bU+3kYnls+++awaC89qmBC\nYVowOxQlz3nq91xF2rU3JoUxQPi6VXXzWBj1pFWri+9IlMImCwM=\n=YJdS\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/94590394d7c0ae54a51cfa687271f4119ff9b0dc",
          "sha": "94590394d7c0ae54a51cfa687271f4119ff9b0dc",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/94590394d7c0ae54a51cfa687271f4119ff9b0dc"
        }
      ],
      "message": "HTTPServer: implement control methods to match legacy API",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T16:04:26Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-01-15T20:17:36Z"
      },
      "sha": "02ce2b0e83ba626bb2486157c6aff805ed430cc8"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGFkYmZhYzc1N2QwZmYyMGU0NDZkODE1OGViYThhNDI2NjQwZWU0MTA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/adbfac757d0ff20e446d8158eba8a426640ee410",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/adbfac757d0ff20e446d8158eba8a426640ee410",
      "tree": {
        "sha": "6cf0a77030aaef68dd86f627968679d1adc59806",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6cf0a77030aaef68dd86f627968679d1adc59806"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 6cf0a77030aaef68dd86f627968679d1adc59806\nparent 02ce2b0e83ba626bb2486157c6aff805ed430cc8\nauthor Matthew Zipkin <pinheadmz@pm.me> 1741627852 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770912266 -0500\n\nHTTPServer: disconnect after idle timeout (-rpcservertimeout)\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN+goACgkQ5+KYS2KJ\nyTqBHg//dxLyLc33+pnmTXihv21THelKCKZd6gONqTt1W8zLSduKsT7rKMuJ5UhZ\nJLKfoK9vLVJTUBQDMtb4vSXutpc22T9uEBFGA4ohKJZpffe+ayMFVeeIOj402HMN\njLiB2RCjEroazP2YpxCN6LpldCo5NWMvtSsfNDY3Lu2NbC6pGm/VGdtNj70LKS6E\nKiu3Rg0HQMP5bAjNqinOXXBLSmUfR0y9bLTcE4CfzGvaLX/kyeIpDCuhGaodCI/T\nZtBY7tlhq49jbMrWTzT4U4wB67H5CRZWb9p9IvfP9vCguINDBYvNWhsggE5XqtIk\nrMvYpiTmWWIN7TOG0yWaGop/7M8MJpjaIB3cFNVhrZwKVXQGopcchsd4qHxZHdfl\nmDsB8hyQ1VvvyjJprNEzRQsy+IcKwhE/paa2Q6kPYYOVljE8gIs4zRgUcoPvDmkz\nzV3fyOWsmvCzNH4H+efv/IKooE/dpjiKTD4EJ3blXpyXzxbxGaVvguhYtdoZntar\nImByasmWLeoQk9Bq506p4tyI8jLVSEyUqIl6XNTvvHxKFuqBtz0iEcfMgsWZKnpj\nY7ihSLeLD/fF2beOIdjz/mo07LstfPrrvIRA4FRNlx86yK0196LloBQs1H6a+rcB\nJLmcw9wdhnSrd/Nop+DM1QdBBmhuD0rTCXMTrb4Dhuh7aA4vR6o=\n=aOT4\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/02ce2b0e83ba626bb2486157c6aff805ed430cc8",
          "sha": "02ce2b0e83ba626bb2486157c6aff805ed430cc8",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/02ce2b0e83ba626bb2486157c6aff805ed430cc8"
        }
      ],
      "message": "HTTPServer: disconnect after idle timeout (-rpcservertimeout)",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T16:04:26Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-03-10T17:30:52Z"
      },
      "sha": "adbfac757d0ff20e446d8158eba8a426640ee410"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGE5YTIyMWZjNzBhYzBhMzUyZmE1OTdkZWFiYjMwNjg5ZDBlZWMzODE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a9a221fc70ac0a352fa597deabb30689d0eec381",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a9a221fc70ac0a352fa597deabb30689d0eec381",
      "tree": {
        "sha": "5c0be934dcb0e849664e70365bec3a8f5d4a168f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5c0be934dcb0e849664e70365bec3a8f5d4a168f"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 5c0be934dcb0e849664e70365bec3a8f5d4a168f\nparent adbfac757d0ff20e446d8158eba8a426640ee410\nauthor Matthew Zipkin <pinheadmz@pm.me> 1736973856 -0500\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770912267 -0500\n\nhttp: switch servers from libevent to bitcoin\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN+gsACgkQ5+KYS2KJ\nyToqIw//QD/Nj7U8SCvuygiGZqUjbWk4B6I8uQzY4fPuO6ZZWqrbjdPx+AODr8GH\noiHK6uPyzMkPLrvJNSgGmAKm5p7ROKUp1MEBtnwmH+tX6ahKD8X72hTRzTqPPBFj\n/c9Yd9aCDM1L59Y29ivk68yH6vA7JQXM4kqawzw7VJCZEVO9c/gSu/ErOhK59/Ca\nG0jYstnWw7KNnl93bBk+CAS3RRX9b+jRmuk48ie/kPmmlUDUtiNmhzEJJbfjK+I7\n+xcIcUgciXjPYTMGm/gnuteMhjopdv8uAl0helcerakvmsuW5zaWm3MbYbU6Vony\nULacpffuWHi2x3o2PwWCMrwjBxbUBDQfrL7uLwpWh6nAQdmZB3Od8fSEgt7Rx3GK\nCcz0waV6WAtNmmAAGEyliPxqSEqeta1GqcLeZ4784Q2CxRgCRKtW0ygH07VlQQWA\nGYoS32ByWQuzCRCT4XdF7crgTxJu8IkQn6A3EbHHxzFWUlFlH0DsPTL2ntPqQabY\n3XB9t4yz5D40C0Sl6S+Ybl03k0C9Hd4nvm93xplIoX5IMUtu+WmMlyBm2tEr1Qa6\nXzC71KjgJOqHA27qZirZs8BEWBXkrEGNxdWAel3Gs2qLXn8uoW7d1p78oUdgPzw/\nKYZ3jtAnhCExh3hx3QQ9DX3yq0EtzxmYtNT9OcccgM9EeXnOpHY=\n=tXzv\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/adbfac757d0ff20e446d8158eba8a426640ee410",
          "sha": "adbfac757d0ff20e446d8158eba8a426640ee410",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/adbfac757d0ff20e446d8158eba8a426640ee410"
        }
      ],
      "message": "http: switch servers from libevent to bitcoin",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T16:04:27Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-01-15T20:44:16Z"
      },
      "sha": "a9a221fc70ac0a352fa597deabb30689d0eec381"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk2ZWIxZGVlZDA5NDRkNTNhYWFmODNiNGJkNmFmNDdmNzljYjEzNWI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/96eb1deed0944d53aaaf83b4bd6af47f79cb135b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/96eb1deed0944d53aaaf83b4bd6af47f79cb135b",
      "tree": {
        "sha": "564f4a3c0b0ad76e6235fe952fcc66550d651fe5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/564f4a3c0b0ad76e6235fe952fcc66550d651fe5"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 564f4a3c0b0ad76e6235fe952fcc66550d651fe5\nparent a9a221fc70ac0a352fa597deabb30689d0eec381\nauthor Matthew Zipkin <pinheadmz@pm.me> 1742317853 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770912272 -0500\n\nfuzz: switch http_libevent::HTTPRequest to http_bitcoin::HTTPRequest\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN+hAACgkQ5+KYS2KJ\nyToiVhAAiCycpuSK5n1JV3t2rsbdh9j4/8sRFO24KB3WlO2pd0Eqh7jymWSQM3Uq\nDwibjMVJhlt8ZMNZr4k3LJ73CETWPFPvur7A5RDFOsKByOuwe1GAvOS81/6fDQE3\nXQXjz+RjqlP3LSc0DKdDvOgFUxEVCOdRFeAg6SCsk07H/iZzGkUaTIDzR7jBiK/U\nmJvaEq6im18n3JQT0vTA2VII3Cotxkc7fhQZcCK+M4pOmPT03+RwhL/hBpRt5BiN\nJhqhMeJ7Iy6oBLC+s/i+Y+xJbe9om8suDdNw7cXqfOZ09OKLY80ziaPwOc1xPt+M\nhvrBkJkY2xx9tPpcHVeF5OP+86pK9SgEK4l3dMakQox0NJbqPrBpzNJHUL98o0kS\nMKtFkebtH47jVIV/DbS7qDuSFDclQ3Opk+M/2/r0ghesFl6CrrHTCidOogltIVYu\ncEGqvdW1CbqW4fzzIQd+XPOx7QbqfBOs/yAl9JNyzu7+tlAnncz4NonCnRdFbjQR\nsLaxHt+0za3CNhsKuiWb4s0XaStekfdpp7jXX/vd7ofj0ftVd4kAsVM1zjVOHRbH\nm8BqzwRL2JLKLdVEPjP1HCIuMeIDsCSoKZuTS8c3KdVTre1vt2TgJPL7i1rULrZk\n2oFu+U3qFdDgxdmKgdzho7eXhTD9eyW6rBYST8hf9W87uPqoirA=\n=YDNT\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a9a221fc70ac0a352fa597deabb30689d0eec381",
          "sha": "a9a221fc70ac0a352fa597deabb30689d0eec381",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a9a221fc70ac0a352fa597deabb30689d0eec381"
        }
      ],
      "message": "fuzz: switch http_libevent::HTTPRequest to http_bitcoin::HTTPRequest",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T16:04:32Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-03-18T17:10:53Z"
      },
      "sha": "96eb1deed0944d53aaaf83b4bd6af47f79cb135b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQ0OGMxOGI4OGM2NDgzOWZkNDg2NDdhOGJiMTBkYjRmYTI2NmYzZTk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "tree": {
        "sha": "50359f1a67361e53db112e77393db9c493b1748f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/50359f1a67361e53db112e77393db9c493b1748f"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 50359f1a67361e53db112e77393db9c493b1748f\nparent 96eb1deed0944d53aaaf83b4bd6af47f79cb135b\nauthor Matthew Zipkin <pinheadmz@pm.me> 1741888678 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1770912273 -0500\n\nhttp: delete libevent!\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmN+hEACgkQ5+KYS2KJ\nyTpvmRAAkxVbcgHXLvsLMvRIfam7Kny1UpBGww7y9oQKcB18f1yRhzQNnyNpl+rN\nbUgpBtUk2ZvNZoCb4/XDNdxgPIeGh/04ywCtQJY3JmHURrw1/DBfaxN+x+NoZAGg\nn6cOAjJ8KkPSsZfVX6onbfnsGoucNVlzk8W638AcjBcjTbkUYJlNApYaYTs/Xn0c\nymsHeCcag9U9xwY6b8j2cLRClCCqRWA8EQJ+5kfLhnrVlXds9lhZQ7t3az6OYddv\nEeoNENXzDJKoMwiLOd1NARGf/FNtBUfBR3Lx4CBWBD+q8wH6QsI03sNxJGcRhBky\nS3Idl+YkByf958bUCQMDRJCSzIZ954MEYLcPEUhdgJ3M4rrTBPya2qdB6P58yHHx\nBn5FJgqzk1vvVw2CLKppp/1nCKx9FtEOJ2LvBdfMcIHzIgj/OLzDpH28nFKGE08K\n4+lg4+DUVysVHXblOv/W0gGQxrYMEqXWoWZsmrnwuWDmYNYcMjeetN2+Zul2Sp4F\nudJ4fmkTSOzzf0tdASqlnTX0d3QccI/Syq84BTkBlNDkn7AgkJV4osbBbr0LlXXy\nVPzcUr3s9X+MxvqNZ8WuwQ1WUkfA7m9XVsg6tKfSf2ptDNcCCJvuNy0CRMlLcvRc\nth5PdwkRmOKmpJkQyviXR0ffznI0EBp96d9UGl+qVuZer5pyabI=\n=F9Lk\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/96eb1deed0944d53aaaf83b4bd6af47f79cb135b",
          "sha": "96eb1deed0944d53aaaf83b4bd6af47f79cb135b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/96eb1deed0944d53aaaf83b4bd6af47f79cb135b"
        }
      ],
      "message": "http: delete libevent!",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2026-02-12T16:04:33Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-03-13T17:57:58Z"
      },
      "sha": "d48c18b88c64839fd48647a8bb10db4fa266f3e9"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 22740954414,
      "node_id": "HRFPE_lADOABII586t8FMgzwAAAAVLd20u",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22740954414",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "created_at": "2026-02-12T16:32:31Z"
    },
    {
      "event": "commented",
      "id": 3891991047,
      "node_id": "IC_kwDOABII587n-xIH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3891991047",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-12T16:34:22Z",
      "updated_at": "2026-02-12T16:34:22Z",
      "author_association": "MEMBER",
      "body": "push to d48c18b88c64839fd48647a8bb10db4fa266f3e9\r\n\r\n- Rebase on master and consume the new `ThreadPool` from #33689 ",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#issuecomment-3891991047",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32061"
    },
    {
      "event": "unlabeled",
      "id": 22743934180,
      "node_id": "UNLE_lADOABII586t8FMgzwAAAAVLpOTk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22743934180",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-12T18:22:25Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 3797179359,
      "node_id": "PRR_kwDOABII587iVFvf",
      "url": null,
      "actor": null,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-02-13T13:02:18Z",
      "author_association": "MEMBER",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#pullrequestreview-3797179359",
      "submitted_at": "2026-02-13T13:02:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2051985554",
      "pull_request_review_id": 2780581749,
      "id": 2051985554,
      "node_id": "PRRC_kwDOABII5856TtCS",
      "diff_hunk": "@@ -0,0 +1,535 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<SockMan::Id>\n+SockMan::ConnectAndMakeId(const std::variant<CService, StringHostIntPort>& to,\n+                          bool is_important,\n+                          std::optional<Proxy> proxy,\n+                          bool& proxy_failed,\n+                          CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};\n+        if (addr_to.IsI2P()) {\n+            if (!Assume(proxy.has_value())) {\n+                return std::nullopt;\n+            }\n+\n+            i2p::Connection conn;\n+            bool connected{false};\n+\n+            if (m_i2p_sam_session) {\n+                connected = m_i2p_sam_session->Connect(addr_to, conn, proxy_failed);\n+            } else {\n+                {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.empty()) {\n+                        i2p_transient_session = std::make_unique<i2p::sam::Session>(proxy.value(), &interruptNet);\n+                    } else {\n+                        i2p_transient_session.swap(m_unused_i2p_sessions.front());\n+                        m_unused_i2p_sessions.pop();\n+                    }\n+                }\n+                connected = i2p_transient_session->Connect(addr_to, conn, proxy_failed);\n+                if (!connected) {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.size() < MAX_UNUSED_I2P_SESSIONS_SIZE) {\n+                        m_unused_i2p_sessions.emplace(i2p_transient_session.release());\n+                    }\n+                }\n+            }\n+\n+            if (connected) {\n+                sock = std::move(conn.sock);\n+                me = conn.me;\n+            }\n+        } else if (proxy.has_value()) {\n+            sock = ConnectThroughProxy(proxy.value(), addr_to.ToStringAddr(), addr_to.GetPort(), proxy_failed);\n+        } else {\n+            sock = ConnectDirectly(addr_to, is_important);\n+        }\n+    } else {\n+        if (!Assume(proxy.has_value())) {\n+            return std::nullopt;\n+        }\n+\n+        const auto& hostport{std::get<StringHostIntPort>(to)};\n+\n+        bool dummy_proxy_failed;\n+        sock = ConnectThroughProxy(proxy.value(), hostport.host, hostport.port, dummy_proxy_failed);\n+    }\n+\n+    if (!sock) {\n+        return std::nullopt;\n+    }\n+\n+    if (!me.IsValid()) {\n+        me = GetBindAddress(*sock);\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock),\n+                                                                    std::move(i2p_transient_session)));\n+    }\n+\n+    return id;\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSockets(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+void SockMan::EventI2PStatus(const CService&, I2PStatus) {}\n+\n+void SockMan::TestOnlyAddExistentConnection(Id id, std::unique_ptr<Sock>&& sock)\n+{\n+    LOCK(m_connected_mutex);\n+    const auto result{m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)))};\n+    assert(result.second);\n+}\n+\n+void SockMan::ThreadI2PAccept()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 5min;\n+    auto err_wait = err_wait_begin;\n+\n+    i2p::Connection conn;\n+\n+    auto SleepOnFailure = [&]() {\n+        interruptNet.sleep_for(err_wait);\n+        if (err_wait < err_wait_cap) {\n+            err_wait += 1s;\n+        }\n+    };\n+\n+    while (!interruptNet) {\n+\n+        if (!m_i2p_sam_session->Listen(conn)) {\n+            EventI2PStatus(conn.me, SockMan::I2PStatus::STOP_LISTENING);\n+            SleepOnFailure();\n+            continue;\n+        }\n+\n+        EventI2PStatus(conn.me, SockMan::I2PStatus::START_LISTENING);\n+\n+        if (!m_i2p_sam_session->Accept(conn)) {\n+            SleepOnFailure();\n+            continue;\n+        }\n+\n+        Assume(conn.me.IsI2P());\n+        Assume(conn.peer.IsI2P());\n+\n+        NewSockAccepted(std::move(conn.sock), conn.me, conn.peer);\n+\n+        err_wait = err_wait_begin;\n+    }\n+}\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAll();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }\n+\n+        // Service (send/receive) each of the already connected sockets.\n+        SocketHandlerConnected(io_readiness);\n+\n+        // Accept new connections from listening sockets.\n+        SocketHandlerListening(io_readiness.events_per_sock);\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 396,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "cfe5eba4463ff289b46ba0b3f4708f7cd3f1e9fe",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: this comment seems to be incorrect, since `TCP_NODELAY` is only set once by `SockMan`.",
      "created_at": "2025-04-21T05:44:31Z",
      "updated_at": "2025-04-21T05:52:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2051985554",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2051985554"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 396,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2051989121",
      "pull_request_review_id": 2780581749,
      "id": 2051989121,
      "node_id": "PRRC_kwDOABII5856Tt6B",
      "diff_hunk": "@@ -116,6 +119,20 @@ std::optional<int64_t> ParseISO8601DateTime(std::string_view str)\n     return int64_t{TicksSinceEpoch<std::chrono::seconds>(tp)};\n }\n \n+std::string FormatRFC7231DateTime(int64_t nTime)\n+{\n+    const std::chrono::sys_seconds secs{std::chrono::seconds{nTime}};\n+    const auto days{std::chrono::floor<std::chrono::days>(secs)};\n+    // 1970-01-01 was a Thursday\n+    std::string weekday{weekdays[(days.time_since_epoch().count() + 4) % 7]};",
      "path": "src/util/time.cpp",
      "position": 1,
      "original_position": 19,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "aeb8352a9de844073c10656e53e3d90b573b9eda",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: `weekday` and `month` can be a `string_view`.",
      "created_at": "2025-04-21T05:49:31Z",
      "updated_at": "2025-04-21T05:52:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2051989121",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2051989121"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 127,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2051998964",
      "pull_request_review_id": 2780602792,
      "id": 2051998964,
      "node_id": "PRRC_kwDOABII5856TwT0",
      "diff_hunk": "@@ -497,3 +497,10 @@ std::optional<uint64_t> ParseByteUnits(std::string_view str, ByteUnit default_mu\n     }\n     return *parsed_num * unit_amount;\n }\n+\n+std::vector<std::byte> StringToBuffer(const std::string& str)\n+{\n+    return std::vector<std::byte>(",
      "path": "src/util/strencodings.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "a1e151c77469574ca61817b611d360f50d44da38",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: maybe using `std::span` will be simpler? \r\nFor example:\r\n```c++\r\n    auto span = std::as_bytes(std::span(str));\r\n    return {span.begin(), span.end()};\r\n```",
      "created_at": "2025-04-21T06:03:20Z",
      "updated_at": "2025-04-21T06:46:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2051998964",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2051998964"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 503,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2052024440",
      "pull_request_review_id": 2780602792,
      "id": 2052024440,
      "node_id": "PRRC_kwDOABII5856T2h4",
      "diff_hunk": "@@ -13,4 +13,42 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n     if (search.empty()) return;\n     in_out = std::regex_replace(in_out, std::regex(search), substitute);\n }\n+\n+LineReader::LineReader(std::span<const std::byte> buffer, size_t max_read)\n+    : start(buffer.begin()), end(buffer.end()), max_read(max_read), it(buffer.begin()) {}\n+\n+std::optional<std::string> LineReader::ReadLine()\n+{\n+    if (it == end) {\n+        return std::nullopt;\n+    }\n+\n+    auto line_start = it;\n+    std::string line{};\n+    while (it != end) {\n+        char c = static_cast<char>(*it);\n+        line += c;",
      "path": "src/util/string.cpp",
      "position": 1,
      "original_position": 18,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "a1e151c77469574ca61817b611d360f50d44da38",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Maybe it would be better (performance-wise) to create the string after the loop is over?\r\n```c++\r\nstd::optional<std::string> LineReader::ReadLine()\r\n{\r\n    if (it == end) {\r\n        return std::nullopt;\r\n    }\r\n\r\n    auto line_start = it;\r\n    size_t count = 0;\r\n    while (it != end) {\r\n        char c = static_cast<char>(*it);\r\n        ++it;\r\n        ++count;\r\n        if (c == '\\n') break;\r\n        if (count >= max_read) throw std::runtime_error(\"max_read exceeded by LineReader\");\r\n    }\r\n    const std::byte *data = &*line_start;\r\n    std::string line{reinterpret_cast<const char *>(data), count};\r\n    line = TrimString(line); // delete trailing \\r and/or \\n\r\n    return line;\r\n}\r\n```",
      "created_at": "2025-04-21T06:33:50Z",
      "updated_at": "2025-04-21T06:46:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2052024440",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2052024440"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 30,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2052025637",
      "pull_request_review_id": 2780602792,
      "id": 2052025637,
      "node_id": "PRRC_kwDOABII5856T20l",
      "diff_hunk": "@@ -13,4 +13,42 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n     if (search.empty()) return;\n     in_out = std::regex_replace(in_out, std::regex(search), substitute);\n }\n+\n+LineReader::LineReader(std::span<const std::byte> buffer, size_t max_read)\n+    : start(buffer.begin()), end(buffer.end()), max_read(max_read), it(buffer.begin()) {}\n+\n+std::optional<std::string> LineReader::ReadLine()\n+{\n+    if (it == end) {\n+        return std::nullopt;\n+    }\n+\n+    auto line_start = it;\n+    std::string line{};\n+    while (it != end) {\n+        char c = static_cast<char>(*it);\n+        line += c;\n+        ++it;\n+        if (c == '\\n') break;\n+        if ((size_t)std::distance(line_start, it) >= max_read) throw std::runtime_error(\"max_read exceeded by LineReader\");\n+    }\n+\n+    line = TrimString(line); // delete trailing \\r and/or \\n",
      "path": "src/util/string.cpp",
      "position": 1,
      "original_position": 24,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "a1e151c77469574ca61817b611d360f50d44da38",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Can we return a `string_view` to the internal buffer?\r\n(preventing allocation & copy)",
      "created_at": "2025-04-21T06:35:11Z",
      "updated_at": "2025-04-21T06:46:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2052025637",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2052025637"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 36,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2052027205",
      "pull_request_review_id": 2780602792,
      "id": 2052027205,
      "node_id": "PRRC_kwDOABII5856T3NF",
      "diff_hunk": "@@ -13,4 +13,42 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n     if (search.empty()) return;\n     in_out = std::regex_replace(in_out, std::regex(search), substitute);\n }\n+\n+LineReader::LineReader(std::span<const std::byte> buffer, size_t max_read)\n+    : start(buffer.begin()), end(buffer.end()), max_read(max_read), it(buffer.begin()) {}\n+\n+std::optional<std::string> LineReader::ReadLine()\n+{\n+    if (it == end) {\n+        return std::nullopt;\n+    }\n+\n+    auto line_start = it;\n+    std::string line{};\n+    while (it != end) {\n+        char c = static_cast<char>(*it);\n+        line += c;\n+        ++it;\n+        if (c == '\\n') break;\n+        if ((size_t)std::distance(line_start, it) >= max_read) throw std::runtime_error(\"max_read exceeded by LineReader\");\n+    }\n+\n+    line = TrimString(line); // delete trailing \\r and/or \\n\n+    return line;\n+}\n+\n+// Ignores max_read but won't overflow\n+std::string LineReader::ReadLength(size_t len)\n+{\n+    if (len == 0) return \"\";\n+    if (Left() < len) throw std::runtime_error(\"Not enough data in buffer\");\n+    std::string out(reinterpret_cast<const char*>(&(*it)), len);",
      "path": "src/util/string.cpp",
      "position": 1,
      "original_position": 33,
      "commit_id": "4c7bdb8aec3f1fa385f3010e1d9995783353ba14",
      "original_commit_id": "a1e151c77469574ca61817b611d360f50d44da38",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Can we return a `string_view` to the internal buffer?\r\n(preventing allocation & copy)",
      "created_at": "2025-04-21T06:37:06Z",
      "updated_at": "2025-04-21T06:46:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2052027205",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2052027205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2052036849",
      "pull_request_review_id": 2780672873,
      "id": 2052036849,
      "node_id": "PRRC_kwDOABII5856T5jx",
      "diff_hunk": "@@ -781,3 +781,69 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n         pathHandlers.erase(i);\n     }\n }\n+\n+\n+namespace http_bitcoin {\n+std::optional<std::string> HTTPHeaders::Find(const std::string key) const",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "70d003ca1028458bd6573bcd067e234e009f66c9",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: consider using `string_view` instead of `string` here and below.",
      "created_at": "2025-04-21T06:48:12Z",
      "updated_at": "2025-04-21T16:06:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2052036849",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2052036849"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2052664896",
      "pull_request_review_id": 2781691846,
      "id": 2052664896,
      "node_id": "PRRC_kwDOABII5856WS5A",
      "diff_hunk": "@@ -781,3 +781,69 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n         pathHandlers.erase(i);\n     }\n }\n+\n+\n+namespace http_bitcoin {\n+std::optional<std::string> HTTPHeaders::Find(const std::string key) const\n+{\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return it->second;\n+}\n+\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = existing_value.value() + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n+\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n+\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n+\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n+\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n+\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (auto it = m_map.begin(); it != m_map.end(); ++it) {",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 60,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "70d003ca1028458bd6573bcd067e234e009f66c9",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: maybe the following would be simpler?\r\n```c++\r\n    for (const auto& [k, v] : m_map) {\r\n        out += k + \": \" + v + \"\\r\\n\";\r\n    }\r\n```",
      "created_at": "2025-04-21T16:11:56Z",
      "updated_at": "2025-04-21T16:14:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2052664896",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2052664896"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 840,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062566402",
      "pull_request_review_id": 2797567891,
      "id": 2062566402,
      "node_id": "PRRC_kwDOABII58568EQC",
      "diff_hunk": "@@ -906,6 +906,24 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n     return true;\n }\n \n+bool HTTPClient::ReadRequest(std::unique_ptr<HTTPRequest>& req)\n+{\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 15,
      "commit_id": "8c81bdf2532aa1c61e25d367a480ce3aa71362ca",
      "original_commit_id": "482382bd1490fa3e0bdf0e82497a583dafd80a45",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: maybe it's better to return a `std::span` from `m_recv_buffer` to avoid a copy here.",
      "created_at": "2025-04-27T08:49:01Z",
      "updated_at": "2025-04-27T09:36:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2062566402",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062566402"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 975,
      "original_line": 920,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062569706",
      "pull_request_review_id": 2797567891,
      "id": 2062569706,
      "node_id": "PRRC_kwDOABII58568FDq",
      "diff_hunk": "@@ -940,6 +941,92 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n     }\n }\n \n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)",
      "path": "src/httpserver.cpp",
      "position": 529,
      "original_position": 12,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "73c3c2e3d3658a2e7d7ba194442a081a5c3e771f",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Would it be possible to allow writing a reply composed of several `span<byte>`?\r\nIt should allow sending while serializing a response object.",
      "created_at": "2025-04-27T09:02:51Z",
      "updated_at": "2025-04-27T09:36:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2062569706",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062569706"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 434,
      "original_line": 944,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062570060",
      "pull_request_review_id": 2797567891,
      "id": 2062570060,
      "node_id": "PRRC_kwDOABII58568FJM",
      "diff_hunk": "@@ -940,6 +941,92 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n     }\n }\n \n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n+        }\n+    }\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n+    }\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    // Fill the send buffer with the complete serialized response headers + body\n+    {\n+        LOCK(m_client->m_send_mutex);\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());",
      "path": "src/httpserver.cpp",
      "position": 605,
      "original_position": 82,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "73c3c2e3d3658a2e7d7ba194442a081a5c3e771f",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Maybe use a list of buffers (instead a single FIFO buffer)?",
      "created_at": "2025-04-27T09:04:42Z",
      "updated_at": "2025-04-27T09:36:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2062570060",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062570060"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 509,
      "original_line": 1014,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062572600",
      "pull_request_review_id": 2797567891,
      "id": 2062572600,
      "node_id": "PRRC_kwDOABII58568Fw4",
      "diff_hunk": "@@ -266,6 +266,15 @@ class HTTPRequest\n     bool LoadControlData(LineReader& reader);\n     bool LoadHeaders(LineReader& reader);\n     bool LoadBody(LineReader& reader);\n+\n+    // Response headers may be set in advance before response body is known\n+    HTTPHeaders m_response_headers;\n+    void WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body = {});\n+    void WriteReply(HTTPStatusCode status, const char* reply_body) {\n+        auto reply_body_view = std::string_view(reply_body);\n+        std::span<const std::byte> byte_span(reinterpret_cast<const std::byte*>(reply_body_view.data()), reply_body_view.size());",
      "path": "src/httpserver.h",
      "position": 1,
      "original_position": 10,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "73c3c2e3d3658a2e7d7ba194442a081a5c3e771f",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: can be simplified using\r\n```c++\r\n    void WriteReply(HTTPStatusCode status, std::string_view reply_body_view)\r\n    {\r\n        WriteReply(status, std::as_bytes(std::span{reply_body_view}));\r\n    }\r\n```",
      "created_at": "2025-04-27T09:16:19Z",
      "updated_at": "2025-04-27T09:36:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2062572600",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062572600"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062573530",
      "pull_request_review_id": 2797567891,
      "id": 2062573530,
      "node_id": "PRRC_kwDOABII58568F_a",
      "diff_hunk": "@@ -27,168 +34,316 @@ static const int DEFAULT_HTTP_WORKQUEUE=64;\n \n static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;\n \n-struct evhttp_request;\n-struct event_base;\n-class CService;\n-class HTTPRequest;\n+enum HTTPRequestMethod {\n+    UNKNOWN,\n+    GET,\n+    POST,\n+    HEAD,\n+    PUT\n+};\n \n-/** Initialize HTTP server.\n- * Call this before RegisterHTTPHandler or EventBase().\n- */\n-bool InitHTTPServer(const util::SignalInterrupt& interrupt);\n-/** Start HTTP server.\n- * This is separate from InitHTTPServer to give users race-condition-free time\n- * to register their handlers between InitHTTPServer and StartHTTPServer.\n+/** Event handler closure.\n  */\n-void StartHTTPServer();\n-/** Interrupt HTTP server threads */\n-void InterruptHTTPServer();\n-/** Stop HTTP server */\n-void StopHTTPServer();\n+class HTTPClosure\n+{\n+public:\n+    virtual void operator()() = 0;\n+    virtual ~HTTPClosure() = default;\n+};\n \n-/** Change logging level for libevent. */\n-void UpdateHTTPServerLogging(bool enable);\n+namespace http_bitcoin {\n+using util::LineReader;\n+using NodeId = SockMan::Id;\n \n-/** Handler for requests to a certain HTTP path */\n-typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n-/** Register handler for prefix.\n- * If multiple handlers match a prefix, the first-registered one will\n- * be invoked.\n- */\n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler);\n-/** Unregister handler for prefix */\n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch);\n+// shortest valid request line, used by libevent in evhttp_parse_request_line()\n+static const size_t MIN_REQUEST_LINE_LENGTH{strlen(\"GET / HTTP/1.0\")};\n+// maximum size of http request (request line + headers)\n+// see https://github.com/bitcoin/bitcoin/issues/6425\n+static const size_t MAX_HEADERS_SIZE{8192};\n \n-/** Return evhttp event base. This can be used by submodules to\n- * queue timers or custom events.\n- */\n-struct event_base* EventBase();\n+class HTTPHeaders\n+{\n+public:\n+    std::optional<std::string> Find(const std::string key) const;\n+    void Write(const std::string key, const std::string value);\n+    void Remove(const std::string key);\n+    bool Read(util::LineReader& reader);\n+    std::string Stringify() const;\n+\n+private:\n+    std::map<std::string, std::string, util::CaseInsensitiveComparator> m_map;\n+};\n+\n+class HTTPResponse\n+{\n+public:\n+    int m_version_major;\n+    int m_version_minor;\n+    HTTPStatusCode m_status;\n+    std::string m_reason;\n+    HTTPHeaders m_headers;\n+    std::vector<std::byte> m_body;\n+    bool m_keep_alive{false};\n+\n+    std::string StringifyHeaders() const;\n+};\n+\n+class HTTPClient;\n \n-/** In-flight HTTP request.\n- * Thin C++ wrapper around evhttp_request.\n- */\n class HTTPRequest\n {\n-private:\n-    struct evhttp_request* req;\n-    const util::SignalInterrupt& m_interrupt;\n-    bool replySent;\n+public:\n+    std::string m_method;\n+    std::string m_target;\n+    // Default protocol version is used by error responses to unreadable requests\n+    int m_version_major{1};\n+    int m_version_minor{1};\n+    HTTPHeaders m_headers;\n+    std::string m_body;\n+\n+    // Keep a pointer to the client that made the request so\n+    // we know who to respond to.\n+    std::shared_ptr<HTTPClient> m_client;\n+    explicit HTTPRequest(std::shared_ptr<HTTPClient> client) : m_client(client) {};\n+    // Null client for unit tests\n+    explicit HTTPRequest() : m_client(nullptr) {};\n+\n+    // Readers return false if they need more data from the\n+    // socket to parse properly. They throw errors if\n+    // the data is invalid.\n+    bool LoadControlData(LineReader& reader);\n+    bool LoadHeaders(LineReader& reader);\n+    bool LoadBody(LineReader& reader);\n \n+    // These methods reimplement the API from http_libevent::HTTPRequest\n+    // for downstream JSONRPC and REST modules.\n+    std::string GetURI() const {return m_target;};\n+    CService GetPeer() const;\n+    HTTPRequestMethod GetRequestMethod() const;\n+    std::optional<std::string> GetQueryParameter(const std::string& key) const;\n+    std::pair<bool, std::string> GetHeader(const std::string& hdr) const;\n+    std::string ReadBody() const {return m_body;};\n+    void WriteHeader(const std::string& hdr, const std::string& value);\n+\n+    // Response headers may be set in advance before response body is known\n+    HTTPHeaders m_response_headers;\n+    void WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body = {});\n+    void WriteReply(HTTPStatusCode status, const char* reply_body)\n+    {\n+        auto reply_body_view = std::string_view(reply_body);\n+        std::span<const std::byte> byte_span(reinterpret_cast<const std::byte*>(reply_body_view.data()), reply_body_view.size());\n+        WriteReply(status, byte_span);\n+    }\n+    void WriteReply(HTTPStatusCode status, const std::string& reply_body)",
      "path": "src/httpserver.h",
      "position": 1,
      "original_position": 160,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "6a6285d268fc387db7dcaaeae736ac5ca502392d",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Can be removed if we'll add `WriteReply(HTTPStatusCode status, std::string_view reply_body_view)` (see above).\r\n",
      "created_at": "2025-04-27T09:20:30Z",
      "updated_at": "2025-04-27T09:36:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2062573530",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062573530"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062578451",
      "pull_request_review_id": 2797582544,
      "id": 2062578451,
      "node_id": "PRRC_kwDOABII58568HMT",
      "diff_hunk": "@@ -243,18 +243,18 @@ static bool InitHTTPAllowList()\n }\n \n /** HTTP request method as string - use for logging only */\n-std::string RequestMethodString(HTTPRequest::RequestMethod m)\n+std::string RequestMethodString(HTTPRequestMethod m)",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 5,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "90761d5026285d10ab89494fc44f3225e778d5a8",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit:\r\n```c++\r\nstd::string_view RequestMethodString(HTTPRequestMethod m)\r\n```",
      "created_at": "2025-04-27T09:43:28Z",
      "updated_at": "2025-04-27T11:04:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2062578451",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062578451"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 246,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062578725",
      "pull_request_review_id": 2797582544,
      "id": 2062578725,
      "node_id": "PRRC_kwDOABII58568HQl",
      "diff_hunk": "@@ -941,6 +942,69 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n     }\n }\n \n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n+\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n+{\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n+\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string query{decoded_uri.substr(start + 1, end - start - 1)};\n+    // find requested parameter in query\n+    const std::vector<std::string> params{SplitString(query, \"&\")};",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 47,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "b828fa1e29f0baf5c08517512509a0138338bd50",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: wouldn't it copy the substrings?",
      "created_at": "2025-04-27T09:44:58Z",
      "updated_at": "2025-04-27T11:04:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2062578725",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062578725"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 980,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062578806",
      "pull_request_review_id": 2797582544,
      "id": 2062578806,
      "node_id": "PRRC_kwDOABII58568HR2",
      "diff_hunk": "@@ -941,6 +942,69 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n     }\n }\n \n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n+\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n+{\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n+\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string query{decoded_uri.substr(start + 1, end - start - 1)};\n+    // find requested parameter in query\n+    const std::vector<std::string> params{SplitString(query, \"&\")};\n+    for (const std::string& param : params) {\n+        size_t delim = param.find('=');\n+        if (key == param.substr(0, delim)) {\n+            if (delim == std::string::npos) {\n+                return \"\";\n+            } else {\n+                return param.substr(delim + 1);\n+            }\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 61,
      "commit_id": "8c81bdf2532aa1c61e25d367a480ce3aa71362ca",
      "original_commit_id": "b828fa1e29f0baf5c08517512509a0138338bd50",
      "in_reply_to_id": null,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit:\r\n```\r\nstd::pair<bool, std::string_view> HTTPRequest::GetHeader(const std::string& hdr) const\r\n```\r\n",
      "created_at": "2025-04-27T09:45:32Z",
      "updated_at": "2025-04-27T11:04:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2062578806",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2062578806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 994,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063711938",
      "pull_request_review_id": 2799390114,
      "id": 2063711938,
      "node_id": "PRRC_kwDOABII5857Ab7C",
      "diff_hunk": "@@ -0,0 +1,535 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<SockMan::Id>\n+SockMan::ConnectAndMakeId(const std::variant<CService, StringHostIntPort>& to,\n+                          bool is_important,\n+                          std::optional<Proxy> proxy,\n+                          bool& proxy_failed,\n+                          CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};\n+        if (addr_to.IsI2P()) {\n+            if (!Assume(proxy.has_value())) {\n+                return std::nullopt;\n+            }\n+\n+            i2p::Connection conn;\n+            bool connected{false};\n+\n+            if (m_i2p_sam_session) {\n+                connected = m_i2p_sam_session->Connect(addr_to, conn, proxy_failed);\n+            } else {\n+                {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.empty()) {\n+                        i2p_transient_session = std::make_unique<i2p::sam::Session>(proxy.value(), &interruptNet);\n+                    } else {\n+                        i2p_transient_session.swap(m_unused_i2p_sessions.front());\n+                        m_unused_i2p_sessions.pop();\n+                    }\n+                }\n+                connected = i2p_transient_session->Connect(addr_to, conn, proxy_failed);\n+                if (!connected) {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.size() < MAX_UNUSED_I2P_SESSIONS_SIZE) {\n+                        m_unused_i2p_sessions.emplace(i2p_transient_session.release());\n+                    }\n+                }\n+            }\n+\n+            if (connected) {\n+                sock = std::move(conn.sock);\n+                me = conn.me;\n+            }\n+        } else if (proxy.has_value()) {\n+            sock = ConnectThroughProxy(proxy.value(), addr_to.ToStringAddr(), addr_to.GetPort(), proxy_failed);\n+        } else {\n+            sock = ConnectDirectly(addr_to, is_important);\n+        }\n+    } else {\n+        if (!Assume(proxy.has_value())) {\n+            return std::nullopt;\n+        }\n+\n+        const auto& hostport{std::get<StringHostIntPort>(to)};\n+\n+        bool dummy_proxy_failed;\n+        sock = ConnectThroughProxy(proxy.value(), hostport.host, hostport.port, dummy_proxy_failed);\n+    }\n+\n+    if (!sock) {\n+        return std::nullopt;\n+    }\n+\n+    if (!me.IsValid()) {\n+        me = GetBindAddress(*sock);\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock),\n+                                                                    std::move(i2p_transient_session)));\n+    }\n+\n+    return id;\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto sockets{GetConnectionSockets(id)};\n+    if (!sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        sockets->mutex,\n+        return sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::StopListening()\n+{\n+    m_listen.clear();\n+}\n+\n+bool SockMan::ShouldTryToSend(Id id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(Id id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForOne(Id id) {}\n+\n+void SockMan::EventIOLoopCompletedForAll() {}\n+\n+void SockMan::EventI2PStatus(const CService&, I2PStatus) {}\n+\n+void SockMan::TestOnlyAddExistentConnection(Id id, std::unique_ptr<Sock>&& sock)\n+{\n+    LOCK(m_connected_mutex);\n+    const auto result{m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock)))};\n+    assert(result.second);\n+}\n+\n+void SockMan::ThreadI2PAccept()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 5min;\n+    auto err_wait = err_wait_begin;\n+\n+    i2p::Connection conn;\n+\n+    auto SleepOnFailure = [&]() {\n+        interruptNet.sleep_for(err_wait);\n+        if (err_wait < err_wait_cap) {\n+            err_wait += 1s;\n+        }\n+    };\n+\n+    while (!interruptNet) {\n+\n+        if (!m_i2p_sam_session->Listen(conn)) {\n+            EventI2PStatus(conn.me, SockMan::I2PStatus::STOP_LISTENING);\n+            SleepOnFailure();\n+            continue;\n+        }\n+\n+        EventI2PStatus(conn.me, SockMan::I2PStatus::START_LISTENING);\n+\n+        if (!m_i2p_sam_session->Accept(conn)) {\n+            SleepOnFailure();\n+            continue;\n+        }\n+\n+        Assume(conn.me.IsI2P());\n+        Assume(conn.peer.IsI2P());\n+\n+        NewSockAccepted(std::move(conn.sock), conn.me, conn.peer);\n+\n+        err_wait = err_wait_begin;\n+    }\n+}\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAll();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }\n+\n+        // Service (send/receive) each of the already connected sockets.\n+        SocketHandlerConnected(io_readiness);\n+\n+        // Accept new connections from listening sockets.\n+        SocketHandlerListening(io_readiness.events_per_sock);\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage), len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.",
      "path": "src/common/sockman.cpp",
      "position": 1,
      "original_position": 396,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "cfe5eba4463ff289b46ba0b3f4708f7cd3f1e9fe",
      "in_reply_to_id": 2051985554,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This comment may need to be applied upstream in https://github.com/bitcoin/bitcoin/pull/30988\r\n\r\nFWIW, the `Sockman` backend might not be what we end up going with, as @theuni and I are considering an alternative.",
      "created_at": "2025-04-28T13:53:26Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2063711938",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063711938"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 396,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063725962",
      "pull_request_review_id": 2799390114,
      "id": 2063725962,
      "node_id": "PRRC_kwDOABII5857AfWK",
      "diff_hunk": "@@ -243,18 +243,18 @@ static bool InitHTTPAllowList()\n }\n \n /** HTTP request method as string - use for logging only */\n-std::string RequestMethodString(HTTPRequest::RequestMethod m)\n+std::string RequestMethodString(HTTPRequestMethod m)",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 5,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "90761d5026285d10ab89494fc44f3225e778d5a8",
      "in_reply_to_id": 2062578451,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2025-04-28T13:59:39Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2063725962",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063725962"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 246,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063753329",
      "pull_request_review_id": 2799390114,
      "id": 2063753329,
      "node_id": "PRRC_kwDOABII5857AmBx",
      "diff_hunk": "@@ -941,6 +942,69 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n     }\n }\n \n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n+\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n+{\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n+\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string query{decoded_uri.substr(start + 1, end - start - 1)};\n+    // find requested parameter in query\n+    const std::vector<std::string> params{SplitString(query, \"&\")};",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 47,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "b828fa1e29f0baf5c08517512509a0138338bd50",
      "in_reply_to_id": 2062578725,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "You're right thanks, I haven't been dilligent about using string_view when copying isn't needed. Fixed that here and also in `HTTPRequest::LoadControlData()`",
      "created_at": "2025-04-28T14:12:41Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2063753329",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063753329"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 980,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063786403",
      "pull_request_review_id": 2799390114,
      "id": 2063786403,
      "node_id": "PRRC_kwDOABII5857AuGj",
      "diff_hunk": "@@ -941,6 +942,69 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n     }\n }\n \n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n+\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n+{\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n+\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string query{decoded_uri.substr(start + 1, end - start - 1)};\n+    // find requested parameter in query\n+    const std::vector<std::string> params{SplitString(query, \"&\")};\n+    for (const std::string& param : params) {\n+        size_t delim = param.find('=');\n+        if (key == param.substr(0, delim)) {\n+            if (delim == std::string::npos) {\n+                return \"\";\n+            } else {\n+                return param.substr(delim + 1);\n+            }\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 61,
      "commit_id": "8c81bdf2532aa1c61e25d367a480ce3aa71362ca",
      "original_commit_id": "b828fa1e29f0baf5c08517512509a0138338bd50",
      "in_reply_to_id": 2062578806,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "thanks, for this fix I added a new commit instead of a fixup. The reason is because in the \"story\" of the commits, `GetHeader()` is already defined and used by the legacy HTTP server returning a string, and the goal at this point is to match the exiting API. But we can optimize it after the big \"switch HTTP servers\" commit.",
      "created_at": "2025-04-28T14:28:45Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2063786403",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063786403"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 994,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063795724",
      "pull_request_review_id": 2799390114,
      "id": 2063795724,
      "node_id": "PRRC_kwDOABII5857AwYM",
      "diff_hunk": "@@ -940,6 +941,92 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n     }\n }\n \n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)",
      "path": "src/httpserver.cpp",
      "position": 529,
      "original_position": 12,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "73c3c2e3d3658a2e7d7ba194442a081a5c3e771f",
      "in_reply_to_id": 2062569706,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Could this be done in a followup? I actually just checked https://github.com/bitcoin/bitcoin/pull/30321 to see why we didn't do this back then -- I remember when that was authored and merged but I didn't realize you were the author!",
      "created_at": "2025-04-28T14:33:38Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2063795724",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063795724"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 434,
      "original_line": 944,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063873609",
      "pull_request_review_id": 2799390114,
      "id": 2063873609,
      "node_id": "PRRC_kwDOABII5857BDZJ",
      "diff_hunk": "@@ -940,6 +941,92 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n     }\n }\n \n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n+        }\n+    }\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n+    }\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    // Fill the send buffer with the complete serialized response headers + body\n+    {\n+        LOCK(m_client->m_send_mutex);\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());",
      "path": "src/httpserver.cpp",
      "position": 605,
      "original_position": 82,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "73c3c2e3d3658a2e7d7ba194442a081a5c3e771f",
      "in_reply_to_id": 2062570060,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I don't understand -- would that be an optimization? It's not really a FIFO, since we insert at the end of the buffer here but send data from the `begin()` of the buffer in `SendBytesFromBuffer()`",
      "created_at": "2025-04-28T15:06:58Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2063873609",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063873609"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 509,
      "original_line": 1014,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063909861",
      "pull_request_review_id": 2799390114,
      "id": 2063909861,
      "node_id": "PRRC_kwDOABII5857BMPl",
      "diff_hunk": "@@ -906,6 +906,24 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n     return true;\n }\n \n+bool HTTPClient::ReadRequest(std::unique_ptr<HTTPRequest>& req)\n+{\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 15,
      "commit_id": "8c81bdf2532aa1c61e25d367a480ce3aa71362ca",
      "original_commit_id": "482382bd1490fa3e0bdf0e82497a583dafd80a45",
      "in_reply_to_id": 2062566402,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "we'd still want to erase the data after fulfilling the request though (if I'm understanding your comment correctly). Would it make more sense if `m_recv_buffer` was a `std::deque` or something where we can truncate the structure without copying/moving/shifting left?",
      "created_at": "2025-04-28T15:21:22Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2063909861",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063909861"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 975,
      "original_line": 920,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063946994",
      "pull_request_review_id": 2799390114,
      "id": 2063946994,
      "node_id": "PRRC_kwDOABII5857BVTy",
      "diff_hunk": "@@ -266,6 +266,15 @@ class HTTPRequest\n     bool LoadControlData(LineReader& reader);\n     bool LoadHeaders(LineReader& reader);\n     bool LoadBody(LineReader& reader);\n+\n+    // Response headers may be set in advance before response body is known\n+    HTTPHeaders m_response_headers;\n+    void WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body = {});\n+    void WriteReply(HTTPStatusCode status, const char* reply_body) {\n+        auto reply_body_view = std::string_view(reply_body);\n+        std::span<const std::byte> byte_span(reinterpret_cast<const std::byte*>(reply_body_view.data()), reply_body_view.size());",
      "path": "src/httpserver.h",
      "position": 1,
      "original_position": 10,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "73c3c2e3d3658a2e7d7ba194442a081a5c3e771f",
      "in_reply_to_id": 2062572600,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "awesome thanks",
      "created_at": "2025-04-28T15:36:34Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2063946994",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063946994"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063947203",
      "pull_request_review_id": 2799390114,
      "id": 2063947203,
      "node_id": "PRRC_kwDOABII5857BVXD",
      "diff_hunk": "@@ -27,168 +34,316 @@ static const int DEFAULT_HTTP_WORKQUEUE=64;\n \n static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;\n \n-struct evhttp_request;\n-struct event_base;\n-class CService;\n-class HTTPRequest;\n+enum HTTPRequestMethod {\n+    UNKNOWN,\n+    GET,\n+    POST,\n+    HEAD,\n+    PUT\n+};\n \n-/** Initialize HTTP server.\n- * Call this before RegisterHTTPHandler or EventBase().\n- */\n-bool InitHTTPServer(const util::SignalInterrupt& interrupt);\n-/** Start HTTP server.\n- * This is separate from InitHTTPServer to give users race-condition-free time\n- * to register their handlers between InitHTTPServer and StartHTTPServer.\n+/** Event handler closure.\n  */\n-void StartHTTPServer();\n-/** Interrupt HTTP server threads */\n-void InterruptHTTPServer();\n-/** Stop HTTP server */\n-void StopHTTPServer();\n+class HTTPClosure\n+{\n+public:\n+    virtual void operator()() = 0;\n+    virtual ~HTTPClosure() = default;\n+};\n \n-/** Change logging level for libevent. */\n-void UpdateHTTPServerLogging(bool enable);\n+namespace http_bitcoin {\n+using util::LineReader;\n+using NodeId = SockMan::Id;\n \n-/** Handler for requests to a certain HTTP path */\n-typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n-/** Register handler for prefix.\n- * If multiple handlers match a prefix, the first-registered one will\n- * be invoked.\n- */\n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler);\n-/** Unregister handler for prefix */\n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch);\n+// shortest valid request line, used by libevent in evhttp_parse_request_line()\n+static const size_t MIN_REQUEST_LINE_LENGTH{strlen(\"GET / HTTP/1.0\")};\n+// maximum size of http request (request line + headers)\n+// see https://github.com/bitcoin/bitcoin/issues/6425\n+static const size_t MAX_HEADERS_SIZE{8192};\n \n-/** Return evhttp event base. This can be used by submodules to\n- * queue timers or custom events.\n- */\n-struct event_base* EventBase();\n+class HTTPHeaders\n+{\n+public:\n+    std::optional<std::string> Find(const std::string key) const;\n+    void Write(const std::string key, const std::string value);\n+    void Remove(const std::string key);\n+    bool Read(util::LineReader& reader);\n+    std::string Stringify() const;\n+\n+private:\n+    std::map<std::string, std::string, util::CaseInsensitiveComparator> m_map;\n+};\n+\n+class HTTPResponse\n+{\n+public:\n+    int m_version_major;\n+    int m_version_minor;\n+    HTTPStatusCode m_status;\n+    std::string m_reason;\n+    HTTPHeaders m_headers;\n+    std::vector<std::byte> m_body;\n+    bool m_keep_alive{false};\n+\n+    std::string StringifyHeaders() const;\n+};\n+\n+class HTTPClient;\n \n-/** In-flight HTTP request.\n- * Thin C++ wrapper around evhttp_request.\n- */\n class HTTPRequest\n {\n-private:\n-    struct evhttp_request* req;\n-    const util::SignalInterrupt& m_interrupt;\n-    bool replySent;\n+public:\n+    std::string m_method;\n+    std::string m_target;\n+    // Default protocol version is used by error responses to unreadable requests\n+    int m_version_major{1};\n+    int m_version_minor{1};\n+    HTTPHeaders m_headers;\n+    std::string m_body;\n+\n+    // Keep a pointer to the client that made the request so\n+    // we know who to respond to.\n+    std::shared_ptr<HTTPClient> m_client;\n+    explicit HTTPRequest(std::shared_ptr<HTTPClient> client) : m_client(client) {};\n+    // Null client for unit tests\n+    explicit HTTPRequest() : m_client(nullptr) {};\n+\n+    // Readers return false if they need more data from the\n+    // socket to parse properly. They throw errors if\n+    // the data is invalid.\n+    bool LoadControlData(LineReader& reader);\n+    bool LoadHeaders(LineReader& reader);\n+    bool LoadBody(LineReader& reader);\n \n+    // These methods reimplement the API from http_libevent::HTTPRequest\n+    // for downstream JSONRPC and REST modules.\n+    std::string GetURI() const {return m_target;};\n+    CService GetPeer() const;\n+    HTTPRequestMethod GetRequestMethod() const;\n+    std::optional<std::string> GetQueryParameter(const std::string& key) const;\n+    std::pair<bool, std::string> GetHeader(const std::string& hdr) const;\n+    std::string ReadBody() const {return m_body;};\n+    void WriteHeader(const std::string& hdr, const std::string& value);\n+\n+    // Response headers may be set in advance before response body is known\n+    HTTPHeaders m_response_headers;\n+    void WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body = {});\n+    void WriteReply(HTTPStatusCode status, const char* reply_body)\n+    {\n+        auto reply_body_view = std::string_view(reply_body);\n+        std::span<const std::byte> byte_span(reinterpret_cast<const std::byte*>(reply_body_view.data()), reply_body_view.size());\n+        WriteReply(status, byte_span);\n+    }\n+    void WriteReply(HTTPStatusCode status, const std::string& reply_body)",
      "path": "src/httpserver.h",
      "position": 1,
      "original_position": 160,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "6a6285d268fc387db7dcaaeae736ac5ca502392d",
      "in_reply_to_id": 2062573530,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "ðŸ‘ ",
      "created_at": "2025-04-28T15:36:40Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2063947203",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063947203"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063952597",
      "pull_request_review_id": 2799390114,
      "id": 2063952597,
      "node_id": "PRRC_kwDOABII5857BWrV",
      "diff_hunk": "@@ -497,3 +497,10 @@ std::optional<uint64_t> ParseByteUnits(std::string_view str, ByteUnit default_mu\n     }\n     return *parsed_num * unit_amount;\n }\n+\n+std::vector<std::byte> StringToBuffer(const std::string& str)\n+{\n+    return std::vector<std::byte>(",
      "path": "src/util/strencodings.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "a1e151c77469574ca61817b611d360f50d44da38",
      "in_reply_to_id": 2051998964,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Great thanks, done.",
      "created_at": "2025-04-28T15:38:54Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2063952597",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063952597"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 503,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063962062",
      "pull_request_review_id": 2799390114,
      "id": 2063962062,
      "node_id": "PRRC_kwDOABII5857BY_O",
      "diff_hunk": "@@ -13,4 +13,42 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n     if (search.empty()) return;\n     in_out = std::regex_replace(in_out, std::regex(search), substitute);\n }\n+\n+LineReader::LineReader(std::span<const std::byte> buffer, size_t max_read)\n+    : start(buffer.begin()), end(buffer.end()), max_read(max_read), it(buffer.begin()) {}\n+\n+std::optional<std::string> LineReader::ReadLine()\n+{\n+    if (it == end) {\n+        return std::nullopt;\n+    }\n+\n+    auto line_start = it;\n+    std::string line{};\n+    while (it != end) {\n+        char c = static_cast<char>(*it);\n+        line += c;",
      "path": "src/util/string.cpp",
      "position": 1,
      "original_position": 18,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "a1e151c77469574ca61817b611d360f50d44da38",
      "in_reply_to_id": 2052024440,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "awesome, done",
      "created_at": "2025-04-28T15:43:02Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2063962062",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2063962062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 30,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2064155842",
      "pull_request_review_id": 2799390114,
      "id": 2064155842,
      "node_id": "PRRC_kwDOABII5857CITC",
      "diff_hunk": "@@ -13,4 +13,42 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n     if (search.empty()) return;\n     in_out = std::regex_replace(in_out, std::regex(search), substitute);\n }\n+\n+LineReader::LineReader(std::span<const std::byte> buffer, size_t max_read)\n+    : start(buffer.begin()), end(buffer.end()), max_read(max_read), it(buffer.begin()) {}\n+\n+std::optional<std::string> LineReader::ReadLine()\n+{\n+    if (it == end) {\n+        return std::nullopt;\n+    }\n+\n+    auto line_start = it;\n+    std::string line{};\n+    while (it != end) {\n+        char c = static_cast<char>(*it);\n+        line += c;\n+        ++it;\n+        if (c == '\\n') break;\n+        if ((size_t)std::distance(line_start, it) >= max_read) throw std::runtime_error(\"max_read exceeded by LineReader\");\n+    }\n+\n+    line = TrimString(line); // delete trailing \\r and/or \\n",
      "path": "src/util/string.cpp",
      "position": 1,
      "original_position": 24,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "a1e151c77469574ca61817b611d360f50d44da38",
      "in_reply_to_id": 2052025637,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "by internal buffer I assume you mean `m_recv_buffer` which im trying to copy from into the HTTPRequest object, then clear the buffer. I left another response about maybe changing the type of that buffer to reduce unnecessary copies, but am going to leave it alone for this current rebase. What I did here though was swap out `TrimString()` with `TrimStringView()` so at least that's one less.",
      "created_at": "2025-04-28T17:31:28Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2064155842",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2064155842"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 36,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2064165018",
      "pull_request_review_id": 2799390114,
      "id": 2064165018,
      "node_id": "PRRC_kwDOABII5857CKia",
      "diff_hunk": "@@ -13,4 +13,42 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n     if (search.empty()) return;\n     in_out = std::regex_replace(in_out, std::regex(search), substitute);\n }\n+\n+LineReader::LineReader(std::span<const std::byte> buffer, size_t max_read)\n+    : start(buffer.begin()), end(buffer.end()), max_read(max_read), it(buffer.begin()) {}\n+\n+std::optional<std::string> LineReader::ReadLine()\n+{\n+    if (it == end) {\n+        return std::nullopt;\n+    }\n+\n+    auto line_start = it;\n+    std::string line{};\n+    while (it != end) {\n+        char c = static_cast<char>(*it);\n+        line += c;\n+        ++it;\n+        if (c == '\\n') break;\n+        if ((size_t)std::distance(line_start, it) >= max_read) throw std::runtime_error(\"max_read exceeded by LineReader\");\n+    }\n+\n+    line = TrimString(line); // delete trailing \\r and/or \\n\n+    return line;\n+}\n+\n+// Ignores max_read but won't overflow\n+std::string LineReader::ReadLength(size_t len)\n+{\n+    if (len == 0) return \"\";\n+    if (Left() < len) throw std::runtime_error(\"Not enough data in buffer\");\n+    std::string out(reinterpret_cast<const char*>(&(*it)), len);",
      "path": "src/util/string.cpp",
      "position": 1,
      "original_position": 33,
      "commit_id": "4c7bdb8aec3f1fa385f3010e1d9995783353ba14",
      "original_commit_id": "a1e151c77469574ca61817b611d360f50d44da38",
      "in_reply_to_id": 2052027205,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think I addressed this already by taking your suggestion here https://github.com/bitcoin/bitcoin/pull/32061/files#r2052024440",
      "created_at": "2025-04-28T17:36:51Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2064165018",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2064165018"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2064167023",
      "pull_request_review_id": 2799390114,
      "id": 2064167023,
      "node_id": "PRRC_kwDOABII5857CLBv",
      "diff_hunk": "@@ -116,6 +119,20 @@ std::optional<int64_t> ParseISO8601DateTime(std::string_view str)\n     return int64_t{TicksSinceEpoch<std::chrono::seconds>(tp)};\n }\n \n+std::string FormatRFC7231DateTime(int64_t nTime)\n+{\n+    const std::chrono::sys_seconds secs{std::chrono::seconds{nTime}};\n+    const auto days{std::chrono::floor<std::chrono::days>(secs)};\n+    // 1970-01-01 was a Thursday\n+    std::string weekday{weekdays[(days.time_since_epoch().count() + 4) % 7]};",
      "path": "src/util/time.cpp",
      "position": 1,
      "original_position": 19,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "aeb8352a9de844073c10656e53e3d90b573b9eda",
      "in_reply_to_id": 2051989121,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2025-04-28T17:38:19Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2064167023",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2064167023"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 127,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2064398722",
      "pull_request_review_id": 2799390114,
      "id": 2064398722,
      "node_id": "PRRC_kwDOABII5857DDmC",
      "diff_hunk": "@@ -781,3 +781,69 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n         pathHandlers.erase(i);\n     }\n }\n+\n+\n+namespace http_bitcoin {\n+std::optional<std::string> HTTPHeaders::Find(const std::string key) const\n+{\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return it->second;\n+}\n+\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = existing_value.value() + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n+\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n+\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n+\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n+\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n+\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (auto it = m_map.begin(); it != m_map.end(); ++it) {",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 60,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "70d003ca1028458bd6573bcd067e234e009f66c9",
      "in_reply_to_id": 2052664896,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "thanks I'll take it!",
      "created_at": "2025-04-28T19:41:16Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2064398722",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2064398722"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 840,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2064400862",
      "pull_request_review_id": 2799390114,
      "id": 2064400862,
      "node_id": "PRRC_kwDOABII5857DEHe",
      "diff_hunk": "@@ -781,3 +781,69 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n         pathHandlers.erase(i);\n     }\n }\n+\n+\n+namespace http_bitcoin {\n+std::optional<std::string> HTTPHeaders::Find(const std::string key) const",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "70d003ca1028458bd6573bcd067e234e009f66c9",
      "in_reply_to_id": 2052036849,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "done.",
      "created_at": "2025-04-28T19:42:06Z",
      "updated_at": "2025-04-29T13:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2064400862",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2064400862"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2067899705",
      "pull_request_review_id": 2805824400,
      "id": 2067899705,
      "node_id": "PRRC_kwDOABII5857QaU5",
      "diff_hunk": "@@ -906,6 +906,24 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n     return true;\n }\n \n+bool HTTPClient::ReadRequest(std::unique_ptr<HTTPRequest>& req)\n+{\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 15,
      "commit_id": "8c81bdf2532aa1c61e25d367a480ce3aa71362ca",
      "original_commit_id": "482382bd1490fa3e0bdf0e82497a583dafd80a45",
      "in_reply_to_id": 2062566402,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Would it make more sense if m_recv_buffer was a std::deque or something where we can truncate the structure without copying/moving/shifting left?\r\n\r\nSounds good :)",
      "created_at": "2025-04-30T05:53:58Z",
      "updated_at": "2025-04-30T05:53:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2067899705",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2067899705"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 975,
      "original_line": 920,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2067900213",
      "pull_request_review_id": 2805825671,
      "id": 2067900213,
      "node_id": "PRRC_kwDOABII5857Qac1",
      "diff_hunk": "@@ -940,6 +941,92 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n     }\n }\n \n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)",
      "path": "src/httpserver.cpp",
      "position": 529,
      "original_position": 12,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "73c3c2e3d3658a2e7d7ba194442a081a5c3e771f",
      "in_reply_to_id": 2062569706,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Sure, thanks :)",
      "created_at": "2025-04-30T05:54:29Z",
      "updated_at": "2025-04-30T05:54:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2067900213",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2067900213"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 434,
      "original_line": 944,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2067902920",
      "pull_request_review_id": 2805829662,
      "id": 2067902920,
      "node_id": "PRRC_kwDOABII5857QbHI",
      "diff_hunk": "@@ -940,6 +941,92 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n     }\n }\n \n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n+        }\n+    }\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n+    }\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    // Fill the send buffer with the complete serialized response headers + body\n+    {\n+        LOCK(m_client->m_send_mutex);\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());",
      "path": "src/httpserver.cpp",
      "position": 605,
      "original_position": 82,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "73c3c2e3d3658a2e7d7ba194442a081a5c3e771f",
      "in_reply_to_id": 2062570060,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I suggest considering a similar approach to `libevent`'s evbuffers:\r\n\r\n> evbuffers are represented using a linked list of memory chunks, with pointers to the first and last chunk in the chain.\r\n\r\nhttps://libevent.org/doc/buffer_8h.html",
      "created_at": "2025-04-30T05:57:12Z",
      "updated_at": "2025-04-30T05:57:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2067902920",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2067902920"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 509,
      "original_line": 1014,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2069908553",
      "pull_request_review_id": 2809245150,
      "id": 2069908553,
      "node_id": "PRRC_kwDOABII5857YExJ",
      "diff_hunk": "@@ -940,6 +941,92 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n     }\n }\n \n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n+        }\n+    }\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n+    }\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    // Fill the send buffer with the complete serialized response headers + body\n+    {\n+        LOCK(m_client->m_send_mutex);\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());",
      "path": "src/httpserver.cpp",
      "position": 605,
      "original_position": 82,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "73c3c2e3d3658a2e7d7ba194442a081a5c3e771f",
      "in_reply_to_id": 2062570060,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Thinking about it, doing the copy here is definitely fine for now ([we can optimize it in a following PR](https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2063795724)).",
      "created_at": "2025-05-01T06:45:36Z",
      "updated_at": "2025-05-01T06:46:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2069908553",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2069908553"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 509,
      "original_line": 1014,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2072365927",
      "pull_request_review_id": 2813204501,
      "id": 2072365927,
      "node_id": "PRRC_kwDOABII5857hctn",
      "diff_hunk": "@@ -13,4 +13,42 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n     if (search.empty()) return;\n     in_out = std::regex_replace(in_out, std::regex(search), substitute);\n }\n+\n+LineReader::LineReader(std::span<const std::byte> buffer, size_t max_read)\n+    : start(buffer.begin()), end(buffer.end()), max_read(max_read), it(buffer.begin()) {}\n+\n+std::optional<std::string> LineReader::ReadLine()\n+{\n+    if (it == end) {\n+        return std::nullopt;\n+    }\n+\n+    auto line_start = it;\n+    std::string line{};\n+    while (it != end) {\n+        char c = static_cast<char>(*it);\n+        line += c;\n+        ++it;\n+        if (c == '\\n') break;\n+        if ((size_t)std::distance(line_start, it) >= max_read) throw std::runtime_error(\"max_read exceeded by LineReader\");\n+    }\n+\n+    line = TrimString(line); // delete trailing \\r and/or \\n\n+    return line;\n+}\n+\n+// Ignores max_read but won't overflow\n+std::string LineReader::ReadLength(size_t len)\n+{\n+    if (len == 0) return \"\";\n+    if (Left() < len) throw std::runtime_error(\"Not enough data in buffer\");\n+    std::string out(reinterpret_cast<const char*>(&(*it)), len);",
      "path": "src/util/string.cpp",
      "position": 1,
      "original_position": 33,
      "commit_id": "4c7bdb8aec3f1fa385f3010e1d9995783353ba14",
      "original_commit_id": "a1e151c77469574ca61817b611d360f50d44da38",
      "in_reply_to_id": 2052027205,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "7d30118401 seems to still return a `std::string`:\r\n```\r\n$ git grep ReadLength\r\nsrc/util/string.cpp:  std::string LineReader::ReadLength(size_t len)\r\nsrc/util/string.h:    std::string ReadLength(size_t len);\r\n\r\n```",
      "created_at": "2025-05-03T10:15:31Z",
      "updated_at": "2025-05-03T10:16:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2072365927",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2072365927"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2072367360",
      "pull_request_review_id": 2813205684,
      "id": 2072367360,
      "node_id": "PRRC_kwDOABII5857hdEA",
      "diff_hunk": "@@ -781,3 +781,69 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n         pathHandlers.erase(i);\n     }\n }\n+\n+\n+namespace http_bitcoin {\n+std::optional<std::string> HTTPHeaders::Find(const std::string key) const",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "70d003ca1028458bd6573bcd067e234e009f66c9",
      "in_reply_to_id": 2052036849,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: `key` & `value` can also be a `string_view` (here and below)",
      "created_at": "2025-05-03T10:23:58Z",
      "updated_at": "2025-05-03T10:23:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2072367360",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2072367360"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2081728831",
      "pull_request_review_id": 2828429932,
      "id": 2081728831,
      "node_id": "PRRC_kwDOABII5858FKk_",
      "diff_hunk": "@@ -13,4 +13,42 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n     if (search.empty()) return;\n     in_out = std::regex_replace(in_out, std::regex(search), substitute);\n }\n+\n+LineReader::LineReader(std::span<const std::byte> buffer, size_t max_read)\n+    : start(buffer.begin()), end(buffer.end()), max_read(max_read), it(buffer.begin()) {}\n+\n+std::optional<std::string> LineReader::ReadLine()\n+{\n+    if (it == end) {\n+        return std::nullopt;\n+    }\n+\n+    auto line_start = it;\n+    std::string line{};\n+    while (it != end) {\n+        char c = static_cast<char>(*it);\n+        line += c;\n+        ++it;\n+        if (c == '\\n') break;\n+        if ((size_t)std::distance(line_start, it) >= max_read) throw std::runtime_error(\"max_read exceeded by LineReader\");\n+    }\n+\n+    line = TrimString(line); // delete trailing \\r and/or \\n\n+    return line;\n+}\n+\n+// Ignores max_read but won't overflow\n+std::string LineReader::ReadLength(size_t len)\n+{\n+    if (len == 0) return \"\";\n+    if (Left() < len) throw std::runtime_error(\"Not enough data in buffer\");\n+    std::string out(reinterpret_cast<const char*>(&(*it)), len);",
      "path": "src/util/string.cpp",
      "position": 1,
      "original_position": 33,
      "commit_id": "4c7bdb8aec3f1fa385f3010e1d9995783353ba14",
      "original_commit_id": "a1e151c77469574ca61817b611d360f50d44da38",
      "in_reply_to_id": 2052027205,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Oh I see I misunderstood. For now I want LineReader to return new string objects because it reads directly from the HTTPClient's `m_recv_buffer` which is then erased. I know we can prevent that copy by being more clever with `m_recv_buffer` and I still plan on exploring that, maybe as a follow up? It's nice and simple now and there is a clean separation between the socket layer receiving data and the `HTTPRequest`",
      "created_at": "2025-05-09T13:43:44Z",
      "updated_at": "2025-05-09T13:43:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2081728831",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2081728831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2081732772",
      "pull_request_review_id": 2828437016,
      "id": 2081732772,
      "node_id": "PRRC_kwDOABII5858FLik",
      "diff_hunk": "@@ -13,4 +13,42 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n     if (search.empty()) return;\n     in_out = std::regex_replace(in_out, std::regex(search), substitute);\n }\n+\n+LineReader::LineReader(std::span<const std::byte> buffer, size_t max_read)\n+    : start(buffer.begin()), end(buffer.end()), max_read(max_read), it(buffer.begin()) {}\n+\n+std::optional<std::string> LineReader::ReadLine()\n+{\n+    if (it == end) {\n+        return std::nullopt;\n+    }\n+\n+    auto line_start = it;\n+    std::string line{};\n+    while (it != end) {\n+        char c = static_cast<char>(*it);\n+        line += c;\n+        ++it;\n+        if (c == '\\n') break;\n+        if ((size_t)std::distance(line_start, it) >= max_read) throw std::runtime_error(\"max_read exceeded by LineReader\");\n+    }\n+\n+    line = TrimString(line); // delete trailing \\r and/or \\n\n+    return line;\n+}\n+\n+// Ignores max_read but won't overflow\n+std::string LineReader::ReadLength(size_t len)\n+{\n+    if (len == 0) return \"\";\n+    if (Left() < len) throw std::runtime_error(\"Not enough data in buffer\");\n+    std::string out(reinterpret_cast<const char*>(&(*it)), len);",
      "path": "src/util/string.cpp",
      "position": 1,
      "original_position": 33,
      "commit_id": "4c7bdb8aec3f1fa385f3010e1d9995783353ba14",
      "original_commit_id": "a1e151c77469574ca61817b611d360f50d44da38",
      "in_reply_to_id": 2052027205,
      "user": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Sounds good, thanks for the context :)",
      "created_at": "2025-05-09T13:46:06Z",
      "updated_at": "2025-05-09T13:46:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2081732772",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2081732772"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2081736316",
      "pull_request_review_id": 2828443585,
      "id": 2081736316,
      "node_id": "PRRC_kwDOABII5858FMZ8",
      "diff_hunk": "@@ -781,3 +781,69 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n         pathHandlers.erase(i);\n     }\n }\n+\n+\n+namespace http_bitcoin {\n+std::optional<std::string> HTTPHeaders::Find(const std::string key) const",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "70d003ca1028458bd6573bcd067e234e009f66c9",
      "in_reply_to_id": 2052036849,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Cool will address this nit on next rebase thanks!",
      "created_at": "2025-05-09T13:48:16Z",
      "updated_at": "2025-05-09T13:48:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2081736316",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2081736316"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089410867",
      "pull_request_review_id": 2840969740,
      "id": 2089410867,
      "node_id": "PRRC_kwDOABII5858ieEz",
      "diff_hunk": "@@ -781,3 +781,69 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n         pathHandlers.erase(i);\n     }\n }\n+\n+\n+namespace http_bitcoin {\n+std::optional<std::string> HTTPHeaders::Find(const std::string key) const",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "70d003ca1028458bd6573bcd067e234e009f66c9",
      "in_reply_to_id": 2052036849,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Bikeshed, feel free to ignore.\r\n\r\nIt is redundant to have \"http\" in both the namespace and in the class name: `http_bitcoin::HTTPHeaders::Find()`. Also no need to suffix anything with `_bitcoin` - if we would do that, then we would have to have e.g. `namespace common_bitcoin`, `namespace i2p_bitcoin`, `namespace node_bitcoin` etc. So `http_bitcoin::HTTPHeaders::Find()` could be shortened to `http::Headers::Find()`.",
      "created_at": "2025-05-14T17:25:44Z",
      "updated_at": "2025-05-14T17:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2089410867",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089410867"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089484885",
      "pull_request_review_id": 2841090313,
      "id": 2089484885,
      "node_id": "PRRC_kwDOABII5858iwJV",
      "diff_hunk": "@@ -781,3 +781,69 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n         pathHandlers.erase(i);\n     }\n }\n+\n+\n+namespace http_bitcoin {\n+std::optional<std::string> HTTPHeaders::Find(const std::string key) const",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "70d003ca1028458bd6573bcd067e234e009f66c9",
      "in_reply_to_id": 2052036849,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Happy to change the names, I just needed to separate the old libevent server from the new one in the PR in the series of commits where each namespace has classes like `HTTPRequest`",
      "created_at": "2025-05-14T18:09:41Z",
      "updated_at": "2025-05-14T18:09:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2089484885",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2089484885"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2090504818",
      "pull_request_review_id": 2842608359,
      "id": 2090504818,
      "node_id": "PRRC_kwDOABII5858mpJy",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)",
      "path": "test/functional/interface_http.py",
      "position": 1,
      "original_position": 35,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "1 second timeout to send or receive seems more than enough for local testing on a dev machine. However, CI virtual machines sometimes are surprisingly slow. To avoid unnecessary test failures maybe it would be better to have this be 5 or 10 seconds for the `sendall()` calls and then set to 1 for the `recv()` call which we expect to timeout.",
      "created_at": "2025-05-15T07:41:37Z",
      "updated_at": "2025-05-15T13:57:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2090504818",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2090504818"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2090527952",
      "pull_request_review_id": 2842608359,
      "id": 2090527952,
      "node_id": "PRRC_kwDOABII5858muzQ",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res",
      "path": "test/functional/interface_http.py",
      "position": 1,
      "original_position": 43,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Shouldn't this be `assert False`? Here the expectation is that the `recv()` will throw an exception due to timeout.\r\n\r\nhttps://docs.python.org/3/library/socket.html#socket.socket.recv\r\n> A returned empty bytes object indicates that the client has disconnected.\r\n\r\nAn \"empty bytes object\" will not trigger the assert `assert not res` but if that happens (= disconnect) then the test should fail.\r\n\r\nsuggestion:\r\n```diff\r\n-            assert not res\r\n+            assert False\r\n```",
      "created_at": "2025-05-15T07:53:04Z",
      "updated_at": "2025-05-20T13:35:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2090527952",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2090527952"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2090840593",
      "pull_request_review_id": 2842608359,
      "id": 2090840593,
      "node_id": "PRRC_kwDOABII5858n7IR",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()\n+        res = sock.recv(1024)\n+        stop = time.time()\n+        assert res == b\"\"\n+        assert stop - start >= 1\n+        # definitely closed\n+        try:\n+            conn.request('GET', '/')\n+            conn.getresponse()\n+        #       macos/linux           windows\n+        except (ConnectionResetError, ConnectionAbortedError):\n+            pass",
      "path": "test/functional/interface_http.py",
      "position": 1,
      "original_position": 120,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This will also pass if no exception is thrown. Either add `assert False` after line 214 or have a boolean variable to false before the `try` and set it to true inside `except` and assert that it is true afterwards.",
      "created_at": "2025-05-15T10:21:00Z",
      "updated_at": "2025-05-15T13:57:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2090840593",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2090840593"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 211,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2090912262",
      "pull_request_review_id": 2842608359,
      "id": 2090912262,
      "node_id": "PRRC_kwDOABII5858oMoG",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]",
      "path": "test/functional/interface_http.py",
      "position": 1,
      "original_position": 72,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Is the intention here to send 8MB of data?",
      "created_at": "2025-05-15T11:02:30Z",
      "updated_at": "2025-05-15T13:57:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2090912262",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2090912262"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": 162,
      "original_start_line": 162,
      "start_side": "RIGHT",
      "line": 169,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2090917556",
      "pull_request_review_id": 2842608359,
      "id": 2090917556,
      "node_id": "PRRC_kwDOABII5858oN60",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'",
      "path": "test/functional/interface_http.py",
      "position": 1,
      "original_position": 82,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Here and elsewhere in the added tests, `assert_equal()` produces a better error message:\r\n\r\n`assert` (value of `out1` is not printed):\r\n```\r\n    assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nAssertionError\r\n```\r\n\r\nvs\r\n\r\n`assert_equal()`:\r\n```\r\nAssertionError: not(b'{\"result\":null,\"error\":{\"code\":-32700,\"message\":\"Parse error\"},\"id\":null}\\n' == b'{\"result\":\"high-hash\",\"error\":null}\\n')\r\n```",
      "created_at": "2025-05-15T11:05:49Z",
      "updated_at": "2025-05-15T13:57:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2090917556",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2090917556"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 179,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2091083332",
      "pull_request_review_id": 2842608359,
      "id": 2091083332,
      "node_id": "PRRC_kwDOABII5858o2ZE",
      "diff_hunk": "@@ -1045,6 +1052,26 @@ BOOST_AUTO_TEST_CASE(test_ParseUInt64)\n     BOOST_CHECK(!ParseUInt64(\"-1234\", &n));\n }\n \n+BOOST_AUTO_TEST_CASE(test_ParseUInt64Hex)\n+{\n+    uint64_t n;\n+    // Valid values\n+    BOOST_CHECK(ParseUInt64Hex(\"1234\", nullptr));\n+    BOOST_CHECK(ParseUInt64Hex(\"1234\", &n) && n == 4660);\n+    BOOST_CHECK(ParseUInt64Hex(\"a\", &n) && n == 10);\n+    BOOST_CHECK(ParseUInt64Hex(\"0000000a\", &n) && n == 10);\n+    BOOST_CHECK(ParseUInt64Hex(\"100\", &n) && n == 256);\n+    BOOST_CHECK(ParseUInt64Hex(\"DEADbeef\", &n) && n == 3735928559);\n+    BOOST_CHECK(ParseUInt64Hex(\"FfFfFfFf\", &n) && n == 4294967295);\n+    // Invalid values\n+    BOOST_CHECK(!ParseUInt64Hex(\"123456789\", &n));\n+    BOOST_CHECK(!ParseUInt64Hex(\"\", &n));\n+    BOOST_CHECK(!ParseUInt64Hex(\"-1\", &n));\n+    BOOST_CHECK(!ParseUInt64Hex(\"10 00\", &n));\n+    BOOST_CHECK(!ParseUInt64Hex(\"1 \", &n));\n+    BOOST_CHECK(!ParseUInt64Hex(\"0xAB\", &n));\n+}",
      "path": "src/test/util_tests.cpp",
      "position": 1,
      "original_position": 36,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Add some more test cases and avoid `BOOST_CHECK(A && B)` because when that fails it is unclear which one of `A` or `B` was false. Prefer `BOOST_CHECK(A); BOOST_CHECK(B);`. Also, because `B` is `n == 123`, do `BOOST_CHECK_EQUAL(n, 123)`:\r\n\r\n```cpp\r\nBOOST_AUTO_TEST_CASE(test_ParseUInt64Hex)\r\n{\r\n    uint64_t n;\r\n    // Valid values\r\n    BOOST_CHECK(ParseUInt64Hex(\"1234\", nullptr));\r\n    BOOST_CHECK(ParseUInt64Hex(\"1234\", &n));\r\n    BOOST_CHECK_EQUAL(n, 0x1234);\r\n    BOOST_CHECK(ParseUInt64Hex(\"a\", &n));\r\n    BOOST_CHECK_EQUAL(n, 0xA);\r\n    BOOST_CHECK(ParseUInt64Hex(\"0000000a\", &n));\r\n    BOOST_CHECK_EQUAL(n, 0xA);\r\n    BOOST_CHECK(ParseUInt64Hex(\"100\", &n));\r\n    BOOST_CHECK_EQUAL(n, 0x100);\r\n    BOOST_CHECK(ParseUInt64Hex(\"DEADbeef\", &n));\r\n    BOOST_CHECK_EQUAL(n, 0xDEADbeef);\r\n    BOOST_CHECK(ParseUInt64Hex(\"FfFfFfFf\", &n));\r\n    BOOST_CHECK_EQUAL(n, 0xFfFfFfFf);\r\n    BOOST_CHECK(ParseUInt64Hex(\"123456789\", &n));                                      \r\n    BOOST_CHECK_EQUAL(n, 0x123456789ULL);\r\n    BOOST_CHECK(ParseUInt64Hex(\"0\", &n));\r\n    BOOST_CHECK_EQUAL(n, 0);\r\n    BOOST_CHECK(ParseUInt64Hex(\"FfFfFfFfFfFfFfFf\", &n));\r\n    BOOST_CHECK_EQUAL(n, 0xFfFfFfFfFfFfFfFfULL);\r\n    // Invalid values\r\n    BOOST_CHECK(!ParseUInt64Hex(\"\", &n));\r\n    BOOST_CHECK(!ParseUInt64Hex(\"-1\", &n));\r\n    BOOST_CHECK(!ParseUInt64Hex(\"10 00\", &n));\r\n    BOOST_CHECK(!ParseUInt64Hex(\"1 \", &n));\r\n    BOOST_CHECK(!ParseUInt64Hex(\"0xAB\", &n));\r\n    BOOST_CHECK(!ParseUInt64Hex(\"FfFfFfFfFfFfFfFf0\", &n));\r\n}\r\n```",
      "created_at": "2025-05-15T12:41:18Z",
      "updated_at": "2025-05-15T13:57:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2091083332",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2091083332"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 1055,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1073,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2091093913",
      "pull_request_review_id": 2842608359,
      "id": 2091093913,
      "node_id": "PRRC_kwDOABII5858o4-Z",
      "diff_hunk": "@@ -251,6 +251,24 @@ bool ParseUInt64(std::string_view str, uint64_t* out)\n     return ParseIntegral<uint64_t>(str, out);\n }\n \n+bool ParseUInt64Hex(std::string_view str, uint64_t* out)\n+{\n+    if (str.size() > 8) return false;\n+    if (str.size() < 1) return false;\n+    uint64_t total{0};\n+    auto it = str.begin();\n+    while (it != str.end()) {\n+        auto v = HexDigit(*(it++));\n+        if (v < 0) return false;\n+        total <<= 4;\n+        total |= v;\n+    }\n+    if (out != nullptr) {\n+        *out = total;\n+    }\n+    return true;\n+}",
      "path": "src/util/strencodings.cpp",
      "position": 1,
      "original_position": 20,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This would not recognize numbers larger than `FFFFFFFF` (4 bytes, 8 chars). That should be `if (str.size() > 16) return false;` instead of `8`.\r\n\r\nBut better not roll our own and use `std::from_chars()` like the others:\r\n\r\n<details>\r\n<summary>[patch] Use ParseIntegral() which uses std::from_chars(), like the other Parse*() functions</summary>\r\n\r\n```diff\r\ndiff --git i/src/util/strencodings.cpp w/src/util/strencodings.cpp\r\nindex d923bdd121..05a5dced62 100644\r\n--- i/src/util/strencodings.cpp\r\n+++ w/src/util/strencodings.cpp\r\n@@ -199,21 +199,21 @@ std::optional<std::vector<unsigned char>> DecodeBase32(std::string_view str)\r\n \r\n     return ret;\r\n }\r\n \r\n namespace {\r\n template <typename T>\r\n-bool ParseIntegral(std::string_view str, T* out)\r\n+bool ParseIntegral(std::string_view str, T* out, size_t base = 10)\r\n {\r\n     static_assert(std::is_integral_v<T>);\r\n     // Replicate the exact behavior of strtol/strtoll/strtoul/strtoull when\r\n     // handling leading +/- for backwards compatibility.\r\n     if (str.length() >= 2 && str[0] == '+' && str[1] == '-') {\r\n         return false;\r\n     }\r\n-    const std::optional<T> opt_int = ToIntegral<T>((!str.empty() && str[0] == '+') ? str.substr(1) : str);\r\n+    const std::optional<T> opt_int = ToIntegral<T>((!str.empty() && str[0] == '+') ? str.substr(1) : str, base);\r\n     if (!opt_int) {\r\n         return false;\r\n     }\r\n     if (out != nullptr) {\r\n         *out = *opt_int;\r\n     }\r\n@@ -250,26 +250,13 @@ bool ParseUInt64(std::string_view str, uint64_t* out)\r\n {\r\n     return ParseIntegral<uint64_t>(str, out);\r\n }\r\n \r\n bool ParseUInt64Hex(std::string_view str, uint64_t* out)\r\n {\r\n-    if (str.size() > 8) return false;\r\n-    if (str.size() < 1) return false;\r\n-    uint64_t total{0};\r\n-    auto it = str.begin();\r\n-    while (it != str.end()) {\r\n-        auto v = HexDigit(*(it++));\r\n-        if (v < 0) return false;\r\n-        total <<= 4;\r\n-        total |= v;\r\n-    }\r\n-    if (out != nullptr) {\r\n-        *out = total;\r\n-    }\r\n-    return true;\r\n+    return ParseIntegral<uint64_t>(str, out, 16);\r\n }\r\n \r\n std::string FormatParagraph(std::string_view in, size_t width, size_t indent)\r\n {\r\n     assert(width >= indent);\r\n     std::stringstream out;\r\ndiff --git i/src/util/strencodings.h w/src/util/strencodings.h\r\nindex b95b21dafd..d83fa3c841 100644\r\n--- i/src/util/strencodings.h\r\n+++ w/src/util/strencodings.h\r\n@@ -173,17 +173,17 @@ constexpr inline bool IsSpace(char c) noexcept {\r\n  * is `-?[0-9]+`. The minus sign is only permitted for signed integer types.\r\n  *\r\n  * @returns std::nullopt if the entire string could not be parsed, or if the\r\n  *   parsed value is not in the range representable by the type T.\r\n  */\r\n template <typename T>\r\n-std::optional<T> ToIntegral(std::string_view str)\r\n+std::optional<T> ToIntegral(std::string_view str, size_t base = 10)\r\n {\r\n     static_assert(std::is_integral_v<T>);\r\n     T result;\r\n-    const auto [first_nonmatching, error_condition] = std::from_chars(str.data(), str.data() + str.size(), result);\r\n+    const auto [first_nonmatching, error_condition] = std::from_chars(str.data(), str.data() + str.size(), result, base);\r\n     if (first_nonmatching != str.data() + str.size() || error_condition != std::errc{}) {\r\n         return std::nullopt;\r\n     }\r\n     return result;\r\n }\r\n \r\n```",
      "created_at": "2025-05-15T12:46:52Z",
      "updated_at": "2025-05-15T13:57:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2091093913",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2091093913"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 254,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 270,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092931817",
      "pull_request_review_id": 2846448811,
      "id": 2092931817,
      "node_id": "PRRC_kwDOABII5858v5rp",
      "diff_hunk": "@@ -116,6 +119,20 @@ std::optional<int64_t> ParseISO8601DateTime(std::string_view str)\n     return int64_t{TicksSinceEpoch<std::chrono::seconds>(tp)};\n }\n \n+std::string FormatRFC7231DateTime(int64_t nTime)\n+{\n+    const std::chrono::sys_seconds secs{std::chrono::seconds{nTime}};\n+    const auto days{std::chrono::floor<std::chrono::days>(secs)};\n+    // 1970-01-01 was a Thursday\n+    std::string_view weekday{weekdays[(days.time_since_epoch().count() + 4) % 7]};",
      "path": "src/util/time.cpp",
      "position": 1,
      "original_position": 19,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Passing `-1717429609` would make this code try to access `weekdays[-1]` :fire: \r\n\r\nFor modern style, better use `std::array` instead of C arrays and, more importantly, use the array's `at()` method which has boundary checks, just in case. Here is a change that adds some more tests and fixes the out-of-bounds access:\r\n\r\n<details>\r\n<summary>[patch] FormatRFC7231DateTime()</summary>\r\n\r\n```diff\r\ndiff --git i/src/test/util_tests.cpp w/src/test/util_tests.cpp\r\nindex 387493152d..ebb40dd713 100644\r\n--- i/src/test/util_tests.cpp\r\n+++ w/src/test/util_tests.cpp\r\n@@ -384,15 +384,23 @@ BOOST_AUTO_TEST_CASE(util_FormatISO8601Date)\r\n     BOOST_CHECK_EQUAL(FormatISO8601Date(0), \"1970-01-01\");\r\n     BOOST_CHECK_EQUAL(FormatISO8601Date(1317425777), \"2011-09-30\");\r\n }\r\n \r\n BOOST_AUTO_TEST_CASE(util_FormatRFC7231DateTime)\r\n {\r\n+    BOOST_CHECK_EQUAL(FormatRFC7231DateTime(std::numeric_limits<int64_t>::max()), \"\");\r\n+    BOOST_CHECK_EQUAL(FormatRFC7231DateTime(253402300800), \"\");\r\n+    BOOST_CHECK_EQUAL(FormatRFC7231DateTime(253402300799), \"Fri, 31 Dec 9999 23:59:59 GMT\");\r\n     BOOST_CHECK_EQUAL(FormatRFC7231DateTime(253402214400), \"Fri, 31 Dec 9999 00:00:00 GMT\");\r\n     BOOST_CHECK_EQUAL(FormatRFC7231DateTime(1717429609), \"Mon, 03 Jun 2024 15:46:49 GMT\");\r\n     BOOST_CHECK_EQUAL(FormatRFC7231DateTime(0), \"Thu, 01 Jan 1970 00:00:00 GMT\");\r\n+    BOOST_CHECK_EQUAL(FormatRFC7231DateTime(-1), \"Wed, 31 Dec 1969 23:59:59 GMT\");\r\n+    BOOST_CHECK_EQUAL(FormatRFC7231DateTime(-1717429609), \"Sat, 31 Jul 1915 08:13:11 GMT\");\r\n+    BOOST_CHECK_EQUAL(FormatRFC7231DateTime(-62167219200), \"Sat, 01 Jan 0000 00:00:00 GMT\");\r\n+    BOOST_CHECK_EQUAL(FormatRFC7231DateTime(-62167219201), \"\");\r\n+    BOOST_CHECK_EQUAL(FormatRFC7231DateTime(std::numeric_limits<int64_t>::min()), \"\");\r\n }\r\n \r\n BOOST_AUTO_TEST_CASE(util_FormatMoney)\r\n {\r\n     BOOST_CHECK_EQUAL(FormatMoney(0), \"0.00\");\r\n     BOOST_CHECK_EQUAL(FormatMoney((COIN/10000)*123456789), \"12345.6789\");\r\ndiff --git i/src/util/time.cpp w/src/util/time.cpp\r\nindex 9b9167d19a..c0f375956a 100644\r\n--- i/src/util/time.cpp\r\n+++ w/src/util/time.cpp\r\n@@ -7,21 +7,22 @@\r\n \r\n #include <compat/compat.h>\r\n #include <tinyformat.h>\r\n #include <util/check.h>\r\n #include <util/strencodings.h>\r\n \r\n+#include <array>\r\n #include <atomic>\r\n #include <chrono>\r\n #include <optional>\r\n #include <string>\r\n #include <string_view>\r\n #include <thread>\r\n \r\n-static const std::string weekdays[7] = {\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"};\r\n-static const std::string months[12] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\r\n+static constexpr std::array<std::string_view, 7> weekdays{\"Thu\", \"Fri\", \"Sat\", \"Sun\", \"Mon\", \"Tue\", \"Wed\"}; // 1970-01-01 was a Thursday.\r\n+static constexpr std::array<std::string_view, 12> months{\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\r\n \r\n void UninterruptibleSleep(const std::chrono::microseconds& n) { std::this_thread::sleep_for(n); }\r\n \r\n static std::atomic<std::chrono::seconds> g_mock_time{}; //!< For testing\r\n std::atomic<bool> g_used_system_time{false};\r\n static std::atomic<std::chrono::milliseconds> g_mock_steady_time{}; //!< For testing\r\n@@ -116,20 +117,24 @@ std::optional<int64_t> ParseISO8601DateTime(std::string_view str)\r\n     }\r\n     const auto time{std::chrono::hours{*hour} + std::chrono::minutes{*min} + std::chrono::seconds{*sec}};\r\n     const auto tp{std::chrono::sys_days{ymd} + time};\r\n     return int64_t{TicksSinceEpoch<std::chrono::seconds>(tp)};\r\n }\r\n \r\n-std::string FormatRFC7231DateTime(int64_t nTime)\r\n+std::string FormatRFC7231DateTime(int64_t time)\r\n {\r\n-    const std::chrono::sys_seconds secs{std::chrono::seconds{nTime}};\r\n+    if (time < -62167219200 || 253402300799 < time) {\r\n+        // RFC7231 mandates 4-digit year, so only support years 0 to 9999\r\n+        return \"\";\r\n+    }\r\n+    const std::chrono::sys_seconds secs{std::chrono::seconds{time}};\r\n     const auto days{std::chrono::floor<std::chrono::days>(secs)};\r\n-    // 1970-01-01 was a Thursday\r\n-    std::string_view weekday{weekdays[(days.time_since_epoch().count() + 4) % 7]};\r\n+    const auto w{days.time_since_epoch().count() % 7}; // will be in the range [-6, 6]\r\n+    std::string_view weekday{weekdays.at(w >= 0 ? w : w + 7)};\r\n     const std::chrono::year_month_day ymd{days};\r\n-    std::string_view month{months[unsigned{ymd.month()} - 1]};\r\n+    std::string_view month{months.at(unsigned{ymd.month()} - 1)};\r\n     const std::chrono::hh_mm_ss hms{secs - days};\r\n     // examples: Mon, 27 Jul 2009 12:28:53 GMT\r\n     //           Fri, 31 May 2024 19:18:04 GMT\r\n     return strprintf(\"%03s, %02u %03s %04i %02i:%02i:%02i GMT\", weekday, unsigned{ymd.day()}, month, signed{ymd.year()}, hms.hours().count(), hms.minutes().count(), hms.seconds().count());\r\n }\r\n \r\n```\r\n</details>",
      "created_at": "2025-05-16T12:13:51Z",
      "updated_at": "2025-05-16T14:44:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2092931817",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092931817"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 127,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093076600",
      "pull_request_review_id": 2846448811,
      "id": 2093076600,
      "node_id": "PRRC_kwDOABII5858wdB4",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 307,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "e95c6f5b6511ae35141b1e440e1f22e1004d3de6\r\n\r\nCopying strings is expensive:\r\n\r\n```suggestion\r\nstd::optional<std::string_view> HTTPHeaders::Find(const std::string& key) const\r\n```",
      "created_at": "2025-05-16T13:40:37Z",
      "updated_at": "2025-05-16T14:44:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2093076600",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093076600"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 314,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093078641",
      "pull_request_review_id": 2846448811,
      "id": 2093078641,
      "node_id": "PRRC_kwDOABII5858wdhx",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 320,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\r\nvoid HTTPHeaders::Write(const std::string& key, const std::string& value)\r\n```",
      "created_at": "2025-05-16T13:41:41Z",
      "updated_at": "2025-05-16T14:44:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2093078641",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093078641"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 321,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093081846",
      "pull_request_review_id": 2846448811,
      "id": 2093081846,
      "node_id": "PRRC_kwDOABII5858weT2",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 336,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\r\nvoid HTTPHeaders::Remove(const std::string& key)\r\n```",
      "created_at": "2025-05-16T13:43:35Z",
      "updated_at": "2025-05-16T14:44:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2093081846",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093081846"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 332,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093181637",
      "pull_request_review_id": 2846448811,
      "id": 2093181637,
      "node_id": "PRRC_kwDOABII5858w2rF",
      "diff_hunk": "@@ -27,168 +34,309 @@ static const int DEFAULT_HTTP_WORKQUEUE=64;\n \n static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;\n \n-struct evhttp_request;\n-struct event_base;\n-class CService;\n-class HTTPRequest;\n+enum HTTPRequestMethod {\n+    UNKNOWN,\n+    GET,\n+    POST,\n+    HEAD,\n+    PUT\n+};\n \n-/** Initialize HTTP server.\n- * Call this before RegisterHTTPHandler or EventBase().\n- */\n-bool InitHTTPServer(const util::SignalInterrupt& interrupt);\n-/** Start HTTP server.\n- * This is separate from InitHTTPServer to give users race-condition-free time\n- * to register their handlers between InitHTTPServer and StartHTTPServer.\n+/** Event handler closure.\n  */\n-void StartHTTPServer();\n-/** Interrupt HTTP server threads */\n-void InterruptHTTPServer();\n-/** Stop HTTP server */\n-void StopHTTPServer();\n+class HTTPClosure\n+{\n+public:\n+    virtual void operator()() = 0;\n+    virtual ~HTTPClosure() = default;\n+};\n \n-/** Change logging level for libevent. */\n-void UpdateHTTPServerLogging(bool enable);\n+namespace http_bitcoin {\n+using util::LineReader;\n+using NodeId = SockMan::Id;\n \n-/** Handler for requests to a certain HTTP path */\n-typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n-/** Register handler for prefix.\n- * If multiple handlers match a prefix, the first-registered one will\n- * be invoked.\n- */\n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler);\n-/** Unregister handler for prefix */\n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch);\n+// shortest valid request line, used by libevent in evhttp_parse_request_line()\n+static const size_t MIN_REQUEST_LINE_LENGTH{strlen(\"GET / HTTP/1.0\")};\n+// maximum size of http request (request line + headers)\n+// see https://github.com/bitcoin/bitcoin/issues/6425\n+static const size_t MAX_HEADERS_SIZE{8192};\n \n-/** Return evhttp event base. This can be used by submodules to\n- * queue timers or custom events.\n- */\n-struct event_base* EventBase();\n+class HTTPHeaders\n+{\n+public:\n+    std::optional<std::string_view> Find(const std::string key) const;\n+    void Write(const std::string key, const std::string value);\n+    void Remove(const std::string key);\n+    bool Read(util::LineReader& reader);",
      "path": "src/httpserver.h",
      "position": 100,
      "original_position": 86,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Would be good to document when `Read()` throws, returns true and false.",
      "created_at": "2025-05-16T14:38:22Z",
      "updated_at": "2025-05-16T14:44:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2093181637",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093181637"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 83,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2094541457",
      "pull_request_review_id": 2849004885,
      "id": 2094541457,
      "node_id": "PRRC_kwDOABII58582CqR",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)",
      "path": "test/functional/interface_http.py",
      "position": 1,
      "original_position": 35,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2090504818,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I should have mentioned the initial test commits have been split off into https://github.com/bitcoin/bitcoin/pull/32408 and the test as written here failed CI, so has been modified with `rpcservertimeout=2` and then expects a timeout between 1 and 4 seconds",
      "created_at": "2025-05-18T14:27:51Z",
      "updated_at": "2025-05-18T14:27:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2094541457",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2094541457"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102323308",
      "pull_request_review_id": 2860857095,
      "id": 2102323308,
      "node_id": "PRRC_kwDOABII5859Tuhs",
      "diff_hunk": "@@ -20,6 +20,20 @@ enum HTTPStatusCode\n     HTTP_SERVICE_UNAVAILABLE   = 503,\n };\n \n+// Copied from libevent http.c success_phrases[] and client_error_phrases[]\n+// TODO: Should HTTPStatusCode and HTTPReason be moved since they are not RPC protocols?\n+const std::map<HTTPStatusCode, std::string> HTTPReason{\n+    {HTTP_OK, \"OK\"},",
      "path": "src/rpc/protocol.h",
      "position": 1,
      "original_position": 7,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> TODO: Should HTTPStatusCode and HTTPReason be moved since they are not RPC protocols?\r\n\r\nI think no because this file already contains generic HTTP constants, e.g. `HTTP_SERVICE_UNAVAILABLE = 503` above.",
      "created_at": "2025-05-22T11:24:40Z",
      "updated_at": "2025-05-22T14:57:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2102323308",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102323308"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": 20,
      "original_start_line": 20,
      "start_side": "LEFT",
      "line": 26,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102548479",
      "pull_request_review_id": 2860857095,
      "id": 2102548479,
      "node_id": "PRRC_kwDOABII5859Ulf_",
      "diff_hunk": "@@ -27,168 +34,309 @@ static const int DEFAULT_HTTP_WORKQUEUE=64;\n \n static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;\n \n-struct evhttp_request;\n-struct event_base;\n-class CService;\n-class HTTPRequest;\n+enum HTTPRequestMethod {\n+    UNKNOWN,\n+    GET,\n+    POST,\n+    HEAD,\n+    PUT\n+};\n \n-/** Initialize HTTP server.\n- * Call this before RegisterHTTPHandler or EventBase().\n- */\n-bool InitHTTPServer(const util::SignalInterrupt& interrupt);\n-/** Start HTTP server.\n- * This is separate from InitHTTPServer to give users race-condition-free time\n- * to register their handlers between InitHTTPServer and StartHTTPServer.\n+/** Event handler closure.\n  */\n-void StartHTTPServer();\n-/** Interrupt HTTP server threads */\n-void InterruptHTTPServer();\n-/** Stop HTTP server */\n-void StopHTTPServer();\n+class HTTPClosure\n+{\n+public:\n+    virtual void operator()() = 0;\n+    virtual ~HTTPClosure() = default;\n+};\n \n-/** Change logging level for libevent. */\n-void UpdateHTTPServerLogging(bool enable);\n+namespace http_bitcoin {\n+using util::LineReader;\n+using NodeId = SockMan::Id;\n \n-/** Handler for requests to a certain HTTP path */\n-typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n-/** Register handler for prefix.\n- * If multiple handlers match a prefix, the first-registered one will\n- * be invoked.\n- */\n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler);\n-/** Unregister handler for prefix */\n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch);\n+// shortest valid request line, used by libevent in evhttp_parse_request_line()\n+static const size_t MIN_REQUEST_LINE_LENGTH{strlen(\"GET / HTTP/1.0\")};\n+// maximum size of http request (request line + headers)\n+// see https://github.com/bitcoin/bitcoin/issues/6425\n+static const size_t MAX_HEADERS_SIZE{8192};\n \n-/** Return evhttp event base. This can be used by submodules to\n- * queue timers or custom events.\n- */\n-struct event_base* EventBase();\n+class HTTPHeaders\n+{\n+public:\n+    std::optional<std::string_view> Find(const std::string key) const;\n+    void Write(const std::string key, const std::string value);\n+    void Remove(const std::string key);\n+    bool Read(util::LineReader& reader);\n+    std::string Stringify() const;\n+\n+private:\n+    std::map<std::string, std::string, util::CaseInsensitiveComparator> m_map;\n+};\n+\n+class HTTPResponse\n+{\n+public:\n+    int m_version_major;\n+    int m_version_minor;\n+    HTTPStatusCode m_status;\n+    std::string m_reason;\n+    HTTPHeaders m_headers;\n+    std::vector<std::byte> m_body;\n+    bool m_keep_alive{false};\n+\n+    std::string StringifyHeaders() const;\n+};\n+\n+class HTTPClient;\n \n-/** In-flight HTTP request.\n- * Thin C++ wrapper around evhttp_request.\n- */\n class HTTPRequest\n {\n-private:\n-    struct evhttp_request* req;\n-    const util::SignalInterrupt& m_interrupt;\n-    bool replySent;\n+public:\n+    std::string m_method;",
      "path": "src/httpserver.h",
      "position": 1,
      "original_position": 119,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Maybe enum is better for this?",
      "created_at": "2025-05-22T13:20:53Z",
      "updated_at": "2025-05-22T14:57:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2102548479",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102548479"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 96,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102608338",
      "pull_request_review_id": 2860857095,
      "id": 2102608338,
      "node_id": "PRRC_kwDOABII5859U0HS",
      "diff_hunk": "@@ -35,8 +101,341 @@ BOOST_AUTO_TEST_CASE(test_query_parameters)\n     uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2\";\n     BOOST_CHECK(!GetQueryParameterFromUri(uri.c_str(), \"p1\").has_value());\n \n-    // URI with invalid characters (%) raises a runtime error regardless of which query parameter is queried\n-    uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2%\";\n-    BOOST_CHECK_EXCEPTION(GetQueryParameterFromUri(uri.c_str(), \"p1\"), std::runtime_error, HasReason(\"URI parsing failed, it likely contained RFC 3986 invalid characters\"));\n+    // Multiple parameters, some characters encoded\n+    uri = \"/rest/endpoint/someresource.json?p1=v1%20&p2=100%25\";\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p1\").value(), \"v1 \");\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p2\").value(), \"100%\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_query_parameters_bitcoin)\n+{\n+    test_query_parameters(http_bitcoin::GetQueryParameterFromUri);\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_headers_tests)\n+{\n+    {\n+        // Writing response headers\n+        HTTPHeaders headers{};\n+        BOOST_CHECK(!headers.Find(\"Cache-Control\"));\n+        headers.Write(\"Cache-Control\", \"no-cache\");\n+        // Check case-insensitive key matching\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"cache-control\").value(), \"no-cache\");\n+        // Additional values are comma-separated and appended\n+        headers.Write(\"Cache-Control\", \"no-store\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache, no-store\");\n+        // Add a few more\n+        headers.Write(\"Pie\", \"apple\");\n+        headers.Write(\"Sandwich\", \"ham\");\n+        headers.Write(\"Coffee\", \"black\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Pie\").value(), \"apple\");\n+        // Remove\n+        headers.Remove(\"Pie\");\n+        BOOST_CHECK(!headers.Find(\"Pie\"));\n+        // Combine for transmission\n+        // std::map sorts alphabetically by key, no order is specified for HTTP\n+        BOOST_CHECK_EQUAL(\n+            headers.Stringify(),\n+            \"Cache-Control: no-cache, no-store\\r\\n\"\n+            \"Coffee: black\\r\\n\"\n+            \"Sandwich: ham\\r\\n\\r\\n\");\n+    }\n+    {\n+        // Reading request headers captured from bitcoin-cli\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(\n+            \"486f73743a203132372e302e302e310d0a436f6e6e656374696f6e3a20636c6f73\"\n+            \"650d0a436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e\"\n+            \"0d0a417574686f72697a6174696f6e3a204261736963205831396a623239726157\"\n+            \"5666587a6f7a597a4a6b4e5441784e44466c4d474a69596d56684d5449354f4467\"\n+            \"334e7a49354d544d334e54526d4e54686b4e6a63324f574d775a5459785a6a677a\"\n+            \"4e5467794e7a4577595459314f47526b596a566d5a4751330d0a436f6e74656e74\"\n+            \"2d4c656e6774683a2034360d0a0d0a\").value()};\n+        util::LineReader reader(buffer, /*max_read=*/1028);\n+        HTTPHeaders headers{};\n+        headers.Read(reader);\n+        BOOST_CHECK_EQUAL(headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzozYzJkNTAxNDFlMGJiYmVhMTI5ODg3NzI5MTM3NTRmNThkNjc2OWMwZTYxZjgzNTgyNzEwYTY1OGRkYjVmZGQ3\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK(!headers.Find(\"Pizza\"));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_response_tests)\n+{\n+    // Typical HTTP 1.1 response headers\n+    HTTPHeaders headers{};\n+    headers.Write(\"Content-Type\", \"application/json\");\n+    headers.Write(\"Date\", \"Tue, 15 Oct 2024 17:54:12 GMT\");\n+    headers.Write(\"Content-Length\", \"41\");\n+    // Response points to headers which already exist because some of them\n+    // are set before we even know what the response will be.\n+    HTTPResponse res;\n+    res.m_version_major = 1;\n+    res.m_version_minor = 1;\n+    res.m_status = HTTP_OK;\n+    res.m_reason = HTTPReason.find(res.m_status)->second;\n+    res.m_body = StringToBuffer(\"{\\\"result\\\":865793,\\\"error\\\":null,\\\"id\\\":null\\\"}\");\n+    // Everything except the body, which might be raw bytes instead of a string\n+    res.m_headers = std::move(headers);\n+    BOOST_CHECK_EQUAL(\n+        res.StringifyHeaders(),\n+        \"HTTP/1.1 200 OK\\r\\n\"\n+        \"Content-Length: 41\\r\\n\"\n+        \"Content-Type: application/json\\r\\n\"\n+        \"Date: Tue, 15 Oct 2024 17:54:12 GMT\\r\\n\"\n+        \"\\r\\n\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_request_tests)\n+{\n+    {\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(full_request).value()};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"POST\");\n+        BOOST_CHECK_EQUAL(req.GetRequestMethod(), HTTPRequestMethod::POST);\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.GetURI(), \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 1);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzo5OGQ5ODQ3MWNmNjg0NzAzYTkzN2EzNzk0ZDFlODQ1NjZmYTRkZjJiMzFkYjhhODI4ZGY4MjVjOTg5ZGI4OTVl\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 46);\n+        BOOST_CHECK_EQUAL(req.m_body, \"{\\\"method\\\":\\\"getblockcount\\\",\\\"params\\\":[],\\\"id\\\":1}\\n\");\n+    }\n+    {\n+        const std::string too_short_request_line = \"GET/HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(too_short_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP / 1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/11\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/1.x\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string ok_request_line = \"GET / HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(ok_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"GET\");\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 0);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        // no body is OK\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string malformed_headers = \"GET / HTTP/1.0\\r\\nHost=127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK_THROW(req.LoadHeaders(reader), std::runtime_error);\n+    }\n+    {\n+        // We might not have received enough data from the client which is not\n+        // an error. We return false so the caller can try again later when the\n+        // buffer has more data.\n+        const std::string incomplete_headers = \"GET / HTTP/1.0\\r\\nHost: \";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(incomplete_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(!req.LoadHeaders(reader));\n+    }\n+    {\n+        const std::string no_content_length = \"GET / HTTP/1.0\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(no_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        // Don't try to read request body if Content-Length is missing\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string bad_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: eleven\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(bad_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK_THROW(req.LoadBody(reader), std::runtime_error);",
      "path": "src/test/httpserver_tests.cpp",
      "position": 1,
      "original_position": 289,
      "commit_id": "3002fbe0d97243d3534a53240d5574d0d4194bba",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It is fine as it is. I am just wondering if it is not more appropriate for `LoadHeaders()` to `throw` instead of succeeding because the header `Content-Length: eleven` is already not according to the spec: https://httpwg.org/specs/rfc9110.html#field.content-length:\r\n\r\n> [Content-Length](https://httpwg.org/specs/rfc9110.html#field.content-length) = 1*[DIGIT](https://httpwg.org/specs/rfc9110.html#core.rules)",
      "created_at": "2025-05-22T13:45:48Z",
      "updated_at": "2025-05-22T14:57:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2102608338",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102608338"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 297,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 303,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102677611",
      "pull_request_review_id": 2860857095,
      "id": 2102677611,
      "node_id": "PRRC_kwDOABII5859VFBr",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {\n+        // Transfer-Encoding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-3.3.1\n+        // Chunked Transfer Coding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-4.1\n+        // see evhttp_handle_chunked_read() in libevent http.c\n+        while (reader.Left() > 0) {\n+            auto maybe_chunk_size = reader.ReadLine();\n+            if (!maybe_chunk_size) return false;\n+            uint64_t chunk_size;\n+\n+            if (!ParseUInt64Hex(maybe_chunk_size.value(), &chunk_size)) throw std::runtime_error(\"Invalid chunk size\");\n+\n+            bool last_chunk{chunk_size == 0};\n+\n+            if (!last_chunk) {\n+                // We are still expecting more data for this chunk\n+                if (reader.Left() < chunk_size) {\n+                    return false;\n+                }\n+                // Pack chunk onto body\n+                m_body += reader.ReadLength(chunk_size);\n+            }\n+\n+            // Even though every chunk size is explicitly declared,\n+            // they are still terminated by a CRLF we don't need.\n+            auto crlf = reader.ReadLine();\n+            if (!crlf || crlf.value().size() != 0) throw std::runtime_error(\"Improperly terminated chunk\");\n+\n+            if (last_chunk) return true;\n+        }\n+\n+        // We read all the chunks but never got the last chunk, wait for client to send more\n+        return false;\n     } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+        // No Content-length or Transfer-Encoding header means no body, see libevent evhttp_get_body()\n+        auto content_length_value{m_headers.Find(\"Content-Length\")};\n+        if (!content_length_value) return true;\n+\n+        uint64_t content_length;\n+        if (!ParseUInt64(content_length_value.value(), &content_length)) throw std::runtime_error(\"Cannot parse Content-Length value\");\n+\n+        // Not enough data in buffer for expected body\n+        if (reader.Left() < content_length) return false;\n+\n+        m_body = reader.ReadLength(content_length);",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 492,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "If the body comes in pieces, then this parsing will be repeated for every piece and the `return` on line 460 will be executed a few times until enough data is received. This is suboptimal - to parse the same thing multiple times. I guess it is fine because we are not building a top performance HTTP server.\r\n\r\nIf this becomes an issue at some point, then it would be better to remember that it has been parsed until e.g. byte 456 and only continue parsing from there as new data is received over the socket. I guess this will complicate the current implementation significantly.",
      "created_at": "2025-05-22T14:13:23Z",
      "updated_at": "2025-05-22T14:57:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2102677611",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102677611"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 453,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 462,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102764352",
      "pull_request_review_id": 2860857095,
      "id": 2102764352,
      "node_id": "PRRC_kwDOABII5859VaNA",
      "diff_hunk": "@@ -35,8 +101,341 @@ BOOST_AUTO_TEST_CASE(test_query_parameters)\n     uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2\";\n     BOOST_CHECK(!GetQueryParameterFromUri(uri.c_str(), \"p1\").has_value());\n \n-    // URI with invalid characters (%) raises a runtime error regardless of which query parameter is queried\n-    uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2%\";\n-    BOOST_CHECK_EXCEPTION(GetQueryParameterFromUri(uri.c_str(), \"p1\"), std::runtime_error, HasReason(\"URI parsing failed, it likely contained RFC 3986 invalid characters\"));\n+    // Multiple parameters, some characters encoded\n+    uri = \"/rest/endpoint/someresource.json?p1=v1%20&p2=100%25\";\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p1\").value(), \"v1 \");\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p2\").value(), \"100%\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_query_parameters_bitcoin)\n+{\n+    test_query_parameters(http_bitcoin::GetQueryParameterFromUri);\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_headers_tests)\n+{\n+    {\n+        // Writing response headers\n+        HTTPHeaders headers{};\n+        BOOST_CHECK(!headers.Find(\"Cache-Control\"));\n+        headers.Write(\"Cache-Control\", \"no-cache\");\n+        // Check case-insensitive key matching\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"cache-control\").value(), \"no-cache\");\n+        // Additional values are comma-separated and appended\n+        headers.Write(\"Cache-Control\", \"no-store\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache, no-store\");\n+        // Add a few more\n+        headers.Write(\"Pie\", \"apple\");\n+        headers.Write(\"Sandwich\", \"ham\");\n+        headers.Write(\"Coffee\", \"black\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Pie\").value(), \"apple\");\n+        // Remove\n+        headers.Remove(\"Pie\");\n+        BOOST_CHECK(!headers.Find(\"Pie\"));\n+        // Combine for transmission\n+        // std::map sorts alphabetically by key, no order is specified for HTTP\n+        BOOST_CHECK_EQUAL(\n+            headers.Stringify(),\n+            \"Cache-Control: no-cache, no-store\\r\\n\"\n+            \"Coffee: black\\r\\n\"\n+            \"Sandwich: ham\\r\\n\\r\\n\");\n+    }\n+    {\n+        // Reading request headers captured from bitcoin-cli\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(\n+            \"486f73743a203132372e302e302e310d0a436f6e6e656374696f6e3a20636c6f73\"\n+            \"650d0a436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e\"\n+            \"0d0a417574686f72697a6174696f6e3a204261736963205831396a623239726157\"\n+            \"5666587a6f7a597a4a6b4e5441784e44466c4d474a69596d56684d5449354f4467\"\n+            \"334e7a49354d544d334e54526d4e54686b4e6a63324f574d775a5459785a6a677a\"\n+            \"4e5467794e7a4577595459314f47526b596a566d5a4751330d0a436f6e74656e74\"\n+            \"2d4c656e6774683a2034360d0a0d0a\").value()};\n+        util::LineReader reader(buffer, /*max_read=*/1028);\n+        HTTPHeaders headers{};\n+        headers.Read(reader);\n+        BOOST_CHECK_EQUAL(headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzozYzJkNTAxNDFlMGJiYmVhMTI5ODg3NzI5MTM3NTRmNThkNjc2OWMwZTYxZjgzNTgyNzEwYTY1OGRkYjVmZGQ3\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK(!headers.Find(\"Pizza\"));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_response_tests)\n+{\n+    // Typical HTTP 1.1 response headers\n+    HTTPHeaders headers{};\n+    headers.Write(\"Content-Type\", \"application/json\");\n+    headers.Write(\"Date\", \"Tue, 15 Oct 2024 17:54:12 GMT\");\n+    headers.Write(\"Content-Length\", \"41\");\n+    // Response points to headers which already exist because some of them\n+    // are set before we even know what the response will be.\n+    HTTPResponse res;\n+    res.m_version_major = 1;\n+    res.m_version_minor = 1;\n+    res.m_status = HTTP_OK;\n+    res.m_reason = HTTPReason.find(res.m_status)->second;\n+    res.m_body = StringToBuffer(\"{\\\"result\\\":865793,\\\"error\\\":null,\\\"id\\\":null\\\"}\");\n+    // Everything except the body, which might be raw bytes instead of a string\n+    res.m_headers = std::move(headers);\n+    BOOST_CHECK_EQUAL(\n+        res.StringifyHeaders(),\n+        \"HTTP/1.1 200 OK\\r\\n\"\n+        \"Content-Length: 41\\r\\n\"\n+        \"Content-Type: application/json\\r\\n\"\n+        \"Date: Tue, 15 Oct 2024 17:54:12 GMT\\r\\n\"\n+        \"\\r\\n\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_request_tests)\n+{\n+    {\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(full_request).value()};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"POST\");\n+        BOOST_CHECK_EQUAL(req.GetRequestMethod(), HTTPRequestMethod::POST);\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.GetURI(), \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 1);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzo5OGQ5ODQ3MWNmNjg0NzAzYTkzN2EzNzk0ZDFlODQ1NjZmYTRkZjJiMzFkYjhhODI4ZGY4MjVjOTg5ZGI4OTVl\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 46);\n+        BOOST_CHECK_EQUAL(req.m_body, \"{\\\"method\\\":\\\"getblockcount\\\",\\\"params\\\":[],\\\"id\\\":1}\\n\");\n+    }\n+    {\n+        const std::string too_short_request_line = \"GET/HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(too_short_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP / 1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/11\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/1.x\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string ok_request_line = \"GET / HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(ok_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"GET\");\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 0);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        // no body is OK\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string malformed_headers = \"GET / HTTP/1.0\\r\\nHost=127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK_THROW(req.LoadHeaders(reader), std::runtime_error);\n+    }\n+    {\n+        // We might not have received enough data from the client which is not\n+        // an error. We return false so the caller can try again later when the\n+        // buffer has more data.\n+        const std::string incomplete_headers = \"GET / HTTP/1.0\\r\\nHost: \";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(incomplete_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(!req.LoadHeaders(reader));\n+    }\n+    {\n+        const std::string no_content_length = \"GET / HTTP/1.0\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(no_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        // Don't try to read request body if Content-Length is missing\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string bad_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: eleven\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(bad_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK_THROW(req.LoadBody(reader), std::runtime_error);\n+    }\n+    {\n+        // Content-Length indicates more data than we have in the buffer.\n+        // Again, not an error just try again later.\n+        const std::string excessive_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: 1024\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(excessive_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(!req.LoadBody(reader));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_client_server_tests)\n+{\n+    // Hard code the timestamp for the Date header in the HTTP response\n+    // Wed Dec 11 00:47:09 2024 UTC\n+    SetMockTime(1733878029);\n+\n+    // Queue of connected sockets returned by listening socket (represents network interface)\n+    std::shared_ptr<DynSock::Queue> accepted_sockets{std::make_shared<DynSock::Queue>()};\n+\n+    CreateSock = [&accepted_sockets](int, int, int) {\n+        // This is a mock Listening Socket that the HTTP server will \"bind\" to and\n+        // listen to for incoming connections. We won't need to access its I/O\n+        // pipes because we don't read or write directly to it. It will return\n+        // Connected Sockets from the queue via its Accept() method.\n+        return std::make_unique<DynSock>(std::make_shared<DynSock::Pipes>(), accepted_sockets);\n+    };\n+\n+    {\n+        // I/O pipes of one mock Connected Socket we can read and write to.\n+        std::shared_ptr<DynSock::Pipes> connected_socket_pipes(std::make_shared<DynSock::Pipes>());\n+\n+        // Insert the payload: a correctly formatted HTTP request\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(full_request).value()};\n+        connected_socket_pipes->recv.PushBytes(buffer.data(), buffer.size());\n+\n+        // Mock Connected Socket that represents a client.\n+        // It needs I/O pipes but its queue can remain empty\n+        std::unique_ptr<DynSock> connected_socket{std::make_unique<DynSock>(connected_socket_pipes, std::make_shared<DynSock::Queue>())};\n+\n+        // Prepare queue of accepted_sockets: just one connection with no data\n+        accepted_sockets->Push(std::move(connected_socket));\n+\n+        // Prepare a request handler that just stores received requests so we can examine them\n+        // Mutex is required to prevent a race between this test's main thread and the Sockman I/O loop.\n+        Mutex requests_mutex;\n+        std::deque<std::unique_ptr<HTTPRequest>> requests;",
      "path": "src/test/httpserver_tests.cpp",
      "position": 1,
      "original_position": 339,
      "commit_id": "8c81bdf2532aa1c61e25d367a480ce3aa71362ca",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\r\n        Mutex requests_mutex;\r\n        std::deque<std::unique_ptr<HTTPRequest>> requests GUARDED_BY(requests_mutex);\r\n```",
      "created_at": "2025-05-22T14:50:53Z",
      "updated_at": "2025-05-22T14:57:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2102764352",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102764352"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 352,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 353,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102772840",
      "pull_request_review_id": 2860857095,
      "id": 2102772840,
      "node_id": "PRRC_kwDOABII5859VcRo",
      "diff_hunk": "@@ -35,8 +101,341 @@ BOOST_AUTO_TEST_CASE(test_query_parameters)\n     uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2\";\n     BOOST_CHECK(!GetQueryParameterFromUri(uri.c_str(), \"p1\").has_value());\n \n-    // URI with invalid characters (%) raises a runtime error regardless of which query parameter is queried\n-    uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2%\";\n-    BOOST_CHECK_EXCEPTION(GetQueryParameterFromUri(uri.c_str(), \"p1\"), std::runtime_error, HasReason(\"URI parsing failed, it likely contained RFC 3986 invalid characters\"));\n+    // Multiple parameters, some characters encoded\n+    uri = \"/rest/endpoint/someresource.json?p1=v1%20&p2=100%25\";\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p1\").value(), \"v1 \");\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p2\").value(), \"100%\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_query_parameters_bitcoin)\n+{\n+    test_query_parameters(http_bitcoin::GetQueryParameterFromUri);\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_headers_tests)\n+{\n+    {\n+        // Writing response headers\n+        HTTPHeaders headers{};\n+        BOOST_CHECK(!headers.Find(\"Cache-Control\"));\n+        headers.Write(\"Cache-Control\", \"no-cache\");\n+        // Check case-insensitive key matching\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"cache-control\").value(), \"no-cache\");\n+        // Additional values are comma-separated and appended\n+        headers.Write(\"Cache-Control\", \"no-store\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache, no-store\");\n+        // Add a few more\n+        headers.Write(\"Pie\", \"apple\");\n+        headers.Write(\"Sandwich\", \"ham\");\n+        headers.Write(\"Coffee\", \"black\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Pie\").value(), \"apple\");\n+        // Remove\n+        headers.Remove(\"Pie\");\n+        BOOST_CHECK(!headers.Find(\"Pie\"));\n+        // Combine for transmission\n+        // std::map sorts alphabetically by key, no order is specified for HTTP\n+        BOOST_CHECK_EQUAL(\n+            headers.Stringify(),\n+            \"Cache-Control: no-cache, no-store\\r\\n\"\n+            \"Coffee: black\\r\\n\"\n+            \"Sandwich: ham\\r\\n\\r\\n\");\n+    }\n+    {\n+        // Reading request headers captured from bitcoin-cli\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(\n+            \"486f73743a203132372e302e302e310d0a436f6e6e656374696f6e3a20636c6f73\"\n+            \"650d0a436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e\"\n+            \"0d0a417574686f72697a6174696f6e3a204261736963205831396a623239726157\"\n+            \"5666587a6f7a597a4a6b4e5441784e44466c4d474a69596d56684d5449354f4467\"\n+            \"334e7a49354d544d334e54526d4e54686b4e6a63324f574d775a5459785a6a677a\"\n+            \"4e5467794e7a4577595459314f47526b596a566d5a4751330d0a436f6e74656e74\"\n+            \"2d4c656e6774683a2034360d0a0d0a\").value()};\n+        util::LineReader reader(buffer, /*max_read=*/1028);\n+        HTTPHeaders headers{};\n+        headers.Read(reader);\n+        BOOST_CHECK_EQUAL(headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzozYzJkNTAxNDFlMGJiYmVhMTI5ODg3NzI5MTM3NTRmNThkNjc2OWMwZTYxZjgzNTgyNzEwYTY1OGRkYjVmZGQ3\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK(!headers.Find(\"Pizza\"));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_response_tests)\n+{\n+    // Typical HTTP 1.1 response headers\n+    HTTPHeaders headers{};\n+    headers.Write(\"Content-Type\", \"application/json\");\n+    headers.Write(\"Date\", \"Tue, 15 Oct 2024 17:54:12 GMT\");\n+    headers.Write(\"Content-Length\", \"41\");\n+    // Response points to headers which already exist because some of them\n+    // are set before we even know what the response will be.\n+    HTTPResponse res;\n+    res.m_version_major = 1;\n+    res.m_version_minor = 1;\n+    res.m_status = HTTP_OK;\n+    res.m_reason = HTTPReason.find(res.m_status)->second;\n+    res.m_body = StringToBuffer(\"{\\\"result\\\":865793,\\\"error\\\":null,\\\"id\\\":null\\\"}\");\n+    // Everything except the body, which might be raw bytes instead of a string\n+    res.m_headers = std::move(headers);\n+    BOOST_CHECK_EQUAL(\n+        res.StringifyHeaders(),\n+        \"HTTP/1.1 200 OK\\r\\n\"\n+        \"Content-Length: 41\\r\\n\"\n+        \"Content-Type: application/json\\r\\n\"\n+        \"Date: Tue, 15 Oct 2024 17:54:12 GMT\\r\\n\"\n+        \"\\r\\n\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_request_tests)\n+{\n+    {\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(full_request).value()};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"POST\");\n+        BOOST_CHECK_EQUAL(req.GetRequestMethod(), HTTPRequestMethod::POST);\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.GetURI(), \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 1);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzo5OGQ5ODQ3MWNmNjg0NzAzYTkzN2EzNzk0ZDFlODQ1NjZmYTRkZjJiMzFkYjhhODI4ZGY4MjVjOTg5ZGI4OTVl\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 46);\n+        BOOST_CHECK_EQUAL(req.m_body, \"{\\\"method\\\":\\\"getblockcount\\\",\\\"params\\\":[],\\\"id\\\":1}\\n\");\n+    }\n+    {\n+        const std::string too_short_request_line = \"GET/HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(too_short_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP / 1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/11\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/1.x\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string ok_request_line = \"GET / HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(ok_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"GET\");\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 0);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        // no body is OK\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string malformed_headers = \"GET / HTTP/1.0\\r\\nHost=127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK_THROW(req.LoadHeaders(reader), std::runtime_error);\n+    }\n+    {\n+        // We might not have received enough data from the client which is not\n+        // an error. We return false so the caller can try again later when the\n+        // buffer has more data.\n+        const std::string incomplete_headers = \"GET / HTTP/1.0\\r\\nHost: \";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(incomplete_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(!req.LoadHeaders(reader));\n+    }\n+    {\n+        const std::string no_content_length = \"GET / HTTP/1.0\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(no_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        // Don't try to read request body if Content-Length is missing\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string bad_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: eleven\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(bad_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK_THROW(req.LoadBody(reader), std::runtime_error);\n+    }\n+    {\n+        // Content-Length indicates more data than we have in the buffer.\n+        // Again, not an error just try again later.\n+        const std::string excessive_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: 1024\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(excessive_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(!req.LoadBody(reader));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_client_server_tests)\n+{\n+    // Hard code the timestamp for the Date header in the HTTP response\n+    // Wed Dec 11 00:47:09 2024 UTC\n+    SetMockTime(1733878029);\n+\n+    // Queue of connected sockets returned by listening socket (represents network interface)\n+    std::shared_ptr<DynSock::Queue> accepted_sockets{std::make_shared<DynSock::Queue>()};\n+\n+    CreateSock = [&accepted_sockets](int, int, int) {\n+        // This is a mock Listening Socket that the HTTP server will \"bind\" to and\n+        // listen to for incoming connections. We won't need to access its I/O\n+        // pipes because we don't read or write directly to it. It will return\n+        // Connected Sockets from the queue via its Accept() method.\n+        return std::make_unique<DynSock>(std::make_shared<DynSock::Pipes>(), accepted_sockets);\n+    };\n+\n+    {\n+        // I/O pipes of one mock Connected Socket we can read and write to.\n+        std::shared_ptr<DynSock::Pipes> connected_socket_pipes(std::make_shared<DynSock::Pipes>());\n+\n+        // Insert the payload: a correctly formatted HTTP request\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(full_request).value()};\n+        connected_socket_pipes->recv.PushBytes(buffer.data(), buffer.size());\n+\n+        // Mock Connected Socket that represents a client.\n+        // It needs I/O pipes but its queue can remain empty\n+        std::unique_ptr<DynSock> connected_socket{std::make_unique<DynSock>(connected_socket_pipes, std::make_shared<DynSock::Queue>())};\n+\n+        // Prepare queue of accepted_sockets: just one connection with no data\n+        accepted_sockets->Push(std::move(connected_socket));\n+\n+        // Prepare a request handler that just stores received requests so we can examine them\n+        // Mutex is required to prevent a race between this test's main thread and the Sockman I/O loop.\n+        Mutex requests_mutex;\n+        std::deque<std::unique_ptr<HTTPRequest>> requests;\n+        auto StoreRequest = [&](std::unique_ptr<HTTPRequest> req) {",
      "path": "src/test/httpserver_tests.cpp",
      "position": 1,
      "original_position": 340,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Passing `unique_ptr` by value looks a bit strange since it is not supposed to be copied. I guess this works when the caller `std::move`s the object, but isn't it more clear to use `std::unique_ptr<HTTPRequest>&& req`?",
      "created_at": "2025-05-22T14:54:49Z",
      "updated_at": "2025-05-22T14:57:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2102772840",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102772840"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128494930",
      "pull_request_review_id": 2899730748,
      "id": 2128494930,
      "node_id": "PRRC_kwDOABII585-3kFS",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {",
      "path": "src/httpserver.cpp",
      "position": 478,
      "original_position": 448,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Would be good to have tests to exercise the chunked transfer encoding from d7778f426c `http: support \"chunked\" Transfer-Encoding`.",
      "created_at": "2025-06-05T10:18:53Z",
      "updated_at": "2025-06-05T14:02:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2128494930",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128494930"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 385,
      "original_line": 419,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128594514",
      "pull_request_review_id": 2899730748,
      "id": 2128594514,
      "node_id": "PRRC_kwDOABII585-38ZS",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {\n+        // Transfer-Encoding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-3.3.1\n+        // Chunked Transfer Coding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-4.1\n+        // see evhttp_handle_chunked_read() in libevent http.c\n+        while (reader.Left() > 0) {\n+            auto maybe_chunk_size = reader.ReadLine();\n+            if (!maybe_chunk_size) return false;\n+            uint64_t chunk_size;\n+\n+            if (!ParseUInt64Hex(maybe_chunk_size.value(), &chunk_size)) throw std::runtime_error(\"Invalid chunk size\");\n+\n+            bool last_chunk{chunk_size == 0};\n+\n+            if (!last_chunk) {\n+                // We are still expecting more data for this chunk\n+                if (reader.Left() < chunk_size) {\n+                    return false;\n+                }\n+                // Pack chunk onto body\n+                m_body += reader.ReadLength(chunk_size);\n+            }\n+\n+            // Even though every chunk size is explicitly declared,\n+            // they are still terminated by a CRLF we don't need.\n+            auto crlf = reader.ReadLine();\n+            if (!crlf || crlf.value().size() != 0) throw std::runtime_error(\"Improperly terminated chunk\");\n+\n+            if (last_chunk) return true;\n+        }\n+\n+        // We read all the chunks but never got the last chunk, wait for client to send more\n+        return false;\n     } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+        // No Content-length or Transfer-Encoding header means no body, see libevent evhttp_get_body()\n+        auto content_length_value{m_headers.Find(\"Content-Length\")};\n+        if (!content_length_value) return true;\n+\n+        uint64_t content_length;\n+        if (!ParseUInt64(content_length_value.value(), &content_length)) throw std::runtime_error(\"Cannot parse Content-Length value\");\n+\n+        // Not enough data in buffer for expected body\n+        if (reader.Left() < content_length) return false;\n+\n+        m_body = reader.ReadLength(content_length);\n+\n+        return true;\n     }\n }\n \n-static std::thread g_thread_http;\n-static std::vector<std::thread> g_thread_http_workers;\n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n \n-void StartHTTPServer()\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n {\n-    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n-    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n-    g_thread_http = std::thread(ThreadHTTP, eventBase);\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n \n-    for (int i = 0; i < rpcThreads; i++) {\n-        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string_view query{decoded_uri.data() + start + 1, end - start - 1};\n+    // find requested parameter in query\n+    const std::vector<std::string_view> params{Split<std::string_view>(query, \"&\")};\n+    for (const std::string_view& param : params) {\n+        size_t delim = param.find('=');\n+        if (key == param.substr(0, delim)) {\n+            if (delim == std::string::npos) {\n+                return \"\";\n+            } else {\n+                return std::string(param.substr(delim + 1));\n+            }\n+        }\n     }\n+    return std::nullopt;\n }\n \n-void InterruptHTTPServer()\n+std::pair<bool, std::string_view> HTTPRequest::GetHeader(const std::string& hdr) const\n {\n-    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n-    if (eventHTTP) {\n-        // Reject requests on current connections\n-        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n-    }\n-    if (g_work_queue) {\n-        g_work_queue->Interrupt();\n-    }\n+    std::optional<std::string_view> found{m_headers.Find(hdr)};\n+    if (found.has_value()) {\n+        return std::make_pair(true, found.value());\n+    } else\n+        return std::make_pair(false, \"\");\n }\n \n-void StopHTTPServer()\n+void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n {\n-    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n-    if (g_work_queue) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n-        for (auto& thread : g_thread_http_workers) {\n-            thread.join();\n+    m_response_headers.Write(hdr, value);\n+}\n+\n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n         }\n-        g_thread_http_workers.clear();\n     }\n-    // Unlisten sockets, these are what make the event loop running, which means\n-    // that after this and all connections are closed the event loop will quit.\n-    for (evhttp_bound_socket *socket : boundSockets) {\n-        evhttp_del_accept_socket(eventHTTP, socket);\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n     }\n-    boundSockets.clear();\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    m_client->m_keep_alive = res.m_keep_alive;\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    bool send_buffer_was_empty{false};\n+    // Fill the send buffer with the complete serialized response headers + body\n     {\n-        if (const auto n_connections{g_requests.CountActiveConnections()}; n_connections != 0) {\n-            LogDebug(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections);\n-        }\n-        g_requests.WaitUntilEmpty();\n-    }\n-    if (eventHTTP) {\n-        // Schedule a callback to call evhttp_free in the event base thread, so\n-        // that evhttp_free does not need to be called again after the handling\n-        // of unfinished request connections that follows.\n-        event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {\n-            evhttp_free(eventHTTP);\n-            eventHTTP = nullptr;\n-        }, nullptr, nullptr);\n-    }\n-    if (eventBase) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n-        if (g_thread_http.joinable()) g_thread_http.join();\n-        event_base_free(eventBase);\n-        eventBase = nullptr;\n-    }\n-    g_work_queue.reset();\n-    LogDebug(BCLog::HTTP, \"Stopped HTTP server\\n\");\n-}\n+        LOCK(m_client->m_send_mutex);\n+        send_buffer_was_empty = m_client->m_send_buffer.empty();\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());\n+    }\n+\n+    LogDebug(\n+        BCLog::HTTP,\n+        \"HTTPResponse (status code: %d size: %lld) added to send buffer for client %s (id=%lld)\\n\",\n+        status,\n+        headers_bytes.size() + reply_body.size(),\n+        m_client->m_origin,\n+        m_client->m_node_id);\n+\n+    // If the send buffer was empty before we wrote this reply, we can try an\n+    // optimistic send akin to CConnman::PushMessage() in which we\n+    // push the data directly out the socket to client right now, instead\n+    // of waiting for the next iteration of the Sockman I/O loop.\n+    if (send_buffer_was_empty) {\n+        m_client->SendBytesFromBuffer();\n+    } else {\n+        // Inform Sockman I/O there is data that is ready to be sent to this client\n+        // in the next loop iteration.\n+        m_client->m_send_ready = true;\n+    }\n \n-struct event_base* EventBase()\n-{\n-    return eventBase;\n+    // Signal to the Sockman I/O loop that we are ready to handle the next request.\n+    m_client->m_req_busy = false;\n }\n \n-static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n+bool HTTPClient::ReadRequest(std::unique_ptr<HTTPRequest>& req)\n {\n-    // Static handler: simply call inner handler\n-    HTTPEvent *self = static_cast<HTTPEvent*>(data);\n-    self->handler();\n-    if (self->deleteWhenTriggered)\n-        delete self;\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(\n+        m_recv_buffer.begin(),\n+        m_recv_buffer.begin() + (reader.it - reader.start));\n+\n+    return true;\n }\n \n-HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):\n-    deleteWhenTriggered(_deleteWhenTriggered), handler(_handler)\n-{\n-    ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n-    assert(ev);\n+bool HTTPClient::SendBytesFromBuffer()\n+{\n+    Assume(m_server);\n+\n+    // Send as much data from this client's buffer as we can\n+    LOCK(m_send_mutex);\n+    if (!m_send_buffer.empty()) {\n+        std::string err;\n+        // We don't intend to \"send more\" because http responses are usually small and we want the kernel to send them right away.\n+        ssize_t bytes_sent = m_server->SendBytes(m_node_id, MakeUCharSpan(m_send_buffer), /*will_send_more=*/false, err);\n+        if (bytes_sent < 0) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error sending HTTP response data to client %s (id=%lld): %s\\n\",\n+                m_origin,\n+                m_node_id,\n+                err);\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+            m_disconnect = true;\n+            return false;\n+        }\n+\n+        Assume(static_cast<size_t>(bytes_sent) <= m_send_buffer.size());\n+        m_send_buffer.erase(m_send_buffer.begin(), m_send_buffer.begin() + bytes_sent);\n+\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Sent %d bytes to client %s (id=%lld)\\n\",\n+            bytes_sent,\n+            m_origin,\n+            m_node_id);\n+\n+        // This check is inside the if(!empty) block meaning \"there was data but now its gone\".\n+        // We shouldn't even be calling SendBytesFromBuffer() when the send buffer is empty,\n+        // but for belt-and-suspenders, we don't want to modify the disconnect flags if SendBytesFromBuffer() was a no-op.\n+        if (m_send_buffer.empty()) {\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+\n+            // Our work is done here\n+            if (!m_keep_alive) {\n+                m_disconnect = true;\n+                return false;\n+            }\n+        } else {\n+            m_send_ready = true;\n+            m_prevent_disconnect = true;\n+        }\n+    }\n+\n+    return true;\n }\n-HTTPEvent::~HTTPEvent()\n+\n+void HTTPServer::CloseConnectionInternal(std::shared_ptr<HTTPClient>& client)\n {\n-    event_free(ev);\n+    if (CloseConnection(client->m_node_id)) {\n+        LogDebug(BCLog::HTTP, \"Disconnected HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    } else {\n+        LogDebug(BCLog::HTTP, \"Failed to disconnect non-existent HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    }\n }",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 809,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The `CloseConnectionInternal()` method can and should take just a reference, no need for shared pointer:\r\n\r\n```diff\r\n- void HTTPServer::CloseConnectionInternal(std::shared_ptr<HTTPClient>& client)\r\n+ void HTTPServer::CloseConnectionInternal(const HTTPClient& client)\r\n```",
      "created_at": "2025-06-05T11:16:12Z",
      "updated_at": "2025-06-05T14:02:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2128594514",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128594514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 704,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 711,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128627105",
      "pull_request_review_id": 2899730748,
      "id": 2128627105,
      "node_id": "PRRC_kwDOABII585-4EWh",
      "diff_hunk": "@@ -27,168 +34,309 @@ static const int DEFAULT_HTTP_WORKQUEUE=64;\n \n static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;\n \n-struct evhttp_request;\n-struct event_base;\n-class CService;\n-class HTTPRequest;\n+enum HTTPRequestMethod {\n+    UNKNOWN,\n+    GET,\n+    POST,\n+    HEAD,\n+    PUT\n+};\n \n-/** Initialize HTTP server.\n- * Call this before RegisterHTTPHandler or EventBase().\n- */\n-bool InitHTTPServer(const util::SignalInterrupt& interrupt);\n-/** Start HTTP server.\n- * This is separate from InitHTTPServer to give users race-condition-free time\n- * to register their handlers between InitHTTPServer and StartHTTPServer.\n+/** Event handler closure.\n  */\n-void StartHTTPServer();\n-/** Interrupt HTTP server threads */\n-void InterruptHTTPServer();\n-/** Stop HTTP server */\n-void StopHTTPServer();\n+class HTTPClosure\n+{\n+public:\n+    virtual void operator()() = 0;\n+    virtual ~HTTPClosure() = default;\n+};\n \n-/** Change logging level for libevent. */\n-void UpdateHTTPServerLogging(bool enable);\n+namespace http_bitcoin {\n+using util::LineReader;\n+using NodeId = SockMan::Id;\n \n-/** Handler for requests to a certain HTTP path */\n-typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n-/** Register handler for prefix.\n- * If multiple handlers match a prefix, the first-registered one will\n- * be invoked.\n- */\n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler);\n-/** Unregister handler for prefix */\n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch);\n+// shortest valid request line, used by libevent in evhttp_parse_request_line()\n+static const size_t MIN_REQUEST_LINE_LENGTH{strlen(\"GET / HTTP/1.0\")};\n+// maximum size of http request (request line + headers)\n+// see https://github.com/bitcoin/bitcoin/issues/6425\n+static const size_t MAX_HEADERS_SIZE{8192};\n \n-/** Return evhttp event base. This can be used by submodules to\n- * queue timers or custom events.\n- */\n-struct event_base* EventBase();\n+class HTTPHeaders\n+{\n+public:\n+    std::optional<std::string_view> Find(const std::string key) const;\n+    void Write(const std::string key, const std::string value);\n+    void Remove(const std::string key);\n+    bool Read(util::LineReader& reader);\n+    std::string Stringify() const;\n+\n+private:\n+    std::map<std::string, std::string, util::CaseInsensitiveComparator> m_map;\n+};\n+\n+class HTTPResponse\n+{\n+public:\n+    int m_version_major;\n+    int m_version_minor;\n+    HTTPStatusCode m_status;\n+    std::string m_reason;\n+    HTTPHeaders m_headers;\n+    std::vector<std::byte> m_body;\n+    bool m_keep_alive{false};\n+\n+    std::string StringifyHeaders() const;\n+};\n+\n+class HTTPClient;\n \n-/** In-flight HTTP request.\n- * Thin C++ wrapper around evhttp_request.\n- */\n class HTTPRequest\n {\n-private:\n-    struct evhttp_request* req;\n-    const util::SignalInterrupt& m_interrupt;\n-    bool replySent;\n+public:\n+    std::string m_method;\n+    std::string m_target;\n+    // Default protocol version is used by error responses to unreadable requests\n+    int m_version_major{1};\n+    int m_version_minor{1};\n+    HTTPHeaders m_headers;\n+    std::string m_body;\n+\n+    // Keep a pointer to the client that made the request so\n+    // we know who to respond to.\n+    std::shared_ptr<HTTPClient> m_client;\n+    explicit HTTPRequest(std::shared_ptr<HTTPClient> client) : m_client(client) {};\n+    // Null client for unit tests\n+    explicit HTTPRequest() : m_client(nullptr) {};\n+\n+    // Readers return false if they need more data from the\n+    // socket to parse properly. They throw errors if\n+    // the data is invalid.\n+    bool LoadControlData(LineReader& reader);\n+    bool LoadHeaders(LineReader& reader);\n+    bool LoadBody(LineReader& reader);\n+\n+    // These methods reimplement the API from http_libevent::HTTPRequest\n+    // for downstream JSONRPC and REST modules.\n+    std::string GetURI() const {return m_target;};\n+    CService GetPeer() const;\n+    HTTPRequestMethod GetRequestMethod() const;\n+    std::optional<std::string> GetQueryParameter(const std::string& key) const;\n+    std::pair<bool, std::string_view> GetHeader(const std::string& hdr) const;\n+    std::string ReadBody() const {return m_body;};\n+    void WriteHeader(const std::string& hdr, const std::string& value);\n+\n+    // Response headers may be set in advance before response body is known\n+    HTTPHeaders m_response_headers;\n+    void WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body = {});\n+    void WriteReply(HTTPStatusCode status, std::string_view reply_body_view)\n+    {\n+        WriteReply(status, std::as_bytes(std::span{reply_body_view}));\n+    }\n+};\n+\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key);\n+\n+class HTTPServer;\n \n+class HTTPClient\n+{\n public:\n-    explicit HTTPRequest(struct evhttp_request* req, const util::SignalInterrupt& interrupt, bool replySent = false);\n-    ~HTTPRequest();\n-\n-    enum RequestMethod {\n-        UNKNOWN,\n-        GET,\n-        POST,\n-        HEAD,\n-        PUT\n+    // ID provided by SockMan, inherited by HTTPServer\n+    NodeId m_node_id;\n+    // Remote address of connected client\n+    CService m_addr;\n+    // IP:port of connected client, cached for logging purposes\n+    std::string m_origin;\n+    // Pointer back to the server so we can call Sockman I/O methods from the client\n+    // Ok to remain null for unit tests.\n+    HTTPServer* m_server;\n+\n+    // In lieu of an intermediate transport class like p2p uses,\n+    // we copy data from the socket buffer to the client object\n+    // and attempt to read HTTP requests from here.\n+    std::vector<std::byte> m_recv_buffer{};\n+\n+    // Requests from a client must be processed in the order in which\n+    // they were received, blocking on a per-client basis. We won't\n+    // process the next request in the queue if we are currently busy\n+    // handling a previous request.\n+    std::deque<std::unique_ptr<HTTPRequest>> m_req_queue;\n+    // Set to true by the main thread when a request is popped off\n+    // and passed to a worker, reset to false by the worker thread.\n+    std::atomic_bool m_req_busy{false};\n+\n+    // Response data destined for this client.\n+    // Written to directly by http worker threads, read and erased by Sockman I/O\n+    Mutex m_send_mutex;\n+    std::vector<std::byte> m_send_buffer GUARDED_BY(m_send_mutex);\n+    // Set true by worker threads after writing a response to m_send_buffer.\n+    // Set false by the Sockman I/O thread after flushing m_send_buffer.\n+    // Checked in the Sockman I/O loop to avoid locking m_send_mutex if there's nothing to send.\n+    std::atomic_bool m_send_ready{false};\n+\n+    // Set to true when we receive request data and set to false once m_send_buffer is cleared.\n+    // Checked during DisconnectClients(). All of these operations take place in the Sockman I/O loop,\n+    // however it may get set my a worker thread during an \"optimistic send\".\n+    std::atomic_bool m_prevent_disconnect{false};",
      "path": "src/httpserver.h",
      "position": 1,
      "original_position": 212,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Would be good to note that this overrides `m_disconnect`:\r\n\r\n```cpp\r\n// If set, then the client will not be disconnected even if `m_disconnect` is true.\r\n```",
      "created_at": "2025-06-05T11:35:50Z",
      "updated_at": "2025-06-05T14:02:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2128627105",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128627105"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 177,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 180,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128628047",
      "pull_request_review_id": 2899730748,
      "id": 2128628047,
      "node_id": "PRRC_kwDOABII585-4ElP",
      "diff_hunk": "@@ -27,168 +34,309 @@ static const int DEFAULT_HTTP_WORKQUEUE=64;\n \n static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;\n \n-struct evhttp_request;\n-struct event_base;\n-class CService;\n-class HTTPRequest;\n+enum HTTPRequestMethod {\n+    UNKNOWN,\n+    GET,\n+    POST,\n+    HEAD,\n+    PUT\n+};\n \n-/** Initialize HTTP server.\n- * Call this before RegisterHTTPHandler or EventBase().\n- */\n-bool InitHTTPServer(const util::SignalInterrupt& interrupt);\n-/** Start HTTP server.\n- * This is separate from InitHTTPServer to give users race-condition-free time\n- * to register their handlers between InitHTTPServer and StartHTTPServer.\n+/** Event handler closure.\n  */\n-void StartHTTPServer();\n-/** Interrupt HTTP server threads */\n-void InterruptHTTPServer();\n-/** Stop HTTP server */\n-void StopHTTPServer();\n+class HTTPClosure\n+{\n+public:\n+    virtual void operator()() = 0;\n+    virtual ~HTTPClosure() = default;\n+};\n \n-/** Change logging level for libevent. */\n-void UpdateHTTPServerLogging(bool enable);\n+namespace http_bitcoin {\n+using util::LineReader;\n+using NodeId = SockMan::Id;\n \n-/** Handler for requests to a certain HTTP path */\n-typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n-/** Register handler for prefix.\n- * If multiple handlers match a prefix, the first-registered one will\n- * be invoked.\n- */\n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler);\n-/** Unregister handler for prefix */\n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch);\n+// shortest valid request line, used by libevent in evhttp_parse_request_line()\n+static const size_t MIN_REQUEST_LINE_LENGTH{strlen(\"GET / HTTP/1.0\")};\n+// maximum size of http request (request line + headers)\n+// see https://github.com/bitcoin/bitcoin/issues/6425\n+static const size_t MAX_HEADERS_SIZE{8192};\n \n-/** Return evhttp event base. This can be used by submodules to\n- * queue timers or custom events.\n- */\n-struct event_base* EventBase();\n+class HTTPHeaders\n+{\n+public:\n+    std::optional<std::string_view> Find(const std::string key) const;\n+    void Write(const std::string key, const std::string value);\n+    void Remove(const std::string key);\n+    bool Read(util::LineReader& reader);\n+    std::string Stringify() const;\n+\n+private:\n+    std::map<std::string, std::string, util::CaseInsensitiveComparator> m_map;\n+};\n+\n+class HTTPResponse\n+{\n+public:\n+    int m_version_major;\n+    int m_version_minor;\n+    HTTPStatusCode m_status;\n+    std::string m_reason;\n+    HTTPHeaders m_headers;\n+    std::vector<std::byte> m_body;\n+    bool m_keep_alive{false};\n+\n+    std::string StringifyHeaders() const;\n+};\n+\n+class HTTPClient;\n \n-/** In-flight HTTP request.\n- * Thin C++ wrapper around evhttp_request.\n- */\n class HTTPRequest\n {\n-private:\n-    struct evhttp_request* req;\n-    const util::SignalInterrupt& m_interrupt;\n-    bool replySent;\n+public:\n+    std::string m_method;\n+    std::string m_target;\n+    // Default protocol version is used by error responses to unreadable requests\n+    int m_version_major{1};\n+    int m_version_minor{1};\n+    HTTPHeaders m_headers;\n+    std::string m_body;\n+\n+    // Keep a pointer to the client that made the request so\n+    // we know who to respond to.\n+    std::shared_ptr<HTTPClient> m_client;\n+    explicit HTTPRequest(std::shared_ptr<HTTPClient> client) : m_client(client) {};\n+    // Null client for unit tests\n+    explicit HTTPRequest() : m_client(nullptr) {};\n+\n+    // Readers return false if they need more data from the\n+    // socket to parse properly. They throw errors if\n+    // the data is invalid.\n+    bool LoadControlData(LineReader& reader);\n+    bool LoadHeaders(LineReader& reader);\n+    bool LoadBody(LineReader& reader);\n+\n+    // These methods reimplement the API from http_libevent::HTTPRequest\n+    // for downstream JSONRPC and REST modules.\n+    std::string GetURI() const {return m_target;};\n+    CService GetPeer() const;\n+    HTTPRequestMethod GetRequestMethod() const;\n+    std::optional<std::string> GetQueryParameter(const std::string& key) const;\n+    std::pair<bool, std::string_view> GetHeader(const std::string& hdr) const;\n+    std::string ReadBody() const {return m_body;};\n+    void WriteHeader(const std::string& hdr, const std::string& value);\n+\n+    // Response headers may be set in advance before response body is known\n+    HTTPHeaders m_response_headers;\n+    void WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body = {});\n+    void WriteReply(HTTPStatusCode status, std::string_view reply_body_view)\n+    {\n+        WriteReply(status, std::as_bytes(std::span{reply_body_view}));\n+    }\n+};\n+\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key);\n+\n+class HTTPServer;\n \n+class HTTPClient\n+{\n public:\n-    explicit HTTPRequest(struct evhttp_request* req, const util::SignalInterrupt& interrupt, bool replySent = false);\n-    ~HTTPRequest();\n-\n-    enum RequestMethod {\n-        UNKNOWN,\n-        GET,\n-        POST,\n-        HEAD,\n-        PUT\n+    // ID provided by SockMan, inherited by HTTPServer\n+    NodeId m_node_id;\n+    // Remote address of connected client\n+    CService m_addr;\n+    // IP:port of connected client, cached for logging purposes\n+    std::string m_origin;\n+    // Pointer back to the server so we can call Sockman I/O methods from the client\n+    // Ok to remain null for unit tests.\n+    HTTPServer* m_server;\n+\n+    // In lieu of an intermediate transport class like p2p uses,\n+    // we copy data from the socket buffer to the client object\n+    // and attempt to read HTTP requests from here.\n+    std::vector<std::byte> m_recv_buffer{};\n+\n+    // Requests from a client must be processed in the order in which\n+    // they were received, blocking on a per-client basis. We won't\n+    // process the next request in the queue if we are currently busy\n+    // handling a previous request.\n+    std::deque<std::unique_ptr<HTTPRequest>> m_req_queue;\n+    // Set to true by the main thread when a request is popped off\n+    // and passed to a worker, reset to false by the worker thread.\n+    std::atomic_bool m_req_busy{false};\n+\n+    // Response data destined for this client.\n+    // Written to directly by http worker threads, read and erased by Sockman I/O\n+    Mutex m_send_mutex;\n+    std::vector<std::byte> m_send_buffer GUARDED_BY(m_send_mutex);\n+    // Set true by worker threads after writing a response to m_send_buffer.\n+    // Set false by the Sockman I/O thread after flushing m_send_buffer.\n+    // Checked in the Sockman I/O loop to avoid locking m_send_mutex if there's nothing to send.\n+    std::atomic_bool m_send_ready{false};\n+\n+    // Set to true when we receive request data and set to false once m_send_buffer is cleared.\n+    // Checked during DisconnectClients(). All of these operations take place in the Sockman I/O loop,\n+    // however it may get set my a worker thread during an \"optimistic send\".\n+    std::atomic_bool m_prevent_disconnect{false};\n+\n+    // Client request to keep connection open after all requests have been responded to.",
      "path": "src/httpserver.h",
      "position": 1,
      "original_position": 214,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit:\r\n```suggestion\r\n    // Client requested to keep the connection open after all requests have been responded to.\r\n```",
      "created_at": "2025-06-05T11:36:21Z",
      "updated_at": "2025-06-05T14:02:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2128628047",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128628047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128770318",
      "pull_request_review_id": 2899730748,
      "id": 2128770318,
      "node_id": "PRRC_kwDOABII585-4nUO",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {\n+        // Transfer-Encoding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-3.3.1\n+        // Chunked Transfer Coding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-4.1\n+        // see evhttp_handle_chunked_read() in libevent http.c\n+        while (reader.Left() > 0) {\n+            auto maybe_chunk_size = reader.ReadLine();\n+            if (!maybe_chunk_size) return false;\n+            uint64_t chunk_size;\n+\n+            if (!ParseUInt64Hex(maybe_chunk_size.value(), &chunk_size)) throw std::runtime_error(\"Invalid chunk size\");\n+\n+            bool last_chunk{chunk_size == 0};\n+\n+            if (!last_chunk) {\n+                // We are still expecting more data for this chunk\n+                if (reader.Left() < chunk_size) {\n+                    return false;\n+                }\n+                // Pack chunk onto body\n+                m_body += reader.ReadLength(chunk_size);\n+            }\n+\n+            // Even though every chunk size is explicitly declared,\n+            // they are still terminated by a CRLF we don't need.\n+            auto crlf = reader.ReadLine();\n+            if (!crlf || crlf.value().size() != 0) throw std::runtime_error(\"Improperly terminated chunk\");\n+\n+            if (last_chunk) return true;\n+        }\n+\n+        // We read all the chunks but never got the last chunk, wait for client to send more\n+        return false;\n     } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+        // No Content-length or Transfer-Encoding header means no body, see libevent evhttp_get_body()\n+        auto content_length_value{m_headers.Find(\"Content-Length\")};\n+        if (!content_length_value) return true;\n+\n+        uint64_t content_length;\n+        if (!ParseUInt64(content_length_value.value(), &content_length)) throw std::runtime_error(\"Cannot parse Content-Length value\");\n+\n+        // Not enough data in buffer for expected body\n+        if (reader.Left() < content_length) return false;\n+\n+        m_body = reader.ReadLength(content_length);\n+\n+        return true;\n     }\n }\n \n-static std::thread g_thread_http;\n-static std::vector<std::thread> g_thread_http_workers;\n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n \n-void StartHTTPServer()\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n {\n-    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n-    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n-    g_thread_http = std::thread(ThreadHTTP, eventBase);\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n \n-    for (int i = 0; i < rpcThreads; i++) {\n-        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string_view query{decoded_uri.data() + start + 1, end - start - 1};\n+    // find requested parameter in query\n+    const std::vector<std::string_view> params{Split<std::string_view>(query, \"&\")};\n+    for (const std::string_view& param : params) {\n+        size_t delim = param.find('=');\n+        if (key == param.substr(0, delim)) {\n+            if (delim == std::string::npos) {\n+                return \"\";\n+            } else {\n+                return std::string(param.substr(delim + 1));\n+            }\n+        }\n     }\n+    return std::nullopt;\n }\n \n-void InterruptHTTPServer()\n+std::pair<bool, std::string_view> HTTPRequest::GetHeader(const std::string& hdr) const\n {\n-    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n-    if (eventHTTP) {\n-        // Reject requests on current connections\n-        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n-    }\n-    if (g_work_queue) {\n-        g_work_queue->Interrupt();\n-    }\n+    std::optional<std::string_view> found{m_headers.Find(hdr)};\n+    if (found.has_value()) {\n+        return std::make_pair(true, found.value());\n+    } else\n+        return std::make_pair(false, \"\");\n }\n \n-void StopHTTPServer()\n+void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n {\n-    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n-    if (g_work_queue) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n-        for (auto& thread : g_thread_http_workers) {\n-            thread.join();\n+    m_response_headers.Write(hdr, value);\n+}\n+\n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n         }\n-        g_thread_http_workers.clear();\n     }\n-    // Unlisten sockets, these are what make the event loop running, which means\n-    // that after this and all connections are closed the event loop will quit.\n-    for (evhttp_bound_socket *socket : boundSockets) {\n-        evhttp_del_accept_socket(eventHTTP, socket);\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n     }\n-    boundSockets.clear();\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    m_client->m_keep_alive = res.m_keep_alive;\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    bool send_buffer_was_empty{false};\n+    // Fill the send buffer with the complete serialized response headers + body\n     {\n-        if (const auto n_connections{g_requests.CountActiveConnections()}; n_connections != 0) {\n-            LogDebug(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections);\n-        }\n-        g_requests.WaitUntilEmpty();\n-    }\n-    if (eventHTTP) {\n-        // Schedule a callback to call evhttp_free in the event base thread, so\n-        // that evhttp_free does not need to be called again after the handling\n-        // of unfinished request connections that follows.\n-        event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {\n-            evhttp_free(eventHTTP);\n-            eventHTTP = nullptr;\n-        }, nullptr, nullptr);\n-    }\n-    if (eventBase) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n-        if (g_thread_http.joinable()) g_thread_http.join();\n-        event_base_free(eventBase);\n-        eventBase = nullptr;\n-    }\n-    g_work_queue.reset();\n-    LogDebug(BCLog::HTTP, \"Stopped HTTP server\\n\");\n-}\n+        LOCK(m_client->m_send_mutex);\n+        send_buffer_was_empty = m_client->m_send_buffer.empty();\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());\n+    }\n+\n+    LogDebug(\n+        BCLog::HTTP,\n+        \"HTTPResponse (status code: %d size: %lld) added to send buffer for client %s (id=%lld)\\n\",\n+        status,\n+        headers_bytes.size() + reply_body.size(),\n+        m_client->m_origin,\n+        m_client->m_node_id);\n+\n+    // If the send buffer was empty before we wrote this reply, we can try an\n+    // optimistic send akin to CConnman::PushMessage() in which we\n+    // push the data directly out the socket to client right now, instead\n+    // of waiting for the next iteration of the Sockman I/O loop.\n+    if (send_buffer_was_empty) {\n+        m_client->SendBytesFromBuffer();\n+    } else {\n+        // Inform Sockman I/O there is data that is ready to be sent to this client\n+        // in the next loop iteration.\n+        m_client->m_send_ready = true;\n+    }\n \n-struct event_base* EventBase()\n-{\n-    return eventBase;\n+    // Signal to the Sockman I/O loop that we are ready to handle the next request.\n+    m_client->m_req_busy = false;\n }\n \n-static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n+bool HTTPClient::ReadRequest(std::unique_ptr<HTTPRequest>& req)\n {\n-    // Static handler: simply call inner handler\n-    HTTPEvent *self = static_cast<HTTPEvent*>(data);\n-    self->handler();\n-    if (self->deleteWhenTriggered)\n-        delete self;\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(\n+        m_recv_buffer.begin(),\n+        m_recv_buffer.begin() + (reader.it - reader.start));\n+\n+    return true;\n }\n \n-HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):\n-    deleteWhenTriggered(_deleteWhenTriggered), handler(_handler)\n-{\n-    ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n-    assert(ev);\n+bool HTTPClient::SendBytesFromBuffer()\n+{\n+    Assume(m_server);\n+\n+    // Send as much data from this client's buffer as we can\n+    LOCK(m_send_mutex);\n+    if (!m_send_buffer.empty()) {\n+        std::string err;\n+        // We don't intend to \"send more\" because http responses are usually small and we want the kernel to send them right away.\n+        ssize_t bytes_sent = m_server->SendBytes(m_node_id, MakeUCharSpan(m_send_buffer), /*will_send_more=*/false, err);\n+        if (bytes_sent < 0) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error sending HTTP response data to client %s (id=%lld): %s\\n\",\n+                m_origin,\n+                m_node_id,\n+                err);\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+            m_disconnect = true;\n+            return false;\n+        }\n+\n+        Assume(static_cast<size_t>(bytes_sent) <= m_send_buffer.size());\n+        m_send_buffer.erase(m_send_buffer.begin(), m_send_buffer.begin() + bytes_sent);\n+\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Sent %d bytes to client %s (id=%lld)\\n\",\n+            bytes_sent,\n+            m_origin,\n+            m_node_id);\n+\n+        // This check is inside the if(!empty) block meaning \"there was data but now its gone\".\n+        // We shouldn't even be calling SendBytesFromBuffer() when the send buffer is empty,\n+        // but for belt-and-suspenders, we don't want to modify the disconnect flags if SendBytesFromBuffer() was a no-op.\n+        if (m_send_buffer.empty()) {\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+\n+            // Our work is done here\n+            if (!m_keep_alive) {\n+                m_disconnect = true;\n+                return false;\n+            }\n+        } else {\n+            m_send_ready = true;\n+            m_prevent_disconnect = true;\n+        }\n+    }\n+\n+    return true;\n }\n-HTTPEvent::~HTTPEvent()\n+\n+void HTTPServer::CloseConnectionInternal(std::shared_ptr<HTTPClient>& client)\n {\n-    event_free(ev);\n+    if (CloseConnection(client->m_node_id)) {\n+        LogDebug(BCLog::HTTP, \"Disconnected HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    } else {\n+        LogDebug(BCLog::HTTP, \"Failed to disconnect non-existent HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    }\n }\n-void HTTPEvent::trigger(struct timeval* tv)\n+\n+void HTTPServer::DisconnectClients()\n {\n-    if (tv == nullptr)\n-        event_active(ev, 0, 0); // immediately trigger event in main thread\n-    else\n-        evtimer_add(ev, tv); // trigger after timeval passed\n+    const auto now{Now<SteadySeconds>()};\n+    for (auto it = m_connected_clients.begin(); it != m_connected_clients.end();) {\n+        bool timeout{now - it->second->m_idle_since > m_rpcservertimeout};\n+        if (((it->second->m_disconnect || m_disconnect_all_clients) && !it->second->m_prevent_disconnect)\n+            || timeout) {\n+            CloseConnectionInternal(it->second);\n+            it = m_connected_clients.erase(it);\n+        } else {\n+            ++it;\n+        }\n+    }\n+    m_no_clients = m_connected_clients.size() == 0;\n }\n-HTTPRequest::HTTPRequest(struct evhttp_request* _req, const util::SignalInterrupt& interrupt, bool _replySent)\n-    : req(_req), m_interrupt(interrupt), replySent(_replySent)\n+\n+bool HTTPServer::EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them)\n {\n+    auto client = std::make_shared<HTTPClient>(node_id, them);\n+    // Point back to the server\n+    client->m_server = this;\n+    // Set timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+    LogDebug(BCLog::HTTP, \"HTTP Connection accepted from %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    m_connected_clients.emplace(client->m_node_id, std::move(client));\n+    m_no_clients = false;\n+    return true;\n }\n \n-HTTPRequest::~HTTPRequest()\n+void HTTPServer::EventReadyToSend(NodeId node_id, bool& cancel_recv)\n {\n-    if (!replySent) {\n-        // Keep track of whether reply was sent to avoid request leaks\n-        LogPrintf(\"%s: Unhandled request\\n\", __func__);\n-        WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\");\n+    // Next attempt to receive data from this node is permitted\n+    cancel_recv = false;\n+\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n     }\n-    // evhttpd cleans up the request, as long as a reply was sent.\n+\n+    // SendBytesFromBuffer() returns true if we should keep the client around,\n+    // false if we are done with it. Invert that boolean to inform Sockman\n+    // whether it should cancel the next receive attempt from this client.\n+    cancel_recv = !client->SendBytesFromBuffer();\n }\n \n-std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const\n+void HTTPServer::EventGotData(NodeId node_id, std::span<const uint8_t> data)\n {\n-    const struct evkeyvalq* headers = evhttp_request_get_input_headers(req);\n-    assert(headers);\n-    const char* val = evhttp_find_header(headers, hdr.c_str());\n-    if (val)\n-        return std::make_pair(true, val);\n-    else\n-        return std::make_pair(false, \"\");\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    // Reset idle timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+\n+    // Prevent disconnect until all requests are completely handled.\n+    client->m_prevent_disconnect = true;\n+\n+    // Copy data from socket buffer to client receive buffer\n+    client->m_recv_buffer.insert(\n+        client->m_recv_buffer.end(),\n+        reinterpret_cast<const std::byte*>(data.data()),\n+        reinterpret_cast<const std::byte*>(data.data() + data.size())\n+    );\n+\n+    // Try reading (potentially multiple) HTTP requests from the buffer\n+    while (client->m_recv_buffer.size() > 0) {\n+        // Create a new request object and try to fill it with data from the receive buffer\n+        auto req = std::make_unique<HTTPRequest>(client);\n+        try {\n+            // Stop reading if we need more data from the client to parse a complete request\n+            if (!client->ReadRequest(req)) break;\n+        } catch (const std::runtime_error& e) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error reading HTTP request from client %s (id=%lld): %s\\n\",\n+                client->m_origin,\n+                client->m_node_id,\n+                e.what());\n+\n+            // We failed to read a complete request from the buffer\n+            req->WriteReply(HTTP_BAD_REQUEST);\n+            client->m_disconnect = true;\n+            break;\n+        }\n+\n+        // We read a complete request from the buffer into the queue\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Received a %s request for %s from %s (id=%lld)\\n\",\n+            req->m_method,\n+            req->m_target,\n+            req->m_client->m_origin,\n+            req->m_client->m_node_id);\n+\n+        // add request to client queue\n+        client->m_req_queue.push_back(std::move(req));\n+    }\n }\n \n-std::string HTTPRequest::ReadBody()\n+void HTTPServer::EventGotEOF(NodeId node_id)\n {\n-    struct evbuffer* buf = evhttp_request_get_input_buffer(req);\n-    if (!buf)\n-        return \"\";\n-    size_t size = evbuffer_get_length(buf);\n-    /** Trivial implementation: if this is ever a performance bottleneck,\n-     * internal copying can be avoided in multi-segment buffers by using\n-     * evbuffer_peek and an awkward loop. Though in that case, it'd be even\n-     * better to not copy into an intermediate string but use a stream\n-     * abstraction to consume the evbuffer on the fly in the parsing algorithm.\n-     */\n-    const char* data = (const char*)evbuffer_pullup(buf, size);\n-    if (!data) // returns nullptr in case of empty buffer\n-        return \"\";\n-    std::string rv(data, size);\n-    evbuffer_drain(buf, size);\n-    return rv;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    client->m_disconnect = true;\n }\n \n-void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n+void HTTPServer::EventGotPermanentReadError(NodeId node_id, const std::string& errmsg)\n {\n-    struct evkeyvalq* headers = evhttp_request_get_output_headers(req);\n-    assert(headers);\n-    evhttp_add_header(headers, hdr.c_str(), value.c_str());\n-}\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-/** Closure sent to main thread to request a reply to be sent to\n- * a HTTP request.\n- * Replies must be sent in the main loop in the main http thread,\n- * this cannot be done from worker threads.\n- */\n-void HTTPRequest::WriteReply(int nStatus, std::span<const std::byte> reply)\n-{\n-    assert(!replySent && req);\n-    if (m_interrupt) {\n-        WriteHeader(\"Connection\", \"close\");\n-    }\n-    // Send event to main http thread to send reply message\n-    struct evbuffer* evb = evhttp_request_get_output_buffer(req);\n-    assert(evb);\n-    evbuffer_add(evb, reply.data(), reply.size());\n-    auto req_copy = req;\n-    HTTPEvent* ev = new HTTPEvent(eventBase, true, [req_copy, nStatus]{\n-        evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);\n-        // Re-enable reading from the socket. This is the second part of the libevent\n-        // workaround above.\n-        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02010900) {\n-            evhttp_connection* conn = evhttp_request_get_connection(req_copy);\n-            if (conn) {\n-                bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n-                if (bev) {\n-                    bufferevent_enable(bev, EV_READ | EV_WRITE);\n-                }\n-            }\n-        }\n-    });\n-    ev->trigger(nullptr);\n-    replySent = true;\n-    req = nullptr; // transferred back to main thread\n+    client->m_disconnect = true;\n }\n \n-CService HTTPRequest::GetPeer() const\n+void HTTPServer::EventIOLoopCompletedForOne(NodeId node_id)\n {\n-    evhttp_connection* con = evhttp_request_get_connection(req);\n-    CService peer;\n-    if (con) {\n-        // evhttp retains ownership over returned address string\n-        const char* address = \"\";\n-        uint16_t port = 0;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-#ifdef HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n-        evhttp_connection_get_peer(con, &address, &port);\n-#else\n-        evhttp_connection_get_peer(con, (char**)&address, &port);\n-#endif // HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n+    // If we are already handling a request from\n+    // this client, do nothing.\n+    if (client->m_req_busy) return;\n \n-        peer = MaybeFlipIPv6toCJDNS(LookupNumeric(address, port));\n+    // Otherwise, if there is a new pending request, handle it.\n+    if (!client->m_req_queue.empty()) {\n+        client->m_req_busy = true;\n+        m_request_dispatcher(std::move(client->m_req_queue.front()));\n+        client->m_req_queue.pop_front();\n     }\n-    return peer;\n }\n \n-std::string HTTPRequest::GetURI() const\n+void HTTPServer::EventIOLoopCompletedForAll()\n {\n-    return evhttp_request_get_uri(req);\n+    DisconnectClients();\n }\n \n-HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod() const\n+bool HTTPServer::ShouldTryToSend(NodeId node_id) const\n {\n-    switch (evhttp_request_get_command(req)) {\n-    case EVHTTP_REQ_GET:\n-        return GET;\n-    case EVHTTP_REQ_POST:\n-        return POST;\n-    case EVHTTP_REQ_HEAD:\n-        return HEAD;\n-    case EVHTTP_REQ_PUT:\n-        return PUT;\n-    default:\n-        return UNKNOWN;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n     }\n+\n+    return client->m_send_ready;\n }\n \n-std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+bool HTTPServer::ShouldTryToRecv(NodeId node_id) const\n {\n-    const char* uri{evhttp_request_get_uri(req)};\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n+    }\n \n-    return GetQueryParameterFromUri(uri, key);\n+    // Don't try to receive again until we've cleared the send buffer to this client\n+    return !client->m_send_ready;\n }\n \n-std::optional<std::string> GetQueryParameterFromUri(const char* uri, const std::string& key)\n+std::shared_ptr<HTTPClient> HTTPServer::GetClientById(NodeId node_id) const\n {\n-    evhttp_uri* uri_parsed{evhttp_uri_parse(uri)};\n-    if (!uri_parsed) {\n-        throw std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\");\n+    auto it{m_connected_clients.find(node_id)};\n+    if (it != m_connected_clients.end()) {\n+        return it->second;\n     }\n-    const char* query{evhttp_uri_get_query(uri_parsed)};\n-    std::optional<std::string> result;\n+    return nullptr;\n+}\n \n-    if (query) {\n-        // Parse the query string into a key-value queue and iterate over it\n-        struct evkeyvalq params_q;\n-        evhttp_parse_query_str(query, &params_q);\n+bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+{\n+    if (!InitHTTPAllowList())\n+        return false;",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 1114,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit:\r\n```suggestion\r\n    if (!InitHTTPAllowList()) {\r\n        return false;\r\n    }\r\n```",
      "created_at": "2025-06-05T12:45:28Z",
      "updated_at": "2025-06-05T14:02:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2128770318",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128770318"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 898,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 899,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128776391",
      "pull_request_review_id": 2899730748,
      "id": 2128776391,
      "node_id": "PRRC_kwDOABII585-4ozH",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {\n+        // Transfer-Encoding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-3.3.1\n+        // Chunked Transfer Coding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-4.1\n+        // see evhttp_handle_chunked_read() in libevent http.c\n+        while (reader.Left() > 0) {\n+            auto maybe_chunk_size = reader.ReadLine();\n+            if (!maybe_chunk_size) return false;\n+            uint64_t chunk_size;\n+\n+            if (!ParseUInt64Hex(maybe_chunk_size.value(), &chunk_size)) throw std::runtime_error(\"Invalid chunk size\");\n+\n+            bool last_chunk{chunk_size == 0};\n+\n+            if (!last_chunk) {\n+                // We are still expecting more data for this chunk\n+                if (reader.Left() < chunk_size) {\n+                    return false;\n+                }\n+                // Pack chunk onto body\n+                m_body += reader.ReadLength(chunk_size);\n+            }\n+\n+            // Even though every chunk size is explicitly declared,\n+            // they are still terminated by a CRLF we don't need.\n+            auto crlf = reader.ReadLine();\n+            if (!crlf || crlf.value().size() != 0) throw std::runtime_error(\"Improperly terminated chunk\");\n+\n+            if (last_chunk) return true;\n+        }\n+\n+        // We read all the chunks but never got the last chunk, wait for client to send more\n+        return false;\n     } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+        // No Content-length or Transfer-Encoding header means no body, see libevent evhttp_get_body()\n+        auto content_length_value{m_headers.Find(\"Content-Length\")};\n+        if (!content_length_value) return true;\n+\n+        uint64_t content_length;\n+        if (!ParseUInt64(content_length_value.value(), &content_length)) throw std::runtime_error(\"Cannot parse Content-Length value\");\n+\n+        // Not enough data in buffer for expected body\n+        if (reader.Left() < content_length) return false;\n+\n+        m_body = reader.ReadLength(content_length);\n+\n+        return true;\n     }\n }\n \n-static std::thread g_thread_http;\n-static std::vector<std::thread> g_thread_http_workers;\n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n \n-void StartHTTPServer()\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n {\n-    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n-    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n-    g_thread_http = std::thread(ThreadHTTP, eventBase);\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n \n-    for (int i = 0; i < rpcThreads; i++) {\n-        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string_view query{decoded_uri.data() + start + 1, end - start - 1};\n+    // find requested parameter in query\n+    const std::vector<std::string_view> params{Split<std::string_view>(query, \"&\")};\n+    for (const std::string_view& param : params) {\n+        size_t delim = param.find('=');\n+        if (key == param.substr(0, delim)) {\n+            if (delim == std::string::npos) {\n+                return \"\";\n+            } else {\n+                return std::string(param.substr(delim + 1));\n+            }\n+        }\n     }\n+    return std::nullopt;\n }\n \n-void InterruptHTTPServer()\n+std::pair<bool, std::string_view> HTTPRequest::GetHeader(const std::string& hdr) const\n {\n-    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n-    if (eventHTTP) {\n-        // Reject requests on current connections\n-        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n-    }\n-    if (g_work_queue) {\n-        g_work_queue->Interrupt();\n-    }\n+    std::optional<std::string_view> found{m_headers.Find(hdr)};\n+    if (found.has_value()) {\n+        return std::make_pair(true, found.value());\n+    } else\n+        return std::make_pair(false, \"\");\n }\n \n-void StopHTTPServer()\n+void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n {\n-    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n-    if (g_work_queue) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n-        for (auto& thread : g_thread_http_workers) {\n-            thread.join();\n+    m_response_headers.Write(hdr, value);\n+}\n+\n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n         }\n-        g_thread_http_workers.clear();\n     }\n-    // Unlisten sockets, these are what make the event loop running, which means\n-    // that after this and all connections are closed the event loop will quit.\n-    for (evhttp_bound_socket *socket : boundSockets) {\n-        evhttp_del_accept_socket(eventHTTP, socket);\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n     }\n-    boundSockets.clear();\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    m_client->m_keep_alive = res.m_keep_alive;\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    bool send_buffer_was_empty{false};\n+    // Fill the send buffer with the complete serialized response headers + body\n     {\n-        if (const auto n_connections{g_requests.CountActiveConnections()}; n_connections != 0) {\n-            LogDebug(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections);\n-        }\n-        g_requests.WaitUntilEmpty();\n-    }\n-    if (eventHTTP) {\n-        // Schedule a callback to call evhttp_free in the event base thread, so\n-        // that evhttp_free does not need to be called again after the handling\n-        // of unfinished request connections that follows.\n-        event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {\n-            evhttp_free(eventHTTP);\n-            eventHTTP = nullptr;\n-        }, nullptr, nullptr);\n-    }\n-    if (eventBase) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n-        if (g_thread_http.joinable()) g_thread_http.join();\n-        event_base_free(eventBase);\n-        eventBase = nullptr;\n-    }\n-    g_work_queue.reset();\n-    LogDebug(BCLog::HTTP, \"Stopped HTTP server\\n\");\n-}\n+        LOCK(m_client->m_send_mutex);\n+        send_buffer_was_empty = m_client->m_send_buffer.empty();\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());\n+    }\n+\n+    LogDebug(\n+        BCLog::HTTP,\n+        \"HTTPResponse (status code: %d size: %lld) added to send buffer for client %s (id=%lld)\\n\",\n+        status,\n+        headers_bytes.size() + reply_body.size(),\n+        m_client->m_origin,\n+        m_client->m_node_id);\n+\n+    // If the send buffer was empty before we wrote this reply, we can try an\n+    // optimistic send akin to CConnman::PushMessage() in which we\n+    // push the data directly out the socket to client right now, instead\n+    // of waiting for the next iteration of the Sockman I/O loop.\n+    if (send_buffer_was_empty) {\n+        m_client->SendBytesFromBuffer();\n+    } else {\n+        // Inform Sockman I/O there is data that is ready to be sent to this client\n+        // in the next loop iteration.\n+        m_client->m_send_ready = true;\n+    }\n \n-struct event_base* EventBase()\n-{\n-    return eventBase;\n+    // Signal to the Sockman I/O loop that we are ready to handle the next request.\n+    m_client->m_req_busy = false;\n }\n \n-static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n+bool HTTPClient::ReadRequest(std::unique_ptr<HTTPRequest>& req)\n {\n-    // Static handler: simply call inner handler\n-    HTTPEvent *self = static_cast<HTTPEvent*>(data);\n-    self->handler();\n-    if (self->deleteWhenTriggered)\n-        delete self;\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(\n+        m_recv_buffer.begin(),\n+        m_recv_buffer.begin() + (reader.it - reader.start));\n+\n+    return true;\n }\n \n-HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):\n-    deleteWhenTriggered(_deleteWhenTriggered), handler(_handler)\n-{\n-    ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n-    assert(ev);\n+bool HTTPClient::SendBytesFromBuffer()\n+{\n+    Assume(m_server);\n+\n+    // Send as much data from this client's buffer as we can\n+    LOCK(m_send_mutex);\n+    if (!m_send_buffer.empty()) {\n+        std::string err;\n+        // We don't intend to \"send more\" because http responses are usually small and we want the kernel to send them right away.\n+        ssize_t bytes_sent = m_server->SendBytes(m_node_id, MakeUCharSpan(m_send_buffer), /*will_send_more=*/false, err);\n+        if (bytes_sent < 0) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error sending HTTP response data to client %s (id=%lld): %s\\n\",\n+                m_origin,\n+                m_node_id,\n+                err);\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+            m_disconnect = true;\n+            return false;\n+        }\n+\n+        Assume(static_cast<size_t>(bytes_sent) <= m_send_buffer.size());\n+        m_send_buffer.erase(m_send_buffer.begin(), m_send_buffer.begin() + bytes_sent);\n+\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Sent %d bytes to client %s (id=%lld)\\n\",\n+            bytes_sent,\n+            m_origin,\n+            m_node_id);\n+\n+        // This check is inside the if(!empty) block meaning \"there was data but now its gone\".\n+        // We shouldn't even be calling SendBytesFromBuffer() when the send buffer is empty,\n+        // but for belt-and-suspenders, we don't want to modify the disconnect flags if SendBytesFromBuffer() was a no-op.\n+        if (m_send_buffer.empty()) {\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+\n+            // Our work is done here\n+            if (!m_keep_alive) {\n+                m_disconnect = true;\n+                return false;\n+            }\n+        } else {\n+            m_send_ready = true;\n+            m_prevent_disconnect = true;\n+        }\n+    }\n+\n+    return true;\n }\n-HTTPEvent::~HTTPEvent()\n+\n+void HTTPServer::CloseConnectionInternal(std::shared_ptr<HTTPClient>& client)\n {\n-    event_free(ev);\n+    if (CloseConnection(client->m_node_id)) {\n+        LogDebug(BCLog::HTTP, \"Disconnected HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    } else {\n+        LogDebug(BCLog::HTTP, \"Failed to disconnect non-existent HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    }\n }\n-void HTTPEvent::trigger(struct timeval* tv)\n+\n+void HTTPServer::DisconnectClients()\n {\n-    if (tv == nullptr)\n-        event_active(ev, 0, 0); // immediately trigger event in main thread\n-    else\n-        evtimer_add(ev, tv); // trigger after timeval passed\n+    const auto now{Now<SteadySeconds>()};\n+    for (auto it = m_connected_clients.begin(); it != m_connected_clients.end();) {\n+        bool timeout{now - it->second->m_idle_since > m_rpcservertimeout};\n+        if (((it->second->m_disconnect || m_disconnect_all_clients) && !it->second->m_prevent_disconnect)\n+            || timeout) {\n+            CloseConnectionInternal(it->second);\n+            it = m_connected_clients.erase(it);\n+        } else {\n+            ++it;\n+        }\n+    }\n+    m_no_clients = m_connected_clients.size() == 0;\n }\n-HTTPRequest::HTTPRequest(struct evhttp_request* _req, const util::SignalInterrupt& interrupt, bool _replySent)\n-    : req(_req), m_interrupt(interrupt), replySent(_replySent)\n+\n+bool HTTPServer::EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them)\n {\n+    auto client = std::make_shared<HTTPClient>(node_id, them);\n+    // Point back to the server\n+    client->m_server = this;\n+    // Set timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+    LogDebug(BCLog::HTTP, \"HTTP Connection accepted from %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    m_connected_clients.emplace(client->m_node_id, std::move(client));\n+    m_no_clients = false;\n+    return true;\n }\n \n-HTTPRequest::~HTTPRequest()\n+void HTTPServer::EventReadyToSend(NodeId node_id, bool& cancel_recv)\n {\n-    if (!replySent) {\n-        // Keep track of whether reply was sent to avoid request leaks\n-        LogPrintf(\"%s: Unhandled request\\n\", __func__);\n-        WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\");\n+    // Next attempt to receive data from this node is permitted\n+    cancel_recv = false;\n+\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n     }\n-    // evhttpd cleans up the request, as long as a reply was sent.\n+\n+    // SendBytesFromBuffer() returns true if we should keep the client around,\n+    // false if we are done with it. Invert that boolean to inform Sockman\n+    // whether it should cancel the next receive attempt from this client.\n+    cancel_recv = !client->SendBytesFromBuffer();\n }\n \n-std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const\n+void HTTPServer::EventGotData(NodeId node_id, std::span<const uint8_t> data)\n {\n-    const struct evkeyvalq* headers = evhttp_request_get_input_headers(req);\n-    assert(headers);\n-    const char* val = evhttp_find_header(headers, hdr.c_str());\n-    if (val)\n-        return std::make_pair(true, val);\n-    else\n-        return std::make_pair(false, \"\");\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    // Reset idle timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+\n+    // Prevent disconnect until all requests are completely handled.\n+    client->m_prevent_disconnect = true;\n+\n+    // Copy data from socket buffer to client receive buffer\n+    client->m_recv_buffer.insert(\n+        client->m_recv_buffer.end(),\n+        reinterpret_cast<const std::byte*>(data.data()),\n+        reinterpret_cast<const std::byte*>(data.data() + data.size())\n+    );\n+\n+    // Try reading (potentially multiple) HTTP requests from the buffer\n+    while (client->m_recv_buffer.size() > 0) {\n+        // Create a new request object and try to fill it with data from the receive buffer\n+        auto req = std::make_unique<HTTPRequest>(client);\n+        try {\n+            // Stop reading if we need more data from the client to parse a complete request\n+            if (!client->ReadRequest(req)) break;\n+        } catch (const std::runtime_error& e) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error reading HTTP request from client %s (id=%lld): %s\\n\",\n+                client->m_origin,\n+                client->m_node_id,\n+                e.what());\n+\n+            // We failed to read a complete request from the buffer\n+            req->WriteReply(HTTP_BAD_REQUEST);\n+            client->m_disconnect = true;\n+            break;\n+        }\n+\n+        // We read a complete request from the buffer into the queue\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Received a %s request for %s from %s (id=%lld)\\n\",\n+            req->m_method,\n+            req->m_target,\n+            req->m_client->m_origin,\n+            req->m_client->m_node_id);\n+\n+        // add request to client queue\n+        client->m_req_queue.push_back(std::move(req));\n+    }\n }\n \n-std::string HTTPRequest::ReadBody()\n+void HTTPServer::EventGotEOF(NodeId node_id)\n {\n-    struct evbuffer* buf = evhttp_request_get_input_buffer(req);\n-    if (!buf)\n-        return \"\";\n-    size_t size = evbuffer_get_length(buf);\n-    /** Trivial implementation: if this is ever a performance bottleneck,\n-     * internal copying can be avoided in multi-segment buffers by using\n-     * evbuffer_peek and an awkward loop. Though in that case, it'd be even\n-     * better to not copy into an intermediate string but use a stream\n-     * abstraction to consume the evbuffer on the fly in the parsing algorithm.\n-     */\n-    const char* data = (const char*)evbuffer_pullup(buf, size);\n-    if (!data) // returns nullptr in case of empty buffer\n-        return \"\";\n-    std::string rv(data, size);\n-    evbuffer_drain(buf, size);\n-    return rv;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    client->m_disconnect = true;\n }\n \n-void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n+void HTTPServer::EventGotPermanentReadError(NodeId node_id, const std::string& errmsg)\n {\n-    struct evkeyvalq* headers = evhttp_request_get_output_headers(req);\n-    assert(headers);\n-    evhttp_add_header(headers, hdr.c_str(), value.c_str());\n-}\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-/** Closure sent to main thread to request a reply to be sent to\n- * a HTTP request.\n- * Replies must be sent in the main loop in the main http thread,\n- * this cannot be done from worker threads.\n- */\n-void HTTPRequest::WriteReply(int nStatus, std::span<const std::byte> reply)\n-{\n-    assert(!replySent && req);\n-    if (m_interrupt) {\n-        WriteHeader(\"Connection\", \"close\");\n-    }\n-    // Send event to main http thread to send reply message\n-    struct evbuffer* evb = evhttp_request_get_output_buffer(req);\n-    assert(evb);\n-    evbuffer_add(evb, reply.data(), reply.size());\n-    auto req_copy = req;\n-    HTTPEvent* ev = new HTTPEvent(eventBase, true, [req_copy, nStatus]{\n-        evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);\n-        // Re-enable reading from the socket. This is the second part of the libevent\n-        // workaround above.\n-        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02010900) {\n-            evhttp_connection* conn = evhttp_request_get_connection(req_copy);\n-            if (conn) {\n-                bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n-                if (bev) {\n-                    bufferevent_enable(bev, EV_READ | EV_WRITE);\n-                }\n-            }\n-        }\n-    });\n-    ev->trigger(nullptr);\n-    replySent = true;\n-    req = nullptr; // transferred back to main thread\n+    client->m_disconnect = true;\n }\n \n-CService HTTPRequest::GetPeer() const\n+void HTTPServer::EventIOLoopCompletedForOne(NodeId node_id)\n {\n-    evhttp_connection* con = evhttp_request_get_connection(req);\n-    CService peer;\n-    if (con) {\n-        // evhttp retains ownership over returned address string\n-        const char* address = \"\";\n-        uint16_t port = 0;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-#ifdef HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n-        evhttp_connection_get_peer(con, &address, &port);\n-#else\n-        evhttp_connection_get_peer(con, (char**)&address, &port);\n-#endif // HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n+    // If we are already handling a request from\n+    // this client, do nothing.\n+    if (client->m_req_busy) return;\n \n-        peer = MaybeFlipIPv6toCJDNS(LookupNumeric(address, port));\n+    // Otherwise, if there is a new pending request, handle it.\n+    if (!client->m_req_queue.empty()) {\n+        client->m_req_busy = true;\n+        m_request_dispatcher(std::move(client->m_req_queue.front()));\n+        client->m_req_queue.pop_front();\n     }\n-    return peer;\n }\n \n-std::string HTTPRequest::GetURI() const\n+void HTTPServer::EventIOLoopCompletedForAll()\n {\n-    return evhttp_request_get_uri(req);\n+    DisconnectClients();\n }\n \n-HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod() const\n+bool HTTPServer::ShouldTryToSend(NodeId node_id) const\n {\n-    switch (evhttp_request_get_command(req)) {\n-    case EVHTTP_REQ_GET:\n-        return GET;\n-    case EVHTTP_REQ_POST:\n-        return POST;\n-    case EVHTTP_REQ_HEAD:\n-        return HEAD;\n-    case EVHTTP_REQ_PUT:\n-        return PUT;\n-    default:\n-        return UNKNOWN;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n     }\n+\n+    return client->m_send_ready;\n }\n \n-std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+bool HTTPServer::ShouldTryToRecv(NodeId node_id) const\n {\n-    const char* uri{evhttp_request_get_uri(req)};\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n+    }\n \n-    return GetQueryParameterFromUri(uri, key);\n+    // Don't try to receive again until we've cleared the send buffer to this client\n+    return !client->m_send_ready;\n }\n \n-std::optional<std::string> GetQueryParameterFromUri(const char* uri, const std::string& key)\n+std::shared_ptr<HTTPClient> HTTPServer::GetClientById(NodeId node_id) const\n {\n-    evhttp_uri* uri_parsed{evhttp_uri_parse(uri)};\n-    if (!uri_parsed) {\n-        throw std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\");\n+    auto it{m_connected_clients.find(node_id)};\n+    if (it != m_connected_clients.end()) {\n+        return it->second;\n     }\n-    const char* query{evhttp_uri_get_query(uri_parsed)};\n-    std::optional<std::string> result;\n+    return nullptr;\n+}\n \n-    if (query) {\n-        // Parse the query string into a key-value queue and iterate over it\n-        struct evkeyvalq params_q;\n-        evhttp_parse_query_str(query, &params_q);\n+bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+{\n+    if (!InitHTTPAllowList())\n+        return false;\n \n-        for (struct evkeyval* param{params_q.tqh_first}; param != nullptr; param = param->next.tqe_next) {\n-            if (param->key == key) {\n-                result = param->value;\n-                break;\n+    // Create HTTPServer\n+    g_http_server = std::make_unique<HTTPServer>(MaybeDispatchRequestToWorker);\n+\n+    g_http_server->m_rpcservertimeout = std::chrono::seconds(gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n+\n+    // Bind HTTP server to specified addresses\n+    std::vector<std::pair<std::string, uint16_t>> endpoints{GetBindAddresses()};\n+    bool bind_success{false};\n+    for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 1128,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\r\n    for (std::vector<std::pair<std::string, uint16_t>>::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\r\n```",
      "created_at": "2025-06-05T12:48:32Z",
      "updated_at": "2025-06-05T14:02:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2128776391",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128776391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 909,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128778896",
      "pull_request_review_id": 2899730748,
      "id": 2128778896,
      "node_id": "PRRC_kwDOABII585-4paQ",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {\n+        // Transfer-Encoding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-3.3.1\n+        // Chunked Transfer Coding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-4.1\n+        // see evhttp_handle_chunked_read() in libevent http.c\n+        while (reader.Left() > 0) {\n+            auto maybe_chunk_size = reader.ReadLine();\n+            if (!maybe_chunk_size) return false;\n+            uint64_t chunk_size;\n+\n+            if (!ParseUInt64Hex(maybe_chunk_size.value(), &chunk_size)) throw std::runtime_error(\"Invalid chunk size\");\n+\n+            bool last_chunk{chunk_size == 0};\n+\n+            if (!last_chunk) {\n+                // We are still expecting more data for this chunk\n+                if (reader.Left() < chunk_size) {\n+                    return false;\n+                }\n+                // Pack chunk onto body\n+                m_body += reader.ReadLength(chunk_size);\n+            }\n+\n+            // Even though every chunk size is explicitly declared,\n+            // they are still terminated by a CRLF we don't need.\n+            auto crlf = reader.ReadLine();\n+            if (!crlf || crlf.value().size() != 0) throw std::runtime_error(\"Improperly terminated chunk\");\n+\n+            if (last_chunk) return true;\n+        }\n+\n+        // We read all the chunks but never got the last chunk, wait for client to send more\n+        return false;\n     } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+        // No Content-length or Transfer-Encoding header means no body, see libevent evhttp_get_body()\n+        auto content_length_value{m_headers.Find(\"Content-Length\")};\n+        if (!content_length_value) return true;\n+\n+        uint64_t content_length;\n+        if (!ParseUInt64(content_length_value.value(), &content_length)) throw std::runtime_error(\"Cannot parse Content-Length value\");\n+\n+        // Not enough data in buffer for expected body\n+        if (reader.Left() < content_length) return false;\n+\n+        m_body = reader.ReadLength(content_length);\n+\n+        return true;\n     }\n }\n \n-static std::thread g_thread_http;\n-static std::vector<std::thread> g_thread_http_workers;\n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n \n-void StartHTTPServer()\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n {\n-    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n-    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n-    g_thread_http = std::thread(ThreadHTTP, eventBase);\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n \n-    for (int i = 0; i < rpcThreads; i++) {\n-        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string_view query{decoded_uri.data() + start + 1, end - start - 1};\n+    // find requested parameter in query\n+    const std::vector<std::string_view> params{Split<std::string_view>(query, \"&\")};\n+    for (const std::string_view& param : params) {\n+        size_t delim = param.find('=');\n+        if (key == param.substr(0, delim)) {\n+            if (delim == std::string::npos) {\n+                return \"\";\n+            } else {\n+                return std::string(param.substr(delim + 1));\n+            }\n+        }\n     }\n+    return std::nullopt;\n }\n \n-void InterruptHTTPServer()\n+std::pair<bool, std::string_view> HTTPRequest::GetHeader(const std::string& hdr) const\n {\n-    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n-    if (eventHTTP) {\n-        // Reject requests on current connections\n-        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n-    }\n-    if (g_work_queue) {\n-        g_work_queue->Interrupt();\n-    }\n+    std::optional<std::string_view> found{m_headers.Find(hdr)};\n+    if (found.has_value()) {\n+        return std::make_pair(true, found.value());\n+    } else\n+        return std::make_pair(false, \"\");\n }\n \n-void StopHTTPServer()\n+void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n {\n-    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n-    if (g_work_queue) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n-        for (auto& thread : g_thread_http_workers) {\n-            thread.join();\n+    m_response_headers.Write(hdr, value);\n+}\n+\n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n         }\n-        g_thread_http_workers.clear();\n     }\n-    // Unlisten sockets, these are what make the event loop running, which means\n-    // that after this and all connections are closed the event loop will quit.\n-    for (evhttp_bound_socket *socket : boundSockets) {\n-        evhttp_del_accept_socket(eventHTTP, socket);\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n     }\n-    boundSockets.clear();\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    m_client->m_keep_alive = res.m_keep_alive;\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    bool send_buffer_was_empty{false};\n+    // Fill the send buffer with the complete serialized response headers + body\n     {\n-        if (const auto n_connections{g_requests.CountActiveConnections()}; n_connections != 0) {\n-            LogDebug(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections);\n-        }\n-        g_requests.WaitUntilEmpty();\n-    }\n-    if (eventHTTP) {\n-        // Schedule a callback to call evhttp_free in the event base thread, so\n-        // that evhttp_free does not need to be called again after the handling\n-        // of unfinished request connections that follows.\n-        event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {\n-            evhttp_free(eventHTTP);\n-            eventHTTP = nullptr;\n-        }, nullptr, nullptr);\n-    }\n-    if (eventBase) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n-        if (g_thread_http.joinable()) g_thread_http.join();\n-        event_base_free(eventBase);\n-        eventBase = nullptr;\n-    }\n-    g_work_queue.reset();\n-    LogDebug(BCLog::HTTP, \"Stopped HTTP server\\n\");\n-}\n+        LOCK(m_client->m_send_mutex);\n+        send_buffer_was_empty = m_client->m_send_buffer.empty();\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());\n+    }\n+\n+    LogDebug(\n+        BCLog::HTTP,\n+        \"HTTPResponse (status code: %d size: %lld) added to send buffer for client %s (id=%lld)\\n\",\n+        status,\n+        headers_bytes.size() + reply_body.size(),\n+        m_client->m_origin,\n+        m_client->m_node_id);\n+\n+    // If the send buffer was empty before we wrote this reply, we can try an\n+    // optimistic send akin to CConnman::PushMessage() in which we\n+    // push the data directly out the socket to client right now, instead\n+    // of waiting for the next iteration of the Sockman I/O loop.\n+    if (send_buffer_was_empty) {\n+        m_client->SendBytesFromBuffer();\n+    } else {\n+        // Inform Sockman I/O there is data that is ready to be sent to this client\n+        // in the next loop iteration.\n+        m_client->m_send_ready = true;\n+    }\n \n-struct event_base* EventBase()\n-{\n-    return eventBase;\n+    // Signal to the Sockman I/O loop that we are ready to handle the next request.\n+    m_client->m_req_busy = false;\n }\n \n-static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n+bool HTTPClient::ReadRequest(std::unique_ptr<HTTPRequest>& req)\n {\n-    // Static handler: simply call inner handler\n-    HTTPEvent *self = static_cast<HTTPEvent*>(data);\n-    self->handler();\n-    if (self->deleteWhenTriggered)\n-        delete self;\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(\n+        m_recv_buffer.begin(),\n+        m_recv_buffer.begin() + (reader.it - reader.start));\n+\n+    return true;\n }\n \n-HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):\n-    deleteWhenTriggered(_deleteWhenTriggered), handler(_handler)\n-{\n-    ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n-    assert(ev);\n+bool HTTPClient::SendBytesFromBuffer()\n+{\n+    Assume(m_server);\n+\n+    // Send as much data from this client's buffer as we can\n+    LOCK(m_send_mutex);\n+    if (!m_send_buffer.empty()) {\n+        std::string err;\n+        // We don't intend to \"send more\" because http responses are usually small and we want the kernel to send them right away.\n+        ssize_t bytes_sent = m_server->SendBytes(m_node_id, MakeUCharSpan(m_send_buffer), /*will_send_more=*/false, err);\n+        if (bytes_sent < 0) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error sending HTTP response data to client %s (id=%lld): %s\\n\",\n+                m_origin,\n+                m_node_id,\n+                err);\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+            m_disconnect = true;\n+            return false;\n+        }\n+\n+        Assume(static_cast<size_t>(bytes_sent) <= m_send_buffer.size());\n+        m_send_buffer.erase(m_send_buffer.begin(), m_send_buffer.begin() + bytes_sent);\n+\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Sent %d bytes to client %s (id=%lld)\\n\",\n+            bytes_sent,\n+            m_origin,\n+            m_node_id);\n+\n+        // This check is inside the if(!empty) block meaning \"there was data but now its gone\".\n+        // We shouldn't even be calling SendBytesFromBuffer() when the send buffer is empty,\n+        // but for belt-and-suspenders, we don't want to modify the disconnect flags if SendBytesFromBuffer() was a no-op.\n+        if (m_send_buffer.empty()) {\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+\n+            // Our work is done here\n+            if (!m_keep_alive) {\n+                m_disconnect = true;\n+                return false;\n+            }\n+        } else {\n+            m_send_ready = true;\n+            m_prevent_disconnect = true;\n+        }\n+    }\n+\n+    return true;\n }\n-HTTPEvent::~HTTPEvent()\n+\n+void HTTPServer::CloseConnectionInternal(std::shared_ptr<HTTPClient>& client)\n {\n-    event_free(ev);\n+    if (CloseConnection(client->m_node_id)) {\n+        LogDebug(BCLog::HTTP, \"Disconnected HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    } else {\n+        LogDebug(BCLog::HTTP, \"Failed to disconnect non-existent HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    }\n }\n-void HTTPEvent::trigger(struct timeval* tv)\n+\n+void HTTPServer::DisconnectClients()\n {\n-    if (tv == nullptr)\n-        event_active(ev, 0, 0); // immediately trigger event in main thread\n-    else\n-        evtimer_add(ev, tv); // trigger after timeval passed\n+    const auto now{Now<SteadySeconds>()};\n+    for (auto it = m_connected_clients.begin(); it != m_connected_clients.end();) {\n+        bool timeout{now - it->second->m_idle_since > m_rpcservertimeout};\n+        if (((it->second->m_disconnect || m_disconnect_all_clients) && !it->second->m_prevent_disconnect)\n+            || timeout) {\n+            CloseConnectionInternal(it->second);\n+            it = m_connected_clients.erase(it);\n+        } else {\n+            ++it;\n+        }\n+    }\n+    m_no_clients = m_connected_clients.size() == 0;\n }\n-HTTPRequest::HTTPRequest(struct evhttp_request* _req, const util::SignalInterrupt& interrupt, bool _replySent)\n-    : req(_req), m_interrupt(interrupt), replySent(_replySent)\n+\n+bool HTTPServer::EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them)\n {\n+    auto client = std::make_shared<HTTPClient>(node_id, them);\n+    // Point back to the server\n+    client->m_server = this;\n+    // Set timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+    LogDebug(BCLog::HTTP, \"HTTP Connection accepted from %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    m_connected_clients.emplace(client->m_node_id, std::move(client));\n+    m_no_clients = false;\n+    return true;\n }\n \n-HTTPRequest::~HTTPRequest()\n+void HTTPServer::EventReadyToSend(NodeId node_id, bool& cancel_recv)\n {\n-    if (!replySent) {\n-        // Keep track of whether reply was sent to avoid request leaks\n-        LogPrintf(\"%s: Unhandled request\\n\", __func__);\n-        WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\");\n+    // Next attempt to receive data from this node is permitted\n+    cancel_recv = false;\n+\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n     }\n-    // evhttpd cleans up the request, as long as a reply was sent.\n+\n+    // SendBytesFromBuffer() returns true if we should keep the client around,\n+    // false if we are done with it. Invert that boolean to inform Sockman\n+    // whether it should cancel the next receive attempt from this client.\n+    cancel_recv = !client->SendBytesFromBuffer();\n }\n \n-std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const\n+void HTTPServer::EventGotData(NodeId node_id, std::span<const uint8_t> data)\n {\n-    const struct evkeyvalq* headers = evhttp_request_get_input_headers(req);\n-    assert(headers);\n-    const char* val = evhttp_find_header(headers, hdr.c_str());\n-    if (val)\n-        return std::make_pair(true, val);\n-    else\n-        return std::make_pair(false, \"\");\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    // Reset idle timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+\n+    // Prevent disconnect until all requests are completely handled.\n+    client->m_prevent_disconnect = true;\n+\n+    // Copy data from socket buffer to client receive buffer\n+    client->m_recv_buffer.insert(\n+        client->m_recv_buffer.end(),\n+        reinterpret_cast<const std::byte*>(data.data()),\n+        reinterpret_cast<const std::byte*>(data.data() + data.size())\n+    );\n+\n+    // Try reading (potentially multiple) HTTP requests from the buffer\n+    while (client->m_recv_buffer.size() > 0) {\n+        // Create a new request object and try to fill it with data from the receive buffer\n+        auto req = std::make_unique<HTTPRequest>(client);\n+        try {\n+            // Stop reading if we need more data from the client to parse a complete request\n+            if (!client->ReadRequest(req)) break;\n+        } catch (const std::runtime_error& e) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error reading HTTP request from client %s (id=%lld): %s\\n\",\n+                client->m_origin,\n+                client->m_node_id,\n+                e.what());\n+\n+            // We failed to read a complete request from the buffer\n+            req->WriteReply(HTTP_BAD_REQUEST);\n+            client->m_disconnect = true;\n+            break;\n+        }\n+\n+        // We read a complete request from the buffer into the queue\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Received a %s request for %s from %s (id=%lld)\\n\",\n+            req->m_method,\n+            req->m_target,\n+            req->m_client->m_origin,\n+            req->m_client->m_node_id);\n+\n+        // add request to client queue\n+        client->m_req_queue.push_back(std::move(req));\n+    }\n }\n \n-std::string HTTPRequest::ReadBody()\n+void HTTPServer::EventGotEOF(NodeId node_id)\n {\n-    struct evbuffer* buf = evhttp_request_get_input_buffer(req);\n-    if (!buf)\n-        return \"\";\n-    size_t size = evbuffer_get_length(buf);\n-    /** Trivial implementation: if this is ever a performance bottleneck,\n-     * internal copying can be avoided in multi-segment buffers by using\n-     * evbuffer_peek and an awkward loop. Though in that case, it'd be even\n-     * better to not copy into an intermediate string but use a stream\n-     * abstraction to consume the evbuffer on the fly in the parsing algorithm.\n-     */\n-    const char* data = (const char*)evbuffer_pullup(buf, size);\n-    if (!data) // returns nullptr in case of empty buffer\n-        return \"\";\n-    std::string rv(data, size);\n-    evbuffer_drain(buf, size);\n-    return rv;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    client->m_disconnect = true;\n }\n \n-void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n+void HTTPServer::EventGotPermanentReadError(NodeId node_id, const std::string& errmsg)\n {\n-    struct evkeyvalq* headers = evhttp_request_get_output_headers(req);\n-    assert(headers);\n-    evhttp_add_header(headers, hdr.c_str(), value.c_str());\n-}\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-/** Closure sent to main thread to request a reply to be sent to\n- * a HTTP request.\n- * Replies must be sent in the main loop in the main http thread,\n- * this cannot be done from worker threads.\n- */\n-void HTTPRequest::WriteReply(int nStatus, std::span<const std::byte> reply)\n-{\n-    assert(!replySent && req);\n-    if (m_interrupt) {\n-        WriteHeader(\"Connection\", \"close\");\n-    }\n-    // Send event to main http thread to send reply message\n-    struct evbuffer* evb = evhttp_request_get_output_buffer(req);\n-    assert(evb);\n-    evbuffer_add(evb, reply.data(), reply.size());\n-    auto req_copy = req;\n-    HTTPEvent* ev = new HTTPEvent(eventBase, true, [req_copy, nStatus]{\n-        evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);\n-        // Re-enable reading from the socket. This is the second part of the libevent\n-        // workaround above.\n-        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02010900) {\n-            evhttp_connection* conn = evhttp_request_get_connection(req_copy);\n-            if (conn) {\n-                bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n-                if (bev) {\n-                    bufferevent_enable(bev, EV_READ | EV_WRITE);\n-                }\n-            }\n-        }\n-    });\n-    ev->trigger(nullptr);\n-    replySent = true;\n-    req = nullptr; // transferred back to main thread\n+    client->m_disconnect = true;\n }\n \n-CService HTTPRequest::GetPeer() const\n+void HTTPServer::EventIOLoopCompletedForOne(NodeId node_id)\n {\n-    evhttp_connection* con = evhttp_request_get_connection(req);\n-    CService peer;\n-    if (con) {\n-        // evhttp retains ownership over returned address string\n-        const char* address = \"\";\n-        uint16_t port = 0;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-#ifdef HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n-        evhttp_connection_get_peer(con, &address, &port);\n-#else\n-        evhttp_connection_get_peer(con, (char**)&address, &port);\n-#endif // HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n+    // If we are already handling a request from\n+    // this client, do nothing.\n+    if (client->m_req_busy) return;\n \n-        peer = MaybeFlipIPv6toCJDNS(LookupNumeric(address, port));\n+    // Otherwise, if there is a new pending request, handle it.\n+    if (!client->m_req_queue.empty()) {\n+        client->m_req_busy = true;\n+        m_request_dispatcher(std::move(client->m_req_queue.front()));\n+        client->m_req_queue.pop_front();\n     }\n-    return peer;\n }\n \n-std::string HTTPRequest::GetURI() const\n+void HTTPServer::EventIOLoopCompletedForAll()\n {\n-    return evhttp_request_get_uri(req);\n+    DisconnectClients();\n }\n \n-HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod() const\n+bool HTTPServer::ShouldTryToSend(NodeId node_id) const\n {\n-    switch (evhttp_request_get_command(req)) {\n-    case EVHTTP_REQ_GET:\n-        return GET;\n-    case EVHTTP_REQ_POST:\n-        return POST;\n-    case EVHTTP_REQ_HEAD:\n-        return HEAD;\n-    case EVHTTP_REQ_PUT:\n-        return PUT;\n-    default:\n-        return UNKNOWN;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n     }\n+\n+    return client->m_send_ready;\n }\n \n-std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+bool HTTPServer::ShouldTryToRecv(NodeId node_id) const\n {\n-    const char* uri{evhttp_request_get_uri(req)};\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n+    }\n \n-    return GetQueryParameterFromUri(uri, key);\n+    // Don't try to receive again until we've cleared the send buffer to this client\n+    return !client->m_send_ready;\n }\n \n-std::optional<std::string> GetQueryParameterFromUri(const char* uri, const std::string& key)\n+std::shared_ptr<HTTPClient> HTTPServer::GetClientById(NodeId node_id) const\n {\n-    evhttp_uri* uri_parsed{evhttp_uri_parse(uri)};\n-    if (!uri_parsed) {\n-        throw std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\");\n+    auto it{m_connected_clients.find(node_id)};\n+    if (it != m_connected_clients.end()) {\n+        return it->second;\n     }\n-    const char* query{evhttp_uri_get_query(uri_parsed)};\n-    std::optional<std::string> result;\n+    return nullptr;\n+}\n \n-    if (query) {\n-        // Parse the query string into a key-value queue and iterate over it\n-        struct evkeyvalq params_q;\n-        evhttp_parse_query_str(query, &params_q);\n+bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+{\n+    if (!InitHTTPAllowList())\n+        return false;\n \n-        for (struct evkeyval* param{params_q.tqh_first}; param != nullptr; param = param->next.tqe_next) {\n-            if (param->key == key) {\n-                result = param->value;\n-                break;\n+    // Create HTTPServer\n+    g_http_server = std::make_unique<HTTPServer>(MaybeDispatchRequestToWorker);\n+\n+    g_http_server->m_rpcservertimeout = std::chrono::seconds(gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n+\n+    // Bind HTTP server to specified addresses\n+    std::vector<std::pair<std::string, uint16_t>> endpoints{GetBindAddresses()};\n+    bool bind_success{false};\n+    for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\n+        LogPrintf(\"Binding RPC on address %s port %i\\n\", i->first, i->second);\n+        const std::optional<CService> addr{Lookup(i->first, i->second, false)};\n+        if (addr) {\n+            if (addr->IsBindAny()) {\n+                LogPrintf(\"WARNING: the RPC server is not safe to expose to untrusted networks such as the public internet\\n\");",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 1133,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "`LogPrintf()` is using the `Info` severity.\r\n\r\n```suggestion\r\n                LogWarning(\"The RPC server is not safe to expose to untrusted networks such as the public internet\\n\");\r\n```",
      "created_at": "2025-06-05T12:49:47Z",
      "updated_at": "2025-06-05T14:02:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2128778896",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128778896"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 914,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128815408",
      "pull_request_review_id": 2899730748,
      "id": 2128815408,
      "node_id": "PRRC_kwDOABII585-4yUw",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {\n+        // Transfer-Encoding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-3.3.1\n+        // Chunked Transfer Coding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-4.1\n+        // see evhttp_handle_chunked_read() in libevent http.c\n+        while (reader.Left() > 0) {\n+            auto maybe_chunk_size = reader.ReadLine();\n+            if (!maybe_chunk_size) return false;\n+            uint64_t chunk_size;\n+\n+            if (!ParseUInt64Hex(maybe_chunk_size.value(), &chunk_size)) throw std::runtime_error(\"Invalid chunk size\");\n+\n+            bool last_chunk{chunk_size == 0};\n+\n+            if (!last_chunk) {\n+                // We are still expecting more data for this chunk\n+                if (reader.Left() < chunk_size) {\n+                    return false;\n+                }\n+                // Pack chunk onto body\n+                m_body += reader.ReadLength(chunk_size);\n+            }\n+\n+            // Even though every chunk size is explicitly declared,\n+            // they are still terminated by a CRLF we don't need.\n+            auto crlf = reader.ReadLine();\n+            if (!crlf || crlf.value().size() != 0) throw std::runtime_error(\"Improperly terminated chunk\");\n+\n+            if (last_chunk) return true;\n+        }\n+\n+        // We read all the chunks but never got the last chunk, wait for client to send more\n+        return false;\n     } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+        // No Content-length or Transfer-Encoding header means no body, see libevent evhttp_get_body()\n+        auto content_length_value{m_headers.Find(\"Content-Length\")};\n+        if (!content_length_value) return true;\n+\n+        uint64_t content_length;\n+        if (!ParseUInt64(content_length_value.value(), &content_length)) throw std::runtime_error(\"Cannot parse Content-Length value\");\n+\n+        // Not enough data in buffer for expected body\n+        if (reader.Left() < content_length) return false;\n+\n+        m_body = reader.ReadLength(content_length);\n+\n+        return true;\n     }\n }\n \n-static std::thread g_thread_http;\n-static std::vector<std::thread> g_thread_http_workers;\n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n \n-void StartHTTPServer()\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n {\n-    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n-    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n-    g_thread_http = std::thread(ThreadHTTP, eventBase);\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n \n-    for (int i = 0; i < rpcThreads; i++) {\n-        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string_view query{decoded_uri.data() + start + 1, end - start - 1};\n+    // find requested parameter in query\n+    const std::vector<std::string_view> params{Split<std::string_view>(query, \"&\")};\n+    for (const std::string_view& param : params) {\n+        size_t delim = param.find('=');\n+        if (key == param.substr(0, delim)) {\n+            if (delim == std::string::npos) {\n+                return \"\";\n+            } else {\n+                return std::string(param.substr(delim + 1));\n+            }\n+        }\n     }\n+    return std::nullopt;\n }\n \n-void InterruptHTTPServer()\n+std::pair<bool, std::string_view> HTTPRequest::GetHeader(const std::string& hdr) const\n {\n-    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n-    if (eventHTTP) {\n-        // Reject requests on current connections\n-        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n-    }\n-    if (g_work_queue) {\n-        g_work_queue->Interrupt();\n-    }\n+    std::optional<std::string_view> found{m_headers.Find(hdr)};\n+    if (found.has_value()) {\n+        return std::make_pair(true, found.value());\n+    } else\n+        return std::make_pair(false, \"\");\n }\n \n-void StopHTTPServer()\n+void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n {\n-    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n-    if (g_work_queue) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n-        for (auto& thread : g_thread_http_workers) {\n-            thread.join();\n+    m_response_headers.Write(hdr, value);\n+}\n+\n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n         }\n-        g_thread_http_workers.clear();\n     }\n-    // Unlisten sockets, these are what make the event loop running, which means\n-    // that after this and all connections are closed the event loop will quit.\n-    for (evhttp_bound_socket *socket : boundSockets) {\n-        evhttp_del_accept_socket(eventHTTP, socket);\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n     }\n-    boundSockets.clear();\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    m_client->m_keep_alive = res.m_keep_alive;\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    bool send_buffer_was_empty{false};\n+    // Fill the send buffer with the complete serialized response headers + body\n     {\n-        if (const auto n_connections{g_requests.CountActiveConnections()}; n_connections != 0) {\n-            LogDebug(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections);\n-        }\n-        g_requests.WaitUntilEmpty();\n-    }\n-    if (eventHTTP) {\n-        // Schedule a callback to call evhttp_free in the event base thread, so\n-        // that evhttp_free does not need to be called again after the handling\n-        // of unfinished request connections that follows.\n-        event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {\n-            evhttp_free(eventHTTP);\n-            eventHTTP = nullptr;\n-        }, nullptr, nullptr);\n-    }\n-    if (eventBase) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n-        if (g_thread_http.joinable()) g_thread_http.join();\n-        event_base_free(eventBase);\n-        eventBase = nullptr;\n-    }\n-    g_work_queue.reset();\n-    LogDebug(BCLog::HTTP, \"Stopped HTTP server\\n\");\n-}\n+        LOCK(m_client->m_send_mutex);\n+        send_buffer_was_empty = m_client->m_send_buffer.empty();\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());\n+    }\n+\n+    LogDebug(\n+        BCLog::HTTP,\n+        \"HTTPResponse (status code: %d size: %lld) added to send buffer for client %s (id=%lld)\\n\",\n+        status,\n+        headers_bytes.size() + reply_body.size(),\n+        m_client->m_origin,\n+        m_client->m_node_id);\n+\n+    // If the send buffer was empty before we wrote this reply, we can try an\n+    // optimistic send akin to CConnman::PushMessage() in which we\n+    // push the data directly out the socket to client right now, instead\n+    // of waiting for the next iteration of the Sockman I/O loop.\n+    if (send_buffer_was_empty) {\n+        m_client->SendBytesFromBuffer();\n+    } else {\n+        // Inform Sockman I/O there is data that is ready to be sent to this client\n+        // in the next loop iteration.\n+        m_client->m_send_ready = true;\n+    }\n \n-struct event_base* EventBase()\n-{\n-    return eventBase;\n+    // Signal to the Sockman I/O loop that we are ready to handle the next request.\n+    m_client->m_req_busy = false;\n }\n \n-static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n+bool HTTPClient::ReadRequest(std::unique_ptr<HTTPRequest>& req)\n {\n-    // Static handler: simply call inner handler\n-    HTTPEvent *self = static_cast<HTTPEvent*>(data);\n-    self->handler();\n-    if (self->deleteWhenTriggered)\n-        delete self;\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(\n+        m_recv_buffer.begin(),\n+        m_recv_buffer.begin() + (reader.it - reader.start));\n+\n+    return true;\n }\n \n-HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):\n-    deleteWhenTriggered(_deleteWhenTriggered), handler(_handler)\n-{\n-    ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n-    assert(ev);\n+bool HTTPClient::SendBytesFromBuffer()\n+{\n+    Assume(m_server);\n+\n+    // Send as much data from this client's buffer as we can\n+    LOCK(m_send_mutex);\n+    if (!m_send_buffer.empty()) {\n+        std::string err;\n+        // We don't intend to \"send more\" because http responses are usually small and we want the kernel to send them right away.\n+        ssize_t bytes_sent = m_server->SendBytes(m_node_id, MakeUCharSpan(m_send_buffer), /*will_send_more=*/false, err);\n+        if (bytes_sent < 0) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error sending HTTP response data to client %s (id=%lld): %s\\n\",\n+                m_origin,\n+                m_node_id,\n+                err);\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+            m_disconnect = true;\n+            return false;\n+        }\n+\n+        Assume(static_cast<size_t>(bytes_sent) <= m_send_buffer.size());\n+        m_send_buffer.erase(m_send_buffer.begin(), m_send_buffer.begin() + bytes_sent);\n+\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Sent %d bytes to client %s (id=%lld)\\n\",\n+            bytes_sent,\n+            m_origin,\n+            m_node_id);\n+\n+        // This check is inside the if(!empty) block meaning \"there was data but now its gone\".\n+        // We shouldn't even be calling SendBytesFromBuffer() when the send buffer is empty,\n+        // but for belt-and-suspenders, we don't want to modify the disconnect flags if SendBytesFromBuffer() was a no-op.\n+        if (m_send_buffer.empty()) {\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+\n+            // Our work is done here\n+            if (!m_keep_alive) {\n+                m_disconnect = true;\n+                return false;\n+            }\n+        } else {\n+            m_send_ready = true;\n+            m_prevent_disconnect = true;\n+        }\n+    }\n+\n+    return true;\n }\n-HTTPEvent::~HTTPEvent()\n+\n+void HTTPServer::CloseConnectionInternal(std::shared_ptr<HTTPClient>& client)\n {\n-    event_free(ev);\n+    if (CloseConnection(client->m_node_id)) {\n+        LogDebug(BCLog::HTTP, \"Disconnected HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    } else {\n+        LogDebug(BCLog::HTTP, \"Failed to disconnect non-existent HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    }\n }\n-void HTTPEvent::trigger(struct timeval* tv)\n+\n+void HTTPServer::DisconnectClients()\n {\n-    if (tv == nullptr)\n-        event_active(ev, 0, 0); // immediately trigger event in main thread\n-    else\n-        evtimer_add(ev, tv); // trigger after timeval passed\n+    const auto now{Now<SteadySeconds>()};\n+    for (auto it = m_connected_clients.begin(); it != m_connected_clients.end();) {\n+        bool timeout{now - it->second->m_idle_since > m_rpcservertimeout};\n+        if (((it->second->m_disconnect || m_disconnect_all_clients) && !it->second->m_prevent_disconnect)\n+            || timeout) {\n+            CloseConnectionInternal(it->second);\n+            it = m_connected_clients.erase(it);\n+        } else {\n+            ++it;\n+        }\n+    }\n+    m_no_clients = m_connected_clients.size() == 0;\n }\n-HTTPRequest::HTTPRequest(struct evhttp_request* _req, const util::SignalInterrupt& interrupt, bool _replySent)\n-    : req(_req), m_interrupt(interrupt), replySent(_replySent)\n+\n+bool HTTPServer::EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them)\n {\n+    auto client = std::make_shared<HTTPClient>(node_id, them);\n+    // Point back to the server\n+    client->m_server = this;\n+    // Set timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+    LogDebug(BCLog::HTTP, \"HTTP Connection accepted from %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    m_connected_clients.emplace(client->m_node_id, std::move(client));\n+    m_no_clients = false;\n+    return true;\n }\n \n-HTTPRequest::~HTTPRequest()\n+void HTTPServer::EventReadyToSend(NodeId node_id, bool& cancel_recv)\n {\n-    if (!replySent) {\n-        // Keep track of whether reply was sent to avoid request leaks\n-        LogPrintf(\"%s: Unhandled request\\n\", __func__);\n-        WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\");\n+    // Next attempt to receive data from this node is permitted\n+    cancel_recv = false;\n+\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n     }\n-    // evhttpd cleans up the request, as long as a reply was sent.\n+\n+    // SendBytesFromBuffer() returns true if we should keep the client around,\n+    // false if we are done with it. Invert that boolean to inform Sockman\n+    // whether it should cancel the next receive attempt from this client.\n+    cancel_recv = !client->SendBytesFromBuffer();\n }\n \n-std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const\n+void HTTPServer::EventGotData(NodeId node_id, std::span<const uint8_t> data)\n {\n-    const struct evkeyvalq* headers = evhttp_request_get_input_headers(req);\n-    assert(headers);\n-    const char* val = evhttp_find_header(headers, hdr.c_str());\n-    if (val)\n-        return std::make_pair(true, val);\n-    else\n-        return std::make_pair(false, \"\");\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    // Reset idle timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+\n+    // Prevent disconnect until all requests are completely handled.\n+    client->m_prevent_disconnect = true;\n+\n+    // Copy data from socket buffer to client receive buffer\n+    client->m_recv_buffer.insert(\n+        client->m_recv_buffer.end(),\n+        reinterpret_cast<const std::byte*>(data.data()),\n+        reinterpret_cast<const std::byte*>(data.data() + data.size())\n+    );\n+\n+    // Try reading (potentially multiple) HTTP requests from the buffer\n+    while (client->m_recv_buffer.size() > 0) {\n+        // Create a new request object and try to fill it with data from the receive buffer\n+        auto req = std::make_unique<HTTPRequest>(client);\n+        try {\n+            // Stop reading if we need more data from the client to parse a complete request\n+            if (!client->ReadRequest(req)) break;\n+        } catch (const std::runtime_error& e) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error reading HTTP request from client %s (id=%lld): %s\\n\",\n+                client->m_origin,\n+                client->m_node_id,\n+                e.what());\n+\n+            // We failed to read a complete request from the buffer\n+            req->WriteReply(HTTP_BAD_REQUEST);\n+            client->m_disconnect = true;\n+            break;\n+        }\n+\n+        // We read a complete request from the buffer into the queue\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Received a %s request for %s from %s (id=%lld)\\n\",\n+            req->m_method,\n+            req->m_target,\n+            req->m_client->m_origin,\n+            req->m_client->m_node_id);\n+\n+        // add request to client queue\n+        client->m_req_queue.push_back(std::move(req));\n+    }\n }\n \n-std::string HTTPRequest::ReadBody()\n+void HTTPServer::EventGotEOF(NodeId node_id)\n {\n-    struct evbuffer* buf = evhttp_request_get_input_buffer(req);\n-    if (!buf)\n-        return \"\";\n-    size_t size = evbuffer_get_length(buf);\n-    /** Trivial implementation: if this is ever a performance bottleneck,\n-     * internal copying can be avoided in multi-segment buffers by using\n-     * evbuffer_peek and an awkward loop. Though in that case, it'd be even\n-     * better to not copy into an intermediate string but use a stream\n-     * abstraction to consume the evbuffer on the fly in the parsing algorithm.\n-     */\n-    const char* data = (const char*)evbuffer_pullup(buf, size);\n-    if (!data) // returns nullptr in case of empty buffer\n-        return \"\";\n-    std::string rv(data, size);\n-    evbuffer_drain(buf, size);\n-    return rv;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    client->m_disconnect = true;\n }\n \n-void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n+void HTTPServer::EventGotPermanentReadError(NodeId node_id, const std::string& errmsg)\n {\n-    struct evkeyvalq* headers = evhttp_request_get_output_headers(req);\n-    assert(headers);\n-    evhttp_add_header(headers, hdr.c_str(), value.c_str());\n-}\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-/** Closure sent to main thread to request a reply to be sent to\n- * a HTTP request.\n- * Replies must be sent in the main loop in the main http thread,\n- * this cannot be done from worker threads.\n- */\n-void HTTPRequest::WriteReply(int nStatus, std::span<const std::byte> reply)\n-{\n-    assert(!replySent && req);\n-    if (m_interrupt) {\n-        WriteHeader(\"Connection\", \"close\");\n-    }\n-    // Send event to main http thread to send reply message\n-    struct evbuffer* evb = evhttp_request_get_output_buffer(req);\n-    assert(evb);\n-    evbuffer_add(evb, reply.data(), reply.size());\n-    auto req_copy = req;\n-    HTTPEvent* ev = new HTTPEvent(eventBase, true, [req_copy, nStatus]{\n-        evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);\n-        // Re-enable reading from the socket. This is the second part of the libevent\n-        // workaround above.\n-        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02010900) {\n-            evhttp_connection* conn = evhttp_request_get_connection(req_copy);\n-            if (conn) {\n-                bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n-                if (bev) {\n-                    bufferevent_enable(bev, EV_READ | EV_WRITE);\n-                }\n-            }\n-        }\n-    });\n-    ev->trigger(nullptr);\n-    replySent = true;\n-    req = nullptr; // transferred back to main thread\n+    client->m_disconnect = true;\n }\n \n-CService HTTPRequest::GetPeer() const\n+void HTTPServer::EventIOLoopCompletedForOne(NodeId node_id)\n {\n-    evhttp_connection* con = evhttp_request_get_connection(req);\n-    CService peer;\n-    if (con) {\n-        // evhttp retains ownership over returned address string\n-        const char* address = \"\";\n-        uint16_t port = 0;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-#ifdef HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n-        evhttp_connection_get_peer(con, &address, &port);\n-#else\n-        evhttp_connection_get_peer(con, (char**)&address, &port);\n-#endif // HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n+    // If we are already handling a request from\n+    // this client, do nothing.\n+    if (client->m_req_busy) return;\n \n-        peer = MaybeFlipIPv6toCJDNS(LookupNumeric(address, port));\n+    // Otherwise, if there is a new pending request, handle it.\n+    if (!client->m_req_queue.empty()) {\n+        client->m_req_busy = true;\n+        m_request_dispatcher(std::move(client->m_req_queue.front()));\n+        client->m_req_queue.pop_front();\n     }\n-    return peer;\n }\n \n-std::string HTTPRequest::GetURI() const\n+void HTTPServer::EventIOLoopCompletedForAll()\n {\n-    return evhttp_request_get_uri(req);\n+    DisconnectClients();\n }\n \n-HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod() const\n+bool HTTPServer::ShouldTryToSend(NodeId node_id) const\n {\n-    switch (evhttp_request_get_command(req)) {\n-    case EVHTTP_REQ_GET:\n-        return GET;\n-    case EVHTTP_REQ_POST:\n-        return POST;\n-    case EVHTTP_REQ_HEAD:\n-        return HEAD;\n-    case EVHTTP_REQ_PUT:\n-        return PUT;\n-    default:\n-        return UNKNOWN;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n     }\n+\n+    return client->m_send_ready;\n }\n \n-std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+bool HTTPServer::ShouldTryToRecv(NodeId node_id) const\n {\n-    const char* uri{evhttp_request_get_uri(req)};\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n+    }\n \n-    return GetQueryParameterFromUri(uri, key);\n+    // Don't try to receive again until we've cleared the send buffer to this client\n+    return !client->m_send_ready;\n }\n \n-std::optional<std::string> GetQueryParameterFromUri(const char* uri, const std::string& key)\n+std::shared_ptr<HTTPClient> HTTPServer::GetClientById(NodeId node_id) const\n {\n-    evhttp_uri* uri_parsed{evhttp_uri_parse(uri)};\n-    if (!uri_parsed) {\n-        throw std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\");\n+    auto it{m_connected_clients.find(node_id)};\n+    if (it != m_connected_clients.end()) {\n+        return it->second;\n     }\n-    const char* query{evhttp_uri_get_query(uri_parsed)};\n-    std::optional<std::string> result;\n+    return nullptr;\n+}\n \n-    if (query) {\n-        // Parse the query string into a key-value queue and iterate over it\n-        struct evkeyvalq params_q;\n-        evhttp_parse_query_str(query, &params_q);\n+bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+{\n+    if (!InitHTTPAllowList())\n+        return false;\n \n-        for (struct evkeyval* param{params_q.tqh_first}; param != nullptr; param = param->next.tqe_next) {\n-            if (param->key == key) {\n-                result = param->value;\n-                break;\n+    // Create HTTPServer\n+    g_http_server = std::make_unique<HTTPServer>(MaybeDispatchRequestToWorker);\n+\n+    g_http_server->m_rpcservertimeout = std::chrono::seconds(gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n+\n+    // Bind HTTP server to specified addresses\n+    std::vector<std::pair<std::string, uint16_t>> endpoints{GetBindAddresses()};\n+    bool bind_success{false};\n+    for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\n+        LogPrintf(\"Binding RPC on address %s port %i\\n\", i->first, i->second);\n+        const std::optional<CService> addr{Lookup(i->first, i->second, false)};\n+        if (addr) {\n+            if (addr->IsBindAny()) {\n+                LogPrintf(\"WARNING: the RPC server is not safe to expose to untrusted networks such as the public internet\\n\");\n             }\n+            bilingual_str strError;\n+            if (!g_http_server->BindAndStartListening(addr.value(), strError)) {\n+                LogPrintf(\"Binding RPC on address %s failed: %s\\n\", addr->ToStringAddrPort(), strError.original);\n+            } else {\n+                bind_success = true;\n+            }\n+        } else {\n+            LogPrintf(\"Binding RPC on address %s port %i failed.\\n\", i->first, i->second);\n         }\n-        evhttp_clear_headers(&params_q);\n     }\n-    evhttp_uri_free(uri_parsed);\n \n-    return result;\n+    if (!bind_success) {\n+        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n+        return false;\n+    }\n+\n+    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n+    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n+    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+\n+    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n+\n+    return true;\n }\n \n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n+static std::vector<std::thread> g_thread_http_workers;\n+\n+void StartHTTPServer()\n {\n-    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n-    LOCK(g_httppathhandlers_mutex);\n-    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n+    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n+    SockMan::Options sockman_options;\n+    sockman_options.socket_handler_thread_name = \"http\";\n+    g_http_server->StartSocketsThreads(sockman_options);\n+\n+    for (int i = 0; i < rpcThreads; i++) {\n+        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+    }\n }\n \n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+void InterruptHTTPServer()\n {\n-    LOCK(g_httppathhandlers_mutex);\n-    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n-    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n-    for (; i != iend; ++i)\n-        if (i->prefix == prefix && i->exactMatch == exactMatch)\n-            break;\n-    if (i != iend)\n-    {\n-        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n-        pathHandlers.erase(i);\n+    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n+    if (g_http_server) {\n+        // Reject all new requests\n+        g_http_server->m_request_dispatcher = RejectAllRequests;\n     }\n+    if (g_work_queue) {\n+        // Stop workers, killing requests we haven't processed or responded to yet\n+        g_work_queue->Interrupt();\n+    }\n+}\n+\n+void StopHTTPServer()\n+{\n+    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n+    if (g_work_queue) {\n+        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n+        for (auto& thread : g_thread_http_workers) {\n+            thread.join();\n+        }\n+        g_thread_http_workers.clear();\n+    }\n+    if (g_http_server) {\n+        // Disconnect clients as their remaining responses are flushed\n+        g_http_server->m_disconnect_all_clients = true;\n+        // Wait for all disconnections\n+        while (!g_http_server->m_no_clients) {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{50});",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 1221,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit:\r\n```suggestion\r\n            std::this_thread::sleep_for(50ms);\r\n```",
      "created_at": "2025-06-05T13:07:30Z",
      "updated_at": "2025-06-05T14:02:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2128815408",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128815408"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 984,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128818962",
      "pull_request_review_id": 2899730748,
      "id": 2128818962,
      "node_id": "PRRC_kwDOABII585-4zMS",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {\n+        // Transfer-Encoding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-3.3.1\n+        // Chunked Transfer Coding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-4.1\n+        // see evhttp_handle_chunked_read() in libevent http.c\n+        while (reader.Left() > 0) {\n+            auto maybe_chunk_size = reader.ReadLine();\n+            if (!maybe_chunk_size) return false;\n+            uint64_t chunk_size;\n+\n+            if (!ParseUInt64Hex(maybe_chunk_size.value(), &chunk_size)) throw std::runtime_error(\"Invalid chunk size\");\n+\n+            bool last_chunk{chunk_size == 0};\n+\n+            if (!last_chunk) {\n+                // We are still expecting more data for this chunk\n+                if (reader.Left() < chunk_size) {\n+                    return false;\n+                }\n+                // Pack chunk onto body\n+                m_body += reader.ReadLength(chunk_size);\n+            }\n+\n+            // Even though every chunk size is explicitly declared,\n+            // they are still terminated by a CRLF we don't need.\n+            auto crlf = reader.ReadLine();\n+            if (!crlf || crlf.value().size() != 0) throw std::runtime_error(\"Improperly terminated chunk\");\n+\n+            if (last_chunk) return true;\n+        }\n+\n+        // We read all the chunks but never got the last chunk, wait for client to send more\n+        return false;\n     } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+        // No Content-length or Transfer-Encoding header means no body, see libevent evhttp_get_body()\n+        auto content_length_value{m_headers.Find(\"Content-Length\")};\n+        if (!content_length_value) return true;\n+\n+        uint64_t content_length;\n+        if (!ParseUInt64(content_length_value.value(), &content_length)) throw std::runtime_error(\"Cannot parse Content-Length value\");\n+\n+        // Not enough data in buffer for expected body\n+        if (reader.Left() < content_length) return false;\n+\n+        m_body = reader.ReadLength(content_length);\n+\n+        return true;\n     }\n }\n \n-static std::thread g_thread_http;\n-static std::vector<std::thread> g_thread_http_workers;\n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n \n-void StartHTTPServer()\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n {\n-    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n-    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n-    g_thread_http = std::thread(ThreadHTTP, eventBase);\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n \n-    for (int i = 0; i < rpcThreads; i++) {\n-        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string_view query{decoded_uri.data() + start + 1, end - start - 1};\n+    // find requested parameter in query\n+    const std::vector<std::string_view> params{Split<std::string_view>(query, \"&\")};\n+    for (const std::string_view& param : params) {\n+        size_t delim = param.find('=');\n+        if (key == param.substr(0, delim)) {\n+            if (delim == std::string::npos) {\n+                return \"\";\n+            } else {\n+                return std::string(param.substr(delim + 1));\n+            }\n+        }\n     }\n+    return std::nullopt;\n }\n \n-void InterruptHTTPServer()\n+std::pair<bool, std::string_view> HTTPRequest::GetHeader(const std::string& hdr) const\n {\n-    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n-    if (eventHTTP) {\n-        // Reject requests on current connections\n-        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n-    }\n-    if (g_work_queue) {\n-        g_work_queue->Interrupt();\n-    }\n+    std::optional<std::string_view> found{m_headers.Find(hdr)};\n+    if (found.has_value()) {\n+        return std::make_pair(true, found.value());\n+    } else\n+        return std::make_pair(false, \"\");\n }\n \n-void StopHTTPServer()\n+void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n {\n-    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n-    if (g_work_queue) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n-        for (auto& thread : g_thread_http_workers) {\n-            thread.join();\n+    m_response_headers.Write(hdr, value);\n+}\n+\n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n         }\n-        g_thread_http_workers.clear();\n     }\n-    // Unlisten sockets, these are what make the event loop running, which means\n-    // that after this and all connections are closed the event loop will quit.\n-    for (evhttp_bound_socket *socket : boundSockets) {\n-        evhttp_del_accept_socket(eventHTTP, socket);\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n     }\n-    boundSockets.clear();\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    m_client->m_keep_alive = res.m_keep_alive;\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    bool send_buffer_was_empty{false};\n+    // Fill the send buffer with the complete serialized response headers + body\n     {\n-        if (const auto n_connections{g_requests.CountActiveConnections()}; n_connections != 0) {\n-            LogDebug(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections);\n-        }\n-        g_requests.WaitUntilEmpty();\n-    }\n-    if (eventHTTP) {\n-        // Schedule a callback to call evhttp_free in the event base thread, so\n-        // that evhttp_free does not need to be called again after the handling\n-        // of unfinished request connections that follows.\n-        event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {\n-            evhttp_free(eventHTTP);\n-            eventHTTP = nullptr;\n-        }, nullptr, nullptr);\n-    }\n-    if (eventBase) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n-        if (g_thread_http.joinable()) g_thread_http.join();\n-        event_base_free(eventBase);\n-        eventBase = nullptr;\n-    }\n-    g_work_queue.reset();\n-    LogDebug(BCLog::HTTP, \"Stopped HTTP server\\n\");\n-}\n+        LOCK(m_client->m_send_mutex);\n+        send_buffer_was_empty = m_client->m_send_buffer.empty();\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());\n+    }\n+\n+    LogDebug(\n+        BCLog::HTTP,\n+        \"HTTPResponse (status code: %d size: %lld) added to send buffer for client %s (id=%lld)\\n\",\n+        status,\n+        headers_bytes.size() + reply_body.size(),\n+        m_client->m_origin,\n+        m_client->m_node_id);\n+\n+    // If the send buffer was empty before we wrote this reply, we can try an\n+    // optimistic send akin to CConnman::PushMessage() in which we\n+    // push the data directly out the socket to client right now, instead\n+    // of waiting for the next iteration of the Sockman I/O loop.\n+    if (send_buffer_was_empty) {\n+        m_client->SendBytesFromBuffer();\n+    } else {\n+        // Inform Sockman I/O there is data that is ready to be sent to this client\n+        // in the next loop iteration.\n+        m_client->m_send_ready = true;\n+    }\n \n-struct event_base* EventBase()\n-{\n-    return eventBase;\n+    // Signal to the Sockman I/O loop that we are ready to handle the next request.\n+    m_client->m_req_busy = false;\n }\n \n-static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n+bool HTTPClient::ReadRequest(std::unique_ptr<HTTPRequest>& req)\n {\n-    // Static handler: simply call inner handler\n-    HTTPEvent *self = static_cast<HTTPEvent*>(data);\n-    self->handler();\n-    if (self->deleteWhenTriggered)\n-        delete self;\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(\n+        m_recv_buffer.begin(),\n+        m_recv_buffer.begin() + (reader.it - reader.start));\n+\n+    return true;\n }\n \n-HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):\n-    deleteWhenTriggered(_deleteWhenTriggered), handler(_handler)\n-{\n-    ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n-    assert(ev);\n+bool HTTPClient::SendBytesFromBuffer()\n+{\n+    Assume(m_server);\n+\n+    // Send as much data from this client's buffer as we can\n+    LOCK(m_send_mutex);\n+    if (!m_send_buffer.empty()) {\n+        std::string err;\n+        // We don't intend to \"send more\" because http responses are usually small and we want the kernel to send them right away.\n+        ssize_t bytes_sent = m_server->SendBytes(m_node_id, MakeUCharSpan(m_send_buffer), /*will_send_more=*/false, err);\n+        if (bytes_sent < 0) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error sending HTTP response data to client %s (id=%lld): %s\\n\",\n+                m_origin,\n+                m_node_id,\n+                err);\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+            m_disconnect = true;\n+            return false;\n+        }\n+\n+        Assume(static_cast<size_t>(bytes_sent) <= m_send_buffer.size());\n+        m_send_buffer.erase(m_send_buffer.begin(), m_send_buffer.begin() + bytes_sent);\n+\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Sent %d bytes to client %s (id=%lld)\\n\",\n+            bytes_sent,\n+            m_origin,\n+            m_node_id);\n+\n+        // This check is inside the if(!empty) block meaning \"there was data but now its gone\".\n+        // We shouldn't even be calling SendBytesFromBuffer() when the send buffer is empty,\n+        // but for belt-and-suspenders, we don't want to modify the disconnect flags if SendBytesFromBuffer() was a no-op.\n+        if (m_send_buffer.empty()) {\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+\n+            // Our work is done here\n+            if (!m_keep_alive) {\n+                m_disconnect = true;\n+                return false;\n+            }\n+        } else {\n+            m_send_ready = true;\n+            m_prevent_disconnect = true;\n+        }\n+    }\n+\n+    return true;\n }\n-HTTPEvent::~HTTPEvent()\n+\n+void HTTPServer::CloseConnectionInternal(std::shared_ptr<HTTPClient>& client)\n {\n-    event_free(ev);\n+    if (CloseConnection(client->m_node_id)) {\n+        LogDebug(BCLog::HTTP, \"Disconnected HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    } else {\n+        LogDebug(BCLog::HTTP, \"Failed to disconnect non-existent HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    }\n }\n-void HTTPEvent::trigger(struct timeval* tv)\n+\n+void HTTPServer::DisconnectClients()\n {\n-    if (tv == nullptr)\n-        event_active(ev, 0, 0); // immediately trigger event in main thread\n-    else\n-        evtimer_add(ev, tv); // trigger after timeval passed\n+    const auto now{Now<SteadySeconds>()};\n+    for (auto it = m_connected_clients.begin(); it != m_connected_clients.end();) {\n+        bool timeout{now - it->second->m_idle_since > m_rpcservertimeout};\n+        if (((it->second->m_disconnect || m_disconnect_all_clients) && !it->second->m_prevent_disconnect)\n+            || timeout) {\n+            CloseConnectionInternal(it->second);\n+            it = m_connected_clients.erase(it);\n+        } else {\n+            ++it;\n+        }\n+    }\n+    m_no_clients = m_connected_clients.size() == 0;\n }\n-HTTPRequest::HTTPRequest(struct evhttp_request* _req, const util::SignalInterrupt& interrupt, bool _replySent)\n-    : req(_req), m_interrupt(interrupt), replySent(_replySent)\n+\n+bool HTTPServer::EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them)\n {\n+    auto client = std::make_shared<HTTPClient>(node_id, them);\n+    // Point back to the server\n+    client->m_server = this;\n+    // Set timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+    LogDebug(BCLog::HTTP, \"HTTP Connection accepted from %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    m_connected_clients.emplace(client->m_node_id, std::move(client));\n+    m_no_clients = false;\n+    return true;\n }\n \n-HTTPRequest::~HTTPRequest()\n+void HTTPServer::EventReadyToSend(NodeId node_id, bool& cancel_recv)\n {\n-    if (!replySent) {\n-        // Keep track of whether reply was sent to avoid request leaks\n-        LogPrintf(\"%s: Unhandled request\\n\", __func__);\n-        WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\");\n+    // Next attempt to receive data from this node is permitted\n+    cancel_recv = false;\n+\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n     }\n-    // evhttpd cleans up the request, as long as a reply was sent.\n+\n+    // SendBytesFromBuffer() returns true if we should keep the client around,\n+    // false if we are done with it. Invert that boolean to inform Sockman\n+    // whether it should cancel the next receive attempt from this client.\n+    cancel_recv = !client->SendBytesFromBuffer();\n }\n \n-std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const\n+void HTTPServer::EventGotData(NodeId node_id, std::span<const uint8_t> data)\n {\n-    const struct evkeyvalq* headers = evhttp_request_get_input_headers(req);\n-    assert(headers);\n-    const char* val = evhttp_find_header(headers, hdr.c_str());\n-    if (val)\n-        return std::make_pair(true, val);\n-    else\n-        return std::make_pair(false, \"\");\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    // Reset idle timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+\n+    // Prevent disconnect until all requests are completely handled.\n+    client->m_prevent_disconnect = true;\n+\n+    // Copy data from socket buffer to client receive buffer\n+    client->m_recv_buffer.insert(\n+        client->m_recv_buffer.end(),\n+        reinterpret_cast<const std::byte*>(data.data()),\n+        reinterpret_cast<const std::byte*>(data.data() + data.size())\n+    );\n+\n+    // Try reading (potentially multiple) HTTP requests from the buffer\n+    while (client->m_recv_buffer.size() > 0) {\n+        // Create a new request object and try to fill it with data from the receive buffer\n+        auto req = std::make_unique<HTTPRequest>(client);\n+        try {\n+            // Stop reading if we need more data from the client to parse a complete request\n+            if (!client->ReadRequest(req)) break;\n+        } catch (const std::runtime_error& e) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error reading HTTP request from client %s (id=%lld): %s\\n\",\n+                client->m_origin,\n+                client->m_node_id,\n+                e.what());\n+\n+            // We failed to read a complete request from the buffer\n+            req->WriteReply(HTTP_BAD_REQUEST);\n+            client->m_disconnect = true;\n+            break;\n+        }\n+\n+        // We read a complete request from the buffer into the queue\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Received a %s request for %s from %s (id=%lld)\\n\",\n+            req->m_method,\n+            req->m_target,\n+            req->m_client->m_origin,\n+            req->m_client->m_node_id);\n+\n+        // add request to client queue\n+        client->m_req_queue.push_back(std::move(req));\n+    }\n }\n \n-std::string HTTPRequest::ReadBody()\n+void HTTPServer::EventGotEOF(NodeId node_id)\n {\n-    struct evbuffer* buf = evhttp_request_get_input_buffer(req);\n-    if (!buf)\n-        return \"\";\n-    size_t size = evbuffer_get_length(buf);\n-    /** Trivial implementation: if this is ever a performance bottleneck,\n-     * internal copying can be avoided in multi-segment buffers by using\n-     * evbuffer_peek and an awkward loop. Though in that case, it'd be even\n-     * better to not copy into an intermediate string but use a stream\n-     * abstraction to consume the evbuffer on the fly in the parsing algorithm.\n-     */\n-    const char* data = (const char*)evbuffer_pullup(buf, size);\n-    if (!data) // returns nullptr in case of empty buffer\n-        return \"\";\n-    std::string rv(data, size);\n-    evbuffer_drain(buf, size);\n-    return rv;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    client->m_disconnect = true;\n }\n \n-void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n+void HTTPServer::EventGotPermanentReadError(NodeId node_id, const std::string& errmsg)\n {\n-    struct evkeyvalq* headers = evhttp_request_get_output_headers(req);\n-    assert(headers);\n-    evhttp_add_header(headers, hdr.c_str(), value.c_str());\n-}\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-/** Closure sent to main thread to request a reply to be sent to\n- * a HTTP request.\n- * Replies must be sent in the main loop in the main http thread,\n- * this cannot be done from worker threads.\n- */\n-void HTTPRequest::WriteReply(int nStatus, std::span<const std::byte> reply)\n-{\n-    assert(!replySent && req);\n-    if (m_interrupt) {\n-        WriteHeader(\"Connection\", \"close\");\n-    }\n-    // Send event to main http thread to send reply message\n-    struct evbuffer* evb = evhttp_request_get_output_buffer(req);\n-    assert(evb);\n-    evbuffer_add(evb, reply.data(), reply.size());\n-    auto req_copy = req;\n-    HTTPEvent* ev = new HTTPEvent(eventBase, true, [req_copy, nStatus]{\n-        evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);\n-        // Re-enable reading from the socket. This is the second part of the libevent\n-        // workaround above.\n-        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02010900) {\n-            evhttp_connection* conn = evhttp_request_get_connection(req_copy);\n-            if (conn) {\n-                bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n-                if (bev) {\n-                    bufferevent_enable(bev, EV_READ | EV_WRITE);\n-                }\n-            }\n-        }\n-    });\n-    ev->trigger(nullptr);\n-    replySent = true;\n-    req = nullptr; // transferred back to main thread\n+    client->m_disconnect = true;\n }\n \n-CService HTTPRequest::GetPeer() const\n+void HTTPServer::EventIOLoopCompletedForOne(NodeId node_id)\n {\n-    evhttp_connection* con = evhttp_request_get_connection(req);\n-    CService peer;\n-    if (con) {\n-        // evhttp retains ownership over returned address string\n-        const char* address = \"\";\n-        uint16_t port = 0;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-#ifdef HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n-        evhttp_connection_get_peer(con, &address, &port);\n-#else\n-        evhttp_connection_get_peer(con, (char**)&address, &port);\n-#endif // HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n+    // If we are already handling a request from\n+    // this client, do nothing.\n+    if (client->m_req_busy) return;\n \n-        peer = MaybeFlipIPv6toCJDNS(LookupNumeric(address, port));\n+    // Otherwise, if there is a new pending request, handle it.\n+    if (!client->m_req_queue.empty()) {\n+        client->m_req_busy = true;\n+        m_request_dispatcher(std::move(client->m_req_queue.front()));\n+        client->m_req_queue.pop_front();\n     }\n-    return peer;\n }\n \n-std::string HTTPRequest::GetURI() const\n+void HTTPServer::EventIOLoopCompletedForAll()\n {\n-    return evhttp_request_get_uri(req);\n+    DisconnectClients();\n }\n \n-HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod() const\n+bool HTTPServer::ShouldTryToSend(NodeId node_id) const\n {\n-    switch (evhttp_request_get_command(req)) {\n-    case EVHTTP_REQ_GET:\n-        return GET;\n-    case EVHTTP_REQ_POST:\n-        return POST;\n-    case EVHTTP_REQ_HEAD:\n-        return HEAD;\n-    case EVHTTP_REQ_PUT:\n-        return PUT;\n-    default:\n-        return UNKNOWN;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n     }\n+\n+    return client->m_send_ready;\n }\n \n-std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+bool HTTPServer::ShouldTryToRecv(NodeId node_id) const\n {\n-    const char* uri{evhttp_request_get_uri(req)};\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n+    }\n \n-    return GetQueryParameterFromUri(uri, key);\n+    // Don't try to receive again until we've cleared the send buffer to this client\n+    return !client->m_send_ready;\n }\n \n-std::optional<std::string> GetQueryParameterFromUri(const char* uri, const std::string& key)\n+std::shared_ptr<HTTPClient> HTTPServer::GetClientById(NodeId node_id) const\n {\n-    evhttp_uri* uri_parsed{evhttp_uri_parse(uri)};\n-    if (!uri_parsed) {\n-        throw std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\");\n+    auto it{m_connected_clients.find(node_id)};\n+    if (it != m_connected_clients.end()) {\n+        return it->second;\n     }\n-    const char* query{evhttp_uri_get_query(uri_parsed)};\n-    std::optional<std::string> result;\n+    return nullptr;\n+}\n \n-    if (query) {\n-        // Parse the query string into a key-value queue and iterate over it\n-        struct evkeyvalq params_q;\n-        evhttp_parse_query_str(query, &params_q);\n+bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+{\n+    if (!InitHTTPAllowList())\n+        return false;\n \n-        for (struct evkeyval* param{params_q.tqh_first}; param != nullptr; param = param->next.tqe_next) {\n-            if (param->key == key) {\n-                result = param->value;\n-                break;\n+    // Create HTTPServer\n+    g_http_server = std::make_unique<HTTPServer>(MaybeDispatchRequestToWorker);\n+\n+    g_http_server->m_rpcservertimeout = std::chrono::seconds(gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n+\n+    // Bind HTTP server to specified addresses\n+    std::vector<std::pair<std::string, uint16_t>> endpoints{GetBindAddresses()};\n+    bool bind_success{false};\n+    for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\n+        LogPrintf(\"Binding RPC on address %s port %i\\n\", i->first, i->second);\n+        const std::optional<CService> addr{Lookup(i->first, i->second, false)};\n+        if (addr) {\n+            if (addr->IsBindAny()) {\n+                LogPrintf(\"WARNING: the RPC server is not safe to expose to untrusted networks such as the public internet\\n\");\n             }\n+            bilingual_str strError;\n+            if (!g_http_server->BindAndStartListening(addr.value(), strError)) {\n+                LogPrintf(\"Binding RPC on address %s failed: %s\\n\", addr->ToStringAddrPort(), strError.original);\n+            } else {\n+                bind_success = true;\n+            }\n+        } else {\n+            LogPrintf(\"Binding RPC on address %s port %i failed.\\n\", i->first, i->second);\n         }\n-        evhttp_clear_headers(&params_q);\n     }\n-    evhttp_uri_free(uri_parsed);\n \n-    return result;\n+    if (!bind_success) {\n+        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n+        return false;\n+    }\n+\n+    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n+    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n+    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+\n+    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n+\n+    return true;\n }\n \n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n+static std::vector<std::thread> g_thread_http_workers;\n+\n+void StartHTTPServer()\n {\n-    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n-    LOCK(g_httppathhandlers_mutex);\n-    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n+    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n+    SockMan::Options sockman_options;\n+    sockman_options.socket_handler_thread_name = \"http\";\n+    g_http_server->StartSocketsThreads(sockman_options);\n+\n+    for (int i = 0; i < rpcThreads; i++) {\n+        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+    }\n }\n \n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+void InterruptHTTPServer()\n {\n-    LOCK(g_httppathhandlers_mutex);\n-    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n-    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n-    for (; i != iend; ++i)\n-        if (i->prefix == prefix && i->exactMatch == exactMatch)\n-            break;\n-    if (i != iend)\n-    {\n-        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n-        pathHandlers.erase(i);\n+    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n+    if (g_http_server) {\n+        // Reject all new requests\n+        g_http_server->m_request_dispatcher = RejectAllRequests;\n     }\n+    if (g_work_queue) {\n+        // Stop workers, killing requests we haven't processed or responded to yet\n+        g_work_queue->Interrupt();\n+    }\n+}\n+\n+void StopHTTPServer()\n+{\n+    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n+    if (g_work_queue) {\n+        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n+        for (auto& thread : g_thread_http_workers) {\n+            thread.join();\n+        }\n+        g_thread_http_workers.clear();\n+    }\n+    if (g_http_server) {\n+        // Disconnect clients as their remaining responses are flushed\n+        g_http_server->m_disconnect_all_clients = true;\n+        // Wait for all disconnections\n+        while (!g_http_server->m_no_clients) {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{50});\n+        }\n+        // Break sockman I/O loop: stop accepting connections, sending and receiving data\n+        g_http_server->interruptNet();\n+        // Wait for sockman threads to exit\n+        g_http_server->JoinSocketsThreads();",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 1226,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Could a new client sneak in after the loop `while (!g_http_server->m_no_clients)` exits? Shouldn't that loop be after `interruptNet()` so that new clients cannot be accepted?",
      "created_at": "2025-06-05T13:09:19Z",
      "updated_at": "2025-06-05T14:02:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2128818962",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128818962"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 982,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 989,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2131476990",
      "pull_request_review_id": 2903739719,
      "id": 2131476990,
      "node_id": "PRRC_kwDOABII585_C8H-",
      "diff_hunk": "@@ -38,22 +42,16 @@ static const char* WWW_AUTH_HEADER_DATA = \"Basic realm=\\\"jsonrpc\\\"\";\n class HTTPRPCTimer : public RPCTimerBase\n {\n public:\n-    HTTPRPCTimer(struct event_base* eventBase, std::function<void()>& func, int64_t millis) :\n-        ev(eventBase, false, func)\n+    HTTPRPCTimer(NodeContext* context, std::function<void()>& func, int64_t millis)\n     {\n-        struct timeval tv;\n-        tv.tv_sec = millis/1000;\n-        tv.tv_usec = (millis%1000)*1000;\n-        ev.trigger(&tv);\n+        context->scheduler->scheduleFromNow(func, std::chrono::milliseconds(millis));",
      "path": "src/httprpc.cpp",
      "position": 1,
      "original_position": 32,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Might use `std::chrono::milliseconds` for the type of the argument instead of `int64_t`:\r\n\r\n```cpp\r\n    HTTPRPCTimer(NodeContext* context, std::function<void()>& func, std::chrono::milliseconds after)\r\n    {\r\n        context->scheduler->scheduleFromNow(func, after);\r\n```\r\n(in commit 2950597694 `use CScheduler for HTTPRPCTimer`)",
      "created_at": "2025-06-06T04:31:49Z",
      "updated_at": "2025-06-06T07:17:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2131476990",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2131476990"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2131479604",
      "pull_request_review_id": 2903739719,
      "id": 2131479604,
      "node_id": "PRRC_kwDOABII585_C8w0",
      "diff_hunk": "@@ -62,10 +60,10 @@ class HTTPRPCTimerInterface : public RPCTimerInterface\n     }\n     RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis) override\n     {\n-        return new HTTPRPCTimer(base, func, millis);\n+        return new HTTPRPCTimer(m_context, func, millis);\n     }\n private:\n-    struct event_base* base;\n+    NodeContext* m_context;",
      "path": "src/httprpc.cpp",
      "position": 1,
      "original_position": 55,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Because the context will always be set, ie will never be `nullptr`, then it is better to use a reference here instead of a pointer: `NodeContext& m_context;`\r\n\r\n",
      "created_at": "2025-06-06T04:35:54Z",
      "updated_at": "2025-06-06T07:17:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2131479604",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2131479604"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2131490238",
      "pull_request_review_id": 2903739719,
      "id": 2131490238,
      "node_id": "PRRC_kwDOABII585_C_W-",
      "diff_hunk": "@@ -132,7 +130,7 @@ static bool multiUserAuthorized(std::string strUserPass)\n     return false;\n }\n \n-static bool RPCAuthorized(const std::string& strAuth, std::string& strAuthUsernameOut)\n+static bool RPCAuthorized(const std::string_view& strAuth, std::string& strAuthUsernameOut)",
      "path": "src/httprpc.cpp",
      "position": 1,
      "original_position": 73,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Can simplify the code a few lines below:\r\n\r\n```diff\r\n- std::string_view strUserPass64 = TrimStringView(std::string_view{strAuth}.substr(6));\r\n+ std::string_view strUserPass64 = TrimStringView(strAuth.substr(6));\r\n```\r\n(in commit 54a36093f7 `http: using string_view to avoid unnecessary copy in Headers`)",
      "created_at": "2025-06-06T04:48:55Z",
      "updated_at": "2025-06-06T07:17:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2131490238",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2131490238"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2131632124",
      "pull_request_review_id": 2903739719,
      "id": 2131632124,
      "node_id": "PRRC_kwDOABII585_Dh_8",
      "diff_hunk": "@@ -27,168 +34,309 @@ static const int DEFAULT_HTTP_WORKQUEUE=64;\n \n static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;\n \n-struct evhttp_request;\n-struct event_base;\n-class CService;\n-class HTTPRequest;\n+enum HTTPRequestMethod {\n+    UNKNOWN,\n+    GET,\n+    POST,\n+    HEAD,\n+    PUT\n+};\n \n-/** Initialize HTTP server.\n- * Call this before RegisterHTTPHandler or EventBase().\n- */\n-bool InitHTTPServer(const util::SignalInterrupt& interrupt);\n-/** Start HTTP server.\n- * This is separate from InitHTTPServer to give users race-condition-free time\n- * to register their handlers between InitHTTPServer and StartHTTPServer.\n+/** Event handler closure.\n  */\n-void StartHTTPServer();\n-/** Interrupt HTTP server threads */\n-void InterruptHTTPServer();\n-/** Stop HTTP server */\n-void StopHTTPServer();\n+class HTTPClosure\n+{\n+public:\n+    virtual void operator()() = 0;\n+    virtual ~HTTPClosure() = default;\n+};\n \n-/** Change logging level for libevent. */\n-void UpdateHTTPServerLogging(bool enable);\n+namespace http_bitcoin {\n+using util::LineReader;\n+using NodeId = SockMan::Id;\n \n-/** Handler for requests to a certain HTTP path */\n-typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n-/** Register handler for prefix.\n- * If multiple handlers match a prefix, the first-registered one will\n- * be invoked.\n- */\n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler);\n-/** Unregister handler for prefix */\n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch);\n+// shortest valid request line, used by libevent in evhttp_parse_request_line()\n+static const size_t MIN_REQUEST_LINE_LENGTH{strlen(\"GET / HTTP/1.0\")};\n+// maximum size of http request (request line + headers)\n+// see https://github.com/bitcoin/bitcoin/issues/6425\n+static const size_t MAX_HEADERS_SIZE{8192};\n \n-/** Return evhttp event base. This can be used by submodules to\n- * queue timers or custom events.\n- */\n-struct event_base* EventBase();\n+class HTTPHeaders\n+{\n+public:\n+    std::optional<std::string_view> Find(const std::string key) const;\n+    void Write(const std::string key, const std::string value);\n+    void Remove(const std::string key);\n+    bool Read(util::LineReader& reader);\n+    std::string Stringify() const;\n+\n+private:\n+    std::map<std::string, std::string, util::CaseInsensitiveComparator> m_map;",
      "path": "src/httpserver.h",
      "position": 1,
      "original_position": 90,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "`std::map` would keep the entries sorted by the key in alphabetical order and lookup time is `O(log(number of elements in the map))` whereas `std::unordered_map` does not maintain an order and has a lookup time of `O(1)`. We do not need any order here, right? This probably is irrelevant since we are only going to put a bunch of entries in this map, but anyway, if there is no reason to use `std::map` I guess we should default to `std::unordered_map`.\r\n\r\n(from commit e95c6f5b65 `http: Implement HTTPHeaders class`)",
      "created_at": "2025-06-06T07:02:12Z",
      "updated_at": "2025-06-06T07:17:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2131632124",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2131632124"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2131642866",
      "pull_request_review_id": 2903739719,
      "id": 2131642866,
      "node_id": "PRRC_kwDOABII585_Dkny",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 313,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This returns a reference (or a \"pointer\") to the outside world (from the point of view of the `HTTPHeaders` class) of an element from the private `m_map` member. That map is not immutable. What happens if the strings it contains get moved around if the map is internally resized when adding new entries? Also there is the `HTTPHeaders::Remove()` method which deletes entries from the map, rendering any returned pointers by `Find()` as dangling.\r\n\r\n54a36093f7 `http: using string_view to avoid unnecessary copy in Headers` -- if there is no any measurable performance gain from this commit then it would be safer to drop it. If there is a measurable performance gain then hmm...",
      "created_at": "2025-06-06T07:10:37Z",
      "updated_at": "2025-06-06T07:18:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2131642866",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2131642866"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 314,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 318,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152981877",
      "pull_request_review_id": 2936787243,
      "id": 2152981877,
      "node_id": "PRRC_kwDOABII586AU-V1",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)",
      "path": "test/functional/interface_http.py",
      "position": 1,
      "original_position": 35,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2090504818,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Addressed in #32408 ",
      "created_at": "2025-06-17T19:04:00Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2152981877",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152981877"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152982176",
      "pull_request_review_id": 2936787243,
      "id": 2152982176,
      "node_id": "PRRC_kwDOABII586AU-ag",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res",
      "path": "test/functional/interface_http.py",
      "position": 1,
      "original_position": 43,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2090527952,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Addressed in #32408",
      "created_at": "2025-06-17T19:04:12Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2152982176",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152982176"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152982469",
      "pull_request_review_id": 2936787243,
      "id": 2152982469,
      "node_id": "PRRC_kwDOABII586AU-fF",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]",
      "path": "test/functional/interface_http.py",
      "position": 1,
      "original_position": 72,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2090912262,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Addressed in #32408",
      "created_at": "2025-06-17T19:04:20Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2152982469",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152982469"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": 162,
      "original_start_line": 162,
      "start_side": "RIGHT",
      "line": 169,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152982779",
      "pull_request_review_id": 2936787243,
      "id": 2152982779,
      "node_id": "PRRC_kwDOABII586AU-j7",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'",
      "path": "test/functional/interface_http.py",
      "position": 1,
      "original_position": 82,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2090917556,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Addressed in #32408",
      "created_at": "2025-06-17T19:04:30Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2152982779",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152982779"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 179,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152983013",
      "pull_request_review_id": 2936787243,
      "id": 2152983013,
      "node_id": "PRRC_kwDOABII586AU-nl",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()\n+        res = sock.recv(1024)\n+        stop = time.time()\n+        assert res == b\"\"\n+        assert stop - start >= 1\n+        # definitely closed\n+        try:\n+            conn.request('GET', '/')\n+            conn.getresponse()\n+        #       macos/linux           windows\n+        except (ConnectionResetError, ConnectionAbortedError):\n+            pass",
      "path": "test/functional/interface_http.py",
      "position": 1,
      "original_position": 120,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2090840593,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Addressed in #32408",
      "created_at": "2025-06-17T19:04:38Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2152983013",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152983013"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 211,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152990633",
      "pull_request_review_id": 2936787243,
      "id": 2152990633,
      "node_id": "PRRC_kwDOABII586AVAep",
      "diff_hunk": "@@ -1045,6 +1052,26 @@ BOOST_AUTO_TEST_CASE(test_ParseUInt64)\n     BOOST_CHECK(!ParseUInt64(\"-1234\", &n));\n }\n \n+BOOST_AUTO_TEST_CASE(test_ParseUInt64Hex)\n+{\n+    uint64_t n;\n+    // Valid values\n+    BOOST_CHECK(ParseUInt64Hex(\"1234\", nullptr));\n+    BOOST_CHECK(ParseUInt64Hex(\"1234\", &n) && n == 4660);\n+    BOOST_CHECK(ParseUInt64Hex(\"a\", &n) && n == 10);\n+    BOOST_CHECK(ParseUInt64Hex(\"0000000a\", &n) && n == 10);\n+    BOOST_CHECK(ParseUInt64Hex(\"100\", &n) && n == 256);\n+    BOOST_CHECK(ParseUInt64Hex(\"DEADbeef\", &n) && n == 3735928559);\n+    BOOST_CHECK(ParseUInt64Hex(\"FfFfFfFf\", &n) && n == 4294967295);\n+    // Invalid values\n+    BOOST_CHECK(!ParseUInt64Hex(\"123456789\", &n));\n+    BOOST_CHECK(!ParseUInt64Hex(\"\", &n));\n+    BOOST_CHECK(!ParseUInt64Hex(\"-1\", &n));\n+    BOOST_CHECK(!ParseUInt64Hex(\"10 00\", &n));\n+    BOOST_CHECK(!ParseUInt64Hex(\"1 \", &n));\n+    BOOST_CHECK(!ParseUInt64Hex(\"0xAB\", &n));\n+}",
      "path": "src/test/util_tests.cpp",
      "position": 1,
      "original_position": 36,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2091083332,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "taken, thanks",
      "created_at": "2025-06-17T19:09:15Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2152990633",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152990633"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 1055,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1073,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2153038752",
      "pull_request_review_id": 2936787243,
      "id": 2153038752,
      "node_id": "PRRC_kwDOABII586AVMOg",
      "diff_hunk": "@@ -251,6 +251,24 @@ bool ParseUInt64(std::string_view str, uint64_t* out)\n     return ParseIntegral<uint64_t>(str, out);\n }\n \n+bool ParseUInt64Hex(std::string_view str, uint64_t* out)\n+{\n+    if (str.size() > 8) return false;\n+    if (str.size() < 1) return false;\n+    uint64_t total{0};\n+    auto it = str.begin();\n+    while (it != str.end()) {\n+        auto v = HexDigit(*(it++));\n+        if (v < 0) return false;\n+        total <<= 4;\n+        total |= v;\n+    }\n+    if (out != nullptr) {\n+        *out = total;\n+    }\n+    return true;\n+}",
      "path": "src/util/strencodings.cpp",
      "position": 1,
      "original_position": 20,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2091093913,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Due to https://github.com/bitcoin/bitcoin/pull/32520 I had to change this entire commit anyway. Took your suggestion about adding `base` argument here and just dropped the wrapper function. Will call `ToIntegral( ... 16)` directly when reading chunk size.",
      "created_at": "2025-06-17T19:39:08Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2153038752",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2153038752"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 254,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 270,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2153057687",
      "pull_request_review_id": 2936787243,
      "id": 2153057687,
      "node_id": "PRRC_kwDOABII586AVQ2X",
      "diff_hunk": "@@ -116,6 +119,20 @@ std::optional<int64_t> ParseISO8601DateTime(std::string_view str)\n     return int64_t{TicksSinceEpoch<std::chrono::seconds>(tp)};\n }\n \n+std::string FormatRFC7231DateTime(int64_t nTime)\n+{\n+    const std::chrono::sys_seconds secs{std::chrono::seconds{nTime}};\n+    const auto days{std::chrono::floor<std::chrono::days>(secs)};\n+    // 1970-01-01 was a Thursday\n+    std::string_view weekday{weekdays[(days.time_since_epoch().count() + 4) % 7]};",
      "path": "src/util/time.cpp",
      "position": 1,
      "original_position": 19,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2092931817,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "ah really really great suggestion thanks, taken",
      "created_at": "2025-06-17T19:56:17Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2153057687",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2153057687"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 127,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154761899",
      "pull_request_review_id": 2936787243,
      "id": 2154761899,
      "node_id": "PRRC_kwDOABII586Abw6r",
      "diff_hunk": "@@ -20,6 +20,20 @@ enum HTTPStatusCode\n     HTTP_SERVICE_UNAVAILABLE   = 503,\n };\n \n+// Copied from libevent http.c success_phrases[] and client_error_phrases[]\n+// TODO: Should HTTPStatusCode and HTTPReason be moved since they are not RPC protocols?\n+const std::map<HTTPStatusCode, std::string> HTTPReason{\n+    {HTTP_OK, \"OK\"},",
      "path": "src/rpc/protocol.h",
      "position": 1,
      "original_position": 7,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2102323308,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'm asking if both should be moved, including the generic HTTP constants. They are also used in `rest.cpp` which has to `#include <rpc/protocol.h>` even though REST is not RPC protocol. I'll remove the comment for now.",
      "created_at": "2025-06-18T14:28:24Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2154761899",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154761899"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": 20,
      "original_start_line": 20,
      "start_side": "LEFT",
      "line": 26,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154786226",
      "pull_request_review_id": 2936787243,
      "id": 2154786226,
      "node_id": "PRRC_kwDOABII586Ab22y",
      "diff_hunk": "@@ -27,168 +34,309 @@ static const int DEFAULT_HTTP_WORKQUEUE=64;\n \n static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;\n \n-struct evhttp_request;\n-struct event_base;\n-class CService;\n-class HTTPRequest;\n+enum HTTPRequestMethod {\n+    UNKNOWN,\n+    GET,\n+    POST,\n+    HEAD,\n+    PUT\n+};\n \n-/** Initialize HTTP server.\n- * Call this before RegisterHTTPHandler or EventBase().\n- */\n-bool InitHTTPServer(const util::SignalInterrupt& interrupt);\n-/** Start HTTP server.\n- * This is separate from InitHTTPServer to give users race-condition-free time\n- * to register their handlers between InitHTTPServer and StartHTTPServer.\n+/** Event handler closure.\n  */\n-void StartHTTPServer();\n-/** Interrupt HTTP server threads */\n-void InterruptHTTPServer();\n-/** Stop HTTP server */\n-void StopHTTPServer();\n+class HTTPClosure\n+{\n+public:\n+    virtual void operator()() = 0;\n+    virtual ~HTTPClosure() = default;\n+};\n \n-/** Change logging level for libevent. */\n-void UpdateHTTPServerLogging(bool enable);\n+namespace http_bitcoin {\n+using util::LineReader;\n+using NodeId = SockMan::Id;\n \n-/** Handler for requests to a certain HTTP path */\n-typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n-/** Register handler for prefix.\n- * If multiple handlers match a prefix, the first-registered one will\n- * be invoked.\n- */\n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler);\n-/** Unregister handler for prefix */\n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch);\n+// shortest valid request line, used by libevent in evhttp_parse_request_line()\n+static const size_t MIN_REQUEST_LINE_LENGTH{strlen(\"GET / HTTP/1.0\")};\n+// maximum size of http request (request line + headers)\n+// see https://github.com/bitcoin/bitcoin/issues/6425\n+static const size_t MAX_HEADERS_SIZE{8192};\n \n-/** Return evhttp event base. This can be used by submodules to\n- * queue timers or custom events.\n- */\n-struct event_base* EventBase();\n+class HTTPHeaders\n+{\n+public:\n+    std::optional<std::string_view> Find(const std::string key) const;\n+    void Write(const std::string key, const std::string value);\n+    void Remove(const std::string key);\n+    bool Read(util::LineReader& reader);\n+    std::string Stringify() const;\n+\n+private:\n+    std::map<std::string, std::string, util::CaseInsensitiveComparator> m_map;\n+};\n+\n+class HTTPResponse\n+{\n+public:\n+    int m_version_major;\n+    int m_version_minor;\n+    HTTPStatusCode m_status;\n+    std::string m_reason;\n+    HTTPHeaders m_headers;\n+    std::vector<std::byte> m_body;\n+    bool m_keep_alive{false};\n+\n+    std::string StringifyHeaders() const;\n+};\n+\n+class HTTPClient;\n \n-/** In-flight HTTP request.\n- * Thin C++ wrapper around evhttp_request.\n- */\n class HTTPRequest\n {\n-private:\n-    struct evhttp_request* req;\n-    const util::SignalInterrupt& m_interrupt;\n-    bool replySent;\n+public:\n+    std::string m_method;",
      "path": "src/httpserver.h",
      "position": 1,
      "original_position": 119,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2102548479,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "yeah good call, I will add that in to \"define HTTP request methods at module level outside of class\" (currently 7a1359064e326f2b28a1c57aaa94fdbe17f9dee2) which is a few commits ahead",
      "created_at": "2025-06-18T14:38:05Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2154786226",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154786226"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 96,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154808021",
      "pull_request_review_id": 2936787243,
      "id": 2154808021,
      "node_id": "PRRC_kwDOABII586Ab8LV",
      "diff_hunk": "@@ -35,8 +101,341 @@ BOOST_AUTO_TEST_CASE(test_query_parameters)\n     uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2\";\n     BOOST_CHECK(!GetQueryParameterFromUri(uri.c_str(), \"p1\").has_value());\n \n-    // URI with invalid characters (%) raises a runtime error regardless of which query parameter is queried\n-    uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2%\";\n-    BOOST_CHECK_EXCEPTION(GetQueryParameterFromUri(uri.c_str(), \"p1\"), std::runtime_error, HasReason(\"URI parsing failed, it likely contained RFC 3986 invalid characters\"));\n+    // Multiple parameters, some characters encoded\n+    uri = \"/rest/endpoint/someresource.json?p1=v1%20&p2=100%25\";\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p1\").value(), \"v1 \");\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p2\").value(), \"100%\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_query_parameters_bitcoin)\n+{\n+    test_query_parameters(http_bitcoin::GetQueryParameterFromUri);\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_headers_tests)\n+{\n+    {\n+        // Writing response headers\n+        HTTPHeaders headers{};\n+        BOOST_CHECK(!headers.Find(\"Cache-Control\"));\n+        headers.Write(\"Cache-Control\", \"no-cache\");\n+        // Check case-insensitive key matching\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"cache-control\").value(), \"no-cache\");\n+        // Additional values are comma-separated and appended\n+        headers.Write(\"Cache-Control\", \"no-store\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache, no-store\");\n+        // Add a few more\n+        headers.Write(\"Pie\", \"apple\");\n+        headers.Write(\"Sandwich\", \"ham\");\n+        headers.Write(\"Coffee\", \"black\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Pie\").value(), \"apple\");\n+        // Remove\n+        headers.Remove(\"Pie\");\n+        BOOST_CHECK(!headers.Find(\"Pie\"));\n+        // Combine for transmission\n+        // std::map sorts alphabetically by key, no order is specified for HTTP\n+        BOOST_CHECK_EQUAL(\n+            headers.Stringify(),\n+            \"Cache-Control: no-cache, no-store\\r\\n\"\n+            \"Coffee: black\\r\\n\"\n+            \"Sandwich: ham\\r\\n\\r\\n\");\n+    }\n+    {\n+        // Reading request headers captured from bitcoin-cli\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(\n+            \"486f73743a203132372e302e302e310d0a436f6e6e656374696f6e3a20636c6f73\"\n+            \"650d0a436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e\"\n+            \"0d0a417574686f72697a6174696f6e3a204261736963205831396a623239726157\"\n+            \"5666587a6f7a597a4a6b4e5441784e44466c4d474a69596d56684d5449354f4467\"\n+            \"334e7a49354d544d334e54526d4e54686b4e6a63324f574d775a5459785a6a677a\"\n+            \"4e5467794e7a4577595459314f47526b596a566d5a4751330d0a436f6e74656e74\"\n+            \"2d4c656e6774683a2034360d0a0d0a\").value()};\n+        util::LineReader reader(buffer, /*max_read=*/1028);\n+        HTTPHeaders headers{};\n+        headers.Read(reader);\n+        BOOST_CHECK_EQUAL(headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzozYzJkNTAxNDFlMGJiYmVhMTI5ODg3NzI5MTM3NTRmNThkNjc2OWMwZTYxZjgzNTgyNzEwYTY1OGRkYjVmZGQ3\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK(!headers.Find(\"Pizza\"));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_response_tests)\n+{\n+    // Typical HTTP 1.1 response headers\n+    HTTPHeaders headers{};\n+    headers.Write(\"Content-Type\", \"application/json\");\n+    headers.Write(\"Date\", \"Tue, 15 Oct 2024 17:54:12 GMT\");\n+    headers.Write(\"Content-Length\", \"41\");\n+    // Response points to headers which already exist because some of them\n+    // are set before we even know what the response will be.\n+    HTTPResponse res;\n+    res.m_version_major = 1;\n+    res.m_version_minor = 1;\n+    res.m_status = HTTP_OK;\n+    res.m_reason = HTTPReason.find(res.m_status)->second;\n+    res.m_body = StringToBuffer(\"{\\\"result\\\":865793,\\\"error\\\":null,\\\"id\\\":null\\\"}\");\n+    // Everything except the body, which might be raw bytes instead of a string\n+    res.m_headers = std::move(headers);\n+    BOOST_CHECK_EQUAL(\n+        res.StringifyHeaders(),\n+        \"HTTP/1.1 200 OK\\r\\n\"\n+        \"Content-Length: 41\\r\\n\"\n+        \"Content-Type: application/json\\r\\n\"\n+        \"Date: Tue, 15 Oct 2024 17:54:12 GMT\\r\\n\"\n+        \"\\r\\n\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_request_tests)\n+{\n+    {\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(full_request).value()};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"POST\");\n+        BOOST_CHECK_EQUAL(req.GetRequestMethod(), HTTPRequestMethod::POST);\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.GetURI(), \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 1);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzo5OGQ5ODQ3MWNmNjg0NzAzYTkzN2EzNzk0ZDFlODQ1NjZmYTRkZjJiMzFkYjhhODI4ZGY4MjVjOTg5ZGI4OTVl\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 46);\n+        BOOST_CHECK_EQUAL(req.m_body, \"{\\\"method\\\":\\\"getblockcount\\\",\\\"params\\\":[],\\\"id\\\":1}\\n\");\n+    }\n+    {\n+        const std::string too_short_request_line = \"GET/HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(too_short_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP / 1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/11\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/1.x\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string ok_request_line = \"GET / HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(ok_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"GET\");\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 0);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        // no body is OK\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string malformed_headers = \"GET / HTTP/1.0\\r\\nHost=127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK_THROW(req.LoadHeaders(reader), std::runtime_error);\n+    }\n+    {\n+        // We might not have received enough data from the client which is not\n+        // an error. We return false so the caller can try again later when the\n+        // buffer has more data.\n+        const std::string incomplete_headers = \"GET / HTTP/1.0\\r\\nHost: \";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(incomplete_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(!req.LoadHeaders(reader));\n+    }\n+    {\n+        const std::string no_content_length = \"GET / HTTP/1.0\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(no_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        // Don't try to read request body if Content-Length is missing\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string bad_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: eleven\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(bad_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK_THROW(req.LoadBody(reader), std::runtime_error);",
      "path": "src/test/httpserver_tests.cpp",
      "position": 1,
      "original_position": 289,
      "commit_id": "3002fbe0d97243d3534a53240d5574d0d4194bba",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2102608338,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Hm yeah I see your point, we don't validate individual headers in `LoadHeaders()`. I'll leave as is for now, for what it's worth, libevent doesn't appear to check this until `evhttp_get_body_length()` as well...",
      "created_at": "2025-06-18T14:45:51Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2154808021",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154808021"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 297,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 303,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154813241",
      "pull_request_review_id": 2936787243,
      "id": 2154813241,
      "node_id": "PRRC_kwDOABII586Ab9c5",
      "diff_hunk": "@@ -35,8 +101,341 @@ BOOST_AUTO_TEST_CASE(test_query_parameters)\n     uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2\";\n     BOOST_CHECK(!GetQueryParameterFromUri(uri.c_str(), \"p1\").has_value());\n \n-    // URI with invalid characters (%) raises a runtime error regardless of which query parameter is queried\n-    uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2%\";\n-    BOOST_CHECK_EXCEPTION(GetQueryParameterFromUri(uri.c_str(), \"p1\"), std::runtime_error, HasReason(\"URI parsing failed, it likely contained RFC 3986 invalid characters\"));\n+    // Multiple parameters, some characters encoded\n+    uri = \"/rest/endpoint/someresource.json?p1=v1%20&p2=100%25\";\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p1\").value(), \"v1 \");\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p2\").value(), \"100%\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_query_parameters_bitcoin)\n+{\n+    test_query_parameters(http_bitcoin::GetQueryParameterFromUri);\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_headers_tests)\n+{\n+    {\n+        // Writing response headers\n+        HTTPHeaders headers{};\n+        BOOST_CHECK(!headers.Find(\"Cache-Control\"));\n+        headers.Write(\"Cache-Control\", \"no-cache\");\n+        // Check case-insensitive key matching\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"cache-control\").value(), \"no-cache\");\n+        // Additional values are comma-separated and appended\n+        headers.Write(\"Cache-Control\", \"no-store\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache, no-store\");\n+        // Add a few more\n+        headers.Write(\"Pie\", \"apple\");\n+        headers.Write(\"Sandwich\", \"ham\");\n+        headers.Write(\"Coffee\", \"black\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Pie\").value(), \"apple\");\n+        // Remove\n+        headers.Remove(\"Pie\");\n+        BOOST_CHECK(!headers.Find(\"Pie\"));\n+        // Combine for transmission\n+        // std::map sorts alphabetically by key, no order is specified for HTTP\n+        BOOST_CHECK_EQUAL(\n+            headers.Stringify(),\n+            \"Cache-Control: no-cache, no-store\\r\\n\"\n+            \"Coffee: black\\r\\n\"\n+            \"Sandwich: ham\\r\\n\\r\\n\");\n+    }\n+    {\n+        // Reading request headers captured from bitcoin-cli\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(\n+            \"486f73743a203132372e302e302e310d0a436f6e6e656374696f6e3a20636c6f73\"\n+            \"650d0a436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e\"\n+            \"0d0a417574686f72697a6174696f6e3a204261736963205831396a623239726157\"\n+            \"5666587a6f7a597a4a6b4e5441784e44466c4d474a69596d56684d5449354f4467\"\n+            \"334e7a49354d544d334e54526d4e54686b4e6a63324f574d775a5459785a6a677a\"\n+            \"4e5467794e7a4577595459314f47526b596a566d5a4751330d0a436f6e74656e74\"\n+            \"2d4c656e6774683a2034360d0a0d0a\").value()};\n+        util::LineReader reader(buffer, /*max_read=*/1028);\n+        HTTPHeaders headers{};\n+        headers.Read(reader);\n+        BOOST_CHECK_EQUAL(headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzozYzJkNTAxNDFlMGJiYmVhMTI5ODg3NzI5MTM3NTRmNThkNjc2OWMwZTYxZjgzNTgyNzEwYTY1OGRkYjVmZGQ3\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK(!headers.Find(\"Pizza\"));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_response_tests)\n+{\n+    // Typical HTTP 1.1 response headers\n+    HTTPHeaders headers{};\n+    headers.Write(\"Content-Type\", \"application/json\");\n+    headers.Write(\"Date\", \"Tue, 15 Oct 2024 17:54:12 GMT\");\n+    headers.Write(\"Content-Length\", \"41\");\n+    // Response points to headers which already exist because some of them\n+    // are set before we even know what the response will be.\n+    HTTPResponse res;\n+    res.m_version_major = 1;\n+    res.m_version_minor = 1;\n+    res.m_status = HTTP_OK;\n+    res.m_reason = HTTPReason.find(res.m_status)->second;\n+    res.m_body = StringToBuffer(\"{\\\"result\\\":865793,\\\"error\\\":null,\\\"id\\\":null\\\"}\");\n+    // Everything except the body, which might be raw bytes instead of a string\n+    res.m_headers = std::move(headers);\n+    BOOST_CHECK_EQUAL(\n+        res.StringifyHeaders(),\n+        \"HTTP/1.1 200 OK\\r\\n\"\n+        \"Content-Length: 41\\r\\n\"\n+        \"Content-Type: application/json\\r\\n\"\n+        \"Date: Tue, 15 Oct 2024 17:54:12 GMT\\r\\n\"\n+        \"\\r\\n\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_request_tests)\n+{\n+    {\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(full_request).value()};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"POST\");\n+        BOOST_CHECK_EQUAL(req.GetRequestMethod(), HTTPRequestMethod::POST);\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.GetURI(), \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 1);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzo5OGQ5ODQ3MWNmNjg0NzAzYTkzN2EzNzk0ZDFlODQ1NjZmYTRkZjJiMzFkYjhhODI4ZGY4MjVjOTg5ZGI4OTVl\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 46);\n+        BOOST_CHECK_EQUAL(req.m_body, \"{\\\"method\\\":\\\"getblockcount\\\",\\\"params\\\":[],\\\"id\\\":1}\\n\");\n+    }\n+    {\n+        const std::string too_short_request_line = \"GET/HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(too_short_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP / 1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/11\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/1.x\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string ok_request_line = \"GET / HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(ok_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"GET\");\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 0);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        // no body is OK\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string malformed_headers = \"GET / HTTP/1.0\\r\\nHost=127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK_THROW(req.LoadHeaders(reader), std::runtime_error);\n+    }\n+    {\n+        // We might not have received enough data from the client which is not\n+        // an error. We return false so the caller can try again later when the\n+        // buffer has more data.\n+        const std::string incomplete_headers = \"GET / HTTP/1.0\\r\\nHost: \";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(incomplete_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(!req.LoadHeaders(reader));\n+    }\n+    {\n+        const std::string no_content_length = \"GET / HTTP/1.0\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(no_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        // Don't try to read request body if Content-Length is missing\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string bad_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: eleven\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(bad_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK_THROW(req.LoadBody(reader), std::runtime_error);\n+    }\n+    {\n+        // Content-Length indicates more data than we have in the buffer.\n+        // Again, not an error just try again later.\n+        const std::string excessive_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: 1024\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(excessive_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(!req.LoadBody(reader));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_client_server_tests)\n+{\n+    // Hard code the timestamp for the Date header in the HTTP response\n+    // Wed Dec 11 00:47:09 2024 UTC\n+    SetMockTime(1733878029);\n+\n+    // Queue of connected sockets returned by listening socket (represents network interface)\n+    std::shared_ptr<DynSock::Queue> accepted_sockets{std::make_shared<DynSock::Queue>()};\n+\n+    CreateSock = [&accepted_sockets](int, int, int) {\n+        // This is a mock Listening Socket that the HTTP server will \"bind\" to and\n+        // listen to for incoming connections. We won't need to access its I/O\n+        // pipes because we don't read or write directly to it. It will return\n+        // Connected Sockets from the queue via its Accept() method.\n+        return std::make_unique<DynSock>(std::make_shared<DynSock::Pipes>(), accepted_sockets);\n+    };\n+\n+    {\n+        // I/O pipes of one mock Connected Socket we can read and write to.\n+        std::shared_ptr<DynSock::Pipes> connected_socket_pipes(std::make_shared<DynSock::Pipes>());\n+\n+        // Insert the payload: a correctly formatted HTTP request\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(full_request).value()};\n+        connected_socket_pipes->recv.PushBytes(buffer.data(), buffer.size());\n+\n+        // Mock Connected Socket that represents a client.\n+        // It needs I/O pipes but its queue can remain empty\n+        std::unique_ptr<DynSock> connected_socket{std::make_unique<DynSock>(connected_socket_pipes, std::make_shared<DynSock::Queue>())};\n+\n+        // Prepare queue of accepted_sockets: just one connection with no data\n+        accepted_sockets->Push(std::move(connected_socket));\n+\n+        // Prepare a request handler that just stores received requests so we can examine them\n+        // Mutex is required to prevent a race between this test's main thread and the Sockman I/O loop.\n+        Mutex requests_mutex;\n+        std::deque<std::unique_ptr<HTTPRequest>> requests;",
      "path": "src/test/httpserver_tests.cpp",
      "position": 1,
      "original_position": 339,
      "commit_id": "8c81bdf2532aa1c61e25d367a480ce3aa71362ca",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2102764352,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Compiler didn't like this actually:\r\n\r\n> warning: 'guarded_by' attribute only applies to non-static data members and global variables [-Wignored-attributes]\r\n",
      "created_at": "2025-06-18T14:48:02Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2154813241",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154813241"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 352,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 353,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154855163",
      "pull_request_review_id": 2936787243,
      "id": 2154855163,
      "node_id": "PRRC_kwDOABII586AcHr7",
      "diff_hunk": "@@ -35,8 +101,341 @@ BOOST_AUTO_TEST_CASE(test_query_parameters)\n     uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2\";\n     BOOST_CHECK(!GetQueryParameterFromUri(uri.c_str(), \"p1\").has_value());\n \n-    // URI with invalid characters (%) raises a runtime error regardless of which query parameter is queried\n-    uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2%\";\n-    BOOST_CHECK_EXCEPTION(GetQueryParameterFromUri(uri.c_str(), \"p1\"), std::runtime_error, HasReason(\"URI parsing failed, it likely contained RFC 3986 invalid characters\"));\n+    // Multiple parameters, some characters encoded\n+    uri = \"/rest/endpoint/someresource.json?p1=v1%20&p2=100%25\";\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p1\").value(), \"v1 \");\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p2\").value(), \"100%\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_query_parameters_bitcoin)\n+{\n+    test_query_parameters(http_bitcoin::GetQueryParameterFromUri);\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_headers_tests)\n+{\n+    {\n+        // Writing response headers\n+        HTTPHeaders headers{};\n+        BOOST_CHECK(!headers.Find(\"Cache-Control\"));\n+        headers.Write(\"Cache-Control\", \"no-cache\");\n+        // Check case-insensitive key matching\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"cache-control\").value(), \"no-cache\");\n+        // Additional values are comma-separated and appended\n+        headers.Write(\"Cache-Control\", \"no-store\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache, no-store\");\n+        // Add a few more\n+        headers.Write(\"Pie\", \"apple\");\n+        headers.Write(\"Sandwich\", \"ham\");\n+        headers.Write(\"Coffee\", \"black\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Pie\").value(), \"apple\");\n+        // Remove\n+        headers.Remove(\"Pie\");\n+        BOOST_CHECK(!headers.Find(\"Pie\"));\n+        // Combine for transmission\n+        // std::map sorts alphabetically by key, no order is specified for HTTP\n+        BOOST_CHECK_EQUAL(\n+            headers.Stringify(),\n+            \"Cache-Control: no-cache, no-store\\r\\n\"\n+            \"Coffee: black\\r\\n\"\n+            \"Sandwich: ham\\r\\n\\r\\n\");\n+    }\n+    {\n+        // Reading request headers captured from bitcoin-cli\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(\n+            \"486f73743a203132372e302e302e310d0a436f6e6e656374696f6e3a20636c6f73\"\n+            \"650d0a436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e\"\n+            \"0d0a417574686f72697a6174696f6e3a204261736963205831396a623239726157\"\n+            \"5666587a6f7a597a4a6b4e5441784e44466c4d474a69596d56684d5449354f4467\"\n+            \"334e7a49354d544d334e54526d4e54686b4e6a63324f574d775a5459785a6a677a\"\n+            \"4e5467794e7a4577595459314f47526b596a566d5a4751330d0a436f6e74656e74\"\n+            \"2d4c656e6774683a2034360d0a0d0a\").value()};\n+        util::LineReader reader(buffer, /*max_read=*/1028);\n+        HTTPHeaders headers{};\n+        headers.Read(reader);\n+        BOOST_CHECK_EQUAL(headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzozYzJkNTAxNDFlMGJiYmVhMTI5ODg3NzI5MTM3NTRmNThkNjc2OWMwZTYxZjgzNTgyNzEwYTY1OGRkYjVmZGQ3\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK(!headers.Find(\"Pizza\"));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_response_tests)\n+{\n+    // Typical HTTP 1.1 response headers\n+    HTTPHeaders headers{};\n+    headers.Write(\"Content-Type\", \"application/json\");\n+    headers.Write(\"Date\", \"Tue, 15 Oct 2024 17:54:12 GMT\");\n+    headers.Write(\"Content-Length\", \"41\");\n+    // Response points to headers which already exist because some of them\n+    // are set before we even know what the response will be.\n+    HTTPResponse res;\n+    res.m_version_major = 1;\n+    res.m_version_minor = 1;\n+    res.m_status = HTTP_OK;\n+    res.m_reason = HTTPReason.find(res.m_status)->second;\n+    res.m_body = StringToBuffer(\"{\\\"result\\\":865793,\\\"error\\\":null,\\\"id\\\":null\\\"}\");\n+    // Everything except the body, which might be raw bytes instead of a string\n+    res.m_headers = std::move(headers);\n+    BOOST_CHECK_EQUAL(\n+        res.StringifyHeaders(),\n+        \"HTTP/1.1 200 OK\\r\\n\"\n+        \"Content-Length: 41\\r\\n\"\n+        \"Content-Type: application/json\\r\\n\"\n+        \"Date: Tue, 15 Oct 2024 17:54:12 GMT\\r\\n\"\n+        \"\\r\\n\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_request_tests)\n+{\n+    {\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(full_request).value()};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"POST\");\n+        BOOST_CHECK_EQUAL(req.GetRequestMethod(), HTTPRequestMethod::POST);\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.GetURI(), \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 1);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzo5OGQ5ODQ3MWNmNjg0NzAzYTkzN2EzNzk0ZDFlODQ1NjZmYTRkZjJiMzFkYjhhODI4ZGY4MjVjOTg5ZGI4OTVl\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 46);\n+        BOOST_CHECK_EQUAL(req.m_body, \"{\\\"method\\\":\\\"getblockcount\\\",\\\"params\\\":[],\\\"id\\\":1}\\n\");\n+    }\n+    {\n+        const std::string too_short_request_line = \"GET/HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(too_short_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP / 1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/11\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/1.x\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string ok_request_line = \"GET / HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(ok_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"GET\");\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 0);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        // no body is OK\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string malformed_headers = \"GET / HTTP/1.0\\r\\nHost=127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK_THROW(req.LoadHeaders(reader), std::runtime_error);\n+    }\n+    {\n+        // We might not have received enough data from the client which is not\n+        // an error. We return false so the caller can try again later when the\n+        // buffer has more data.\n+        const std::string incomplete_headers = \"GET / HTTP/1.0\\r\\nHost: \";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(incomplete_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(!req.LoadHeaders(reader));\n+    }\n+    {\n+        const std::string no_content_length = \"GET / HTTP/1.0\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(no_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        // Don't try to read request body if Content-Length is missing\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string bad_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: eleven\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(bad_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK_THROW(req.LoadBody(reader), std::runtime_error);\n+    }\n+    {\n+        // Content-Length indicates more data than we have in the buffer.\n+        // Again, not an error just try again later.\n+        const std::string excessive_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: 1024\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(excessive_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(!req.LoadBody(reader));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_client_server_tests)\n+{\n+    // Hard code the timestamp for the Date header in the HTTP response\n+    // Wed Dec 11 00:47:09 2024 UTC\n+    SetMockTime(1733878029);\n+\n+    // Queue of connected sockets returned by listening socket (represents network interface)\n+    std::shared_ptr<DynSock::Queue> accepted_sockets{std::make_shared<DynSock::Queue>()};\n+\n+    CreateSock = [&accepted_sockets](int, int, int) {\n+        // This is a mock Listening Socket that the HTTP server will \"bind\" to and\n+        // listen to for incoming connections. We won't need to access its I/O\n+        // pipes because we don't read or write directly to it. It will return\n+        // Connected Sockets from the queue via its Accept() method.\n+        return std::make_unique<DynSock>(std::make_shared<DynSock::Pipes>(), accepted_sockets);\n+    };\n+\n+    {\n+        // I/O pipes of one mock Connected Socket we can read and write to.\n+        std::shared_ptr<DynSock::Pipes> connected_socket_pipes(std::make_shared<DynSock::Pipes>());\n+\n+        // Insert the payload: a correctly formatted HTTP request\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(full_request).value()};\n+        connected_socket_pipes->recv.PushBytes(buffer.data(), buffer.size());\n+\n+        // Mock Connected Socket that represents a client.\n+        // It needs I/O pipes but its queue can remain empty\n+        std::unique_ptr<DynSock> connected_socket{std::make_unique<DynSock>(connected_socket_pipes, std::make_shared<DynSock::Queue>())};\n+\n+        // Prepare queue of accepted_sockets: just one connection with no data\n+        accepted_sockets->Push(std::move(connected_socket));\n+\n+        // Prepare a request handler that just stores received requests so we can examine them\n+        // Mutex is required to prevent a race between this test's main thread and the Sockman I/O loop.\n+        Mutex requests_mutex;\n+        std::deque<std::unique_ptr<HTTPRequest>> requests;\n+        auto StoreRequest = [&](std::unique_ptr<HTTPRequest> req) {",
      "path": "src/test/httpserver_tests.cpp",
      "position": 1,
      "original_position": 340,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2102772840,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Agreed this better, thanks.",
      "created_at": "2025-06-18T15:03:55Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2154855163",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154855163"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154902000",
      "pull_request_review_id": 2936787243,
      "id": 2154902000,
      "node_id": "PRRC_kwDOABII586AcTHw",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {",
      "path": "src/httpserver.cpp",
      "position": 478,
      "original_position": 448,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2128494930,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "That was merged in https://github.com/bitcoin/bitcoin/pull/32408 unless you mean a unit test?",
      "created_at": "2025-06-18T15:22:56Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2154902000",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154902000"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 385,
      "original_line": 419,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154905083",
      "pull_request_review_id": 2936787243,
      "id": 2154905083,
      "node_id": "PRRC_kwDOABII586AcT37",
      "diff_hunk": "@@ -27,168 +34,309 @@ static const int DEFAULT_HTTP_WORKQUEUE=64;\n \n static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;\n \n-struct evhttp_request;\n-struct event_base;\n-class CService;\n-class HTTPRequest;\n+enum HTTPRequestMethod {\n+    UNKNOWN,\n+    GET,\n+    POST,\n+    HEAD,\n+    PUT\n+};\n \n-/** Initialize HTTP server.\n- * Call this before RegisterHTTPHandler or EventBase().\n- */\n-bool InitHTTPServer(const util::SignalInterrupt& interrupt);\n-/** Start HTTP server.\n- * This is separate from InitHTTPServer to give users race-condition-free time\n- * to register their handlers between InitHTTPServer and StartHTTPServer.\n+/** Event handler closure.\n  */\n-void StartHTTPServer();\n-/** Interrupt HTTP server threads */\n-void InterruptHTTPServer();\n-/** Stop HTTP server */\n-void StopHTTPServer();\n+class HTTPClosure\n+{\n+public:\n+    virtual void operator()() = 0;\n+    virtual ~HTTPClosure() = default;\n+};\n \n-/** Change logging level for libevent. */\n-void UpdateHTTPServerLogging(bool enable);\n+namespace http_bitcoin {\n+using util::LineReader;\n+using NodeId = SockMan::Id;\n \n-/** Handler for requests to a certain HTTP path */\n-typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n-/** Register handler for prefix.\n- * If multiple handlers match a prefix, the first-registered one will\n- * be invoked.\n- */\n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler);\n-/** Unregister handler for prefix */\n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch);\n+// shortest valid request line, used by libevent in evhttp_parse_request_line()\n+static const size_t MIN_REQUEST_LINE_LENGTH{strlen(\"GET / HTTP/1.0\")};\n+// maximum size of http request (request line + headers)\n+// see https://github.com/bitcoin/bitcoin/issues/6425\n+static const size_t MAX_HEADERS_SIZE{8192};\n \n-/** Return evhttp event base. This can be used by submodules to\n- * queue timers or custom events.\n- */\n-struct event_base* EventBase();\n+class HTTPHeaders\n+{\n+public:\n+    std::optional<std::string_view> Find(const std::string key) const;\n+    void Write(const std::string key, const std::string value);\n+    void Remove(const std::string key);\n+    bool Read(util::LineReader& reader);\n+    std::string Stringify() const;\n+\n+private:\n+    std::map<std::string, std::string, util::CaseInsensitiveComparator> m_map;\n+};\n+\n+class HTTPResponse\n+{\n+public:\n+    int m_version_major;\n+    int m_version_minor;\n+    HTTPStatusCode m_status;\n+    std::string m_reason;\n+    HTTPHeaders m_headers;\n+    std::vector<std::byte> m_body;\n+    bool m_keep_alive{false};\n+\n+    std::string StringifyHeaders() const;\n+};\n+\n+class HTTPClient;\n \n-/** In-flight HTTP request.\n- * Thin C++ wrapper around evhttp_request.\n- */\n class HTTPRequest\n {\n-private:\n-    struct evhttp_request* req;\n-    const util::SignalInterrupt& m_interrupt;\n-    bool replySent;\n+public:\n+    std::string m_method;\n+    std::string m_target;\n+    // Default protocol version is used by error responses to unreadable requests\n+    int m_version_major{1};\n+    int m_version_minor{1};\n+    HTTPHeaders m_headers;\n+    std::string m_body;\n+\n+    // Keep a pointer to the client that made the request so\n+    // we know who to respond to.\n+    std::shared_ptr<HTTPClient> m_client;\n+    explicit HTTPRequest(std::shared_ptr<HTTPClient> client) : m_client(client) {};\n+    // Null client for unit tests\n+    explicit HTTPRequest() : m_client(nullptr) {};\n+\n+    // Readers return false if they need more data from the\n+    // socket to parse properly. They throw errors if\n+    // the data is invalid.\n+    bool LoadControlData(LineReader& reader);\n+    bool LoadHeaders(LineReader& reader);\n+    bool LoadBody(LineReader& reader);\n+\n+    // These methods reimplement the API from http_libevent::HTTPRequest\n+    // for downstream JSONRPC and REST modules.\n+    std::string GetURI() const {return m_target;};\n+    CService GetPeer() const;\n+    HTTPRequestMethod GetRequestMethod() const;\n+    std::optional<std::string> GetQueryParameter(const std::string& key) const;\n+    std::pair<bool, std::string_view> GetHeader(const std::string& hdr) const;\n+    std::string ReadBody() const {return m_body;};\n+    void WriteHeader(const std::string& hdr, const std::string& value);\n+\n+    // Response headers may be set in advance before response body is known\n+    HTTPHeaders m_response_headers;\n+    void WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body = {});\n+    void WriteReply(HTTPStatusCode status, std::string_view reply_body_view)\n+    {\n+        WriteReply(status, std::as_bytes(std::span{reply_body_view}));\n+    }\n+};\n+\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key);\n+\n+class HTTPServer;\n \n+class HTTPClient\n+{\n public:\n-    explicit HTTPRequest(struct evhttp_request* req, const util::SignalInterrupt& interrupt, bool replySent = false);\n-    ~HTTPRequest();\n-\n-    enum RequestMethod {\n-        UNKNOWN,\n-        GET,\n-        POST,\n-        HEAD,\n-        PUT\n+    // ID provided by SockMan, inherited by HTTPServer\n+    NodeId m_node_id;\n+    // Remote address of connected client\n+    CService m_addr;\n+    // IP:port of connected client, cached for logging purposes\n+    std::string m_origin;\n+    // Pointer back to the server so we can call Sockman I/O methods from the client\n+    // Ok to remain null for unit tests.\n+    HTTPServer* m_server;\n+\n+    // In lieu of an intermediate transport class like p2p uses,\n+    // we copy data from the socket buffer to the client object\n+    // and attempt to read HTTP requests from here.\n+    std::vector<std::byte> m_recv_buffer{};\n+\n+    // Requests from a client must be processed in the order in which\n+    // they were received, blocking on a per-client basis. We won't\n+    // process the next request in the queue if we are currently busy\n+    // handling a previous request.\n+    std::deque<std::unique_ptr<HTTPRequest>> m_req_queue;\n+    // Set to true by the main thread when a request is popped off\n+    // and passed to a worker, reset to false by the worker thread.\n+    std::atomic_bool m_req_busy{false};\n+\n+    // Response data destined for this client.\n+    // Written to directly by http worker threads, read and erased by Sockman I/O\n+    Mutex m_send_mutex;\n+    std::vector<std::byte> m_send_buffer GUARDED_BY(m_send_mutex);\n+    // Set true by worker threads after writing a response to m_send_buffer.\n+    // Set false by the Sockman I/O thread after flushing m_send_buffer.\n+    // Checked in the Sockman I/O loop to avoid locking m_send_mutex if there's nothing to send.\n+    std::atomic_bool m_send_ready{false};\n+\n+    // Set to true when we receive request data and set to false once m_send_buffer is cleared.\n+    // Checked during DisconnectClients(). All of these operations take place in the Sockman I/O loop,\n+    // however it may get set my a worker thread during an \"optimistic send\".\n+    std::atomic_bool m_prevent_disconnect{false};\n+\n+    // Client request to keep connection open after all requests have been responded to.",
      "path": "src/httpserver.h",
      "position": 1,
      "original_position": 214,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2128628047,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "ðŸ‘ ",
      "created_at": "2025-06-18T15:24:21Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2154905083",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154905083"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155072446",
      "pull_request_review_id": 2936787243,
      "id": 2155072446,
      "node_id": "PRRC_kwDOABII586Ac8u-",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {\n+        // Transfer-Encoding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-3.3.1\n+        // Chunked Transfer Coding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-4.1\n+        // see evhttp_handle_chunked_read() in libevent http.c\n+        while (reader.Left() > 0) {\n+            auto maybe_chunk_size = reader.ReadLine();\n+            if (!maybe_chunk_size) return false;\n+            uint64_t chunk_size;\n+\n+            if (!ParseUInt64Hex(maybe_chunk_size.value(), &chunk_size)) throw std::runtime_error(\"Invalid chunk size\");\n+\n+            bool last_chunk{chunk_size == 0};\n+\n+            if (!last_chunk) {\n+                // We are still expecting more data for this chunk\n+                if (reader.Left() < chunk_size) {\n+                    return false;\n+                }\n+                // Pack chunk onto body\n+                m_body += reader.ReadLength(chunk_size);\n+            }\n+\n+            // Even though every chunk size is explicitly declared,\n+            // they are still terminated by a CRLF we don't need.\n+            auto crlf = reader.ReadLine();\n+            if (!crlf || crlf.value().size() != 0) throw std::runtime_error(\"Improperly terminated chunk\");\n+\n+            if (last_chunk) return true;\n+        }\n+\n+        // We read all the chunks but never got the last chunk, wait for client to send more\n+        return false;\n     } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+        // No Content-length or Transfer-Encoding header means no body, see libevent evhttp_get_body()\n+        auto content_length_value{m_headers.Find(\"Content-Length\")};\n+        if (!content_length_value) return true;\n+\n+        uint64_t content_length;\n+        if (!ParseUInt64(content_length_value.value(), &content_length)) throw std::runtime_error(\"Cannot parse Content-Length value\");\n+\n+        // Not enough data in buffer for expected body\n+        if (reader.Left() < content_length) return false;\n+\n+        m_body = reader.ReadLength(content_length);\n+\n+        return true;\n     }\n }\n \n-static std::thread g_thread_http;\n-static std::vector<std::thread> g_thread_http_workers;\n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n \n-void StartHTTPServer()\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n {\n-    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n-    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n-    g_thread_http = std::thread(ThreadHTTP, eventBase);\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n \n-    for (int i = 0; i < rpcThreads; i++) {\n-        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string_view query{decoded_uri.data() + start + 1, end - start - 1};\n+    // find requested parameter in query\n+    const std::vector<std::string_view> params{Split<std::string_view>(query, \"&\")};\n+    for (const std::string_view& param : params) {\n+        size_t delim = param.find('=');\n+        if (key == param.substr(0, delim)) {\n+            if (delim == std::string::npos) {\n+                return \"\";\n+            } else {\n+                return std::string(param.substr(delim + 1));\n+            }\n+        }\n     }\n+    return std::nullopt;\n }\n \n-void InterruptHTTPServer()\n+std::pair<bool, std::string_view> HTTPRequest::GetHeader(const std::string& hdr) const\n {\n-    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n-    if (eventHTTP) {\n-        // Reject requests on current connections\n-        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n-    }\n-    if (g_work_queue) {\n-        g_work_queue->Interrupt();\n-    }\n+    std::optional<std::string_view> found{m_headers.Find(hdr)};\n+    if (found.has_value()) {\n+        return std::make_pair(true, found.value());\n+    } else\n+        return std::make_pair(false, \"\");\n }\n \n-void StopHTTPServer()\n+void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n {\n-    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n-    if (g_work_queue) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n-        for (auto& thread : g_thread_http_workers) {\n-            thread.join();\n+    m_response_headers.Write(hdr, value);\n+}\n+\n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n         }\n-        g_thread_http_workers.clear();\n     }\n-    // Unlisten sockets, these are what make the event loop running, which means\n-    // that after this and all connections are closed the event loop will quit.\n-    for (evhttp_bound_socket *socket : boundSockets) {\n-        evhttp_del_accept_socket(eventHTTP, socket);\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n     }\n-    boundSockets.clear();\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    m_client->m_keep_alive = res.m_keep_alive;\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    bool send_buffer_was_empty{false};\n+    // Fill the send buffer with the complete serialized response headers + body\n     {\n-        if (const auto n_connections{g_requests.CountActiveConnections()}; n_connections != 0) {\n-            LogDebug(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections);\n-        }\n-        g_requests.WaitUntilEmpty();\n-    }\n-    if (eventHTTP) {\n-        // Schedule a callback to call evhttp_free in the event base thread, so\n-        // that evhttp_free does not need to be called again after the handling\n-        // of unfinished request connections that follows.\n-        event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {\n-            evhttp_free(eventHTTP);\n-            eventHTTP = nullptr;\n-        }, nullptr, nullptr);\n-    }\n-    if (eventBase) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n-        if (g_thread_http.joinable()) g_thread_http.join();\n-        event_base_free(eventBase);\n-        eventBase = nullptr;\n-    }\n-    g_work_queue.reset();\n-    LogDebug(BCLog::HTTP, \"Stopped HTTP server\\n\");\n-}\n+        LOCK(m_client->m_send_mutex);\n+        send_buffer_was_empty = m_client->m_send_buffer.empty();\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());\n+    }\n+\n+    LogDebug(\n+        BCLog::HTTP,\n+        \"HTTPResponse (status code: %d size: %lld) added to send buffer for client %s (id=%lld)\\n\",\n+        status,\n+        headers_bytes.size() + reply_body.size(),\n+        m_client->m_origin,\n+        m_client->m_node_id);\n+\n+    // If the send buffer was empty before we wrote this reply, we can try an\n+    // optimistic send akin to CConnman::PushMessage() in which we\n+    // push the data directly out the socket to client right now, instead\n+    // of waiting for the next iteration of the Sockman I/O loop.\n+    if (send_buffer_was_empty) {\n+        m_client->SendBytesFromBuffer();\n+    } else {\n+        // Inform Sockman I/O there is data that is ready to be sent to this client\n+        // in the next loop iteration.\n+        m_client->m_send_ready = true;\n+    }\n \n-struct event_base* EventBase()\n-{\n-    return eventBase;\n+    // Signal to the Sockman I/O loop that we are ready to handle the next request.\n+    m_client->m_req_busy = false;\n }\n \n-static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n+bool HTTPClient::ReadRequest(std::unique_ptr<HTTPRequest>& req)\n {\n-    // Static handler: simply call inner handler\n-    HTTPEvent *self = static_cast<HTTPEvent*>(data);\n-    self->handler();\n-    if (self->deleteWhenTriggered)\n-        delete self;\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(\n+        m_recv_buffer.begin(),\n+        m_recv_buffer.begin() + (reader.it - reader.start));\n+\n+    return true;\n }\n \n-HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):\n-    deleteWhenTriggered(_deleteWhenTriggered), handler(_handler)\n-{\n-    ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n-    assert(ev);\n+bool HTTPClient::SendBytesFromBuffer()\n+{\n+    Assume(m_server);\n+\n+    // Send as much data from this client's buffer as we can\n+    LOCK(m_send_mutex);\n+    if (!m_send_buffer.empty()) {\n+        std::string err;\n+        // We don't intend to \"send more\" because http responses are usually small and we want the kernel to send them right away.\n+        ssize_t bytes_sent = m_server->SendBytes(m_node_id, MakeUCharSpan(m_send_buffer), /*will_send_more=*/false, err);\n+        if (bytes_sent < 0) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error sending HTTP response data to client %s (id=%lld): %s\\n\",\n+                m_origin,\n+                m_node_id,\n+                err);\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+            m_disconnect = true;\n+            return false;\n+        }\n+\n+        Assume(static_cast<size_t>(bytes_sent) <= m_send_buffer.size());\n+        m_send_buffer.erase(m_send_buffer.begin(), m_send_buffer.begin() + bytes_sent);\n+\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Sent %d bytes to client %s (id=%lld)\\n\",\n+            bytes_sent,\n+            m_origin,\n+            m_node_id);\n+\n+        // This check is inside the if(!empty) block meaning \"there was data but now its gone\".\n+        // We shouldn't even be calling SendBytesFromBuffer() when the send buffer is empty,\n+        // but for belt-and-suspenders, we don't want to modify the disconnect flags if SendBytesFromBuffer() was a no-op.\n+        if (m_send_buffer.empty()) {\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+\n+            // Our work is done here\n+            if (!m_keep_alive) {\n+                m_disconnect = true;\n+                return false;\n+            }\n+        } else {\n+            m_send_ready = true;\n+            m_prevent_disconnect = true;\n+        }\n+    }\n+\n+    return true;\n }\n-HTTPEvent::~HTTPEvent()\n+\n+void HTTPServer::CloseConnectionInternal(std::shared_ptr<HTTPClient>& client)\n {\n-    event_free(ev);\n+    if (CloseConnection(client->m_node_id)) {\n+        LogDebug(BCLog::HTTP, \"Disconnected HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    } else {\n+        LogDebug(BCLog::HTTP, \"Failed to disconnect non-existent HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    }\n }\n-void HTTPEvent::trigger(struct timeval* tv)\n+\n+void HTTPServer::DisconnectClients()\n {\n-    if (tv == nullptr)\n-        event_active(ev, 0, 0); // immediately trigger event in main thread\n-    else\n-        evtimer_add(ev, tv); // trigger after timeval passed\n+    const auto now{Now<SteadySeconds>()};\n+    for (auto it = m_connected_clients.begin(); it != m_connected_clients.end();) {\n+        bool timeout{now - it->second->m_idle_since > m_rpcservertimeout};\n+        if (((it->second->m_disconnect || m_disconnect_all_clients) && !it->second->m_prevent_disconnect)\n+            || timeout) {\n+            CloseConnectionInternal(it->second);\n+            it = m_connected_clients.erase(it);\n+        } else {\n+            ++it;\n+        }\n+    }\n+    m_no_clients = m_connected_clients.size() == 0;\n }\n-HTTPRequest::HTTPRequest(struct evhttp_request* _req, const util::SignalInterrupt& interrupt, bool _replySent)\n-    : req(_req), m_interrupt(interrupt), replySent(_replySent)\n+\n+bool HTTPServer::EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them)\n {\n+    auto client = std::make_shared<HTTPClient>(node_id, them);\n+    // Point back to the server\n+    client->m_server = this;\n+    // Set timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+    LogDebug(BCLog::HTTP, \"HTTP Connection accepted from %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    m_connected_clients.emplace(client->m_node_id, std::move(client));\n+    m_no_clients = false;\n+    return true;\n }\n \n-HTTPRequest::~HTTPRequest()\n+void HTTPServer::EventReadyToSend(NodeId node_id, bool& cancel_recv)\n {\n-    if (!replySent) {\n-        // Keep track of whether reply was sent to avoid request leaks\n-        LogPrintf(\"%s: Unhandled request\\n\", __func__);\n-        WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\");\n+    // Next attempt to receive data from this node is permitted\n+    cancel_recv = false;\n+\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n     }\n-    // evhttpd cleans up the request, as long as a reply was sent.\n+\n+    // SendBytesFromBuffer() returns true if we should keep the client around,\n+    // false if we are done with it. Invert that boolean to inform Sockman\n+    // whether it should cancel the next receive attempt from this client.\n+    cancel_recv = !client->SendBytesFromBuffer();\n }\n \n-std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const\n+void HTTPServer::EventGotData(NodeId node_id, std::span<const uint8_t> data)\n {\n-    const struct evkeyvalq* headers = evhttp_request_get_input_headers(req);\n-    assert(headers);\n-    const char* val = evhttp_find_header(headers, hdr.c_str());\n-    if (val)\n-        return std::make_pair(true, val);\n-    else\n-        return std::make_pair(false, \"\");\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    // Reset idle timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+\n+    // Prevent disconnect until all requests are completely handled.\n+    client->m_prevent_disconnect = true;\n+\n+    // Copy data from socket buffer to client receive buffer\n+    client->m_recv_buffer.insert(\n+        client->m_recv_buffer.end(),\n+        reinterpret_cast<const std::byte*>(data.data()),\n+        reinterpret_cast<const std::byte*>(data.data() + data.size())\n+    );\n+\n+    // Try reading (potentially multiple) HTTP requests from the buffer\n+    while (client->m_recv_buffer.size() > 0) {\n+        // Create a new request object and try to fill it with data from the receive buffer\n+        auto req = std::make_unique<HTTPRequest>(client);\n+        try {\n+            // Stop reading if we need more data from the client to parse a complete request\n+            if (!client->ReadRequest(req)) break;\n+        } catch (const std::runtime_error& e) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error reading HTTP request from client %s (id=%lld): %s\\n\",\n+                client->m_origin,\n+                client->m_node_id,\n+                e.what());\n+\n+            // We failed to read a complete request from the buffer\n+            req->WriteReply(HTTP_BAD_REQUEST);\n+            client->m_disconnect = true;\n+            break;\n+        }\n+\n+        // We read a complete request from the buffer into the queue\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Received a %s request for %s from %s (id=%lld)\\n\",\n+            req->m_method,\n+            req->m_target,\n+            req->m_client->m_origin,\n+            req->m_client->m_node_id);\n+\n+        // add request to client queue\n+        client->m_req_queue.push_back(std::move(req));\n+    }\n }\n \n-std::string HTTPRequest::ReadBody()\n+void HTTPServer::EventGotEOF(NodeId node_id)\n {\n-    struct evbuffer* buf = evhttp_request_get_input_buffer(req);\n-    if (!buf)\n-        return \"\";\n-    size_t size = evbuffer_get_length(buf);\n-    /** Trivial implementation: if this is ever a performance bottleneck,\n-     * internal copying can be avoided in multi-segment buffers by using\n-     * evbuffer_peek and an awkward loop. Though in that case, it'd be even\n-     * better to not copy into an intermediate string but use a stream\n-     * abstraction to consume the evbuffer on the fly in the parsing algorithm.\n-     */\n-    const char* data = (const char*)evbuffer_pullup(buf, size);\n-    if (!data) // returns nullptr in case of empty buffer\n-        return \"\";\n-    std::string rv(data, size);\n-    evbuffer_drain(buf, size);\n-    return rv;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    client->m_disconnect = true;\n }\n \n-void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n+void HTTPServer::EventGotPermanentReadError(NodeId node_id, const std::string& errmsg)\n {\n-    struct evkeyvalq* headers = evhttp_request_get_output_headers(req);\n-    assert(headers);\n-    evhttp_add_header(headers, hdr.c_str(), value.c_str());\n-}\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-/** Closure sent to main thread to request a reply to be sent to\n- * a HTTP request.\n- * Replies must be sent in the main loop in the main http thread,\n- * this cannot be done from worker threads.\n- */\n-void HTTPRequest::WriteReply(int nStatus, std::span<const std::byte> reply)\n-{\n-    assert(!replySent && req);\n-    if (m_interrupt) {\n-        WriteHeader(\"Connection\", \"close\");\n-    }\n-    // Send event to main http thread to send reply message\n-    struct evbuffer* evb = evhttp_request_get_output_buffer(req);\n-    assert(evb);\n-    evbuffer_add(evb, reply.data(), reply.size());\n-    auto req_copy = req;\n-    HTTPEvent* ev = new HTTPEvent(eventBase, true, [req_copy, nStatus]{\n-        evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);\n-        // Re-enable reading from the socket. This is the second part of the libevent\n-        // workaround above.\n-        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02010900) {\n-            evhttp_connection* conn = evhttp_request_get_connection(req_copy);\n-            if (conn) {\n-                bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n-                if (bev) {\n-                    bufferevent_enable(bev, EV_READ | EV_WRITE);\n-                }\n-            }\n-        }\n-    });\n-    ev->trigger(nullptr);\n-    replySent = true;\n-    req = nullptr; // transferred back to main thread\n+    client->m_disconnect = true;\n }\n \n-CService HTTPRequest::GetPeer() const\n+void HTTPServer::EventIOLoopCompletedForOne(NodeId node_id)\n {\n-    evhttp_connection* con = evhttp_request_get_connection(req);\n-    CService peer;\n-    if (con) {\n-        // evhttp retains ownership over returned address string\n-        const char* address = \"\";\n-        uint16_t port = 0;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-#ifdef HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n-        evhttp_connection_get_peer(con, &address, &port);\n-#else\n-        evhttp_connection_get_peer(con, (char**)&address, &port);\n-#endif // HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n+    // If we are already handling a request from\n+    // this client, do nothing.\n+    if (client->m_req_busy) return;\n \n-        peer = MaybeFlipIPv6toCJDNS(LookupNumeric(address, port));\n+    // Otherwise, if there is a new pending request, handle it.\n+    if (!client->m_req_queue.empty()) {\n+        client->m_req_busy = true;\n+        m_request_dispatcher(std::move(client->m_req_queue.front()));\n+        client->m_req_queue.pop_front();\n     }\n-    return peer;\n }\n \n-std::string HTTPRequest::GetURI() const\n+void HTTPServer::EventIOLoopCompletedForAll()\n {\n-    return evhttp_request_get_uri(req);\n+    DisconnectClients();\n }\n \n-HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod() const\n+bool HTTPServer::ShouldTryToSend(NodeId node_id) const\n {\n-    switch (evhttp_request_get_command(req)) {\n-    case EVHTTP_REQ_GET:\n-        return GET;\n-    case EVHTTP_REQ_POST:\n-        return POST;\n-    case EVHTTP_REQ_HEAD:\n-        return HEAD;\n-    case EVHTTP_REQ_PUT:\n-        return PUT;\n-    default:\n-        return UNKNOWN;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n     }\n+\n+    return client->m_send_ready;\n }\n \n-std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+bool HTTPServer::ShouldTryToRecv(NodeId node_id) const\n {\n-    const char* uri{evhttp_request_get_uri(req)};\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n+    }\n \n-    return GetQueryParameterFromUri(uri, key);\n+    // Don't try to receive again until we've cleared the send buffer to this client\n+    return !client->m_send_ready;\n }\n \n-std::optional<std::string> GetQueryParameterFromUri(const char* uri, const std::string& key)\n+std::shared_ptr<HTTPClient> HTTPServer::GetClientById(NodeId node_id) const\n {\n-    evhttp_uri* uri_parsed{evhttp_uri_parse(uri)};\n-    if (!uri_parsed) {\n-        throw std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\");\n+    auto it{m_connected_clients.find(node_id)};\n+    if (it != m_connected_clients.end()) {\n+        return it->second;\n     }\n-    const char* query{evhttp_uri_get_query(uri_parsed)};\n-    std::optional<std::string> result;\n+    return nullptr;\n+}\n \n-    if (query) {\n-        // Parse the query string into a key-value queue and iterate over it\n-        struct evkeyvalq params_q;\n-        evhttp_parse_query_str(query, &params_q);\n+bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+{\n+    if (!InitHTTPAllowList())\n+        return false;",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 1114,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2128770318,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "ðŸ‘ ",
      "created_at": "2025-06-18T16:43:19Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2155072446",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155072446"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 898,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 899,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155072993",
      "pull_request_review_id": 2936787243,
      "id": 2155072993,
      "node_id": "PRRC_kwDOABII586Ac83h",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {\n+        // Transfer-Encoding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-3.3.1\n+        // Chunked Transfer Coding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-4.1\n+        // see evhttp_handle_chunked_read() in libevent http.c\n+        while (reader.Left() > 0) {\n+            auto maybe_chunk_size = reader.ReadLine();\n+            if (!maybe_chunk_size) return false;\n+            uint64_t chunk_size;\n+\n+            if (!ParseUInt64Hex(maybe_chunk_size.value(), &chunk_size)) throw std::runtime_error(\"Invalid chunk size\");\n+\n+            bool last_chunk{chunk_size == 0};\n+\n+            if (!last_chunk) {\n+                // We are still expecting more data for this chunk\n+                if (reader.Left() < chunk_size) {\n+                    return false;\n+                }\n+                // Pack chunk onto body\n+                m_body += reader.ReadLength(chunk_size);\n+            }\n+\n+            // Even though every chunk size is explicitly declared,\n+            // they are still terminated by a CRLF we don't need.\n+            auto crlf = reader.ReadLine();\n+            if (!crlf || crlf.value().size() != 0) throw std::runtime_error(\"Improperly terminated chunk\");\n+\n+            if (last_chunk) return true;\n+        }\n+\n+        // We read all the chunks but never got the last chunk, wait for client to send more\n+        return false;\n     } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+        // No Content-length or Transfer-Encoding header means no body, see libevent evhttp_get_body()\n+        auto content_length_value{m_headers.Find(\"Content-Length\")};\n+        if (!content_length_value) return true;\n+\n+        uint64_t content_length;\n+        if (!ParseUInt64(content_length_value.value(), &content_length)) throw std::runtime_error(\"Cannot parse Content-Length value\");\n+\n+        // Not enough data in buffer for expected body\n+        if (reader.Left() < content_length) return false;\n+\n+        m_body = reader.ReadLength(content_length);\n+\n+        return true;\n     }\n }\n \n-static std::thread g_thread_http;\n-static std::vector<std::thread> g_thread_http_workers;\n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n \n-void StartHTTPServer()\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n {\n-    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n-    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n-    g_thread_http = std::thread(ThreadHTTP, eventBase);\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n \n-    for (int i = 0; i < rpcThreads; i++) {\n-        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string_view query{decoded_uri.data() + start + 1, end - start - 1};\n+    // find requested parameter in query\n+    const std::vector<std::string_view> params{Split<std::string_view>(query, \"&\")};\n+    for (const std::string_view& param : params) {\n+        size_t delim = param.find('=');\n+        if (key == param.substr(0, delim)) {\n+            if (delim == std::string::npos) {\n+                return \"\";\n+            } else {\n+                return std::string(param.substr(delim + 1));\n+            }\n+        }\n     }\n+    return std::nullopt;\n }\n \n-void InterruptHTTPServer()\n+std::pair<bool, std::string_view> HTTPRequest::GetHeader(const std::string& hdr) const\n {\n-    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n-    if (eventHTTP) {\n-        // Reject requests on current connections\n-        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n-    }\n-    if (g_work_queue) {\n-        g_work_queue->Interrupt();\n-    }\n+    std::optional<std::string_view> found{m_headers.Find(hdr)};\n+    if (found.has_value()) {\n+        return std::make_pair(true, found.value());\n+    } else\n+        return std::make_pair(false, \"\");\n }\n \n-void StopHTTPServer()\n+void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n {\n-    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n-    if (g_work_queue) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n-        for (auto& thread : g_thread_http_workers) {\n-            thread.join();\n+    m_response_headers.Write(hdr, value);\n+}\n+\n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n         }\n-        g_thread_http_workers.clear();\n     }\n-    // Unlisten sockets, these are what make the event loop running, which means\n-    // that after this and all connections are closed the event loop will quit.\n-    for (evhttp_bound_socket *socket : boundSockets) {\n-        evhttp_del_accept_socket(eventHTTP, socket);\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n     }\n-    boundSockets.clear();\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    m_client->m_keep_alive = res.m_keep_alive;\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    bool send_buffer_was_empty{false};\n+    // Fill the send buffer with the complete serialized response headers + body\n     {\n-        if (const auto n_connections{g_requests.CountActiveConnections()}; n_connections != 0) {\n-            LogDebug(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections);\n-        }\n-        g_requests.WaitUntilEmpty();\n-    }\n-    if (eventHTTP) {\n-        // Schedule a callback to call evhttp_free in the event base thread, so\n-        // that evhttp_free does not need to be called again after the handling\n-        // of unfinished request connections that follows.\n-        event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {\n-            evhttp_free(eventHTTP);\n-            eventHTTP = nullptr;\n-        }, nullptr, nullptr);\n-    }\n-    if (eventBase) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n-        if (g_thread_http.joinable()) g_thread_http.join();\n-        event_base_free(eventBase);\n-        eventBase = nullptr;\n-    }\n-    g_work_queue.reset();\n-    LogDebug(BCLog::HTTP, \"Stopped HTTP server\\n\");\n-}\n+        LOCK(m_client->m_send_mutex);\n+        send_buffer_was_empty = m_client->m_send_buffer.empty();\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());\n+    }\n+\n+    LogDebug(\n+        BCLog::HTTP,\n+        \"HTTPResponse (status code: %d size: %lld) added to send buffer for client %s (id=%lld)\\n\",\n+        status,\n+        headers_bytes.size() + reply_body.size(),\n+        m_client->m_origin,\n+        m_client->m_node_id);\n+\n+    // If the send buffer was empty before we wrote this reply, we can try an\n+    // optimistic send akin to CConnman::PushMessage() in which we\n+    // push the data directly out the socket to client right now, instead\n+    // of waiting for the next iteration of the Sockman I/O loop.\n+    if (send_buffer_was_empty) {\n+        m_client->SendBytesFromBuffer();\n+    } else {\n+        // Inform Sockman I/O there is data that is ready to be sent to this client\n+        // in the next loop iteration.\n+        m_client->m_send_ready = true;\n+    }\n \n-struct event_base* EventBase()\n-{\n-    return eventBase;\n+    // Signal to the Sockman I/O loop that we are ready to handle the next request.\n+    m_client->m_req_busy = false;\n }\n \n-static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n+bool HTTPClient::ReadRequest(std::unique_ptr<HTTPRequest>& req)\n {\n-    // Static handler: simply call inner handler\n-    HTTPEvent *self = static_cast<HTTPEvent*>(data);\n-    self->handler();\n-    if (self->deleteWhenTriggered)\n-        delete self;\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(\n+        m_recv_buffer.begin(),\n+        m_recv_buffer.begin() + (reader.it - reader.start));\n+\n+    return true;\n }\n \n-HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):\n-    deleteWhenTriggered(_deleteWhenTriggered), handler(_handler)\n-{\n-    ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n-    assert(ev);\n+bool HTTPClient::SendBytesFromBuffer()\n+{\n+    Assume(m_server);\n+\n+    // Send as much data from this client's buffer as we can\n+    LOCK(m_send_mutex);\n+    if (!m_send_buffer.empty()) {\n+        std::string err;\n+        // We don't intend to \"send more\" because http responses are usually small and we want the kernel to send them right away.\n+        ssize_t bytes_sent = m_server->SendBytes(m_node_id, MakeUCharSpan(m_send_buffer), /*will_send_more=*/false, err);\n+        if (bytes_sent < 0) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error sending HTTP response data to client %s (id=%lld): %s\\n\",\n+                m_origin,\n+                m_node_id,\n+                err);\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+            m_disconnect = true;\n+            return false;\n+        }\n+\n+        Assume(static_cast<size_t>(bytes_sent) <= m_send_buffer.size());\n+        m_send_buffer.erase(m_send_buffer.begin(), m_send_buffer.begin() + bytes_sent);\n+\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Sent %d bytes to client %s (id=%lld)\\n\",\n+            bytes_sent,\n+            m_origin,\n+            m_node_id);\n+\n+        // This check is inside the if(!empty) block meaning \"there was data but now its gone\".\n+        // We shouldn't even be calling SendBytesFromBuffer() when the send buffer is empty,\n+        // but for belt-and-suspenders, we don't want to modify the disconnect flags if SendBytesFromBuffer() was a no-op.\n+        if (m_send_buffer.empty()) {\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+\n+            // Our work is done here\n+            if (!m_keep_alive) {\n+                m_disconnect = true;\n+                return false;\n+            }\n+        } else {\n+            m_send_ready = true;\n+            m_prevent_disconnect = true;\n+        }\n+    }\n+\n+    return true;\n }\n-HTTPEvent::~HTTPEvent()\n+\n+void HTTPServer::CloseConnectionInternal(std::shared_ptr<HTTPClient>& client)\n {\n-    event_free(ev);\n+    if (CloseConnection(client->m_node_id)) {\n+        LogDebug(BCLog::HTTP, \"Disconnected HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    } else {\n+        LogDebug(BCLog::HTTP, \"Failed to disconnect non-existent HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    }\n }\n-void HTTPEvent::trigger(struct timeval* tv)\n+\n+void HTTPServer::DisconnectClients()\n {\n-    if (tv == nullptr)\n-        event_active(ev, 0, 0); // immediately trigger event in main thread\n-    else\n-        evtimer_add(ev, tv); // trigger after timeval passed\n+    const auto now{Now<SteadySeconds>()};\n+    for (auto it = m_connected_clients.begin(); it != m_connected_clients.end();) {\n+        bool timeout{now - it->second->m_idle_since > m_rpcservertimeout};\n+        if (((it->second->m_disconnect || m_disconnect_all_clients) && !it->second->m_prevent_disconnect)\n+            || timeout) {\n+            CloseConnectionInternal(it->second);\n+            it = m_connected_clients.erase(it);\n+        } else {\n+            ++it;\n+        }\n+    }\n+    m_no_clients = m_connected_clients.size() == 0;\n }\n-HTTPRequest::HTTPRequest(struct evhttp_request* _req, const util::SignalInterrupt& interrupt, bool _replySent)\n-    : req(_req), m_interrupt(interrupt), replySent(_replySent)\n+\n+bool HTTPServer::EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them)\n {\n+    auto client = std::make_shared<HTTPClient>(node_id, them);\n+    // Point back to the server\n+    client->m_server = this;\n+    // Set timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+    LogDebug(BCLog::HTTP, \"HTTP Connection accepted from %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    m_connected_clients.emplace(client->m_node_id, std::move(client));\n+    m_no_clients = false;\n+    return true;\n }\n \n-HTTPRequest::~HTTPRequest()\n+void HTTPServer::EventReadyToSend(NodeId node_id, bool& cancel_recv)\n {\n-    if (!replySent) {\n-        // Keep track of whether reply was sent to avoid request leaks\n-        LogPrintf(\"%s: Unhandled request\\n\", __func__);\n-        WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\");\n+    // Next attempt to receive data from this node is permitted\n+    cancel_recv = false;\n+\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n     }\n-    // evhttpd cleans up the request, as long as a reply was sent.\n+\n+    // SendBytesFromBuffer() returns true if we should keep the client around,\n+    // false if we are done with it. Invert that boolean to inform Sockman\n+    // whether it should cancel the next receive attempt from this client.\n+    cancel_recv = !client->SendBytesFromBuffer();\n }\n \n-std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const\n+void HTTPServer::EventGotData(NodeId node_id, std::span<const uint8_t> data)\n {\n-    const struct evkeyvalq* headers = evhttp_request_get_input_headers(req);\n-    assert(headers);\n-    const char* val = evhttp_find_header(headers, hdr.c_str());\n-    if (val)\n-        return std::make_pair(true, val);\n-    else\n-        return std::make_pair(false, \"\");\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    // Reset idle timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+\n+    // Prevent disconnect until all requests are completely handled.\n+    client->m_prevent_disconnect = true;\n+\n+    // Copy data from socket buffer to client receive buffer\n+    client->m_recv_buffer.insert(\n+        client->m_recv_buffer.end(),\n+        reinterpret_cast<const std::byte*>(data.data()),\n+        reinterpret_cast<const std::byte*>(data.data() + data.size())\n+    );\n+\n+    // Try reading (potentially multiple) HTTP requests from the buffer\n+    while (client->m_recv_buffer.size() > 0) {\n+        // Create a new request object and try to fill it with data from the receive buffer\n+        auto req = std::make_unique<HTTPRequest>(client);\n+        try {\n+            // Stop reading if we need more data from the client to parse a complete request\n+            if (!client->ReadRequest(req)) break;\n+        } catch (const std::runtime_error& e) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error reading HTTP request from client %s (id=%lld): %s\\n\",\n+                client->m_origin,\n+                client->m_node_id,\n+                e.what());\n+\n+            // We failed to read a complete request from the buffer\n+            req->WriteReply(HTTP_BAD_REQUEST);\n+            client->m_disconnect = true;\n+            break;\n+        }\n+\n+        // We read a complete request from the buffer into the queue\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Received a %s request for %s from %s (id=%lld)\\n\",\n+            req->m_method,\n+            req->m_target,\n+            req->m_client->m_origin,\n+            req->m_client->m_node_id);\n+\n+        // add request to client queue\n+        client->m_req_queue.push_back(std::move(req));\n+    }\n }\n \n-std::string HTTPRequest::ReadBody()\n+void HTTPServer::EventGotEOF(NodeId node_id)\n {\n-    struct evbuffer* buf = evhttp_request_get_input_buffer(req);\n-    if (!buf)\n-        return \"\";\n-    size_t size = evbuffer_get_length(buf);\n-    /** Trivial implementation: if this is ever a performance bottleneck,\n-     * internal copying can be avoided in multi-segment buffers by using\n-     * evbuffer_peek and an awkward loop. Though in that case, it'd be even\n-     * better to not copy into an intermediate string but use a stream\n-     * abstraction to consume the evbuffer on the fly in the parsing algorithm.\n-     */\n-    const char* data = (const char*)evbuffer_pullup(buf, size);\n-    if (!data) // returns nullptr in case of empty buffer\n-        return \"\";\n-    std::string rv(data, size);\n-    evbuffer_drain(buf, size);\n-    return rv;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    client->m_disconnect = true;\n }\n \n-void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n+void HTTPServer::EventGotPermanentReadError(NodeId node_id, const std::string& errmsg)\n {\n-    struct evkeyvalq* headers = evhttp_request_get_output_headers(req);\n-    assert(headers);\n-    evhttp_add_header(headers, hdr.c_str(), value.c_str());\n-}\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-/** Closure sent to main thread to request a reply to be sent to\n- * a HTTP request.\n- * Replies must be sent in the main loop in the main http thread,\n- * this cannot be done from worker threads.\n- */\n-void HTTPRequest::WriteReply(int nStatus, std::span<const std::byte> reply)\n-{\n-    assert(!replySent && req);\n-    if (m_interrupt) {\n-        WriteHeader(\"Connection\", \"close\");\n-    }\n-    // Send event to main http thread to send reply message\n-    struct evbuffer* evb = evhttp_request_get_output_buffer(req);\n-    assert(evb);\n-    evbuffer_add(evb, reply.data(), reply.size());\n-    auto req_copy = req;\n-    HTTPEvent* ev = new HTTPEvent(eventBase, true, [req_copy, nStatus]{\n-        evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);\n-        // Re-enable reading from the socket. This is the second part of the libevent\n-        // workaround above.\n-        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02010900) {\n-            evhttp_connection* conn = evhttp_request_get_connection(req_copy);\n-            if (conn) {\n-                bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n-                if (bev) {\n-                    bufferevent_enable(bev, EV_READ | EV_WRITE);\n-                }\n-            }\n-        }\n-    });\n-    ev->trigger(nullptr);\n-    replySent = true;\n-    req = nullptr; // transferred back to main thread\n+    client->m_disconnect = true;\n }\n \n-CService HTTPRequest::GetPeer() const\n+void HTTPServer::EventIOLoopCompletedForOne(NodeId node_id)\n {\n-    evhttp_connection* con = evhttp_request_get_connection(req);\n-    CService peer;\n-    if (con) {\n-        // evhttp retains ownership over returned address string\n-        const char* address = \"\";\n-        uint16_t port = 0;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-#ifdef HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n-        evhttp_connection_get_peer(con, &address, &port);\n-#else\n-        evhttp_connection_get_peer(con, (char**)&address, &port);\n-#endif // HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n+    // If we are already handling a request from\n+    // this client, do nothing.\n+    if (client->m_req_busy) return;\n \n-        peer = MaybeFlipIPv6toCJDNS(LookupNumeric(address, port));\n+    // Otherwise, if there is a new pending request, handle it.\n+    if (!client->m_req_queue.empty()) {\n+        client->m_req_busy = true;\n+        m_request_dispatcher(std::move(client->m_req_queue.front()));\n+        client->m_req_queue.pop_front();\n     }\n-    return peer;\n }\n \n-std::string HTTPRequest::GetURI() const\n+void HTTPServer::EventIOLoopCompletedForAll()\n {\n-    return evhttp_request_get_uri(req);\n+    DisconnectClients();\n }\n \n-HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod() const\n+bool HTTPServer::ShouldTryToSend(NodeId node_id) const\n {\n-    switch (evhttp_request_get_command(req)) {\n-    case EVHTTP_REQ_GET:\n-        return GET;\n-    case EVHTTP_REQ_POST:\n-        return POST;\n-    case EVHTTP_REQ_HEAD:\n-        return HEAD;\n-    case EVHTTP_REQ_PUT:\n-        return PUT;\n-    default:\n-        return UNKNOWN;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n     }\n+\n+    return client->m_send_ready;\n }\n \n-std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+bool HTTPServer::ShouldTryToRecv(NodeId node_id) const\n {\n-    const char* uri{evhttp_request_get_uri(req)};\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n+    }\n \n-    return GetQueryParameterFromUri(uri, key);\n+    // Don't try to receive again until we've cleared the send buffer to this client\n+    return !client->m_send_ready;\n }\n \n-std::optional<std::string> GetQueryParameterFromUri(const char* uri, const std::string& key)\n+std::shared_ptr<HTTPClient> HTTPServer::GetClientById(NodeId node_id) const\n {\n-    evhttp_uri* uri_parsed{evhttp_uri_parse(uri)};\n-    if (!uri_parsed) {\n-        throw std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\");\n+    auto it{m_connected_clients.find(node_id)};\n+    if (it != m_connected_clients.end()) {\n+        return it->second;\n     }\n-    const char* query{evhttp_uri_get_query(uri_parsed)};\n-    std::optional<std::string> result;\n+    return nullptr;\n+}\n \n-    if (query) {\n-        // Parse the query string into a key-value queue and iterate over it\n-        struct evkeyvalq params_q;\n-        evhttp_parse_query_str(query, &params_q);\n+bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+{\n+    if (!InitHTTPAllowList())\n+        return false;\n \n-        for (struct evkeyval* param{params_q.tqh_first}; param != nullptr; param = param->next.tqe_next) {\n-            if (param->key == key) {\n-                result = param->value;\n-                break;\n+    // Create HTTPServer\n+    g_http_server = std::make_unique<HTTPServer>(MaybeDispatchRequestToWorker);\n+\n+    g_http_server->m_rpcservertimeout = std::chrono::seconds(gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n+\n+    // Bind HTTP server to specified addresses\n+    std::vector<std::pair<std::string, uint16_t>> endpoints{GetBindAddresses()};\n+    bool bind_success{false};\n+    for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 1128,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2128776391,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "ðŸ‘ ",
      "created_at": "2025-06-18T16:43:38Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2155072993",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155072993"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 909,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155074456",
      "pull_request_review_id": 2936787243,
      "id": 2155074456,
      "node_id": "PRRC_kwDOABII586Ac9OY",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {\n+        // Transfer-Encoding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-3.3.1\n+        // Chunked Transfer Coding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-4.1\n+        // see evhttp_handle_chunked_read() in libevent http.c\n+        while (reader.Left() > 0) {\n+            auto maybe_chunk_size = reader.ReadLine();\n+            if (!maybe_chunk_size) return false;\n+            uint64_t chunk_size;\n+\n+            if (!ParseUInt64Hex(maybe_chunk_size.value(), &chunk_size)) throw std::runtime_error(\"Invalid chunk size\");\n+\n+            bool last_chunk{chunk_size == 0};\n+\n+            if (!last_chunk) {\n+                // We are still expecting more data for this chunk\n+                if (reader.Left() < chunk_size) {\n+                    return false;\n+                }\n+                // Pack chunk onto body\n+                m_body += reader.ReadLength(chunk_size);\n+            }\n+\n+            // Even though every chunk size is explicitly declared,\n+            // they are still terminated by a CRLF we don't need.\n+            auto crlf = reader.ReadLine();\n+            if (!crlf || crlf.value().size() != 0) throw std::runtime_error(\"Improperly terminated chunk\");\n+\n+            if (last_chunk) return true;\n+        }\n+\n+        // We read all the chunks but never got the last chunk, wait for client to send more\n+        return false;\n     } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+        // No Content-length or Transfer-Encoding header means no body, see libevent evhttp_get_body()\n+        auto content_length_value{m_headers.Find(\"Content-Length\")};\n+        if (!content_length_value) return true;\n+\n+        uint64_t content_length;\n+        if (!ParseUInt64(content_length_value.value(), &content_length)) throw std::runtime_error(\"Cannot parse Content-Length value\");\n+\n+        // Not enough data in buffer for expected body\n+        if (reader.Left() < content_length) return false;\n+\n+        m_body = reader.ReadLength(content_length);\n+\n+        return true;\n     }\n }\n \n-static std::thread g_thread_http;\n-static std::vector<std::thread> g_thread_http_workers;\n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n \n-void StartHTTPServer()\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n {\n-    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n-    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n-    g_thread_http = std::thread(ThreadHTTP, eventBase);\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n \n-    for (int i = 0; i < rpcThreads; i++) {\n-        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string_view query{decoded_uri.data() + start + 1, end - start - 1};\n+    // find requested parameter in query\n+    const std::vector<std::string_view> params{Split<std::string_view>(query, \"&\")};\n+    for (const std::string_view& param : params) {\n+        size_t delim = param.find('=');\n+        if (key == param.substr(0, delim)) {\n+            if (delim == std::string::npos) {\n+                return \"\";\n+            } else {\n+                return std::string(param.substr(delim + 1));\n+            }\n+        }\n     }\n+    return std::nullopt;\n }\n \n-void InterruptHTTPServer()\n+std::pair<bool, std::string_view> HTTPRequest::GetHeader(const std::string& hdr) const\n {\n-    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n-    if (eventHTTP) {\n-        // Reject requests on current connections\n-        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n-    }\n-    if (g_work_queue) {\n-        g_work_queue->Interrupt();\n-    }\n+    std::optional<std::string_view> found{m_headers.Find(hdr)};\n+    if (found.has_value()) {\n+        return std::make_pair(true, found.value());\n+    } else\n+        return std::make_pair(false, \"\");\n }\n \n-void StopHTTPServer()\n+void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n {\n-    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n-    if (g_work_queue) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n-        for (auto& thread : g_thread_http_workers) {\n-            thread.join();\n+    m_response_headers.Write(hdr, value);\n+}\n+\n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n         }\n-        g_thread_http_workers.clear();\n     }\n-    // Unlisten sockets, these are what make the event loop running, which means\n-    // that after this and all connections are closed the event loop will quit.\n-    for (evhttp_bound_socket *socket : boundSockets) {\n-        evhttp_del_accept_socket(eventHTTP, socket);\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n     }\n-    boundSockets.clear();\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    m_client->m_keep_alive = res.m_keep_alive;\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    bool send_buffer_was_empty{false};\n+    // Fill the send buffer with the complete serialized response headers + body\n     {\n-        if (const auto n_connections{g_requests.CountActiveConnections()}; n_connections != 0) {\n-            LogDebug(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections);\n-        }\n-        g_requests.WaitUntilEmpty();\n-    }\n-    if (eventHTTP) {\n-        // Schedule a callback to call evhttp_free in the event base thread, so\n-        // that evhttp_free does not need to be called again after the handling\n-        // of unfinished request connections that follows.\n-        event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {\n-            evhttp_free(eventHTTP);\n-            eventHTTP = nullptr;\n-        }, nullptr, nullptr);\n-    }\n-    if (eventBase) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n-        if (g_thread_http.joinable()) g_thread_http.join();\n-        event_base_free(eventBase);\n-        eventBase = nullptr;\n-    }\n-    g_work_queue.reset();\n-    LogDebug(BCLog::HTTP, \"Stopped HTTP server\\n\");\n-}\n+        LOCK(m_client->m_send_mutex);\n+        send_buffer_was_empty = m_client->m_send_buffer.empty();\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());\n+    }\n+\n+    LogDebug(\n+        BCLog::HTTP,\n+        \"HTTPResponse (status code: %d size: %lld) added to send buffer for client %s (id=%lld)\\n\",\n+        status,\n+        headers_bytes.size() + reply_body.size(),\n+        m_client->m_origin,\n+        m_client->m_node_id);\n+\n+    // If the send buffer was empty before we wrote this reply, we can try an\n+    // optimistic send akin to CConnman::PushMessage() in which we\n+    // push the data directly out the socket to client right now, instead\n+    // of waiting for the next iteration of the Sockman I/O loop.\n+    if (send_buffer_was_empty) {\n+        m_client->SendBytesFromBuffer();\n+    } else {\n+        // Inform Sockman I/O there is data that is ready to be sent to this client\n+        // in the next loop iteration.\n+        m_client->m_send_ready = true;\n+    }\n \n-struct event_base* EventBase()\n-{\n-    return eventBase;\n+    // Signal to the Sockman I/O loop that we are ready to handle the next request.\n+    m_client->m_req_busy = false;\n }\n \n-static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n+bool HTTPClient::ReadRequest(std::unique_ptr<HTTPRequest>& req)\n {\n-    // Static handler: simply call inner handler\n-    HTTPEvent *self = static_cast<HTTPEvent*>(data);\n-    self->handler();\n-    if (self->deleteWhenTriggered)\n-        delete self;\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(\n+        m_recv_buffer.begin(),\n+        m_recv_buffer.begin() + (reader.it - reader.start));\n+\n+    return true;\n }\n \n-HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):\n-    deleteWhenTriggered(_deleteWhenTriggered), handler(_handler)\n-{\n-    ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n-    assert(ev);\n+bool HTTPClient::SendBytesFromBuffer()\n+{\n+    Assume(m_server);\n+\n+    // Send as much data from this client's buffer as we can\n+    LOCK(m_send_mutex);\n+    if (!m_send_buffer.empty()) {\n+        std::string err;\n+        // We don't intend to \"send more\" because http responses are usually small and we want the kernel to send them right away.\n+        ssize_t bytes_sent = m_server->SendBytes(m_node_id, MakeUCharSpan(m_send_buffer), /*will_send_more=*/false, err);\n+        if (bytes_sent < 0) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error sending HTTP response data to client %s (id=%lld): %s\\n\",\n+                m_origin,\n+                m_node_id,\n+                err);\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+            m_disconnect = true;\n+            return false;\n+        }\n+\n+        Assume(static_cast<size_t>(bytes_sent) <= m_send_buffer.size());\n+        m_send_buffer.erase(m_send_buffer.begin(), m_send_buffer.begin() + bytes_sent);\n+\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Sent %d bytes to client %s (id=%lld)\\n\",\n+            bytes_sent,\n+            m_origin,\n+            m_node_id);\n+\n+        // This check is inside the if(!empty) block meaning \"there was data but now its gone\".\n+        // We shouldn't even be calling SendBytesFromBuffer() when the send buffer is empty,\n+        // but for belt-and-suspenders, we don't want to modify the disconnect flags if SendBytesFromBuffer() was a no-op.\n+        if (m_send_buffer.empty()) {\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+\n+            // Our work is done here\n+            if (!m_keep_alive) {\n+                m_disconnect = true;\n+                return false;\n+            }\n+        } else {\n+            m_send_ready = true;\n+            m_prevent_disconnect = true;\n+        }\n+    }\n+\n+    return true;\n }\n-HTTPEvent::~HTTPEvent()\n+\n+void HTTPServer::CloseConnectionInternal(std::shared_ptr<HTTPClient>& client)\n {\n-    event_free(ev);\n+    if (CloseConnection(client->m_node_id)) {\n+        LogDebug(BCLog::HTTP, \"Disconnected HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    } else {\n+        LogDebug(BCLog::HTTP, \"Failed to disconnect non-existent HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    }\n }\n-void HTTPEvent::trigger(struct timeval* tv)\n+\n+void HTTPServer::DisconnectClients()\n {\n-    if (tv == nullptr)\n-        event_active(ev, 0, 0); // immediately trigger event in main thread\n-    else\n-        evtimer_add(ev, tv); // trigger after timeval passed\n+    const auto now{Now<SteadySeconds>()};\n+    for (auto it = m_connected_clients.begin(); it != m_connected_clients.end();) {\n+        bool timeout{now - it->second->m_idle_since > m_rpcservertimeout};\n+        if (((it->second->m_disconnect || m_disconnect_all_clients) && !it->second->m_prevent_disconnect)\n+            || timeout) {\n+            CloseConnectionInternal(it->second);\n+            it = m_connected_clients.erase(it);\n+        } else {\n+            ++it;\n+        }\n+    }\n+    m_no_clients = m_connected_clients.size() == 0;\n }\n-HTTPRequest::HTTPRequest(struct evhttp_request* _req, const util::SignalInterrupt& interrupt, bool _replySent)\n-    : req(_req), m_interrupt(interrupt), replySent(_replySent)\n+\n+bool HTTPServer::EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them)\n {\n+    auto client = std::make_shared<HTTPClient>(node_id, them);\n+    // Point back to the server\n+    client->m_server = this;\n+    // Set timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+    LogDebug(BCLog::HTTP, \"HTTP Connection accepted from %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    m_connected_clients.emplace(client->m_node_id, std::move(client));\n+    m_no_clients = false;\n+    return true;\n }\n \n-HTTPRequest::~HTTPRequest()\n+void HTTPServer::EventReadyToSend(NodeId node_id, bool& cancel_recv)\n {\n-    if (!replySent) {\n-        // Keep track of whether reply was sent to avoid request leaks\n-        LogPrintf(\"%s: Unhandled request\\n\", __func__);\n-        WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\");\n+    // Next attempt to receive data from this node is permitted\n+    cancel_recv = false;\n+\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n     }\n-    // evhttpd cleans up the request, as long as a reply was sent.\n+\n+    // SendBytesFromBuffer() returns true if we should keep the client around,\n+    // false if we are done with it. Invert that boolean to inform Sockman\n+    // whether it should cancel the next receive attempt from this client.\n+    cancel_recv = !client->SendBytesFromBuffer();\n }\n \n-std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const\n+void HTTPServer::EventGotData(NodeId node_id, std::span<const uint8_t> data)\n {\n-    const struct evkeyvalq* headers = evhttp_request_get_input_headers(req);\n-    assert(headers);\n-    const char* val = evhttp_find_header(headers, hdr.c_str());\n-    if (val)\n-        return std::make_pair(true, val);\n-    else\n-        return std::make_pair(false, \"\");\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    // Reset idle timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+\n+    // Prevent disconnect until all requests are completely handled.\n+    client->m_prevent_disconnect = true;\n+\n+    // Copy data from socket buffer to client receive buffer\n+    client->m_recv_buffer.insert(\n+        client->m_recv_buffer.end(),\n+        reinterpret_cast<const std::byte*>(data.data()),\n+        reinterpret_cast<const std::byte*>(data.data() + data.size())\n+    );\n+\n+    // Try reading (potentially multiple) HTTP requests from the buffer\n+    while (client->m_recv_buffer.size() > 0) {\n+        // Create a new request object and try to fill it with data from the receive buffer\n+        auto req = std::make_unique<HTTPRequest>(client);\n+        try {\n+            // Stop reading if we need more data from the client to parse a complete request\n+            if (!client->ReadRequest(req)) break;\n+        } catch (const std::runtime_error& e) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error reading HTTP request from client %s (id=%lld): %s\\n\",\n+                client->m_origin,\n+                client->m_node_id,\n+                e.what());\n+\n+            // We failed to read a complete request from the buffer\n+            req->WriteReply(HTTP_BAD_REQUEST);\n+            client->m_disconnect = true;\n+            break;\n+        }\n+\n+        // We read a complete request from the buffer into the queue\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Received a %s request for %s from %s (id=%lld)\\n\",\n+            req->m_method,\n+            req->m_target,\n+            req->m_client->m_origin,\n+            req->m_client->m_node_id);\n+\n+        // add request to client queue\n+        client->m_req_queue.push_back(std::move(req));\n+    }\n }\n \n-std::string HTTPRequest::ReadBody()\n+void HTTPServer::EventGotEOF(NodeId node_id)\n {\n-    struct evbuffer* buf = evhttp_request_get_input_buffer(req);\n-    if (!buf)\n-        return \"\";\n-    size_t size = evbuffer_get_length(buf);\n-    /** Trivial implementation: if this is ever a performance bottleneck,\n-     * internal copying can be avoided in multi-segment buffers by using\n-     * evbuffer_peek and an awkward loop. Though in that case, it'd be even\n-     * better to not copy into an intermediate string but use a stream\n-     * abstraction to consume the evbuffer on the fly in the parsing algorithm.\n-     */\n-    const char* data = (const char*)evbuffer_pullup(buf, size);\n-    if (!data) // returns nullptr in case of empty buffer\n-        return \"\";\n-    std::string rv(data, size);\n-    evbuffer_drain(buf, size);\n-    return rv;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    client->m_disconnect = true;\n }\n \n-void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n+void HTTPServer::EventGotPermanentReadError(NodeId node_id, const std::string& errmsg)\n {\n-    struct evkeyvalq* headers = evhttp_request_get_output_headers(req);\n-    assert(headers);\n-    evhttp_add_header(headers, hdr.c_str(), value.c_str());\n-}\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-/** Closure sent to main thread to request a reply to be sent to\n- * a HTTP request.\n- * Replies must be sent in the main loop in the main http thread,\n- * this cannot be done from worker threads.\n- */\n-void HTTPRequest::WriteReply(int nStatus, std::span<const std::byte> reply)\n-{\n-    assert(!replySent && req);\n-    if (m_interrupt) {\n-        WriteHeader(\"Connection\", \"close\");\n-    }\n-    // Send event to main http thread to send reply message\n-    struct evbuffer* evb = evhttp_request_get_output_buffer(req);\n-    assert(evb);\n-    evbuffer_add(evb, reply.data(), reply.size());\n-    auto req_copy = req;\n-    HTTPEvent* ev = new HTTPEvent(eventBase, true, [req_copy, nStatus]{\n-        evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);\n-        // Re-enable reading from the socket. This is the second part of the libevent\n-        // workaround above.\n-        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02010900) {\n-            evhttp_connection* conn = evhttp_request_get_connection(req_copy);\n-            if (conn) {\n-                bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n-                if (bev) {\n-                    bufferevent_enable(bev, EV_READ | EV_WRITE);\n-                }\n-            }\n-        }\n-    });\n-    ev->trigger(nullptr);\n-    replySent = true;\n-    req = nullptr; // transferred back to main thread\n+    client->m_disconnect = true;\n }\n \n-CService HTTPRequest::GetPeer() const\n+void HTTPServer::EventIOLoopCompletedForOne(NodeId node_id)\n {\n-    evhttp_connection* con = evhttp_request_get_connection(req);\n-    CService peer;\n-    if (con) {\n-        // evhttp retains ownership over returned address string\n-        const char* address = \"\";\n-        uint16_t port = 0;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-#ifdef HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n-        evhttp_connection_get_peer(con, &address, &port);\n-#else\n-        evhttp_connection_get_peer(con, (char**)&address, &port);\n-#endif // HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n+    // If we are already handling a request from\n+    // this client, do nothing.\n+    if (client->m_req_busy) return;\n \n-        peer = MaybeFlipIPv6toCJDNS(LookupNumeric(address, port));\n+    // Otherwise, if there is a new pending request, handle it.\n+    if (!client->m_req_queue.empty()) {\n+        client->m_req_busy = true;\n+        m_request_dispatcher(std::move(client->m_req_queue.front()));\n+        client->m_req_queue.pop_front();\n     }\n-    return peer;\n }\n \n-std::string HTTPRequest::GetURI() const\n+void HTTPServer::EventIOLoopCompletedForAll()\n {\n-    return evhttp_request_get_uri(req);\n+    DisconnectClients();\n }\n \n-HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod() const\n+bool HTTPServer::ShouldTryToSend(NodeId node_id) const\n {\n-    switch (evhttp_request_get_command(req)) {\n-    case EVHTTP_REQ_GET:\n-        return GET;\n-    case EVHTTP_REQ_POST:\n-        return POST;\n-    case EVHTTP_REQ_HEAD:\n-        return HEAD;\n-    case EVHTTP_REQ_PUT:\n-        return PUT;\n-    default:\n-        return UNKNOWN;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n     }\n+\n+    return client->m_send_ready;\n }\n \n-std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+bool HTTPServer::ShouldTryToRecv(NodeId node_id) const\n {\n-    const char* uri{evhttp_request_get_uri(req)};\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n+    }\n \n-    return GetQueryParameterFromUri(uri, key);\n+    // Don't try to receive again until we've cleared the send buffer to this client\n+    return !client->m_send_ready;\n }\n \n-std::optional<std::string> GetQueryParameterFromUri(const char* uri, const std::string& key)\n+std::shared_ptr<HTTPClient> HTTPServer::GetClientById(NodeId node_id) const\n {\n-    evhttp_uri* uri_parsed{evhttp_uri_parse(uri)};\n-    if (!uri_parsed) {\n-        throw std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\");\n+    auto it{m_connected_clients.find(node_id)};\n+    if (it != m_connected_clients.end()) {\n+        return it->second;\n     }\n-    const char* query{evhttp_uri_get_query(uri_parsed)};\n-    std::optional<std::string> result;\n+    return nullptr;\n+}\n \n-    if (query) {\n-        // Parse the query string into a key-value queue and iterate over it\n-        struct evkeyvalq params_q;\n-        evhttp_parse_query_str(query, &params_q);\n+bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+{\n+    if (!InitHTTPAllowList())\n+        return false;\n \n-        for (struct evkeyval* param{params_q.tqh_first}; param != nullptr; param = param->next.tqe_next) {\n-            if (param->key == key) {\n-                result = param->value;\n-                break;\n+    // Create HTTPServer\n+    g_http_server = std::make_unique<HTTPServer>(MaybeDispatchRequestToWorker);\n+\n+    g_http_server->m_rpcservertimeout = std::chrono::seconds(gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n+\n+    // Bind HTTP server to specified addresses\n+    std::vector<std::pair<std::string, uint16_t>> endpoints{GetBindAddresses()};\n+    bool bind_success{false};\n+    for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\n+        LogPrintf(\"Binding RPC on address %s port %i\\n\", i->first, i->second);\n+        const std::optional<CService> addr{Lookup(i->first, i->second, false)};\n+        if (addr) {\n+            if (addr->IsBindAny()) {\n+                LogPrintf(\"WARNING: the RPC server is not safe to expose to untrusted networks such as the public internet\\n\");",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 1133,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2128778896,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "good catch thanks",
      "created_at": "2025-06-18T16:44:27Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2155074456",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155074456"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 914,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155084860",
      "pull_request_review_id": 2936787243,
      "id": 2155084860,
      "node_id": "PRRC_kwDOABII586Ac_w8",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {\n+        // Transfer-Encoding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-3.3.1\n+        // Chunked Transfer Coding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-4.1\n+        // see evhttp_handle_chunked_read() in libevent http.c\n+        while (reader.Left() > 0) {\n+            auto maybe_chunk_size = reader.ReadLine();\n+            if (!maybe_chunk_size) return false;\n+            uint64_t chunk_size;\n+\n+            if (!ParseUInt64Hex(maybe_chunk_size.value(), &chunk_size)) throw std::runtime_error(\"Invalid chunk size\");\n+\n+            bool last_chunk{chunk_size == 0};\n+\n+            if (!last_chunk) {\n+                // We are still expecting more data for this chunk\n+                if (reader.Left() < chunk_size) {\n+                    return false;\n+                }\n+                // Pack chunk onto body\n+                m_body += reader.ReadLength(chunk_size);\n+            }\n+\n+            // Even though every chunk size is explicitly declared,\n+            // they are still terminated by a CRLF we don't need.\n+            auto crlf = reader.ReadLine();\n+            if (!crlf || crlf.value().size() != 0) throw std::runtime_error(\"Improperly terminated chunk\");\n+\n+            if (last_chunk) return true;\n+        }\n+\n+        // We read all the chunks but never got the last chunk, wait for client to send more\n+        return false;\n     } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+        // No Content-length or Transfer-Encoding header means no body, see libevent evhttp_get_body()\n+        auto content_length_value{m_headers.Find(\"Content-Length\")};\n+        if (!content_length_value) return true;\n+\n+        uint64_t content_length;\n+        if (!ParseUInt64(content_length_value.value(), &content_length)) throw std::runtime_error(\"Cannot parse Content-Length value\");\n+\n+        // Not enough data in buffer for expected body\n+        if (reader.Left() < content_length) return false;\n+\n+        m_body = reader.ReadLength(content_length);\n+\n+        return true;\n     }\n }\n \n-static std::thread g_thread_http;\n-static std::vector<std::thread> g_thread_http_workers;\n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n \n-void StartHTTPServer()\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n {\n-    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n-    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n-    g_thread_http = std::thread(ThreadHTTP, eventBase);\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n \n-    for (int i = 0; i < rpcThreads; i++) {\n-        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string_view query{decoded_uri.data() + start + 1, end - start - 1};\n+    // find requested parameter in query\n+    const std::vector<std::string_view> params{Split<std::string_view>(query, \"&\")};\n+    for (const std::string_view& param : params) {\n+        size_t delim = param.find('=');\n+        if (key == param.substr(0, delim)) {\n+            if (delim == std::string::npos) {\n+                return \"\";\n+            } else {\n+                return std::string(param.substr(delim + 1));\n+            }\n+        }\n     }\n+    return std::nullopt;\n }\n \n-void InterruptHTTPServer()\n+std::pair<bool, std::string_view> HTTPRequest::GetHeader(const std::string& hdr) const\n {\n-    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n-    if (eventHTTP) {\n-        // Reject requests on current connections\n-        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n-    }\n-    if (g_work_queue) {\n-        g_work_queue->Interrupt();\n-    }\n+    std::optional<std::string_view> found{m_headers.Find(hdr)};\n+    if (found.has_value()) {\n+        return std::make_pair(true, found.value());\n+    } else\n+        return std::make_pair(false, \"\");\n }\n \n-void StopHTTPServer()\n+void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n {\n-    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n-    if (g_work_queue) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n-        for (auto& thread : g_thread_http_workers) {\n-            thread.join();\n+    m_response_headers.Write(hdr, value);\n+}\n+\n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n         }\n-        g_thread_http_workers.clear();\n     }\n-    // Unlisten sockets, these are what make the event loop running, which means\n-    // that after this and all connections are closed the event loop will quit.\n-    for (evhttp_bound_socket *socket : boundSockets) {\n-        evhttp_del_accept_socket(eventHTTP, socket);\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n     }\n-    boundSockets.clear();\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    m_client->m_keep_alive = res.m_keep_alive;\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    bool send_buffer_was_empty{false};\n+    // Fill the send buffer with the complete serialized response headers + body\n     {\n-        if (const auto n_connections{g_requests.CountActiveConnections()}; n_connections != 0) {\n-            LogDebug(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections);\n-        }\n-        g_requests.WaitUntilEmpty();\n-    }\n-    if (eventHTTP) {\n-        // Schedule a callback to call evhttp_free in the event base thread, so\n-        // that evhttp_free does not need to be called again after the handling\n-        // of unfinished request connections that follows.\n-        event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {\n-            evhttp_free(eventHTTP);\n-            eventHTTP = nullptr;\n-        }, nullptr, nullptr);\n-    }\n-    if (eventBase) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n-        if (g_thread_http.joinable()) g_thread_http.join();\n-        event_base_free(eventBase);\n-        eventBase = nullptr;\n-    }\n-    g_work_queue.reset();\n-    LogDebug(BCLog::HTTP, \"Stopped HTTP server\\n\");\n-}\n+        LOCK(m_client->m_send_mutex);\n+        send_buffer_was_empty = m_client->m_send_buffer.empty();\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());\n+    }\n+\n+    LogDebug(\n+        BCLog::HTTP,\n+        \"HTTPResponse (status code: %d size: %lld) added to send buffer for client %s (id=%lld)\\n\",\n+        status,\n+        headers_bytes.size() + reply_body.size(),\n+        m_client->m_origin,\n+        m_client->m_node_id);\n+\n+    // If the send buffer was empty before we wrote this reply, we can try an\n+    // optimistic send akin to CConnman::PushMessage() in which we\n+    // push the data directly out the socket to client right now, instead\n+    // of waiting for the next iteration of the Sockman I/O loop.\n+    if (send_buffer_was_empty) {\n+        m_client->SendBytesFromBuffer();\n+    } else {\n+        // Inform Sockman I/O there is data that is ready to be sent to this client\n+        // in the next loop iteration.\n+        m_client->m_send_ready = true;\n+    }\n \n-struct event_base* EventBase()\n-{\n-    return eventBase;\n+    // Signal to the Sockman I/O loop that we are ready to handle the next request.\n+    m_client->m_req_busy = false;\n }\n \n-static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n+bool HTTPClient::ReadRequest(std::unique_ptr<HTTPRequest>& req)\n {\n-    // Static handler: simply call inner handler\n-    HTTPEvent *self = static_cast<HTTPEvent*>(data);\n-    self->handler();\n-    if (self->deleteWhenTriggered)\n-        delete self;\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(\n+        m_recv_buffer.begin(),\n+        m_recv_buffer.begin() + (reader.it - reader.start));\n+\n+    return true;\n }\n \n-HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):\n-    deleteWhenTriggered(_deleteWhenTriggered), handler(_handler)\n-{\n-    ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n-    assert(ev);\n+bool HTTPClient::SendBytesFromBuffer()\n+{\n+    Assume(m_server);\n+\n+    // Send as much data from this client's buffer as we can\n+    LOCK(m_send_mutex);\n+    if (!m_send_buffer.empty()) {\n+        std::string err;\n+        // We don't intend to \"send more\" because http responses are usually small and we want the kernel to send them right away.\n+        ssize_t bytes_sent = m_server->SendBytes(m_node_id, MakeUCharSpan(m_send_buffer), /*will_send_more=*/false, err);\n+        if (bytes_sent < 0) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error sending HTTP response data to client %s (id=%lld): %s\\n\",\n+                m_origin,\n+                m_node_id,\n+                err);\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+            m_disconnect = true;\n+            return false;\n+        }\n+\n+        Assume(static_cast<size_t>(bytes_sent) <= m_send_buffer.size());\n+        m_send_buffer.erase(m_send_buffer.begin(), m_send_buffer.begin() + bytes_sent);\n+\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Sent %d bytes to client %s (id=%lld)\\n\",\n+            bytes_sent,\n+            m_origin,\n+            m_node_id);\n+\n+        // This check is inside the if(!empty) block meaning \"there was data but now its gone\".\n+        // We shouldn't even be calling SendBytesFromBuffer() when the send buffer is empty,\n+        // but for belt-and-suspenders, we don't want to modify the disconnect flags if SendBytesFromBuffer() was a no-op.\n+        if (m_send_buffer.empty()) {\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+\n+            // Our work is done here\n+            if (!m_keep_alive) {\n+                m_disconnect = true;\n+                return false;\n+            }\n+        } else {\n+            m_send_ready = true;\n+            m_prevent_disconnect = true;\n+        }\n+    }\n+\n+    return true;\n }\n-HTTPEvent::~HTTPEvent()\n+\n+void HTTPServer::CloseConnectionInternal(std::shared_ptr<HTTPClient>& client)\n {\n-    event_free(ev);\n+    if (CloseConnection(client->m_node_id)) {\n+        LogDebug(BCLog::HTTP, \"Disconnected HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    } else {\n+        LogDebug(BCLog::HTTP, \"Failed to disconnect non-existent HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    }\n }\n-void HTTPEvent::trigger(struct timeval* tv)\n+\n+void HTTPServer::DisconnectClients()\n {\n-    if (tv == nullptr)\n-        event_active(ev, 0, 0); // immediately trigger event in main thread\n-    else\n-        evtimer_add(ev, tv); // trigger after timeval passed\n+    const auto now{Now<SteadySeconds>()};\n+    for (auto it = m_connected_clients.begin(); it != m_connected_clients.end();) {\n+        bool timeout{now - it->second->m_idle_since > m_rpcservertimeout};\n+        if (((it->second->m_disconnect || m_disconnect_all_clients) && !it->second->m_prevent_disconnect)\n+            || timeout) {\n+            CloseConnectionInternal(it->second);\n+            it = m_connected_clients.erase(it);\n+        } else {\n+            ++it;\n+        }\n+    }\n+    m_no_clients = m_connected_clients.size() == 0;\n }\n-HTTPRequest::HTTPRequest(struct evhttp_request* _req, const util::SignalInterrupt& interrupt, bool _replySent)\n-    : req(_req), m_interrupt(interrupt), replySent(_replySent)\n+\n+bool HTTPServer::EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them)\n {\n+    auto client = std::make_shared<HTTPClient>(node_id, them);\n+    // Point back to the server\n+    client->m_server = this;\n+    // Set timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+    LogDebug(BCLog::HTTP, \"HTTP Connection accepted from %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    m_connected_clients.emplace(client->m_node_id, std::move(client));\n+    m_no_clients = false;\n+    return true;\n }\n \n-HTTPRequest::~HTTPRequest()\n+void HTTPServer::EventReadyToSend(NodeId node_id, bool& cancel_recv)\n {\n-    if (!replySent) {\n-        // Keep track of whether reply was sent to avoid request leaks\n-        LogPrintf(\"%s: Unhandled request\\n\", __func__);\n-        WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\");\n+    // Next attempt to receive data from this node is permitted\n+    cancel_recv = false;\n+\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n     }\n-    // evhttpd cleans up the request, as long as a reply was sent.\n+\n+    // SendBytesFromBuffer() returns true if we should keep the client around,\n+    // false if we are done with it. Invert that boolean to inform Sockman\n+    // whether it should cancel the next receive attempt from this client.\n+    cancel_recv = !client->SendBytesFromBuffer();\n }\n \n-std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const\n+void HTTPServer::EventGotData(NodeId node_id, std::span<const uint8_t> data)\n {\n-    const struct evkeyvalq* headers = evhttp_request_get_input_headers(req);\n-    assert(headers);\n-    const char* val = evhttp_find_header(headers, hdr.c_str());\n-    if (val)\n-        return std::make_pair(true, val);\n-    else\n-        return std::make_pair(false, \"\");\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    // Reset idle timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+\n+    // Prevent disconnect until all requests are completely handled.\n+    client->m_prevent_disconnect = true;\n+\n+    // Copy data from socket buffer to client receive buffer\n+    client->m_recv_buffer.insert(\n+        client->m_recv_buffer.end(),\n+        reinterpret_cast<const std::byte*>(data.data()),\n+        reinterpret_cast<const std::byte*>(data.data() + data.size())\n+    );\n+\n+    // Try reading (potentially multiple) HTTP requests from the buffer\n+    while (client->m_recv_buffer.size() > 0) {\n+        // Create a new request object and try to fill it with data from the receive buffer\n+        auto req = std::make_unique<HTTPRequest>(client);\n+        try {\n+            // Stop reading if we need more data from the client to parse a complete request\n+            if (!client->ReadRequest(req)) break;\n+        } catch (const std::runtime_error& e) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error reading HTTP request from client %s (id=%lld): %s\\n\",\n+                client->m_origin,\n+                client->m_node_id,\n+                e.what());\n+\n+            // We failed to read a complete request from the buffer\n+            req->WriteReply(HTTP_BAD_REQUEST);\n+            client->m_disconnect = true;\n+            break;\n+        }\n+\n+        // We read a complete request from the buffer into the queue\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Received a %s request for %s from %s (id=%lld)\\n\",\n+            req->m_method,\n+            req->m_target,\n+            req->m_client->m_origin,\n+            req->m_client->m_node_id);\n+\n+        // add request to client queue\n+        client->m_req_queue.push_back(std::move(req));\n+    }\n }\n \n-std::string HTTPRequest::ReadBody()\n+void HTTPServer::EventGotEOF(NodeId node_id)\n {\n-    struct evbuffer* buf = evhttp_request_get_input_buffer(req);\n-    if (!buf)\n-        return \"\";\n-    size_t size = evbuffer_get_length(buf);\n-    /** Trivial implementation: if this is ever a performance bottleneck,\n-     * internal copying can be avoided in multi-segment buffers by using\n-     * evbuffer_peek and an awkward loop. Though in that case, it'd be even\n-     * better to not copy into an intermediate string but use a stream\n-     * abstraction to consume the evbuffer on the fly in the parsing algorithm.\n-     */\n-    const char* data = (const char*)evbuffer_pullup(buf, size);\n-    if (!data) // returns nullptr in case of empty buffer\n-        return \"\";\n-    std::string rv(data, size);\n-    evbuffer_drain(buf, size);\n-    return rv;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    client->m_disconnect = true;\n }\n \n-void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n+void HTTPServer::EventGotPermanentReadError(NodeId node_id, const std::string& errmsg)\n {\n-    struct evkeyvalq* headers = evhttp_request_get_output_headers(req);\n-    assert(headers);\n-    evhttp_add_header(headers, hdr.c_str(), value.c_str());\n-}\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-/** Closure sent to main thread to request a reply to be sent to\n- * a HTTP request.\n- * Replies must be sent in the main loop in the main http thread,\n- * this cannot be done from worker threads.\n- */\n-void HTTPRequest::WriteReply(int nStatus, std::span<const std::byte> reply)\n-{\n-    assert(!replySent && req);\n-    if (m_interrupt) {\n-        WriteHeader(\"Connection\", \"close\");\n-    }\n-    // Send event to main http thread to send reply message\n-    struct evbuffer* evb = evhttp_request_get_output_buffer(req);\n-    assert(evb);\n-    evbuffer_add(evb, reply.data(), reply.size());\n-    auto req_copy = req;\n-    HTTPEvent* ev = new HTTPEvent(eventBase, true, [req_copy, nStatus]{\n-        evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);\n-        // Re-enable reading from the socket. This is the second part of the libevent\n-        // workaround above.\n-        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02010900) {\n-            evhttp_connection* conn = evhttp_request_get_connection(req_copy);\n-            if (conn) {\n-                bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n-                if (bev) {\n-                    bufferevent_enable(bev, EV_READ | EV_WRITE);\n-                }\n-            }\n-        }\n-    });\n-    ev->trigger(nullptr);\n-    replySent = true;\n-    req = nullptr; // transferred back to main thread\n+    client->m_disconnect = true;\n }\n \n-CService HTTPRequest::GetPeer() const\n+void HTTPServer::EventIOLoopCompletedForOne(NodeId node_id)\n {\n-    evhttp_connection* con = evhttp_request_get_connection(req);\n-    CService peer;\n-    if (con) {\n-        // evhttp retains ownership over returned address string\n-        const char* address = \"\";\n-        uint16_t port = 0;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-#ifdef HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n-        evhttp_connection_get_peer(con, &address, &port);\n-#else\n-        evhttp_connection_get_peer(con, (char**)&address, &port);\n-#endif // HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n+    // If we are already handling a request from\n+    // this client, do nothing.\n+    if (client->m_req_busy) return;\n \n-        peer = MaybeFlipIPv6toCJDNS(LookupNumeric(address, port));\n+    // Otherwise, if there is a new pending request, handle it.\n+    if (!client->m_req_queue.empty()) {\n+        client->m_req_busy = true;\n+        m_request_dispatcher(std::move(client->m_req_queue.front()));\n+        client->m_req_queue.pop_front();\n     }\n-    return peer;\n }\n \n-std::string HTTPRequest::GetURI() const\n+void HTTPServer::EventIOLoopCompletedForAll()\n {\n-    return evhttp_request_get_uri(req);\n+    DisconnectClients();\n }\n \n-HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod() const\n+bool HTTPServer::ShouldTryToSend(NodeId node_id) const\n {\n-    switch (evhttp_request_get_command(req)) {\n-    case EVHTTP_REQ_GET:\n-        return GET;\n-    case EVHTTP_REQ_POST:\n-        return POST;\n-    case EVHTTP_REQ_HEAD:\n-        return HEAD;\n-    case EVHTTP_REQ_PUT:\n-        return PUT;\n-    default:\n-        return UNKNOWN;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n     }\n+\n+    return client->m_send_ready;\n }\n \n-std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+bool HTTPServer::ShouldTryToRecv(NodeId node_id) const\n {\n-    const char* uri{evhttp_request_get_uri(req)};\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n+    }\n \n-    return GetQueryParameterFromUri(uri, key);\n+    // Don't try to receive again until we've cleared the send buffer to this client\n+    return !client->m_send_ready;\n }\n \n-std::optional<std::string> GetQueryParameterFromUri(const char* uri, const std::string& key)\n+std::shared_ptr<HTTPClient> HTTPServer::GetClientById(NodeId node_id) const\n {\n-    evhttp_uri* uri_parsed{evhttp_uri_parse(uri)};\n-    if (!uri_parsed) {\n-        throw std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\");\n+    auto it{m_connected_clients.find(node_id)};\n+    if (it != m_connected_clients.end()) {\n+        return it->second;\n     }\n-    const char* query{evhttp_uri_get_query(uri_parsed)};\n-    std::optional<std::string> result;\n+    return nullptr;\n+}\n \n-    if (query) {\n-        // Parse the query string into a key-value queue and iterate over it\n-        struct evkeyvalq params_q;\n-        evhttp_parse_query_str(query, &params_q);\n+bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+{\n+    if (!InitHTTPAllowList())\n+        return false;\n \n-        for (struct evkeyval* param{params_q.tqh_first}; param != nullptr; param = param->next.tqe_next) {\n-            if (param->key == key) {\n-                result = param->value;\n-                break;\n+    // Create HTTPServer\n+    g_http_server = std::make_unique<HTTPServer>(MaybeDispatchRequestToWorker);\n+\n+    g_http_server->m_rpcservertimeout = std::chrono::seconds(gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n+\n+    // Bind HTTP server to specified addresses\n+    std::vector<std::pair<std::string, uint16_t>> endpoints{GetBindAddresses()};\n+    bool bind_success{false};\n+    for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\n+        LogPrintf(\"Binding RPC on address %s port %i\\n\", i->first, i->second);\n+        const std::optional<CService> addr{Lookup(i->first, i->second, false)};\n+        if (addr) {\n+            if (addr->IsBindAny()) {\n+                LogPrintf(\"WARNING: the RPC server is not safe to expose to untrusted networks such as the public internet\\n\");\n             }\n+            bilingual_str strError;\n+            if (!g_http_server->BindAndStartListening(addr.value(), strError)) {\n+                LogPrintf(\"Binding RPC on address %s failed: %s\\n\", addr->ToStringAddrPort(), strError.original);\n+            } else {\n+                bind_success = true;\n+            }\n+        } else {\n+            LogPrintf(\"Binding RPC on address %s port %i failed.\\n\", i->first, i->second);\n         }\n-        evhttp_clear_headers(&params_q);\n     }\n-    evhttp_uri_free(uri_parsed);\n \n-    return result;\n+    if (!bind_success) {\n+        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n+        return false;\n+    }\n+\n+    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n+    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n+    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+\n+    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n+\n+    return true;\n }\n \n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n+static std::vector<std::thread> g_thread_http_workers;\n+\n+void StartHTTPServer()\n {\n-    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n-    LOCK(g_httppathhandlers_mutex);\n-    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n+    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n+    SockMan::Options sockman_options;\n+    sockman_options.socket_handler_thread_name = \"http\";\n+    g_http_server->StartSocketsThreads(sockman_options);\n+\n+    for (int i = 0; i < rpcThreads; i++) {\n+        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+    }\n }\n \n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+void InterruptHTTPServer()\n {\n-    LOCK(g_httppathhandlers_mutex);\n-    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n-    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n-    for (; i != iend; ++i)\n-        if (i->prefix == prefix && i->exactMatch == exactMatch)\n-            break;\n-    if (i != iend)\n-    {\n-        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n-        pathHandlers.erase(i);\n+    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n+    if (g_http_server) {\n+        // Reject all new requests\n+        g_http_server->m_request_dispatcher = RejectAllRequests;\n     }\n+    if (g_work_queue) {\n+        // Stop workers, killing requests we haven't processed or responded to yet\n+        g_work_queue->Interrupt();\n+    }\n+}\n+\n+void StopHTTPServer()\n+{\n+    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n+    if (g_work_queue) {\n+        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n+        for (auto& thread : g_thread_http_workers) {\n+            thread.join();\n+        }\n+        g_thread_http_workers.clear();\n+    }\n+    if (g_http_server) {\n+        // Disconnect clients as their remaining responses are flushed\n+        g_http_server->m_disconnect_all_clients = true;\n+        // Wait for all disconnections\n+        while (!g_http_server->m_no_clients) {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{50});",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 1221,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2128815408,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": ":+1:",
      "created_at": "2025-06-18T16:49:49Z",
      "updated_at": "2025-06-22T23:20:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2155084860",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155084860"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 984,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155102294",
      "pull_request_review_id": 2936787243,
      "id": 2155102294,
      "node_id": "PRRC_kwDOABII586AdEBW",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {\n+        // Transfer-Encoding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-3.3.1\n+        // Chunked Transfer Coding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-4.1\n+        // see evhttp_handle_chunked_read() in libevent http.c\n+        while (reader.Left() > 0) {\n+            auto maybe_chunk_size = reader.ReadLine();\n+            if (!maybe_chunk_size) return false;\n+            uint64_t chunk_size;\n+\n+            if (!ParseUInt64Hex(maybe_chunk_size.value(), &chunk_size)) throw std::runtime_error(\"Invalid chunk size\");\n+\n+            bool last_chunk{chunk_size == 0};\n+\n+            if (!last_chunk) {\n+                // We are still expecting more data for this chunk\n+                if (reader.Left() < chunk_size) {\n+                    return false;\n+                }\n+                // Pack chunk onto body\n+                m_body += reader.ReadLength(chunk_size);\n+            }\n+\n+            // Even though every chunk size is explicitly declared,\n+            // they are still terminated by a CRLF we don't need.\n+            auto crlf = reader.ReadLine();\n+            if (!crlf || crlf.value().size() != 0) throw std::runtime_error(\"Improperly terminated chunk\");\n+\n+            if (last_chunk) return true;\n+        }\n+\n+        // We read all the chunks but never got the last chunk, wait for client to send more\n+        return false;\n     } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+        // No Content-length or Transfer-Encoding header means no body, see libevent evhttp_get_body()\n+        auto content_length_value{m_headers.Find(\"Content-Length\")};\n+        if (!content_length_value) return true;\n+\n+        uint64_t content_length;\n+        if (!ParseUInt64(content_length_value.value(), &content_length)) throw std::runtime_error(\"Cannot parse Content-Length value\");\n+\n+        // Not enough data in buffer for expected body\n+        if (reader.Left() < content_length) return false;\n+\n+        m_body = reader.ReadLength(content_length);\n+\n+        return true;\n     }\n }\n \n-static std::thread g_thread_http;\n-static std::vector<std::thread> g_thread_http_workers;\n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n \n-void StartHTTPServer()\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n {\n-    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n-    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n-    g_thread_http = std::thread(ThreadHTTP, eventBase);\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n \n-    for (int i = 0; i < rpcThreads; i++) {\n-        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string_view query{decoded_uri.data() + start + 1, end - start - 1};\n+    // find requested parameter in query\n+    const std::vector<std::string_view> params{Split<std::string_view>(query, \"&\")};\n+    for (const std::string_view& param : params) {\n+        size_t delim = param.find('=');\n+        if (key == param.substr(0, delim)) {\n+            if (delim == std::string::npos) {\n+                return \"\";\n+            } else {\n+                return std::string(param.substr(delim + 1));\n+            }\n+        }\n     }\n+    return std::nullopt;\n }\n \n-void InterruptHTTPServer()\n+std::pair<bool, std::string_view> HTTPRequest::GetHeader(const std::string& hdr) const\n {\n-    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n-    if (eventHTTP) {\n-        // Reject requests on current connections\n-        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n-    }\n-    if (g_work_queue) {\n-        g_work_queue->Interrupt();\n-    }\n+    std::optional<std::string_view> found{m_headers.Find(hdr)};\n+    if (found.has_value()) {\n+        return std::make_pair(true, found.value());\n+    } else\n+        return std::make_pair(false, \"\");\n }\n \n-void StopHTTPServer()\n+void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n {\n-    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n-    if (g_work_queue) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n-        for (auto& thread : g_thread_http_workers) {\n-            thread.join();\n+    m_response_headers.Write(hdr, value);\n+}\n+\n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n         }\n-        g_thread_http_workers.clear();\n     }\n-    // Unlisten sockets, these are what make the event loop running, which means\n-    // that after this and all connections are closed the event loop will quit.\n-    for (evhttp_bound_socket *socket : boundSockets) {\n-        evhttp_del_accept_socket(eventHTTP, socket);\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n     }\n-    boundSockets.clear();\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    m_client->m_keep_alive = res.m_keep_alive;\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    bool send_buffer_was_empty{false};\n+    // Fill the send buffer with the complete serialized response headers + body\n     {\n-        if (const auto n_connections{g_requests.CountActiveConnections()}; n_connections != 0) {\n-            LogDebug(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections);\n-        }\n-        g_requests.WaitUntilEmpty();\n-    }\n-    if (eventHTTP) {\n-        // Schedule a callback to call evhttp_free in the event base thread, so\n-        // that evhttp_free does not need to be called again after the handling\n-        // of unfinished request connections that follows.\n-        event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {\n-            evhttp_free(eventHTTP);\n-            eventHTTP = nullptr;\n-        }, nullptr, nullptr);\n-    }\n-    if (eventBase) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n-        if (g_thread_http.joinable()) g_thread_http.join();\n-        event_base_free(eventBase);\n-        eventBase = nullptr;\n-    }\n-    g_work_queue.reset();\n-    LogDebug(BCLog::HTTP, \"Stopped HTTP server\\n\");\n-}\n+        LOCK(m_client->m_send_mutex);\n+        send_buffer_was_empty = m_client->m_send_buffer.empty();\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());\n+    }\n+\n+    LogDebug(\n+        BCLog::HTTP,\n+        \"HTTPResponse (status code: %d size: %lld) added to send buffer for client %s (id=%lld)\\n\",\n+        status,\n+        headers_bytes.size() + reply_body.size(),\n+        m_client->m_origin,\n+        m_client->m_node_id);\n+\n+    // If the send buffer was empty before we wrote this reply, we can try an\n+    // optimistic send akin to CConnman::PushMessage() in which we\n+    // push the data directly out the socket to client right now, instead\n+    // of waiting for the next iteration of the Sockman I/O loop.\n+    if (send_buffer_was_empty) {\n+        m_client->SendBytesFromBuffer();\n+    } else {\n+        // Inform Sockman I/O there is data that is ready to be sent to this client\n+        // in the next loop iteration.\n+        m_client->m_send_ready = true;\n+    }\n \n-struct event_base* EventBase()\n-{\n-    return eventBase;\n+    // Signal to the Sockman I/O loop that we are ready to handle the next request.\n+    m_client->m_req_busy = false;\n }\n \n-static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n+bool HTTPClient::ReadRequest(std::unique_ptr<HTTPRequest>& req)\n {\n-    // Static handler: simply call inner handler\n-    HTTPEvent *self = static_cast<HTTPEvent*>(data);\n-    self->handler();\n-    if (self->deleteWhenTriggered)\n-        delete self;\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(\n+        m_recv_buffer.begin(),\n+        m_recv_buffer.begin() + (reader.it - reader.start));\n+\n+    return true;\n }\n \n-HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):\n-    deleteWhenTriggered(_deleteWhenTriggered), handler(_handler)\n-{\n-    ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n-    assert(ev);\n+bool HTTPClient::SendBytesFromBuffer()\n+{\n+    Assume(m_server);\n+\n+    // Send as much data from this client's buffer as we can\n+    LOCK(m_send_mutex);\n+    if (!m_send_buffer.empty()) {\n+        std::string err;\n+        // We don't intend to \"send more\" because http responses are usually small and we want the kernel to send them right away.\n+        ssize_t bytes_sent = m_server->SendBytes(m_node_id, MakeUCharSpan(m_send_buffer), /*will_send_more=*/false, err);\n+        if (bytes_sent < 0) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error sending HTTP response data to client %s (id=%lld): %s\\n\",\n+                m_origin,\n+                m_node_id,\n+                err);\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+            m_disconnect = true;\n+            return false;\n+        }\n+\n+        Assume(static_cast<size_t>(bytes_sent) <= m_send_buffer.size());\n+        m_send_buffer.erase(m_send_buffer.begin(), m_send_buffer.begin() + bytes_sent);\n+\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Sent %d bytes to client %s (id=%lld)\\n\",\n+            bytes_sent,\n+            m_origin,\n+            m_node_id);\n+\n+        // This check is inside the if(!empty) block meaning \"there was data but now its gone\".\n+        // We shouldn't even be calling SendBytesFromBuffer() when the send buffer is empty,\n+        // but for belt-and-suspenders, we don't want to modify the disconnect flags if SendBytesFromBuffer() was a no-op.\n+        if (m_send_buffer.empty()) {\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+\n+            // Our work is done here\n+            if (!m_keep_alive) {\n+                m_disconnect = true;\n+                return false;\n+            }\n+        } else {\n+            m_send_ready = true;\n+            m_prevent_disconnect = true;\n+        }\n+    }\n+\n+    return true;\n }\n-HTTPEvent::~HTTPEvent()\n+\n+void HTTPServer::CloseConnectionInternal(std::shared_ptr<HTTPClient>& client)\n {\n-    event_free(ev);\n+    if (CloseConnection(client->m_node_id)) {\n+        LogDebug(BCLog::HTTP, \"Disconnected HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    } else {\n+        LogDebug(BCLog::HTTP, \"Failed to disconnect non-existent HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    }\n }\n-void HTTPEvent::trigger(struct timeval* tv)\n+\n+void HTTPServer::DisconnectClients()\n {\n-    if (tv == nullptr)\n-        event_active(ev, 0, 0); // immediately trigger event in main thread\n-    else\n-        evtimer_add(ev, tv); // trigger after timeval passed\n+    const auto now{Now<SteadySeconds>()};\n+    for (auto it = m_connected_clients.begin(); it != m_connected_clients.end();) {\n+        bool timeout{now - it->second->m_idle_since > m_rpcservertimeout};\n+        if (((it->second->m_disconnect || m_disconnect_all_clients) && !it->second->m_prevent_disconnect)\n+            || timeout) {\n+            CloseConnectionInternal(it->second);\n+            it = m_connected_clients.erase(it);\n+        } else {\n+            ++it;\n+        }\n+    }\n+    m_no_clients = m_connected_clients.size() == 0;\n }\n-HTTPRequest::HTTPRequest(struct evhttp_request* _req, const util::SignalInterrupt& interrupt, bool _replySent)\n-    : req(_req), m_interrupt(interrupt), replySent(_replySent)\n+\n+bool HTTPServer::EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them)\n {\n+    auto client = std::make_shared<HTTPClient>(node_id, them);\n+    // Point back to the server\n+    client->m_server = this;\n+    // Set timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+    LogDebug(BCLog::HTTP, \"HTTP Connection accepted from %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    m_connected_clients.emplace(client->m_node_id, std::move(client));\n+    m_no_clients = false;\n+    return true;\n }\n \n-HTTPRequest::~HTTPRequest()\n+void HTTPServer::EventReadyToSend(NodeId node_id, bool& cancel_recv)\n {\n-    if (!replySent) {\n-        // Keep track of whether reply was sent to avoid request leaks\n-        LogPrintf(\"%s: Unhandled request\\n\", __func__);\n-        WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\");\n+    // Next attempt to receive data from this node is permitted\n+    cancel_recv = false;\n+\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n     }\n-    // evhttpd cleans up the request, as long as a reply was sent.\n+\n+    // SendBytesFromBuffer() returns true if we should keep the client around,\n+    // false if we are done with it. Invert that boolean to inform Sockman\n+    // whether it should cancel the next receive attempt from this client.\n+    cancel_recv = !client->SendBytesFromBuffer();\n }\n \n-std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const\n+void HTTPServer::EventGotData(NodeId node_id, std::span<const uint8_t> data)\n {\n-    const struct evkeyvalq* headers = evhttp_request_get_input_headers(req);\n-    assert(headers);\n-    const char* val = evhttp_find_header(headers, hdr.c_str());\n-    if (val)\n-        return std::make_pair(true, val);\n-    else\n-        return std::make_pair(false, \"\");\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    // Reset idle timeout\n+    client->m_idle_since = Now<SteadySeconds>();\n+\n+    // Prevent disconnect until all requests are completely handled.\n+    client->m_prevent_disconnect = true;\n+\n+    // Copy data from socket buffer to client receive buffer\n+    client->m_recv_buffer.insert(\n+        client->m_recv_buffer.end(),\n+        reinterpret_cast<const std::byte*>(data.data()),\n+        reinterpret_cast<const std::byte*>(data.data() + data.size())\n+    );\n+\n+    // Try reading (potentially multiple) HTTP requests from the buffer\n+    while (client->m_recv_buffer.size() > 0) {\n+        // Create a new request object and try to fill it with data from the receive buffer\n+        auto req = std::make_unique<HTTPRequest>(client);\n+        try {\n+            // Stop reading if we need more data from the client to parse a complete request\n+            if (!client->ReadRequest(req)) break;\n+        } catch (const std::runtime_error& e) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error reading HTTP request from client %s (id=%lld): %s\\n\",\n+                client->m_origin,\n+                client->m_node_id,\n+                e.what());\n+\n+            // We failed to read a complete request from the buffer\n+            req->WriteReply(HTTP_BAD_REQUEST);\n+            client->m_disconnect = true;\n+            break;\n+        }\n+\n+        // We read a complete request from the buffer into the queue\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Received a %s request for %s from %s (id=%lld)\\n\",\n+            req->m_method,\n+            req->m_target,\n+            req->m_client->m_origin,\n+            req->m_client->m_node_id);\n+\n+        // add request to client queue\n+        client->m_req_queue.push_back(std::move(req));\n+    }\n }\n \n-std::string HTTPRequest::ReadBody()\n+void HTTPServer::EventGotEOF(NodeId node_id)\n {\n-    struct evbuffer* buf = evhttp_request_get_input_buffer(req);\n-    if (!buf)\n-        return \"\";\n-    size_t size = evbuffer_get_length(buf);\n-    /** Trivial implementation: if this is ever a performance bottleneck,\n-     * internal copying can be avoided in multi-segment buffers by using\n-     * evbuffer_peek and an awkward loop. Though in that case, it'd be even\n-     * better to not copy into an intermediate string but use a stream\n-     * abstraction to consume the evbuffer on the fly in the parsing algorithm.\n-     */\n-    const char* data = (const char*)evbuffer_pullup(buf, size);\n-    if (!data) // returns nullptr in case of empty buffer\n-        return \"\";\n-    std::string rv(data, size);\n-    evbuffer_drain(buf, size);\n-    return rv;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n+\n+    client->m_disconnect = true;\n }\n \n-void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n+void HTTPServer::EventGotPermanentReadError(NodeId node_id, const std::string& errmsg)\n {\n-    struct evkeyvalq* headers = evhttp_request_get_output_headers(req);\n-    assert(headers);\n-    evhttp_add_header(headers, hdr.c_str(), value.c_str());\n-}\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-/** Closure sent to main thread to request a reply to be sent to\n- * a HTTP request.\n- * Replies must be sent in the main loop in the main http thread,\n- * this cannot be done from worker threads.\n- */\n-void HTTPRequest::WriteReply(int nStatus, std::span<const std::byte> reply)\n-{\n-    assert(!replySent && req);\n-    if (m_interrupt) {\n-        WriteHeader(\"Connection\", \"close\");\n-    }\n-    // Send event to main http thread to send reply message\n-    struct evbuffer* evb = evhttp_request_get_output_buffer(req);\n-    assert(evb);\n-    evbuffer_add(evb, reply.data(), reply.size());\n-    auto req_copy = req;\n-    HTTPEvent* ev = new HTTPEvent(eventBase, true, [req_copy, nStatus]{\n-        evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);\n-        // Re-enable reading from the socket. This is the second part of the libevent\n-        // workaround above.\n-        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02010900) {\n-            evhttp_connection* conn = evhttp_request_get_connection(req_copy);\n-            if (conn) {\n-                bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n-                if (bev) {\n-                    bufferevent_enable(bev, EV_READ | EV_WRITE);\n-                }\n-            }\n-        }\n-    });\n-    ev->trigger(nullptr);\n-    replySent = true;\n-    req = nullptr; // transferred back to main thread\n+    client->m_disconnect = true;\n }\n \n-CService HTTPRequest::GetPeer() const\n+void HTTPServer::EventIOLoopCompletedForOne(NodeId node_id)\n {\n-    evhttp_connection* con = evhttp_request_get_connection(req);\n-    CService peer;\n-    if (con) {\n-        // evhttp retains ownership over returned address string\n-        const char* address = \"\";\n-        uint16_t port = 0;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return;\n+    }\n \n-#ifdef HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n-        evhttp_connection_get_peer(con, &address, &port);\n-#else\n-        evhttp_connection_get_peer(con, (char**)&address, &port);\n-#endif // HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n+    // If we are already handling a request from\n+    // this client, do nothing.\n+    if (client->m_req_busy) return;\n \n-        peer = MaybeFlipIPv6toCJDNS(LookupNumeric(address, port));\n+    // Otherwise, if there is a new pending request, handle it.\n+    if (!client->m_req_queue.empty()) {\n+        client->m_req_busy = true;\n+        m_request_dispatcher(std::move(client->m_req_queue.front()));\n+        client->m_req_queue.pop_front();\n     }\n-    return peer;\n }\n \n-std::string HTTPRequest::GetURI() const\n+void HTTPServer::EventIOLoopCompletedForAll()\n {\n-    return evhttp_request_get_uri(req);\n+    DisconnectClients();\n }\n \n-HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod() const\n+bool HTTPServer::ShouldTryToSend(NodeId node_id) const\n {\n-    switch (evhttp_request_get_command(req)) {\n-    case EVHTTP_REQ_GET:\n-        return GET;\n-    case EVHTTP_REQ_POST:\n-        return POST;\n-    case EVHTTP_REQ_HEAD:\n-        return HEAD;\n-    case EVHTTP_REQ_PUT:\n-        return PUT;\n-    default:\n-        return UNKNOWN;\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n     }\n+\n+    return client->m_send_ready;\n }\n \n-std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+bool HTTPServer::ShouldTryToRecv(NodeId node_id) const\n {\n-    const char* uri{evhttp_request_get_uri(req)};\n+    // Get the HTTPClient\n+    auto client{GetClientById(node_id)};\n+    if (client == nullptr) {\n+        return false;\n+    }\n \n-    return GetQueryParameterFromUri(uri, key);\n+    // Don't try to receive again until we've cleared the send buffer to this client\n+    return !client->m_send_ready;\n }\n \n-std::optional<std::string> GetQueryParameterFromUri(const char* uri, const std::string& key)\n+std::shared_ptr<HTTPClient> HTTPServer::GetClientById(NodeId node_id) const\n {\n-    evhttp_uri* uri_parsed{evhttp_uri_parse(uri)};\n-    if (!uri_parsed) {\n-        throw std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\");\n+    auto it{m_connected_clients.find(node_id)};\n+    if (it != m_connected_clients.end()) {\n+        return it->second;\n     }\n-    const char* query{evhttp_uri_get_query(uri_parsed)};\n-    std::optional<std::string> result;\n+    return nullptr;\n+}\n \n-    if (query) {\n-        // Parse the query string into a key-value queue and iterate over it\n-        struct evkeyvalq params_q;\n-        evhttp_parse_query_str(query, &params_q);\n+bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+{\n+    if (!InitHTTPAllowList())\n+        return false;\n \n-        for (struct evkeyval* param{params_q.tqh_first}; param != nullptr; param = param->next.tqe_next) {\n-            if (param->key == key) {\n-                result = param->value;\n-                break;\n+    // Create HTTPServer\n+    g_http_server = std::make_unique<HTTPServer>(MaybeDispatchRequestToWorker);\n+\n+    g_http_server->m_rpcservertimeout = std::chrono::seconds(gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n+\n+    // Bind HTTP server to specified addresses\n+    std::vector<std::pair<std::string, uint16_t>> endpoints{GetBindAddresses()};\n+    bool bind_success{false};\n+    for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\n+        LogPrintf(\"Binding RPC on address %s port %i\\n\", i->first, i->second);\n+        const std::optional<CService> addr{Lookup(i->first, i->second, false)};\n+        if (addr) {\n+            if (addr->IsBindAny()) {\n+                LogPrintf(\"WARNING: the RPC server is not safe to expose to untrusted networks such as the public internet\\n\");\n             }\n+            bilingual_str strError;\n+            if (!g_http_server->BindAndStartListening(addr.value(), strError)) {\n+                LogPrintf(\"Binding RPC on address %s failed: %s\\n\", addr->ToStringAddrPort(), strError.original);\n+            } else {\n+                bind_success = true;\n+            }\n+        } else {\n+            LogPrintf(\"Binding RPC on address %s port %i failed.\\n\", i->first, i->second);\n         }\n-        evhttp_clear_headers(&params_q);\n     }\n-    evhttp_uri_free(uri_parsed);\n \n-    return result;\n+    if (!bind_success) {\n+        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n+        return false;\n+    }\n+\n+    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n+    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n+    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+\n+    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n+\n+    return true;\n }\n \n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n+static std::vector<std::thread> g_thread_http_workers;\n+\n+void StartHTTPServer()\n {\n-    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n-    LOCK(g_httppathhandlers_mutex);\n-    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n+    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n+    SockMan::Options sockman_options;\n+    sockman_options.socket_handler_thread_name = \"http\";\n+    g_http_server->StartSocketsThreads(sockman_options);\n+\n+    for (int i = 0; i < rpcThreads; i++) {\n+        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+    }\n }\n \n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+void InterruptHTTPServer()\n {\n-    LOCK(g_httppathhandlers_mutex);\n-    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n-    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n-    for (; i != iend; ++i)\n-        if (i->prefix == prefix && i->exactMatch == exactMatch)\n-            break;\n-    if (i != iend)\n-    {\n-        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n-        pathHandlers.erase(i);\n+    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n+    if (g_http_server) {\n+        // Reject all new requests\n+        g_http_server->m_request_dispatcher = RejectAllRequests;\n     }\n+    if (g_work_queue) {\n+        // Stop workers, killing requests we haven't processed or responded to yet\n+        g_work_queue->Interrupt();\n+    }\n+}\n+\n+void StopHTTPServer()\n+{\n+    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n+    if (g_work_queue) {\n+        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n+        for (auto& thread : g_thread_http_workers) {\n+            thread.join();\n+        }\n+        g_thread_http_workers.clear();\n+    }\n+    if (g_http_server) {\n+        // Disconnect clients as their remaining responses are flushed\n+        g_http_server->m_disconnect_all_clients = true;\n+        // Wait for all disconnections\n+        while (!g_http_server->m_no_clients) {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{50});\n+        }\n+        // Break sockman I/O loop: stop accepting connections, sending and receiving data\n+        g_http_server->interruptNet();\n+        // Wait for sockman threads to exit\n+        g_http_server->JoinSocketsThreads();",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 1226,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2128818962,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Hm that's a good catch. I need the loop running to disconnect clients though -- although I might be able to call `HTTPServer::DisconnectClients()` one *extra* time after `interruptNet()` to clean up edge cases like that.\r\n\r\nOtherwise I'm not sure if it's even really a problem. We reject all requests in `InterruptHTTPServer()` which is called first, so the only risk on the server side would be if a lingering connection means `JoinSocketsThreads()` blocks forever.\r\n\r\n",
      "created_at": "2025-06-18T17:00:01Z",
      "updated_at": "2025-06-22T23:20:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2155102294",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155102294"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 982,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 989,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155113430",
      "pull_request_review_id": 2936787243,
      "id": 2155113430,
      "node_id": "PRRC_kwDOABII586AdGvW",
      "diff_hunk": "@@ -38,22 +42,16 @@ static const char* WWW_AUTH_HEADER_DATA = \"Basic realm=\\\"jsonrpc\\\"\";\n class HTTPRPCTimer : public RPCTimerBase\n {\n public:\n-    HTTPRPCTimer(struct event_base* eventBase, std::function<void()>& func, int64_t millis) :\n-        ev(eventBase, false, func)\n+    HTTPRPCTimer(NodeContext* context, std::function<void()>& func, int64_t millis)\n     {\n-        struct timeval tv;\n-        tv.tv_sec = millis/1000;\n-        tv.tv_usec = (millis%1000)*1000;\n-        ev.trigger(&tv);\n+        context->scheduler->scheduleFromNow(func, std::chrono::milliseconds(millis));",
      "path": "src/httprpc.cpp",
      "position": 1,
      "original_position": 32,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2131476990,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Can I though? Parent class `RPCTimerInterface` uses `int64_t millis` and so does our sibling class `QtRPCTimerBase` because of its `QTimer`.",
      "created_at": "2025-06-18T17:07:02Z",
      "updated_at": "2025-06-22T23:20:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2155113430",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155113430"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155128685",
      "pull_request_review_id": 2936787243,
      "id": 2155128685,
      "node_id": "PRRC_kwDOABII586AdKdt",
      "diff_hunk": "@@ -62,10 +60,10 @@ class HTTPRPCTimerInterface : public RPCTimerInterface\n     }\n     RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis) override\n     {\n-        return new HTTPRPCTimer(base, func, millis);\n+        return new HTTPRPCTimer(m_context, func, millis);\n     }\n private:\n-    struct event_base* base;\n+    NodeContext* m_context;",
      "path": "src/httprpc.cpp",
      "position": 1,
      "original_position": 55,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2131479604,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This makes sense to me but the problem is we are only ever given a pointer to a `NodeContext` (line 718):\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/5e6dbfd14ea9eace1c7e5ee76b140be46a0ec855/src/init.cpp#L710-L723\r\n\r\nIt was explicitly changed from a reference to a pointer in https://github.com/bitcoin/bitcoin/pull/21574\r\n\r\nI tried passing `node` here and then jsut extracting the `&address` for `HTTPReq_JSONRPC()` but that resulted in `JSONRPCException: Node context not found (-32603)`.\r\n\r\nGoing to put this daemon back in the bottle for now, but can re-examine in a future rebase or follow-up",
      "created_at": "2025-06-18T17:16:20Z",
      "updated_at": "2025-06-22T23:20:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2155128685",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155128685"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157346969",
      "pull_request_review_id": 2936787243,
      "id": 2157346969,
      "node_id": "PRRC_kwDOABII586AloCZ",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 307,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2093076600,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "ðŸ‘ ",
      "created_at": "2025-06-19T16:12:09Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2157346969",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157346969"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 314,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157347254",
      "pull_request_review_id": 2936787243,
      "id": 2157347254,
      "node_id": "PRRC_kwDOABII586AloG2",
      "diff_hunk": "@@ -132,7 +130,7 @@ static bool multiUserAuthorized(std::string strUserPass)\n     return false;\n }\n \n-static bool RPCAuthorized(const std::string& strAuth, std::string& strAuthUsernameOut)\n+static bool RPCAuthorized(const std::string_view& strAuth, std::string& strAuthUsernameOut)",
      "path": "src/httprpc.cpp",
      "position": 1,
      "original_position": 73,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2131490238,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nice catch thanks",
      "created_at": "2025-06-19T16:12:22Z",
      "updated_at": "2025-06-22T23:20:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2157347254",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157347254"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157371364",
      "pull_request_review_id": 2936787243,
      "id": 2157371364,
      "node_id": "PRRC_kwDOABII586Alt_k",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 320,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2093078641,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": ":+1:",
      "created_at": "2025-06-19T16:29:54Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2157371364",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157371364"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 321,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157372062",
      "pull_request_review_id": 2936787243,
      "id": 2157372062,
      "node_id": "PRRC_kwDOABII586AluKe",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 336,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2093081846,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": ":+1:",
      "created_at": "2025-06-19T16:30:36Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2157372062",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157372062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 332,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157378785",
      "pull_request_review_id": 2936787243,
      "id": 2157378785,
      "node_id": "PRRC_kwDOABII586Alvzh",
      "diff_hunk": "@@ -27,168 +34,309 @@ static const int DEFAULT_HTTP_WORKQUEUE=64;\n \n static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;\n \n-struct evhttp_request;\n-struct event_base;\n-class CService;\n-class HTTPRequest;\n+enum HTTPRequestMethod {\n+    UNKNOWN,\n+    GET,\n+    POST,\n+    HEAD,\n+    PUT\n+};\n \n-/** Initialize HTTP server.\n- * Call this before RegisterHTTPHandler or EventBase().\n- */\n-bool InitHTTPServer(const util::SignalInterrupt& interrupt);\n-/** Start HTTP server.\n- * This is separate from InitHTTPServer to give users race-condition-free time\n- * to register their handlers between InitHTTPServer and StartHTTPServer.\n+/** Event handler closure.\n  */\n-void StartHTTPServer();\n-/** Interrupt HTTP server threads */\n-void InterruptHTTPServer();\n-/** Stop HTTP server */\n-void StopHTTPServer();\n+class HTTPClosure\n+{\n+public:\n+    virtual void operator()() = 0;\n+    virtual ~HTTPClosure() = default;\n+};\n \n-/** Change logging level for libevent. */\n-void UpdateHTTPServerLogging(bool enable);\n+namespace http_bitcoin {\n+using util::LineReader;\n+using NodeId = SockMan::Id;\n \n-/** Handler for requests to a certain HTTP path */\n-typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n-/** Register handler for prefix.\n- * If multiple handlers match a prefix, the first-registered one will\n- * be invoked.\n- */\n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler);\n-/** Unregister handler for prefix */\n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch);\n+// shortest valid request line, used by libevent in evhttp_parse_request_line()\n+static const size_t MIN_REQUEST_LINE_LENGTH{strlen(\"GET / HTTP/1.0\")};\n+// maximum size of http request (request line + headers)\n+// see https://github.com/bitcoin/bitcoin/issues/6425\n+static const size_t MAX_HEADERS_SIZE{8192};\n \n-/** Return evhttp event base. This can be used by submodules to\n- * queue timers or custom events.\n- */\n-struct event_base* EventBase();\n+class HTTPHeaders\n+{\n+public:\n+    std::optional<std::string_view> Find(const std::string key) const;\n+    void Write(const std::string key, const std::string value);\n+    void Remove(const std::string key);\n+    bool Read(util::LineReader& reader);",
      "path": "src/httpserver.h",
      "position": 100,
      "original_position": 86,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2093181637,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "sure will add",
      "created_at": "2025-06-19T16:36:32Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2157378785",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157378785"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 83,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157403403",
      "pull_request_review_id": 2936787243,
      "id": 2157403403,
      "node_id": "PRRC_kwDOABII586Al10L",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {\n+        // Transfer-Encoding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-3.3.1\n+        // Chunked Transfer Coding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-4.1\n+        // see evhttp_handle_chunked_read() in libevent http.c\n+        while (reader.Left() > 0) {\n+            auto maybe_chunk_size = reader.ReadLine();\n+            if (!maybe_chunk_size) return false;\n+            uint64_t chunk_size;\n+\n+            if (!ParseUInt64Hex(maybe_chunk_size.value(), &chunk_size)) throw std::runtime_error(\"Invalid chunk size\");\n+\n+            bool last_chunk{chunk_size == 0};\n+\n+            if (!last_chunk) {\n+                // We are still expecting more data for this chunk\n+                if (reader.Left() < chunk_size) {\n+                    return false;\n+                }\n+                // Pack chunk onto body\n+                m_body += reader.ReadLength(chunk_size);\n+            }\n+\n+            // Even though every chunk size is explicitly declared,\n+            // they are still terminated by a CRLF we don't need.\n+            auto crlf = reader.ReadLine();\n+            if (!crlf || crlf.value().size() != 0) throw std::runtime_error(\"Improperly terminated chunk\");\n+\n+            if (last_chunk) return true;\n+        }\n+\n+        // We read all the chunks but never got the last chunk, wait for client to send more\n+        return false;\n     } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+        // No Content-length or Transfer-Encoding header means no body, see libevent evhttp_get_body()\n+        auto content_length_value{m_headers.Find(\"Content-Length\")};\n+        if (!content_length_value) return true;\n+\n+        uint64_t content_length;\n+        if (!ParseUInt64(content_length_value.value(), &content_length)) throw std::runtime_error(\"Cannot parse Content-Length value\");\n+\n+        // Not enough data in buffer for expected body\n+        if (reader.Left() < content_length) return false;\n+\n+        m_body = reader.ReadLength(content_length);\n+\n+        return true;\n     }\n }\n \n-static std::thread g_thread_http;\n-static std::vector<std::thread> g_thread_http_workers;\n+CService HTTPRequest::GetPeer() const\n+{\n+    return m_client->m_addr;\n+}\n \n-void StartHTTPServer()\n+HTTPRequestMethod HTTPRequest::GetRequestMethod() const\n {\n-    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n-    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n-    g_thread_http = std::thread(ThreadHTTP, eventBase);\n+    if (m_method == \"GET\") return HTTPRequestMethod::GET;\n+    if (m_method == \"POST\") return HTTPRequestMethod::POST;\n+    if (m_method == \"HEAD\") return HTTPRequestMethod::HEAD;\n+    if (m_method == \"PUT\") return HTTPRequestMethod::PUT;\n+    return HTTPRequestMethod::UNKNOWN;\n+}\n \n-    for (int i = 0; i < rpcThreads; i++) {\n-        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+{\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n+    }\n+    const std::string_view query{decoded_uri.data() + start + 1, end - start - 1};\n+    // find requested parameter in query\n+    const std::vector<std::string_view> params{Split<std::string_view>(query, \"&\")};\n+    for (const std::string_view& param : params) {\n+        size_t delim = param.find('=');\n+        if (key == param.substr(0, delim)) {\n+            if (delim == std::string::npos) {\n+                return \"\";\n+            } else {\n+                return std::string(param.substr(delim + 1));\n+            }\n+        }\n     }\n+    return std::nullopt;\n }\n \n-void InterruptHTTPServer()\n+std::pair<bool, std::string_view> HTTPRequest::GetHeader(const std::string& hdr) const\n {\n-    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n-    if (eventHTTP) {\n-        // Reject requests on current connections\n-        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n-    }\n-    if (g_work_queue) {\n-        g_work_queue->Interrupt();\n-    }\n+    std::optional<std::string_view> found{m_headers.Find(hdr)};\n+    if (found.has_value()) {\n+        return std::make_pair(true, found.value());\n+    } else\n+        return std::make_pair(false, \"\");\n }\n \n-void StopHTTPServer()\n+void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n {\n-    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n-    if (g_work_queue) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n-        for (auto& thread : g_thread_http_workers) {\n-            thread.join();\n+    m_response_headers.Write(hdr, value);\n+}\n+\n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.Find(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC7231DateTime(now_seconds));\n+\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n         }\n-        g_thread_http_workers.clear();\n     }\n-    // Unlisten sockets, these are what make the event loop running, which means\n-    // that after this and all connections are closed the event loop will quit.\n-    for (evhttp_bound_socket *socket : boundSockets) {\n-        evhttp_del_accept_socket(eventHTTP, socket);\n+\n+    if (needs_body && !res.m_headers.Find(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n     }\n-    boundSockets.clear();\n+\n+    auto connection_header{m_headers.Find(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        res.m_headers.Remove(\"Connection\");\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    m_client->m_keep_alive = res.m_keep_alive;\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    bool send_buffer_was_empty{false};\n+    // Fill the send buffer with the complete serialized response headers + body\n     {\n-        if (const auto n_connections{g_requests.CountActiveConnections()}; n_connections != 0) {\n-            LogDebug(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections);\n-        }\n-        g_requests.WaitUntilEmpty();\n-    }\n-    if (eventHTTP) {\n-        // Schedule a callback to call evhttp_free in the event base thread, so\n-        // that evhttp_free does not need to be called again after the handling\n-        // of unfinished request connections that follows.\n-        event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {\n-            evhttp_free(eventHTTP);\n-            eventHTTP = nullptr;\n-        }, nullptr, nullptr);\n-    }\n-    if (eventBase) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n-        if (g_thread_http.joinable()) g_thread_http.join();\n-        event_base_free(eventBase);\n-        eventBase = nullptr;\n-    }\n-    g_work_queue.reset();\n-    LogDebug(BCLog::HTTP, \"Stopped HTTP server\\n\");\n-}\n+        LOCK(m_client->m_send_mutex);\n+        send_buffer_was_empty = m_client->m_send_buffer.empty();\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());\n+    }\n+\n+    LogDebug(\n+        BCLog::HTTP,\n+        \"HTTPResponse (status code: %d size: %lld) added to send buffer for client %s (id=%lld)\\n\",\n+        status,\n+        headers_bytes.size() + reply_body.size(),\n+        m_client->m_origin,\n+        m_client->m_node_id);\n+\n+    // If the send buffer was empty before we wrote this reply, we can try an\n+    // optimistic send akin to CConnman::PushMessage() in which we\n+    // push the data directly out the socket to client right now, instead\n+    // of waiting for the next iteration of the Sockman I/O loop.\n+    if (send_buffer_was_empty) {\n+        m_client->SendBytesFromBuffer();\n+    } else {\n+        // Inform Sockman I/O there is data that is ready to be sent to this client\n+        // in the next loop iteration.\n+        m_client->m_send_ready = true;\n+    }\n \n-struct event_base* EventBase()\n-{\n-    return eventBase;\n+    // Signal to the Sockman I/O loop that we are ready to handle the next request.\n+    m_client->m_req_busy = false;\n }\n \n-static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n+bool HTTPClient::ReadRequest(std::unique_ptr<HTTPRequest>& req)\n {\n-    // Static handler: simply call inner handler\n-    HTTPEvent *self = static_cast<HTTPEvent*>(data);\n-    self->handler();\n-    if (self->deleteWhenTriggered)\n-        delete self;\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(\n+        m_recv_buffer.begin(),\n+        m_recv_buffer.begin() + (reader.it - reader.start));\n+\n+    return true;\n }\n \n-HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):\n-    deleteWhenTriggered(_deleteWhenTriggered), handler(_handler)\n-{\n-    ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n-    assert(ev);\n+bool HTTPClient::SendBytesFromBuffer()\n+{\n+    Assume(m_server);\n+\n+    // Send as much data from this client's buffer as we can\n+    LOCK(m_send_mutex);\n+    if (!m_send_buffer.empty()) {\n+        std::string err;\n+        // We don't intend to \"send more\" because http responses are usually small and we want the kernel to send them right away.\n+        ssize_t bytes_sent = m_server->SendBytes(m_node_id, MakeUCharSpan(m_send_buffer), /*will_send_more=*/false, err);\n+        if (bytes_sent < 0) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error sending HTTP response data to client %s (id=%lld): %s\\n\",\n+                m_origin,\n+                m_node_id,\n+                err);\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+            m_disconnect = true;\n+            return false;\n+        }\n+\n+        Assume(static_cast<size_t>(bytes_sent) <= m_send_buffer.size());\n+        m_send_buffer.erase(m_send_buffer.begin(), m_send_buffer.begin() + bytes_sent);\n+\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Sent %d bytes to client %s (id=%lld)\\n\",\n+            bytes_sent,\n+            m_origin,\n+            m_node_id);\n+\n+        // This check is inside the if(!empty) block meaning \"there was data but now its gone\".\n+        // We shouldn't even be calling SendBytesFromBuffer() when the send buffer is empty,\n+        // but for belt-and-suspenders, we don't want to modify the disconnect flags if SendBytesFromBuffer() was a no-op.\n+        if (m_send_buffer.empty()) {\n+            m_send_ready = false;\n+            m_prevent_disconnect = false;\n+\n+            // Our work is done here\n+            if (!m_keep_alive) {\n+                m_disconnect = true;\n+                return false;\n+            }\n+        } else {\n+            m_send_ready = true;\n+            m_prevent_disconnect = true;\n+        }\n+    }\n+\n+    return true;\n }\n-HTTPEvent::~HTTPEvent()\n+\n+void HTTPServer::CloseConnectionInternal(std::shared_ptr<HTTPClient>& client)\n {\n-    event_free(ev);\n+    if (CloseConnection(client->m_node_id)) {\n+        LogDebug(BCLog::HTTP, \"Disconnected HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    } else {\n+        LogDebug(BCLog::HTTP, \"Failed to disconnect non-existent HTTP client %s (id=%d)\\n\", client->m_origin, client->m_node_id);\n+    }\n }",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 809,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2128594514,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "yes thanks",
      "created_at": "2025-06-19T16:58:09Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2157403403",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157403403"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 704,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 711,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157405828",
      "pull_request_review_id": 2936787243,
      "id": 2157405828,
      "node_id": "PRRC_kwDOABII586Al2aE",
      "diff_hunk": "@@ -27,168 +34,309 @@ static const int DEFAULT_HTTP_WORKQUEUE=64;\n \n static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;\n \n-struct evhttp_request;\n-struct event_base;\n-class CService;\n-class HTTPRequest;\n+enum HTTPRequestMethod {\n+    UNKNOWN,\n+    GET,\n+    POST,\n+    HEAD,\n+    PUT\n+};\n \n-/** Initialize HTTP server.\n- * Call this before RegisterHTTPHandler or EventBase().\n- */\n-bool InitHTTPServer(const util::SignalInterrupt& interrupt);\n-/** Start HTTP server.\n- * This is separate from InitHTTPServer to give users race-condition-free time\n- * to register their handlers between InitHTTPServer and StartHTTPServer.\n+/** Event handler closure.\n  */\n-void StartHTTPServer();\n-/** Interrupt HTTP server threads */\n-void InterruptHTTPServer();\n-/** Stop HTTP server */\n-void StopHTTPServer();\n+class HTTPClosure\n+{\n+public:\n+    virtual void operator()() = 0;\n+    virtual ~HTTPClosure() = default;\n+};\n \n-/** Change logging level for libevent. */\n-void UpdateHTTPServerLogging(bool enable);\n+namespace http_bitcoin {\n+using util::LineReader;\n+using NodeId = SockMan::Id;\n \n-/** Handler for requests to a certain HTTP path */\n-typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n-/** Register handler for prefix.\n- * If multiple handlers match a prefix, the first-registered one will\n- * be invoked.\n- */\n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler);\n-/** Unregister handler for prefix */\n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch);\n+// shortest valid request line, used by libevent in evhttp_parse_request_line()\n+static const size_t MIN_REQUEST_LINE_LENGTH{strlen(\"GET / HTTP/1.0\")};\n+// maximum size of http request (request line + headers)\n+// see https://github.com/bitcoin/bitcoin/issues/6425\n+static const size_t MAX_HEADERS_SIZE{8192};\n \n-/** Return evhttp event base. This can be used by submodules to\n- * queue timers or custom events.\n- */\n-struct event_base* EventBase();\n+class HTTPHeaders\n+{\n+public:\n+    std::optional<std::string_view> Find(const std::string key) const;\n+    void Write(const std::string key, const std::string value);\n+    void Remove(const std::string key);\n+    bool Read(util::LineReader& reader);\n+    std::string Stringify() const;\n+\n+private:\n+    std::map<std::string, std::string, util::CaseInsensitiveComparator> m_map;\n+};\n+\n+class HTTPResponse\n+{\n+public:\n+    int m_version_major;\n+    int m_version_minor;\n+    HTTPStatusCode m_status;\n+    std::string m_reason;\n+    HTTPHeaders m_headers;\n+    std::vector<std::byte> m_body;\n+    bool m_keep_alive{false};\n+\n+    std::string StringifyHeaders() const;\n+};\n+\n+class HTTPClient;\n \n-/** In-flight HTTP request.\n- * Thin C++ wrapper around evhttp_request.\n- */\n class HTTPRequest\n {\n-private:\n-    struct evhttp_request* req;\n-    const util::SignalInterrupt& m_interrupt;\n-    bool replySent;\n+public:\n+    std::string m_method;\n+    std::string m_target;\n+    // Default protocol version is used by error responses to unreadable requests\n+    int m_version_major{1};\n+    int m_version_minor{1};\n+    HTTPHeaders m_headers;\n+    std::string m_body;\n+\n+    // Keep a pointer to the client that made the request so\n+    // we know who to respond to.\n+    std::shared_ptr<HTTPClient> m_client;\n+    explicit HTTPRequest(std::shared_ptr<HTTPClient> client) : m_client(client) {};\n+    // Null client for unit tests\n+    explicit HTTPRequest() : m_client(nullptr) {};\n+\n+    // Readers return false if they need more data from the\n+    // socket to parse properly. They throw errors if\n+    // the data is invalid.\n+    bool LoadControlData(LineReader& reader);\n+    bool LoadHeaders(LineReader& reader);\n+    bool LoadBody(LineReader& reader);\n+\n+    // These methods reimplement the API from http_libevent::HTTPRequest\n+    // for downstream JSONRPC and REST modules.\n+    std::string GetURI() const {return m_target;};\n+    CService GetPeer() const;\n+    HTTPRequestMethod GetRequestMethod() const;\n+    std::optional<std::string> GetQueryParameter(const std::string& key) const;\n+    std::pair<bool, std::string_view> GetHeader(const std::string& hdr) const;\n+    std::string ReadBody() const {return m_body;};\n+    void WriteHeader(const std::string& hdr, const std::string& value);\n+\n+    // Response headers may be set in advance before response body is known\n+    HTTPHeaders m_response_headers;\n+    void WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body = {});\n+    void WriteReply(HTTPStatusCode status, std::string_view reply_body_view)\n+    {\n+        WriteReply(status, std::as_bytes(std::span{reply_body_view}));\n+    }\n+};\n+\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key);\n+\n+class HTTPServer;\n \n+class HTTPClient\n+{\n public:\n-    explicit HTTPRequest(struct evhttp_request* req, const util::SignalInterrupt& interrupt, bool replySent = false);\n-    ~HTTPRequest();\n-\n-    enum RequestMethod {\n-        UNKNOWN,\n-        GET,\n-        POST,\n-        HEAD,\n-        PUT\n+    // ID provided by SockMan, inherited by HTTPServer\n+    NodeId m_node_id;\n+    // Remote address of connected client\n+    CService m_addr;\n+    // IP:port of connected client, cached for logging purposes\n+    std::string m_origin;\n+    // Pointer back to the server so we can call Sockman I/O methods from the client\n+    // Ok to remain null for unit tests.\n+    HTTPServer* m_server;\n+\n+    // In lieu of an intermediate transport class like p2p uses,\n+    // we copy data from the socket buffer to the client object\n+    // and attempt to read HTTP requests from here.\n+    std::vector<std::byte> m_recv_buffer{};\n+\n+    // Requests from a client must be processed in the order in which\n+    // they were received, blocking on a per-client basis. We won't\n+    // process the next request in the queue if we are currently busy\n+    // handling a previous request.\n+    std::deque<std::unique_ptr<HTTPRequest>> m_req_queue;\n+    // Set to true by the main thread when a request is popped off\n+    // and passed to a worker, reset to false by the worker thread.\n+    std::atomic_bool m_req_busy{false};\n+\n+    // Response data destined for this client.\n+    // Written to directly by http worker threads, read and erased by Sockman I/O\n+    Mutex m_send_mutex;\n+    std::vector<std::byte> m_send_buffer GUARDED_BY(m_send_mutex);\n+    // Set true by worker threads after writing a response to m_send_buffer.\n+    // Set false by the Sockman I/O thread after flushing m_send_buffer.\n+    // Checked in the Sockman I/O loop to avoid locking m_send_mutex if there's nothing to send.\n+    std::atomic_bool m_send_ready{false};\n+\n+    // Set to true when we receive request data and set to false once m_send_buffer is cleared.\n+    // Checked during DisconnectClients(). All of these operations take place in the Sockman I/O loop,\n+    // however it may get set my a worker thread during an \"optimistic send\".\n+    std::atomic_bool m_prevent_disconnect{false};",
      "path": "src/httpserver.h",
      "position": 1,
      "original_position": 212,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2128627105,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": ":+1:",
      "created_at": "2025-06-19T17:00:06Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2157405828",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157405828"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 177,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 180,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157422216",
      "pull_request_review_id": 2936787243,
      "id": 2157422216,
      "node_id": "PRRC_kwDOABII586Al6aI",
      "diff_hunk": "@@ -27,168 +34,309 @@ static const int DEFAULT_HTTP_WORKQUEUE=64;\n \n static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;\n \n-struct evhttp_request;\n-struct event_base;\n-class CService;\n-class HTTPRequest;\n+enum HTTPRequestMethod {\n+    UNKNOWN,\n+    GET,\n+    POST,\n+    HEAD,\n+    PUT\n+};\n \n-/** Initialize HTTP server.\n- * Call this before RegisterHTTPHandler or EventBase().\n- */\n-bool InitHTTPServer(const util::SignalInterrupt& interrupt);\n-/** Start HTTP server.\n- * This is separate from InitHTTPServer to give users race-condition-free time\n- * to register their handlers between InitHTTPServer and StartHTTPServer.\n+/** Event handler closure.\n  */\n-void StartHTTPServer();\n-/** Interrupt HTTP server threads */\n-void InterruptHTTPServer();\n-/** Stop HTTP server */\n-void StopHTTPServer();\n+class HTTPClosure\n+{\n+public:\n+    virtual void operator()() = 0;\n+    virtual ~HTTPClosure() = default;\n+};\n \n-/** Change logging level for libevent. */\n-void UpdateHTTPServerLogging(bool enable);\n+namespace http_bitcoin {\n+using util::LineReader;\n+using NodeId = SockMan::Id;\n \n-/** Handler for requests to a certain HTTP path */\n-typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n-/** Register handler for prefix.\n- * If multiple handlers match a prefix, the first-registered one will\n- * be invoked.\n- */\n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler);\n-/** Unregister handler for prefix */\n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch);\n+// shortest valid request line, used by libevent in evhttp_parse_request_line()\n+static const size_t MIN_REQUEST_LINE_LENGTH{strlen(\"GET / HTTP/1.0\")};\n+// maximum size of http request (request line + headers)\n+// see https://github.com/bitcoin/bitcoin/issues/6425\n+static const size_t MAX_HEADERS_SIZE{8192};\n \n-/** Return evhttp event base. This can be used by submodules to\n- * queue timers or custom events.\n- */\n-struct event_base* EventBase();\n+class HTTPHeaders\n+{\n+public:\n+    std::optional<std::string_view> Find(const std::string key) const;\n+    void Write(const std::string key, const std::string value);\n+    void Remove(const std::string key);\n+    bool Read(util::LineReader& reader);\n+    std::string Stringify() const;\n+\n+private:\n+    std::map<std::string, std::string, util::CaseInsensitiveComparator> m_map;",
      "path": "src/httpserver.h",
      "position": 1,
      "original_position": 90,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2131632124,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This is great feedback thanks. I made this change by first editing the `\"string: add CaseInsensitiveComparator\"` commit which is now `\"string: add CaseInsensitive{KeyEqual, Hash} for unordered map\"` and implements the two operators needed for the unordered map.",
      "created_at": "2025-06-19T17:16:37Z",
      "updated_at": "2025-06-22T23:20:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2157422216",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157422216"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157499320",
      "pull_request_review_id": 2936787243,
      "id": 2157499320,
      "node_id": "PRRC_kwDOABII586AmNO4",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 313,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2131642866,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Ah that is another great catch thank you. Glad I wrote that as an extra commit! I'll pop it off, it was added in response to this review comment: https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2062578806",
      "created_at": "2025-06-19T18:30:47Z",
      "updated_at": "2025-06-22T23:20:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2157499320",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157499320"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 314,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 318,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157508576",
      "pull_request_review_id": 2936787243,
      "id": 2157508576,
      "node_id": "PRRC_kwDOABII586AmPfg",
      "diff_hunk": "@@ -417,361 +286,708 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n     queue->Run();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    BCLog::Level level;\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        level = BCLog::Level::Debug;\n-        break;\n-    case EVENT_LOG_MSG:\n-        level = BCLog::Level::Info;\n-        break;\n-    case EVENT_LOG_WARN:\n-        level = BCLog::Level::Warning;\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        level = BCLog::Level::Error;\n-        break;\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+namespace http_bitcoin {\n+using util::Split;\n+\n+std::optional<std::string_view> HTTPHeaders::Find(const std::string key) const\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return std::string_view(it->second);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+void HTTPHeaders::Write(const std::string key, const std::string value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = std::string(existing_value.value()) + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+void HTTPHeaders::Remove(const std::string key)\n+{\n+    m_map.erase(key);\n+}\n \n-    raii_event_base base_ctr = obtain_event_base();\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        return false;\n-    }\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        return false;\n+        // Whitespace is optional\n+        std::string key = util::TrimString(line.substr(0, pos));\n+        std::string value = util::TrimString(line.substr(pos + 1));\n+        Write(key, value);\n+    } while (true);\n+\n+    return true;\n+}\n+\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n+\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_method = parts[0];\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<int>(version_parts[0]);\n+    auto minor = ToIntegral<int>(version_parts[1]);\n+    if (!major || !minor) throw std::runtime_error(\"HTTP request line malformed\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+\n+    auto transfer_encoding_header = m_headers.Find(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {\n+        // Transfer-Encoding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-3.3.1\n+        // Chunked Transfer Coding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-4.1\n+        // see evhttp_handle_chunked_read() in libevent http.c\n+        while (reader.Left() > 0) {\n+            auto maybe_chunk_size = reader.ReadLine();\n+            if (!maybe_chunk_size) return false;\n+            uint64_t chunk_size;\n+\n+            if (!ParseUInt64Hex(maybe_chunk_size.value(), &chunk_size)) throw std::runtime_error(\"Invalid chunk size\");\n+\n+            bool last_chunk{chunk_size == 0};\n+\n+            if (!last_chunk) {\n+                // We are still expecting more data for this chunk\n+                if (reader.Left() < chunk_size) {\n+                    return false;\n+                }\n+                // Pack chunk onto body\n+                m_body += reader.ReadLength(chunk_size);\n+            }\n+\n+            // Even though every chunk size is explicitly declared,\n+            // they are still terminated by a CRLF we don't need.\n+            auto crlf = reader.ReadLine();\n+            if (!crlf || crlf.value().size() != 0) throw std::runtime_error(\"Improperly terminated chunk\");\n+\n+            if (last_chunk) return true;\n+        }\n+\n+        // We read all the chunks but never got the last chunk, wait for client to send more\n+        return false;\n     } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+        // No Content-length or Transfer-Encoding header means no body, see libevent evhttp_get_body()\n+        auto content_length_value{m_headers.Find(\"Content-Length\")};\n+        if (!content_length_value) return true;\n+\n+        uint64_t content_length;\n+        if (!ParseUInt64(content_length_value.value(), &content_length)) throw std::runtime_error(\"Cannot parse Content-Length value\");\n+\n+        // Not enough data in buffer for expected body\n+        if (reader.Left() < content_length) return false;\n+\n+        m_body = reader.ReadLength(content_length);",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 492,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "7d301184016a3f59c2e363dff631263cdbe21da0",
      "in_reply_to_id": 2102677611,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Yeah its true, a client could send a request with a huge list of HTTP headers and an incomplete body and we would parse the headers over and over again from `m_recv_buffer` until the body was finally completed, when we finally pinch off a `HTTPRequest` and erase the data from the buffer.\r\n\r\nThere certainly is an optimization there, keeping an in-progress request attached to `HTTPClient` with a \"where we left off\" pointer. It sounds like you would be ok with seeing that in a follow-up PR but let me know if its blocking for you here.",
      "created_at": "2025-06-19T18:40:33Z",
      "updated_at": "2025-06-22T23:20:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2157508576",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2157508576"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 453,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 462,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2201222699",
      "pull_request_review_id": 3011050697,
      "id": 2201222699,
      "node_id": "PRRC_kwDOABII586DM_4r",
      "diff_hunk": "@@ -27,168 +35,317 @@ static const int DEFAULT_HTTP_WORKQUEUE=64;\n \n static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;\n \n-struct evhttp_request;\n-struct event_base;\n-class CService;\n-class HTTPRequest;\n+enum HTTPRequestMethod {\n+    UNKNOWN,\n+    GET,\n+    POST,\n+    HEAD,\n+    PUT\n+};\n \n-/** Initialize HTTP server.\n- * Call this before RegisterHTTPHandler or EventBase().\n- */\n-bool InitHTTPServer(const util::SignalInterrupt& interrupt);\n-/** Start HTTP server.\n- * This is separate from InitHTTPServer to give users race-condition-free time\n- * to register their handlers between InitHTTPServer and StartHTTPServer.\n+/** Event handler closure.\n  */\n-void StartHTTPServer();\n-/** Interrupt HTTP server threads */\n-void InterruptHTTPServer();\n-/** Stop HTTP server */\n-void StopHTTPServer();\n+class HTTPClosure\n+{\n+public:\n+    virtual void operator()() = 0;\n+    virtual ~HTTPClosure() = default;\n+};\n \n-/** Change logging level for libevent. */\n-void UpdateHTTPServerLogging(bool enable);\n+namespace http_bitcoin {",
      "path": "src/httpserver.h",
      "position": 53,
      "original_position": 59,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Just an idea, and not necessarily a suggestion for this PR since it could be a followup, but I was thinking since `httpserver.h` and `httpserver.cpp` files are basically rewritten here it could also be good to rename them to `rpc/http/server.h` and `rpc/http/server.cpp` and put them in a matching `rpc::http` namespace. Reasons for suggesting this:\r\n\r\n- To take some files out of the top level directory.\r\n- To choose a namespace name `rpc::http` that matches the directory path `rpc/http`.\r\n- To make space for a client library to be located at `rpc/http/client.h` `rpc/http/client.cpp` (for tools that may that want to use some `bitcoin-cli` functionality without shelling out to `bitcoin-cli`)\r\n- To make space for other RPC protocols to be implemented places like `rpc/grpc/`.\r\n- To make [`rpc/`](https://github.com/bitcoin/bitcoin/tree/master/src/rpc) and [`ipc/`](https://github.com/bitcoin/bitcoin/tree/master/src/ipc) layouts more consistent (since latter uses `src/ipc/<protocol>` structure).\r\n\r\nOne reason to _not_ like this suggestion would be if you wouldn't consider other uses of the HTTP server to be RPC. But I would interpret \"rpc\" liberally and probably move the related files as well:\r\n\r\n- `rest.h` -> `rpc/http/rest.h`\r\n- `rest.cpp` -> `rpc/http/rest.cpp`\r\n- `httprpc.h` -> `rpc/http/jsonrpc.h`\r\n- `httprpc.cpp` -> `rpc/http/jsonrpc.cpp`\r\n\r\nAgain not pushing for this, just wanted to mention the idea.",
      "created_at": "2025-07-11T16:32:04Z",
      "updated_at": "2025-07-11T16:32:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2201222699",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2201222699"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 51,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2318674837",
      "pull_request_review_id": 3180206398,
      "id": 2318674837,
      "node_id": "PRRC_kwDOABII586KNCuV",
      "diff_hunk": "@@ -352,6 +363,30 @@ struct Hex {\n };\n } // namespace detail\n \n+struct CaseInsensitiveKeyEqual {\n+    bool operator()(const std::string& s1, const std::string& s2) const\n+    {\n+        return ToLower(s1) == ToLower(s2);\n+    }\n+};\n+\n+struct CaseInsensitiveHash {\n+    size_t operator()(const std::string& s) const {\n+        std::string lowered;\n+        lowered.resize(s.size());\n+        std::transform(s.begin(), s.end(), lowered.begin(),\n+            [](char c) {\n+                // Avoid implicit-integer-sign-change UB by only\n+                // processing ASCII.\n+                unsigned char uc = static_cast<unsigned char>(c);\n+                if (uc >= 128) return c;",
      "path": "src/util/strencodings.h",
      "position": 1,
      "original_position": 66,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: I think that can be a bit shorter:\r\n\r\n```suggestion\r\n            [](char c) {\r\n                // Avoid implicit-integer-sign-change UB by only\r\n                // processing ASCII.\r\n                if (c < 0) return c;\r\n```",
      "created_at": "2025-09-03T11:30:09Z",
      "updated_at": "2025-09-03T13:20:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2318674837",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2318674837"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 378,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 382,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2318700631",
      "pull_request_review_id": 3180206398,
      "id": 2318700631,
      "node_id": "PRRC_kwDOABII586KNJBX",
      "diff_hunk": "@@ -35,8 +100,341 @@ BOOST_AUTO_TEST_CASE(test_query_parameters)\n     uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2\";\n     BOOST_CHECK(!GetQueryParameterFromUri(uri.c_str(), \"p1\").has_value());\n \n-    // URI with invalid characters (%) raises a runtime error regardless of which query parameter is queried\n-    uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2%\";\n-    BOOST_CHECK_EXCEPTION(GetQueryParameterFromUri(uri.c_str(), \"p1\"), std::runtime_error, HasReason(\"URI parsing failed, it likely contained RFC 3986 invalid characters\"));\n+    // Multiple parameters, some characters encoded\n+    uri = \"/rest/endpoint/someresource.json?p1=v1%20&p2=100%25\";\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p1\").value(), \"v1 \");\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p2\").value(), \"100%\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_query_parameters_bitcoin)\n+{\n+    test_query_parameters(http_bitcoin::GetQueryParameterFromUri);\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_headers_tests)\n+{\n+    {\n+        // Writing response headers\n+        HTTPHeaders headers{};\n+        BOOST_CHECK(!headers.Find(\"Cache-Control\"));\n+        headers.Write(\"Cache-Control\", \"no-cache\");\n+        // Check case-insensitive key matching\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"cache-control\").value(), \"no-cache\");\n+        // Additional values are comma-separated and appended\n+        headers.Write(\"Cache-Control\", \"no-store\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache, no-store\");\n+        // Add a few more\n+        headers.Write(\"Pie\", \"apple\");\n+        headers.Write(\"Sandwich\", \"ham\");\n+        headers.Write(\"Coffee\", \"black\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Pie\").value(), \"apple\");\n+        // Remove\n+        headers.Remove(\"Pie\");\n+        BOOST_CHECK(!headers.Find(\"Pie\"));\n+        // Combine for transmission\n+        // No order is specified for HTTP headers, ours are stored in std::unordered_map\n+        std::string headers_string{headers.Stringify()};\n+        BOOST_REQUIRE(headers_string.find(\"Sandwich: ham\\r\\n\") != std::string::npos);\n+        BOOST_REQUIRE(headers_string.find(\"Coffee: black\\r\\n\") != std::string::npos);\n+        BOOST_REQUIRE(headers_string.find(\"Cache-Control: no-cache, no-store\\r\\n\") != std::string::npos);\n+        // No matter what order the headers end up in, it should be terminated by an empty line\n+        BOOST_REQUIRE(headers_string.ends_with(\"\\r\\n\\r\\n\"));",
      "path": "src/test/httpserver_tests.cpp",
      "position": 1,
      "original_position": 128,
      "commit_id": "3002fbe0d97243d3534a53240d5574d0d4194bba",
      "original_commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Maybe also check that the total length of all headers is as expected. That is, no extra, unexpected, stuff has been returned:\r\n\r\n```diff\r\n         BOOST_REQUIRE(headers_string.ends_with(\"\\r\\n\\r\\n\"));\r\n+        BOOST_CHECK_EQUAL(headers_string.length(), 67);\r\n     }\r\n```",
      "created_at": "2025-09-03T11:42:10Z",
      "updated_at": "2025-09-03T13:20:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2318700631",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2318700631"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 137,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2318877575",
      "pull_request_review_id": 3180206398,
      "id": 2318877575,
      "node_id": "PRRC_kwDOABII586KN0OH",
      "diff_hunk": "@@ -35,8 +100,341 @@ BOOST_AUTO_TEST_CASE(test_query_parameters)\n     uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2\";\n     BOOST_CHECK(!GetQueryParameterFromUri(uri.c_str(), \"p1\").has_value());\n \n-    // URI with invalid characters (%) raises a runtime error regardless of which query parameter is queried\n-    uri = \"/rest/endpoint/someresource.json&p1=v1&p2=v2%\";\n-    BOOST_CHECK_EXCEPTION(GetQueryParameterFromUri(uri.c_str(), \"p1\"), std::runtime_error, HasReason(\"URI parsing failed, it likely contained RFC 3986 invalid characters\"));\n+    // Multiple parameters, some characters encoded\n+    uri = \"/rest/endpoint/someresource.json?p1=v1%20&p2=100%25\";\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p1\").value(), \"v1 \");\n+    BOOST_CHECK_EQUAL(GetQueryParameterFromUri(uri.c_str(), \"p2\").value(), \"100%\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_query_parameters_bitcoin)\n+{\n+    test_query_parameters(http_bitcoin::GetQueryParameterFromUri);\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_headers_tests)\n+{\n+    {\n+        // Writing response headers\n+        HTTPHeaders headers{};\n+        BOOST_CHECK(!headers.Find(\"Cache-Control\"));\n+        headers.Write(\"Cache-Control\", \"no-cache\");\n+        // Check case-insensitive key matching\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"cache-control\").value(), \"no-cache\");\n+        // Additional values are comma-separated and appended\n+        headers.Write(\"Cache-Control\", \"no-store\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Cache-Control\").value(), \"no-cache, no-store\");\n+        // Add a few more\n+        headers.Write(\"Pie\", \"apple\");\n+        headers.Write(\"Sandwich\", \"ham\");\n+        headers.Write(\"Coffee\", \"black\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Pie\").value(), \"apple\");\n+        // Remove\n+        headers.Remove(\"Pie\");\n+        BOOST_CHECK(!headers.Find(\"Pie\"));\n+        // Combine for transmission\n+        // No order is specified for HTTP headers, ours are stored in std::unordered_map\n+        std::string headers_string{headers.Stringify()};\n+        BOOST_REQUIRE(headers_string.find(\"Sandwich: ham\\r\\n\") != std::string::npos);\n+        BOOST_REQUIRE(headers_string.find(\"Coffee: black\\r\\n\") != std::string::npos);\n+        BOOST_REQUIRE(headers_string.find(\"Cache-Control: no-cache, no-store\\r\\n\") != std::string::npos);\n+        // No matter what order the headers end up in, it should be terminated by an empty line\n+        BOOST_REQUIRE(headers_string.ends_with(\"\\r\\n\\r\\n\"));\n+    }\n+    {\n+        // Reading request headers captured from bitcoin-cli\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(\n+            \"486f73743a203132372e302e302e310d0a436f6e6e656374696f6e3a20636c6f73\"\n+            \"650d0a436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e\"\n+            \"0d0a417574686f72697a6174696f6e3a204261736963205831396a623239726157\"\n+            \"5666587a6f7a597a4a6b4e5441784e44466c4d474a69596d56684d5449354f4467\"\n+            \"334e7a49354d544d334e54526d4e54686b4e6a63324f574d775a5459785a6a677a\"\n+            \"4e5467794e7a4577595459314f47526b596a566d5a4751330d0a436f6e74656e74\"\n+            \"2d4c656e6774683a2034360d0a0d0a\").value()};\n+        util::LineReader reader(buffer, /*max_read=*/1028);\n+        HTTPHeaders headers{};\n+        headers.Read(reader);\n+        BOOST_CHECK_EQUAL(headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzozYzJkNTAxNDFlMGJiYmVhMTI5ODg3NzI5MTM3NTRmNThkNjc2OWMwZTYxZjgzNTgyNzEwYTY1OGRkYjVmZGQ3\");\n+        BOOST_CHECK_EQUAL(headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK(!headers.Find(\"Pizza\"));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_response_tests)\n+{\n+    // Typical HTTP 1.1 response headers\n+    HTTPHeaders headers{};\n+    headers.Write(\"Content-Length\", \"41\");\n+    // Response points to headers which already exist because some of them\n+    // are set before we even know what the response will be.\n+    HTTPResponse res;\n+    res.m_version_major = 1;\n+    res.m_version_minor = 1;\n+    res.m_status = HTTP_OK;\n+    res.m_reason = HTTPReason.find(res.m_status)->second;\n+    res.m_body = StringToBuffer(\"{\\\"result\\\":865793,\\\"error\\\":null,\\\"id\\\":null\\\"}\");\n+    res.m_headers = std::move(headers);\n+    // Only one header means we don't need to worry about unordered_map,\n+    // this should always be the same:\n+    BOOST_CHECK_EQUAL(\n+        res.StringifyHeaders(),\n+        \"HTTP/1.1 200 OK\\r\\n\"\n+        \"Content-Length: 41\\r\\n\"\n+        \"\\r\\n\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_request_tests)\n+{\n+    {\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(full_request).value()};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, HTTPRequestMethod::POST);\n+        BOOST_CHECK_EQUAL(req.GetRequestMethod(), HTTPRequestMethod::POST);\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.GetURI(), \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 1);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzo5OGQ5ODQ3MWNmNjg0NzAzYTkzN2EzNzk0ZDFlODQ1NjZmYTRkZjJiMzFkYjhhODI4ZGY4MjVjOTg5ZGI4OTVl\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 46);\n+        BOOST_CHECK_EQUAL(req.m_body, \"{\\\"method\\\":\\\"getblockcount\\\",\\\"params\\\":[],\\\"id\\\":1}\\n\");\n+    }\n+    {\n+        const std::string too_short_request_line = \"GET/HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(too_short_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP / 1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/11\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/1.x\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string ok_request_line = \"GET / HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(ok_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, HTTPRequestMethod::GET);\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 0);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        // no body is OK\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string malformed_headers = \"GET / HTTP/1.0\\r\\nHost=127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK_THROW(req.LoadHeaders(reader), std::runtime_error);\n+    }\n+    {\n+        // We might not have received enough data from the client which is not\n+        // an error. We return false so the caller can try again later when the\n+        // buffer has more data.\n+        const std::string incomplete_headers = \"GET / HTTP/1.0\\r\\nHost: \";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(incomplete_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(!req.LoadHeaders(reader));\n+    }\n+    {\n+        const std::string no_content_length = \"GET / HTTP/1.0\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(no_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        // Don't try to read request body if Content-Length is missing\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string bad_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: eleven\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(bad_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK_THROW(req.LoadBody(reader), std::runtime_error);\n+    }\n+    {\n+        // Content-Length indicates more data than we have in the buffer.\n+        // Again, not an error just try again later.\n+        const std::string excessive_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: 1024\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(excessive_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(!req.LoadBody(reader));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(http_client_server_tests)\n+{\n+    // Hard code the timestamp for the Date header in the HTTP response\n+    // Wed Dec 11 00:47:09 2024 UTC\n+    SetMockTime(1733878029);\n+\n+    // Queue of connected sockets returned by listening socket (represents network interface)\n+    std::shared_ptr<DynSock::Queue> accepted_sockets{std::make_shared<DynSock::Queue>()};\n+\n+    CreateSock = [&accepted_sockets](int, int, int) {\n+        // This is a mock Listening Socket that the HTTP server will \"bind\" to and\n+        // listen to for incoming connections. We won't need to access its I/O\n+        // pipes because we don't read or write directly to it. It will return\n+        // Connected Sockets from the queue via its Accept() method.\n+        return std::make_unique<DynSock>(std::make_shared<DynSock::Pipes>(), accepted_sockets);\n+    };\n+\n+    {\n+        // I/O pipes of one mock Connected Socket we can read and write to.\n+        std::shared_ptr<DynSock::Pipes> connected_socket_pipes(std::make_shared<DynSock::Pipes>());\n+\n+        // Insert the payload: a correctly formatted HTTP request\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(full_request).value()};\n+        connected_socket_pipes->recv.PushBytes(buffer.data(), buffer.size());\n+\n+        // Mock Connected Socket that represents a client.\n+        // It needs I/O pipes but its queue can remain empty\n+        std::unique_ptr<DynSock> connected_socket{std::make_unique<DynSock>(connected_socket_pipes, std::make_shared<DynSock::Queue>())};\n+\n+        // Prepare queue of accepted_sockets: just one connection with no data\n+        accepted_sockets->Push(std::move(connected_socket));\n+\n+        // Prepare a request handler that just stores received requests so we can examine them\n+        // Mutex is required to prevent a race between this test's main thread and the Sockman I/O loop.\n+        Mutex requests_mutex;\n+        std::deque<std::unique_ptr<HTTPRequest>> requests;\n+        auto StoreRequest = [&](std::unique_ptr<HTTPRequest>&& req) {\n+            LOCK(requests_mutex);\n+            requests.push_back(std::move(req));\n+        };\n+\n+        // Instantiate server with dead-end request handler\n+        HTTPServer server = HTTPServer(StoreRequest);\n+        BOOST_REQUIRE(server.m_no_clients);\n+\n+        // This address won't actually get used because we stubbed CreateSock()\n+        const std::optional<CService> addr{Lookup(\"127.0.0.1\", 8333, false)};\n+        bilingual_str strError;\n+        // Bind to mock Listening Socket\n+        BOOST_REQUIRE(server.BindAndStartListening(addr.value(), strError));\n+        // Start the I/O loop, accepting connections\n+        SockMan::Options sockman_options;\n+        server.StartSocketsThreads(sockman_options);\n+\n+        // Wait up to one minute for mock client to connect.\n+        // Given that the mock client is itself a mock socket\n+        // with hard-coded data it should only take a fraction of that.\n+        int attempts{6000};\n+        while (attempts > 0)\n+        {\n+            if (!server.m_no_clients) break;\n+\n+            std::this_thread::sleep_for(10ms);\n+            --attempts;\n+        }\n+        BOOST_REQUIRE(!server.m_no_clients);\n+\n+        {\n+            LOCK(requests_mutex);\n+            // Connected client should have one request already from the static content.\n+            BOOST_CHECK_EQUAL(requests.size(), 1);\n+\n+            // Check the received request\n+            BOOST_CHECK_EQUAL(requests.front()->m_body, \"{\\\"method\\\":\\\"getblockcount\\\",\\\"params\\\":[],\\\"id\\\":1}\\n\");\n+            BOOST_CHECK_EQUAL(requests.front()->GetPeer().ToStringAddrPort(), \"5.5.5.5:6789\");\n+\n+            // Respond to request\n+            requests.front()->WriteReply(HTTP_OK, \"874140\\n\");\n+        }\n+\n+        // Check the sent response from the mock client at the other end of the mock socket\n+        std::string actual;\n+        bool expected{false};\n+        // Wait up to one minute for all the bytes to appear in the \"send\" pipe.\n+        char buf[0x10000] = {};\n+        attempts = 6000;\n+        while (attempts > 0)\n+        {\n+            ssize_t bytes_read = connected_socket_pipes->send.GetBytes(buf, sizeof(buf), 0);\n+            if (bytes_read > 0) {\n+                actual.append(buf, bytes_read);\n+                if (actual.ends_with(\"\\r\\n\\r\\n874140\\n\") &&\n+                    actual.find(\"HTTP/1.1 200 OK\\r\\n\") != std::string::npos &&\n+                    actual.find(\"Connection: close\\r\\n\") != std::string::npos &&\n+                    actual.find(\"Content-Length: 7\\r\\n\") != std::string::npos &&\n+                    actual.find(\"Content-Type: text/html; charset=ISO-8859-1\\r\\n\") != std::string::npos &&\n+                    actual.find(\"Date: Wed, 11 Dec 2024 00:47:09 GMT\\r\\n\") != std::string::npos",
      "path": "src/test/httpserver_tests.cpp",
      "position": 1,
      "original_position": 397,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Similar to above:\r\n\r\n```suggestion\r\n                    actual.find(\"Date: Wed, 11 Dec 2024 00:47:09 GMT\\r\\n\") != std::string::npos &&\r\n                    actual.length() == 146\r\n```",
      "created_at": "2025-09-03T12:50:43Z",
      "updated_at": "2025-09-03T13:20:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2318877575",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2318877575"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 411,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2318891980",
      "pull_request_review_id": 3180206398,
      "id": 2318891980,
      "node_id": "PRRC_kwDOABII586KN3vM",
      "diff_hunk": "@@ -27,168 +35,317 @@ static const int DEFAULT_HTTP_WORKQUEUE=64;\n \n static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;\n \n-struct evhttp_request;\n-struct event_base;\n-class CService;\n-class HTTPRequest;\n+enum HTTPRequestMethod {\n+    UNKNOWN,\n+    GET,\n+    POST,\n+    HEAD,\n+    PUT\n+};\n \n-/** Initialize HTTP server.\n- * Call this before RegisterHTTPHandler or EventBase().\n- */\n-bool InitHTTPServer(const util::SignalInterrupt& interrupt);\n-/** Start HTTP server.\n- * This is separate from InitHTTPServer to give users race-condition-free time\n- * to register their handlers between InitHTTPServer and StartHTTPServer.\n+/** Event handler closure.\n  */\n-void StartHTTPServer();\n-/** Interrupt HTTP server threads */\n-void InterruptHTTPServer();\n-/** Stop HTTP server */\n-void StopHTTPServer();\n+class HTTPClosure\n+{\n+public:\n+    virtual void operator()() = 0;\n+    virtual ~HTTPClosure() = default;\n+};\n \n-/** Change logging level for libevent. */\n-void UpdateHTTPServerLogging(bool enable);\n+namespace http_bitcoin {\n+using util::LineReader;\n+using NodeId = SockMan::Id;\n \n-/** Handler for requests to a certain HTTP path */\n-typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n-/** Register handler for prefix.\n- * If multiple handlers match a prefix, the first-registered one will\n- * be invoked.\n- */\n-void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler);\n-/** Unregister handler for prefix */\n-void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch);\n+// shortest valid request line, used by libevent in evhttp_parse_request_line()\n+static const size_t MIN_REQUEST_LINE_LENGTH{strlen(\"GET / HTTP/1.0\")};\n+// maximum size of http request (request line + headers)\n+// see https://github.com/bitcoin/bitcoin/issues/6425\n+static const size_t MAX_HEADERS_SIZE{8192};\n \n-/** Return evhttp event base. This can be used by submodules to\n- * queue timers or custom events.\n- */\n-struct event_base* EventBase();\n+class HTTPHeaders\n+{\n+public:\n+    std::optional<std::string> Find(const std::string key) const;\n+    void Write(const std::string& key, const std::string& value);\n+    void Remove(const std::string& key);\n+    /*\n+     * @returns false if LineReader hits the end of the buffer before reading an\n+     *                \\n, meaning that we are still waiting on more data from the client.\n+     *          true  after reading an entire HTTP headers section, terminated\n+     *                by an empty line and \\n.\n+     * @throws on exceeded read limit and on bad headers syntax (e.g. no \":\" in a line)\n+     */\n+    bool Read(util::LineReader& reader);\n+    std::string Stringify() const;\n+\n+private:\n+    std::unordered_map<std::string, std::string, util::CaseInsensitiveHash, util::CaseInsensitiveKeyEqual> m_map;\n+};\n+\n+class HTTPResponse\n+{\n+public:\n+    int m_version_major;\n+    int m_version_minor;\n+    HTTPStatusCode m_status;\n+    std::string m_reason;\n+    HTTPHeaders m_headers;\n+    std::vector<std::byte> m_body;\n+    bool m_keep_alive{false};\n+\n+    std::string StringifyHeaders() const;\n+};\n+\n+class HTTPClient;\n \n-/** In-flight HTTP request.\n- * Thin C++ wrapper around evhttp_request.\n- */\n class HTTPRequest\n {\n-private:\n-    struct evhttp_request* req;\n-    const util::SignalInterrupt& m_interrupt;\n-    bool replySent;\n+public:\n+    HTTPRequestMethod m_method;\n+    std::string m_target;\n+    // Default protocol version is used by error responses to unreadable requests\n+    int m_version_major{1};\n+    int m_version_minor{1};\n+    HTTPHeaders m_headers;\n+    std::string m_body;\n+\n+    // Keep a pointer to the client that made the request so\n+    // we know who to respond to.\n+    std::shared_ptr<HTTPClient> m_client;\n+    explicit HTTPRequest(std::shared_ptr<HTTPClient> client) : m_client(client) {};\n+    // Null client for unit tests\n+    explicit HTTPRequest() : m_client(nullptr) {};\n \n+    // Readers return false if they need more data from the\n+    // socket to parse properly. They throw errors if\n+    // the data is invalid.\n+    bool LoadControlData(LineReader& reader);\n+    bool LoadHeaders(LineReader& reader);\n+    bool LoadBody(LineReader& reader);\n+\n+    // These methods reimplement the API from http_libevent::HTTPRequest\n+    // for downstream JSONRPC and REST modules.\n+    std::string GetURI() const {return m_target;};\n+    CService GetPeer() const;\n+    HTTPRequestMethod GetRequestMethod() const {return m_method;};",
      "path": "src/httpserver.h",
      "position": 1,
      "original_position": 154,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: no need for trailing `;` and some missing whitespace:\r\n\r\n```suggestion\r\n    HTTPRequestMethod GetRequestMethod() const { return m_method; }\r\n```",
      "created_at": "2025-09-03T12:55:44Z",
      "updated_at": "2025-09-03T13:20:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2318891980",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2318891980"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542711002",
      "pull_request_review_id": 3483640692,
      "id": 2542711002,
      "node_id": "PRRC_kwDOABII586XjrDa",
      "diff_hunk": "@@ -352,6 +363,30 @@ struct Hex {\n };\n } // namespace detail\n \n+struct CaseInsensitiveKeyEqual {\n+    bool operator()(const std::string& s1, const std::string& s2) const\n+    {\n+        return ToLower(s1) == ToLower(s2);\n+    }\n+};\n+\n+struct CaseInsensitiveHash {\n+    size_t operator()(const std::string& s) const {\n+        std::string lowered;\n+        lowered.resize(s.size());\n+        std::transform(s.begin(), s.end(), lowered.begin(),\n+            [](char c) {\n+                // Avoid implicit-integer-sign-change UB by only\n+                // processing ASCII.\n+                unsigned char uc = static_cast<unsigned char>(c);\n+                if (uc >= 128) return c;",
      "path": "src/util/strencodings.h",
      "position": 1,
      "original_position": 66,
      "commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "original_commit_id": "e531a7cd2c17dfb8d075d02865dbc25f8a832b3a",
      "in_reply_to_id": 2318674837,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I guess I need to specify unsigned char for some platforms ?\r\n\r\n```\r\n/home/runner/work/_temp/src/util/strencodings.h:381:23: error: comparison is always false due to limited range of data type [-Werror=type-limits]\r\n  381 |                 if (c < 0) return c;\r\n      |                     ~~^~~\r\ncc1plus: all warnings being treated as errors\r\n```",
      "created_at": "2025-11-19T16:18:20Z",
      "updated_at": "2025-11-19T16:18:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2542711002",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542711002"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": 378,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 382,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647153745",
      "pull_request_review_id": 3612461816,
      "id": 2647153745,
      "node_id": "PRRC_kwDOABII586dyFxR",
      "diff_hunk": "@@ -362,4 +362,7 @@ bool IsBadPort(uint16_t port);\n  */\n CService MaybeFlipIPv6toCJDNS(const CService& service);\n \n+/** Get the bind address for a socket as CService. */\n+CService GetBindAddress(const Sock& sock);",
      "path": "src/netbase.h",
      "position": 1,
      "original_position": 5,
      "commit_id": "b6afd81f58f5aabb20fb02924a3e259670d6b3ab",
      "original_commit_id": "b656c35c09a36541c689d0278212ec99cf22bd72",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: I think I wouldn't call the commit move-only because of this.",
      "created_at": "2025-12-25T16:32:16Z",
      "updated_at": "2025-12-25T17:38:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2647153745",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647153745"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 367,
      "original_line": 366,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647158429",
      "pull_request_review_id": 3612461816,
      "id": 2647158429,
      "node_id": "PRRC_kwDOABII586dyG6d",
      "diff_hunk": "@@ -951,10 +951,13 @@ CService MaybeFlipIPv6toCJDNS(const CService& service)\n CService GetBindAddress(const Sock& sock)\n {\n     CService addr_bind;\n-    struct sockaddr_storage sockaddr_bind;\n-    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n-    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n-        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    sockaddr_storage storage;\n+    socklen_t len = sizeof(storage);\n+\n+    auto sa = static_cast<sockaddr*>(static_cast<void*>(&storage));",
      "path": "src/netbase.cpp",
      "position": 1,
      "original_position": 11,
      "commit_id": "b6afd81f58f5aabb20fb02924a3e259670d6b3ab",
      "original_commit_id": "ed360080c16404a3181090741ff69bf35fc4deb0",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The commit message talks about `reinterpret_cast` but the code uses `static_cast`?",
      "created_at": "2025-12-25T16:42:38Z",
      "updated_at": "2025-12-25T17:38:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2647158429",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647158429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 957,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647162093",
      "pull_request_review_id": 3612461816,
      "id": 2647162093,
      "node_id": "PRRC_kwDOABII586dyHzt",
      "diff_hunk": "@@ -951,10 +951,13 @@ CService MaybeFlipIPv6toCJDNS(const CService& service)\n CService GetBindAddress(const Sock& sock)\n {\n     CService addr_bind;\n-    struct sockaddr_storage sockaddr_bind;\n-    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n-    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n-        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    sockaddr_storage storage;\n+    socklen_t len = sizeof(storage);\n+\n+    auto sa = static_cast<sockaddr*>(static_cast<void*>(&storage));\n+\n+    if (!sock.GetSockName(sa, &len)) {",
      "path": "src/netbase.cpp",
      "position": 1,
      "original_position": 13,
      "commit_id": "625088468a3f2f1438fd71d1b87210e16904fa58",
      "original_commit_id": "ed360080c16404a3181090741ff69bf35fc4deb0",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: I would prefer something like this because it's clearer to me when you look at this with c++ eyes like I did at first. Take it only if you like it too.\r\n\r\n```\r\n    // POSIX convention: 0 is success\r\n    if (sock.GetSockName(sa, &len) == 0) {\r\n```",
      "created_at": "2025-12-25T16:50:26Z",
      "updated_at": "2025-12-25T17:38:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2647162093",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647162093"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 959,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647164566",
      "pull_request_review_id": 3612461816,
      "id": 2647164566,
      "node_id": "PRRC_kwDOABII586dyIaW",
      "diff_hunk": "@@ -169,17 +169,18 @@ constexpr inline bool IsSpace(char c) noexcept {\n /**\n  * Convert string to integral type T. Leading whitespace, a leading +, or any\n  * trailing character fail the parsing. The required format expressed as regex\n- * is `-?[0-9]+`. The minus sign is only permitted for signed integer types.\n+ * is `-?[0-9]+` by default (or e.g. `-?[0-9a-fA-F]+` if base = 16).\n+ * The minus sign is only permitted for signed integer types.\n  *\n  * @returns std::nullopt if the entire string could not be parsed, or if the\n  *   parsed value is not in the range representable by the type T.\n  */\n template <typename T>\n-std::optional<T> ToIntegral(std::string_view str)\n+std::optional<T> ToIntegral(std::string_view str, size_t base = 10)",
      "path": "src/util/strencodings.h",
      "position": 1,
      "original_position": 13,
      "commit_id": "b6afd81f58f5aabb20fb02924a3e259670d6b3ab",
      "original_commit_id": "cd2fe7fbf220bce44ec3098b5258046d20e0878b",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: If we are only plan to use this with base 10 or 16 maybe it would be safer to make this a bool. But I don't feel too strongly about it.",
      "created_at": "2025-12-25T16:55:16Z",
      "updated_at": "2025-12-25T17:38:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2647164566",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647164566"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 180,
      "original_line": 179,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647169681",
      "pull_request_review_id": 3612461816,
      "id": 2647169681,
      "node_id": "PRRC_kwDOABII586dyJqR",
      "diff_hunk": "@@ -353,6 +354,29 @@ struct Hex {\n };\n } // namespace detail\n \n+struct CaseInsensitiveKeyEqual {\n+    bool operator()(const std::string& s1, const std::string& s2) const\n+    {\n+        return ToLower(s1) == ToLower(s2);\n+    }\n+};\n+\n+struct CaseInsensitiveHash {\n+    size_t operator()(const std::string_view& s) const {\n+        std::string lowered;\n+        lowered.resize(s.size());\n+        std::ranges::transform(s, lowered.begin(),\n+            [](char c) {\n+                // Avoid implicit-integer-sign-change UB by only",
      "path": "src/util/strencodings.h",
      "position": 1,
      "original_position": 25,
      "commit_id": "b6afd81f58f5aabb20fb02924a3e259670d6b3ab",
      "original_commit_id": "bd924ecf4e29b3ff918def6cb55b959fe19f33dc",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: I would call the classe `AsciiCaseInsensitiveHash`",
      "created_at": "2025-12-25T17:04:48Z",
      "updated_at": "2025-12-25T17:38:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2647169681",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647169681"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 370,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647171914",
      "pull_request_review_id": 3612461816,
      "id": 2647171914,
      "node_id": "PRRC_kwDOABII586dyKNK",
      "diff_hunk": "@@ -353,6 +354,29 @@ struct Hex {\n };\n } // namespace detail\n \n+struct CaseInsensitiveKeyEqual {",
      "path": "src/util/strencodings.h",
      "position": 1,
      "original_position": 12,
      "commit_id": "625088468a3f2f1438fd71d1b87210e16904fa58",
      "original_commit_id": "bd924ecf4e29b3ff918def6cb55b959fe19f33dc",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In the bd924ecf4e29b3ff918def6cb55b959fe19f33dc commit message: Not sure why this talks about libevent comparing in lowercase. This is just following HTTP requirements, right? So I found it a bit confusing and checked if this meant that this behavior was just temporary and maybe removed later together with libevent, but it isn't...",
      "created_at": "2025-12-25T17:09:23Z",
      "updated_at": "2025-12-25T17:38:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2647171914",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647171914"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 357,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647177146",
      "pull_request_review_id": 3612461816,
      "id": 2647177146,
      "node_id": "PRRC_kwDOABII586dyLe6",
      "diff_hunk": "@@ -136,6 +136,12 @@ std::string FormatISO8601DateTime(int64_t nTime);\n std::string FormatISO8601Date(int64_t nTime);\n std::optional<int64_t> ParseISO8601DateTime(std::string_view str);\n \n+/**\n+ * RFC7231 formatting https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1",
      "path": "src/util/time.h",
      "position": 1,
      "original_position": 5,
      "commit_id": "625088468a3f2f1438fd71d1b87210e16904fa58",
      "original_commit_id": "333af4bb589115964c62d64d9f9d15d86ff436aa",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: This seems to be superseeded by RFC9110: https://www.rfc-editor.org/rfc/rfc9110.html#name-date-time-formats",
      "created_at": "2025-12-25T17:20:20Z",
      "updated_at": "2025-12-25T17:38:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2647177146",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647177146"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647178318",
      "pull_request_review_id": 3612461816,
      "id": 2647178318,
      "node_id": "PRRC_kwDOABII586dyLxO",
      "diff_hunk": "@@ -136,6 +136,12 @@ std::string FormatISO8601DateTime(int64_t nTime);\n std::string FormatISO8601Date(int64_t nTime);\n std::optional<int64_t> ParseISO8601DateTime(std::string_view str);\n \n+/**\n+ * RFC7231 formatting https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1\n+ * Used in HTTP/1.1 responses\n+ */\n+std::string FormatRFC7231DateTime(int64_t nTime);",
      "path": "src/util/time.h",
      "position": 1,
      "original_position": 8,
      "commit_id": "625088468a3f2f1438fd71d1b87210e16904fa58",
      "original_commit_id": "333af4bb589115964c62d64d9f9d15d86ff436aa",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Not sure if we should have the RFC in the name if it's ambiguous where the format is specified (see above). Maybe `FormatHTTPDate` or something like that would be better.",
      "created_at": "2025-12-25T17:22:56Z",
      "updated_at": "2025-12-25T17:38:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2647178318",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647178318"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 143,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647183161",
      "pull_request_review_id": 3612461816,
      "id": 2647183161,
      "node_id": "PRRC_kwDOABII586dyM85",
      "diff_hunk": "@@ -13,4 +13,42 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n     if (search.empty()) return;\n     in_out = std::regex_replace(in_out, std::regex(search), substitute);\n }\n+\n+LineReader::LineReader(std::span<const std::byte> buffer, size_t max_read)\n+    : start(buffer.begin()), end(buffer.end()), max_read(max_read), it(buffer.begin()) {}\n+\n+std::optional<std::string> LineReader::ReadLine()\n+{\n+    if (it == end) {\n+        return std::nullopt;\n+    }\n+\n+    auto line_start = it;\n+    size_t count = 0;\n+    while (it != end) {\n+        auto c = static_cast<char>(*it);\n+        ++it;\n+        ++count;\n+        if (c == '\\n') break;\n+        if (count >= max_read) throw std::runtime_error(\"max_read exceeded by LineReader\");",
      "path": "src/util/string.cpp",
      "position": 1,
      "original_position": 21,
      "commit_id": "63a9487dc3f1667b66a711ee43ec3c5a6ff181fc",
      "original_commit_id": "6d5aa51abd7e0ca935d0f016d7350c89edc38c38",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Shouldn't this be rather `count > max_read`? At least that would be what I would expect based on the error here and the docs in the .h: \"Will not search for \\n past max_read.\". It's currently more like \"up until but not including max_read\", right?",
      "created_at": "2025-12-25T17:33:58Z",
      "updated_at": "2025-12-25T17:38:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2647183161",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2647183161"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669642185",
      "pull_request_review_id": 3636265629,
      "id": 2669642185,
      "node_id": "PRRC_kwDOABII586fH4HJ",
      "diff_hunk": "@@ -362,4 +362,7 @@ bool IsBadPort(uint16_t port);\n  */\n CService MaybeFlipIPv6toCJDNS(const CService& service);\n \n+/** Get the bind address for a socket as CService. */\n+CService GetBindAddress(const Sock& sock);",
      "path": "src/netbase.h",
      "position": 1,
      "original_position": 5,
      "commit_id": "b6afd81f58f5aabb20fb02924a3e259670d6b3ab",
      "original_commit_id": "b656c35c09a36541c689d0278212ec99cf22bd72",
      "in_reply_to_id": 2647153745,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "ðŸ‘  re-worded the commit message",
      "created_at": "2026-01-07T18:32:21Z",
      "updated_at": "2026-01-07T23:00:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2669642185",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669642185"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 367,
      "original_line": 366,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669647767",
      "pull_request_review_id": 3636265629,
      "id": 2669647767,
      "node_id": "PRRC_kwDOABII586fH5eX",
      "diff_hunk": "@@ -951,10 +951,13 @@ CService MaybeFlipIPv6toCJDNS(const CService& service)\n CService GetBindAddress(const Sock& sock)\n {\n     CService addr_bind;\n-    struct sockaddr_storage sockaddr_bind;\n-    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n-    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n-        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    sockaddr_storage storage;\n+    socklen_t len = sizeof(storage);\n+\n+    auto sa = static_cast<sockaddr*>(static_cast<void*>(&storage));",
      "path": "src/netbase.cpp",
      "position": 1,
      "original_position": 11,
      "commit_id": "b6afd81f58f5aabb20fb02924a3e259670d6b3ab",
      "original_commit_id": "ed360080c16404a3181090741ff69bf35fc4deb0",
      "in_reply_to_id": 2647158429,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Ah thanks, fixed this commit message",
      "created_at": "2026-01-07T18:34:25Z",
      "updated_at": "2026-01-07T23:00:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2669647767",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669647767"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 957,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669652530",
      "pull_request_review_id": 3636265629,
      "id": 2669652530,
      "node_id": "PRRC_kwDOABII586fH6oy",
      "diff_hunk": "@@ -951,10 +951,13 @@ CService MaybeFlipIPv6toCJDNS(const CService& service)\n CService GetBindAddress(const Sock& sock)\n {\n     CService addr_bind;\n-    struct sockaddr_storage sockaddr_bind;\n-    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n-    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n-        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    sockaddr_storage storage;\n+    socklen_t len = sizeof(storage);\n+\n+    auto sa = static_cast<sockaddr*>(static_cast<void*>(&storage));\n+\n+    if (!sock.GetSockName(sa, &len)) {",
      "path": "src/netbase.cpp",
      "position": 1,
      "original_position": 13,
      "commit_id": "625088468a3f2f1438fd71d1b87210e16904fa58",
      "original_commit_id": "ed360080c16404a3181090741ff69bf35fc4deb0",
      "in_reply_to_id": 2647162093,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "sure, taken. every little bit of legibility helps ;-)",
      "created_at": "2026-01-07T18:36:04Z",
      "updated_at": "2026-01-07T23:00:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2669652530",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669652530"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 959,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669659413",
      "pull_request_review_id": 3636265629,
      "id": 2669659413,
      "node_id": "PRRC_kwDOABII586fH8UV",
      "diff_hunk": "@@ -169,17 +169,18 @@ constexpr inline bool IsSpace(char c) noexcept {\n /**\n  * Convert string to integral type T. Leading whitespace, a leading +, or any\n  * trailing character fail the parsing. The required format expressed as regex\n- * is `-?[0-9]+`. The minus sign is only permitted for signed integer types.\n+ * is `-?[0-9]+` by default (or e.g. `-?[0-9a-fA-F]+` if base = 16).\n+ * The minus sign is only permitted for signed integer types.\n  *\n  * @returns std::nullopt if the entire string could not be parsed, or if the\n  *   parsed value is not in the range representable by the type T.\n  */\n template <typename T>\n-std::optional<T> ToIntegral(std::string_view str)\n+std::optional<T> ToIntegral(std::string_view str, size_t base = 10)",
      "path": "src/util/strencodings.h",
      "position": 1,
      "original_position": 13,
      "commit_id": "b6afd81f58f5aabb20fb02924a3e259670d6b3ab",
      "original_commit_id": "cd2fe7fbf220bce44ec3098b5258046d20e0878b",
      "in_reply_to_id": 2647164566,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think I will leave as-is, a bool would require explanation and this way we have explicit argument name and default value.",
      "created_at": "2026-01-07T18:38:03Z",
      "updated_at": "2026-01-07T23:00:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2669659413",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669659413"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 180,
      "original_line": 179,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669687759",
      "pull_request_review_id": 3636265629,
      "id": 2669687759,
      "node_id": "PRRC_kwDOABII586fIDPP",
      "diff_hunk": "@@ -353,6 +354,29 @@ struct Hex {\n };\n } // namespace detail\n \n+struct CaseInsensitiveKeyEqual {\n+    bool operator()(const std::string& s1, const std::string& s2) const\n+    {\n+        return ToLower(s1) == ToLower(s2);\n+    }\n+};\n+\n+struct CaseInsensitiveHash {\n+    size_t operator()(const std::string_view& s) const {\n+        std::string lowered;\n+        lowered.resize(s.size());\n+        std::ranges::transform(s, lowered.begin(),\n+            [](char c) {\n+                // Avoid implicit-integer-sign-change UB by only",
      "path": "src/util/strencodings.h",
      "position": 1,
      "original_position": 25,
      "commit_id": "b6afd81f58f5aabb20fb02924a3e259670d6b3ab",
      "original_commit_id": "bd924ecf4e29b3ff918def6cb55b959fe19f33dc",
      "in_reply_to_id": 2647169681,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Ok taken. I was doubtful at first but learned about \"case folding\" in unicode so, the qualification is justified.",
      "created_at": "2026-01-07T18:46:11Z",
      "updated_at": "2026-01-07T23:00:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2669687759",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669687759"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 370,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669700042",
      "pull_request_review_id": 3636265629,
      "id": 2669700042,
      "node_id": "PRRC_kwDOABII586fIGPK",
      "diff_hunk": "@@ -353,6 +354,29 @@ struct Hex {\n };\n } // namespace detail\n \n+struct CaseInsensitiveKeyEqual {",
      "path": "src/util/strencodings.h",
      "position": 1,
      "original_position": 12,
      "commit_id": "625088468a3f2f1438fd71d1b87210e16904fa58",
      "original_commit_id": "bd924ecf4e29b3ff918def6cb55b959fe19f33dc",
      "in_reply_to_id": 2647171914,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The important bit is the case-insensitivity of the HTTP protocol. I reference libevent functions in comments and commit messages throughout the PR because I referenced them when writing and also for reviewers to compare. I'll reword this commit message to better explain.",
      "created_at": "2026-01-07T18:50:06Z",
      "updated_at": "2026-01-07T23:00:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2669700042",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669700042"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 357,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669858499",
      "pull_request_review_id": 3636265629,
      "id": 2669858499,
      "node_id": "PRRC_kwDOABII586fIs7D",
      "diff_hunk": "@@ -136,6 +136,12 @@ std::string FormatISO8601DateTime(int64_t nTime);\n std::string FormatISO8601Date(int64_t nTime);\n std::optional<int64_t> ParseISO8601DateTime(std::string_view str);\n \n+/**\n+ * RFC7231 formatting https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1",
      "path": "src/util/time.h",
      "position": 1,
      "original_position": 5,
      "commit_id": "625088468a3f2f1438fd71d1b87210e16904fa58",
      "original_commit_id": "333af4bb589115964c62d64d9f9d15d86ff436aa",
      "in_reply_to_id": 2647177146,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Replaced the reference to HTTP spec with reference to the actual date/time spec implemented in the function.",
      "created_at": "2026-01-07T19:47:28Z",
      "updated_at": "2026-01-07T23:00:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2669858499",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669858499"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669892725",
      "pull_request_review_id": 3636265629,
      "id": 2669892725,
      "node_id": "PRRC_kwDOABII586fI1R1",
      "diff_hunk": "@@ -136,6 +136,12 @@ std::string FormatISO8601DateTime(int64_t nTime);\n std::string FormatISO8601Date(int64_t nTime);\n std::optional<int64_t> ParseISO8601DateTime(std::string_view str);\n \n+/**\n+ * RFC7231 formatting https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1\n+ * Used in HTTP/1.1 responses\n+ */\n+std::string FormatRFC7231DateTime(int64_t nTime);",
      "path": "src/util/time.h",
      "position": 1,
      "original_position": 8,
      "commit_id": "625088468a3f2f1438fd71d1b87210e16904fa58",
      "original_commit_id": "333af4bb589115964c62d64d9f9d15d86ff436aa",
      "in_reply_to_id": 2647178318,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Great catch, I had to dig through the forest of RFCs again, and rewrote the commit message and function name. I'm going with `RFC1123` because that is the RFC [referenced by libevent](https://github.com/libevent/libevent/blob/c6e8f17541b99e8c3a089a1c6f70119d6f95db9d/evutil_time.c#L184). I also wanted to keep the pattern of naming similar to neighbor functions like `FormatISO8601DateTime()` ",
      "created_at": "2026-01-07T19:59:10Z",
      "updated_at": "2026-01-07T23:00:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2669892725",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2669892725"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 143,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2670057951",
      "pull_request_review_id": 3636265629,
      "id": 2670057951,
      "node_id": "PRRC_kwDOABII586fJdnf",
      "diff_hunk": "@@ -13,4 +13,42 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n     if (search.empty()) return;\n     in_out = std::regex_replace(in_out, std::regex(search), substitute);\n }\n+\n+LineReader::LineReader(std::span<const std::byte> buffer, size_t max_read)\n+    : start(buffer.begin()), end(buffer.end()), max_read(max_read), it(buffer.begin()) {}\n+\n+std::optional<std::string> LineReader::ReadLine()\n+{\n+    if (it == end) {\n+        return std::nullopt;\n+    }\n+\n+    auto line_start = it;\n+    size_t count = 0;\n+    while (it != end) {\n+        auto c = static_cast<char>(*it);\n+        ++it;\n+        ++count;\n+        if (c == '\\n') break;\n+        if (count >= max_read) throw std::runtime_error(\"max_read exceeded by LineReader\");",
      "path": "src/util/string.cpp",
      "position": 1,
      "original_position": 21,
      "commit_id": "63a9487dc3f1667b66a711ee43ec3c5a6ff181fc",
      "original_commit_id": "6d5aa51abd7e0ca935d0f016d7350c89edc38c38",
      "in_reply_to_id": 2647183161,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think everything is correct as-is, but I refactored the tests in order to make sure I hit the edge correctly. I still could be missing an off-by-one though, so I appreciate your patience and re-review.\r\n\r\nIf `max_read` is 8, I want to read no more than 8 characters looking for `\\n`. So `123567\\n` is fine, meaning that indeed we read up to AND including `max_read`.\r\n\r\nHowever `12345678\\n` would throw an error because we would consume `max_read` characters and not find an EOL. In this case the EOL is \"past `max_read`\".",
      "created_at": "2026-01-07T20:59:28Z",
      "updated_at": "2026-01-07T23:00:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2670057951",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2670057951"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2672320830",
      "pull_request_review_id": 3639386661,
      "id": 2672320830,
      "node_id": "PRRC_kwDOABII586fSGE-",
      "diff_hunk": "@@ -180,4 +180,50 @@ BOOST_AUTO_TEST_CASE(ascii_case_insensitive_hash_test)\n     BOOST_CHECK_EQUAL(hsh(\"Ab\"), hsh(\"aB\"));\n }\n \n+BOOST_AUTO_TEST_CASE(line_reader_test)\n+{\n+    {\n+        // Check three lines terminated by \\n, \\r\\n, and end of buffer, trimming whitespace\n+        const std::vector<std::byte> input{StringToBuffer(\"once upon a time\\n there was a dog \\r\\nwho liked food\")};\n+        LineReader reader(input, /*max_read=*/128);\n+        std::optional<std::string> line1{reader.ReadLine()};\n+        BOOST_CHECK_EQUAL(reader.Left(), 33);\n+        std::optional<std::string> line2{reader.ReadLine()};\n+        BOOST_CHECK_EQUAL(reader.Left(), 14);\n+        std::optional<std::string> line3{reader.ReadLine()};\n+        std::optional<std::string> line4{reader.ReadLine()};\n+        BOOST_CHECK(line1);\n+        BOOST_CHECK(line2);\n+        BOOST_CHECK(line3);\n+        BOOST_CHECK(!line4);\n+        BOOST_CHECK_EQUAL(line1.value(), \"once upon a time\");\n+        BOOST_CHECK_EQUAL(line2.value(), \"there was a dog\");\n+        BOOST_CHECK_EQUAL(line3.value(), \"who liked food\");\n+    }\n+    {\n+        // Do not exceed max_read while searching for EOL\n+        // Test with 22-character line + EOL + 23-character line + EOL\n+        const std::vector<std::byte> input{StringToBuffer(\"once upon a time there\\nwas a dog who liked tea\\n\")};\n+        // EOL is +1 past max_read: immediate error\n+        LineReader reader1(input, /*max_read=*/22);\n+        BOOST_CHECK_THROW(reader1.ReadLine(), std::runtime_error);\n+\n+        // EOL is at position equal to max_read: can read first line up to and including EOL,\n+        // but then throws because there is no EOL within max_read\n+        LineReader reader2(input, /*max_read=*/23);\n+        BOOST_CHECK_EQUAL(reader2.ReadLine(), \"once upon a time there\");\n+        BOOST_CHECK_THROW(reader2.ReadLine(), std::runtime_error);",
      "path": "src/test/util_string_tests.cpp",
      "position": 1,
      "original_position": 36,
      "commit_id": "63a9487dc3f1667b66a711ee43ec3c5a6ff181fc",
      "original_commit_id": "892d8effbc4a9a3999bba0412921d75858826990",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> EOL is at position equal to max_read\r\n\r\nThis is a 23-char line so for me EOL is at max_read+1 again, same to what is said above in the 22-char line case:\r\n\r\n> EOL is +1 past max_read",
      "created_at": "2026-01-08T13:15:49Z",
      "updated_at": "2026-01-08T14:24:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2672320830",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2672320830"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2672363270",
      "pull_request_review_id": 3639386661,
      "id": 2672363270,
      "node_id": "PRRC_kwDOABII586fSQcG",
      "diff_hunk": "@@ -13,4 +13,42 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n     if (search.empty()) return;\n     in_out = std::regex_replace(in_out, std::regex(search), substitute);\n }\n+\n+LineReader::LineReader(std::span<const std::byte> buffer, size_t max_read)\n+    : start(buffer.begin()), end(buffer.end()), max_read(max_read), it(buffer.begin()) {}\n+\n+std::optional<std::string> LineReader::ReadLine()\n+{\n+    if (it == end) {\n+        return std::nullopt;\n+    }\n+\n+    auto line_start = it;\n+    size_t count = 0;\n+    while (it != end) {\n+        auto c = static_cast<char>(*it);\n+        ++it;\n+        ++count;\n+        if (c == '\\n') break;\n+        if (count >= max_read) throw std::runtime_error(\"max_read exceeded by LineReader\");",
      "path": "src/util/string.cpp",
      "position": 1,
      "original_position": 21,
      "commit_id": "63a9487dc3f1667b66a711ee43ec3c5a6ff181fc",
      "original_commit_id": "6d5aa51abd7e0ca935d0f016d7350c89edc38c38",
      "in_reply_to_id": 2647183161,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Hm, yeah, I think the behavior is fine after looking at this again. I guess the first thing that made this a bit hard to parse is the ordering of the lines but I can see now that this is probably the most efficient way to do it. It may just not be the most readable and I needed some extra time to stare at it :)\r\n\r\nI will add some nits at the appropriate lines.",
      "created_at": "2026-01-08T13:28:20Z",
      "updated_at": "2026-01-08T14:24:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2672363270",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2672363270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2672452080",
      "pull_request_review_id": 3639386661,
      "id": 2672452080,
      "node_id": "PRRC_kwDOABII586fSmHw",
      "diff_hunk": "@@ -180,4 +180,50 @@ BOOST_AUTO_TEST_CASE(ascii_case_insensitive_hash_test)\n     BOOST_CHECK_EQUAL(hsh(\"Ab\"), hsh(\"aB\"));\n }\n \n+BOOST_AUTO_TEST_CASE(line_reader_test)\n+{\n+    {\n+        // Check three lines terminated by \\n, \\r\\n, and end of buffer, trimming whitespace\n+        const std::vector<std::byte> input{StringToBuffer(\"once upon a time\\n there was a dog \\r\\nwho liked food\")};\n+        LineReader reader(input, /*max_read=*/128);\n+        std::optional<std::string> line1{reader.ReadLine()};\n+        BOOST_CHECK_EQUAL(reader.Left(), 33);\n+        std::optional<std::string> line2{reader.ReadLine()};\n+        BOOST_CHECK_EQUAL(reader.Left(), 14);\n+        std::optional<std::string> line3{reader.ReadLine()};\n+        std::optional<std::string> line4{reader.ReadLine()};\n+        BOOST_CHECK(line1);\n+        BOOST_CHECK(line2);\n+        BOOST_CHECK(line3);\n+        BOOST_CHECK(!line4);\n+        BOOST_CHECK_EQUAL(line1.value(), \"once upon a time\");\n+        BOOST_CHECK_EQUAL(line2.value(), \"there was a dog\");\n+        BOOST_CHECK_EQUAL(line3.value(), \"who liked food\");\n+    }\n+    {\n+        // Do not exceed max_read while searching for EOL\n+        // Test with 22-character line + EOL + 23-character line + EOL\n+        const std::vector<std::byte> input{StringToBuffer(\"once upon a time there\\nwas a dog who liked tea\\n\")};\n+        // EOL is +1 past max_read: immediate error\n+        LineReader reader1(input, /*max_read=*/22);\n+        BOOST_CHECK_THROW(reader1.ReadLine(), std::runtime_error);\n+\n+        // EOL is at position equal to max_read: can read first line up to and including EOL,\n+        // but then throws because there is no EOL within max_read\n+        LineReader reader2(input, /*max_read=*/23);\n+        BOOST_CHECK_EQUAL(reader2.ReadLine(), \"once upon a time there\");\n+        BOOST_CHECK_THROW(reader2.ReadLine(), std::runtime_error);",
      "path": "src/test/util_string_tests.cpp",
      "position": 1,
      "original_position": 36,
      "commit_id": "63a9487dc3f1667b66a711ee43ec3c5a6ff181fc",
      "original_commit_id": "892d8effbc4a9a3999bba0412921d75858826990",
      "in_reply_to_id": 2672320830,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Also, another edge case is a string without any `\\n` or a last line without it, e.g. instead of EOL there is EOF. If I understand correctly, because of how the loop is structured, a string without `\\n` and length 10 will throw the error if `max_read=10` but a string with length 9 without a `\\n` will not throw at all and just return the string. I would expect only a line of 11+ without `\\n` to throw.\r\n\r\nMaybe this ordering of the lines in the loop would do a bit better for this edge case? I didn't test it yet so it's possible there are other issues with it, feel free to ignore if that's the case.\r\n\r\n```\r\nwhile (it != end) {\r\n        if (count >= max_read) throw std::runtime_error(\"max_read exceeded by LineReader\");\r\n        ++count;\r\n\r\n        auto c = static_cast<char>(*it);\r\n        if (c == '\\n') break;\r\n\r\n        ++it;\r\n}\r\n```",
      "created_at": "2026-01-08T13:53:59Z",
      "updated_at": "2026-01-08T14:24:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2672452080",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2672452080"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2672509264",
      "pull_request_review_id": 3639386661,
      "id": 2672509264,
      "node_id": "PRRC_kwDOABII586fS0FQ",
      "diff_hunk": "@@ -260,6 +261,36 @@ template <typename T1, size_t PREFIX_LEN>\n     return obj.size() >= PREFIX_LEN &&\n            std::equal(std::begin(prefix), std::end(prefix), std::begin(obj));\n }\n+\n+struct LineReader {\n+    const std::span<const std::byte>::iterator start;\n+    const std::span<const std::byte>::iterator end;\n+    const size_t max_read;\n+    std::span<const std::byte>::iterator it;\n+\n+    explicit LineReader(std::span<const std::byte> buffer, size_t max_read);\n+\n+    /**\n+     * Returns a string from current iterator position up to next \\n\n+     * and advances iterator, does not return trailing \\n or \\r.\n+     * Will not search for \\n past max_read.",
      "path": "src/util/string.h",
      "position": 1,
      "original_position": 24,
      "commit_id": "63a9487dc3f1667b66a711ee43ec3c5a6ff181fc",
      "original_commit_id": "892d8effbc4a9a3999bba0412921d75858826990",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It sounds a bit like this might just return: \"Will throw if a line length exceeds max_read.\"",
      "created_at": "2026-01-08T14:09:28Z",
      "updated_at": "2026-01-08T14:24:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2672509264",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2672509264"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 276,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2672870979",
      "pull_request_review_id": 3640027158,
      "id": 2672870979,
      "node_id": "PRRC_kwDOABII586fUMZD",
      "diff_hunk": "@@ -260,6 +261,36 @@ template <typename T1, size_t PREFIX_LEN>\n     return obj.size() >= PREFIX_LEN &&\n            std::equal(std::begin(prefix), std::end(prefix), std::begin(obj));\n }\n+\n+struct LineReader {\n+    const std::span<const std::byte>::iterator start;\n+    const std::span<const std::byte>::iterator end;\n+    const size_t max_read;\n+    std::span<const std::byte>::iterator it;\n+\n+    explicit LineReader(std::span<const std::byte> buffer, size_t max_read);\n+\n+    /**\n+     * Returns a string from current iterator position up to next \\n\n+     * and advances iterator, does not return trailing \\n or \\r.\n+     * Will not search for \\n past max_read.",
      "path": "src/util/string.h",
      "position": 1,
      "original_position": 24,
      "commit_id": "63a9487dc3f1667b66a711ee43ec3c5a6ff181fc",
      "original_commit_id": "892d8effbc4a9a3999bba0412921d75858826990",
      "in_reply_to_id": 2672509264,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Good point, updated",
      "created_at": "2026-01-08T15:42:39Z",
      "updated_at": "2026-01-09T17:38:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2672870979",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2672870979"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 276,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2672927418",
      "pull_request_review_id": 3640027158,
      "id": 2672927418,
      "node_id": "PRRC_kwDOABII586fUaK6",
      "diff_hunk": "@@ -180,4 +180,50 @@ BOOST_AUTO_TEST_CASE(ascii_case_insensitive_hash_test)\n     BOOST_CHECK_EQUAL(hsh(\"Ab\"), hsh(\"aB\"));\n }\n \n+BOOST_AUTO_TEST_CASE(line_reader_test)\n+{\n+    {\n+        // Check three lines terminated by \\n, \\r\\n, and end of buffer, trimming whitespace\n+        const std::vector<std::byte> input{StringToBuffer(\"once upon a time\\n there was a dog \\r\\nwho liked food\")};\n+        LineReader reader(input, /*max_read=*/128);\n+        std::optional<std::string> line1{reader.ReadLine()};\n+        BOOST_CHECK_EQUAL(reader.Left(), 33);\n+        std::optional<std::string> line2{reader.ReadLine()};\n+        BOOST_CHECK_EQUAL(reader.Left(), 14);\n+        std::optional<std::string> line3{reader.ReadLine()};\n+        std::optional<std::string> line4{reader.ReadLine()};\n+        BOOST_CHECK(line1);\n+        BOOST_CHECK(line2);\n+        BOOST_CHECK(line3);\n+        BOOST_CHECK(!line4);\n+        BOOST_CHECK_EQUAL(line1.value(), \"once upon a time\");\n+        BOOST_CHECK_EQUAL(line2.value(), \"there was a dog\");\n+        BOOST_CHECK_EQUAL(line3.value(), \"who liked food\");\n+    }\n+    {\n+        // Do not exceed max_read while searching for EOL\n+        // Test with 22-character line + EOL + 23-character line + EOL\n+        const std::vector<std::byte> input{StringToBuffer(\"once upon a time there\\nwas a dog who liked tea\\n\")};\n+        // EOL is +1 past max_read: immediate error\n+        LineReader reader1(input, /*max_read=*/22);\n+        BOOST_CHECK_THROW(reader1.ReadLine(), std::runtime_error);\n+\n+        // EOL is at position equal to max_read: can read first line up to and including EOL,\n+        // but then throws because there is no EOL within max_read\n+        LineReader reader2(input, /*max_read=*/23);\n+        BOOST_CHECK_EQUAL(reader2.ReadLine(), \"once upon a time there\");\n+        BOOST_CHECK_THROW(reader2.ReadLine(), std::runtime_error);",
      "path": "src/test/util_string_tests.cpp",
      "position": 1,
      "original_position": 36,
      "commit_id": "63a9487dc3f1667b66a711ee43ec3c5a6ff181fc",
      "original_commit_id": "892d8effbc4a9a3999bba0412921d75858826990",
      "in_reply_to_id": 2672320830,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "You're right and I think your original instinct on this was right as well. I modified the logic of the `ReadLine()` loop, added more comments, and covered the end-of-buffer case with another unit test. So it should be more clear: `max_read` is the length of the longest line we will return, and the line can be terminated either by `\\n` (not counted) or by the end of the buffer.\r\n\r\n\r\nmax_read = 8\r\n\r\n`\"12345678\"` OK\r\n`\"12345678\\n\"` OK\r\n`\"123456789\"` bad\r\n`\"123456789\\n\"` bad\r\n",
      "created_at": "2026-01-08T15:57:39Z",
      "updated_at": "2026-01-09T17:38:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2672927418",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2672927418"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724314025",
      "pull_request_review_id": 3701930019,
      "id": 2724314025,
      "node_id": "PRRC_kwDOABII586iYbup",
      "diff_hunk": "@@ -781,3 +781,68 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n         pathHandlers.erase(i);\n     }\n }\n+\n+namespace http_bitcoin {\n+std::optional<std::string> HTTPHeaders::Find(const std::string& key) const\n+{\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return it->second;\n+}\n+\n+void HTTPHeaders::Write(const std::string& key, const std::string& value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = existing_value.value() + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n+\n+void HTTPHeaders::Remove(const std::string& key)\n+{\n+    m_map.erase(key);\n+}\n+\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n+\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n+\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n+\n+        // Whitespace is optional\n+        std::string key = util::TrimString(std::string_view(line).substr(0, pos));",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 48,
      "commit_id": "3002fbe0d97243d3534a53240d5574d0d4194bba",
      "original_commit_id": "d549f01caab659f1c431ccabf0f5ff1800debcfe",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think this would allow and empty key to be stored as well, which is probably not part of the spec. Maybe add a check like this:\r\n\r\n```\r\nif (key.empty()) throw std::runtime_error(\"Empty HTTP header name\");\r\n```",
      "created_at": "2026-01-24T16:17:58Z",
      "updated_at": "2026-01-24T22:14:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2724314025",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724314025"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 828,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724354027",
      "pull_request_review_id": 3701930019,
      "id": 2724354027,
      "node_id": "PRRC_kwDOABII586iYlfr",
      "diff_hunk": "@@ -781,3 +781,68 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n         pathHandlers.erase(i);\n     }\n }\n+\n+namespace http_bitcoin {\n+std::optional<std::string> HTTPHeaders::Find(const std::string& key) const\n+{\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return it->second;\n+}\n+\n+void HTTPHeaders::Write(const std::string& key, const std::string& value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = existing_value.value() + \", \" + value;",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 18,
      "commit_id": "3002fbe0d97243d3534a53240d5574d0d4194bba",
      "original_commit_id": "d549f01caab659f1c431ccabf0f5ff1800debcfe",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Hm, for some keys this is ok, for others it isn't afaict. But not sure yet where that is handled best. I guess what bothers me so far is that it's the general `Write` function that does this internally. But I will need to check how the special cases are handled in the later commits.\r\n\r\nSee especially https://www.rfc-editor.org/rfc/rfc9110.html#section-5.3:\r\n\r\n> Note: In practice, the \"Set-Cookie\" header field ([[COOKIE](https://www.rfc-editor.org/rfc/rfc9110.html#COOKIE)]) often appears in a response message across multiple field lines and does not use the list syntax, violating the above requirements on multiple field lines with the same field name. Since it cannot be combined into a single field value, recipients ought to handle \"Set-Cookie\" as a special case while processing fields. (See Appendix A.2.3 of [[Kri2001](https://www.rfc-editor.org/rfc/rfc9110.html#Kri2001)] for details.)",
      "created_at": "2026-01-24T16:49:00Z",
      "updated_at": "2026-01-24T22:14:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2724354027",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724354027"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 798,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724359103",
      "pull_request_review_id": 3701930019,
      "id": 2724359103,
      "node_id": "PRRC_kwDOABII586iYmu_",
      "diff_hunk": "@@ -96,4 +98,27 @@ BOOST_AUTO_TEST_CASE(http_headers_tests)\n         BOOST_CHECK(!headers.Find(\"Pizza\"));\n     }\n }\n+\n+BOOST_AUTO_TEST_CASE(http_response_tests)\n+{\n+    // Typical HTTP 1.1 response headers\n+    HTTPHeaders headers{};\n+    headers.Write(\"Content-Length\", \"41\");\n+    // Response points to headers which already exist because some of them\n+    // are set before we even know what the response will be.\n+    HTTPResponse res;\n+    res.m_version_major = 1;\n+    res.m_version_minor = 1;\n+    res.m_status = HTTP_OK;\n+    res.m_reason = HTTPReason.find(res.m_status)->second;\n+    res.m_body = StringToBuffer(\"{\\\"result\\\":865793,\\\"error\\\":null,\\\"id\\\":null\\\"}\");",
      "path": "src/test/httpserver_tests.cpp",
      "position": 1,
      "original_position": 33,
      "commit_id": "3002fbe0d97243d3534a53240d5574d0d4194bba",
      "original_commit_id": "5aae24049f9c05a69783883a8b41eb52b2d1cfe2",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: There seems to be one too many quotes\r\n\r\n```suggestion\r\n    res.m_body = StringToBuffer(\"{\\\"result\\\":865793,\\\"error\\\":null,\\\"id\\\":null}\");\r\n```",
      "created_at": "2026-01-24T16:53:36Z",
      "updated_at": "2026-01-24T22:14:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2724359103",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724359103"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724366697",
      "pull_request_review_id": 3701930019,
      "id": 2724366697,
      "node_id": "PRRC_kwDOABII586iYolp",
      "diff_hunk": "@@ -202,6 +202,15 @@ class HTTPEvent\n };\n \n namespace http_bitcoin {\n+using util::LineReader;\n+\n+//! Shortest valid request line, used by libevent in evhttp_parse_request_line()\n+static const size_t MIN_REQUEST_LINE_LENGTH{strlen(\"GET / HTTP/1.0\")};",
      "path": "src/httpserver.h",
      "position": 1,
      "original_position": 7,
      "commit_id": "3002fbe0d97243d3534a53240d5574d0d4194bba",
      "original_commit_id": "12430fe99e9ceaa0dd6885a3b9dc27421c260401",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: could be `constexpr` I think, also below",
      "created_at": "2026-01-24T17:00:16Z",
      "updated_at": "2026-01-24T22:14:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2724366697",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724366697"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 208,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724375360",
      "pull_request_review_id": 3701930019,
      "id": 2724375360,
      "node_id": "PRRC_kwDOABII586iYqtA",
      "diff_hunk": "@@ -121,4 +124,139 @@ BOOST_AUTO_TEST_CASE(http_response_tests)\n         \"Content-Length: 41\\r\\n\"\n         \"\\r\\n\");\n }\n+\n+BOOST_AUTO_TEST_CASE(http_request_tests)\n+{\n+    {\n+        // Reading request captured from bitcoin-cli\n+        const std::string full_request =\n+            \"504f5354202f20485454502f312e310d0a486f73743a203132372e302e302e310d\"\n+            \"0a436f6e6e656374696f6e3a20636c6f73650d0a436f6e74656e742d547970653a\"\n+            \"206170706c69636174696f6e2f6a736f6e0d0a417574686f72697a6174696f6e3a\"\n+            \"204261736963205831396a6232397261575666587a6f354f4751354f4451334d57\"\n+            \"4e6d4e6a67304e7a417a59546b7a4e32457a4e7a6b305a44466c4f4451314e6a5a\"\n+            \"6d5954526b5a6a4a694d7a466b596a68684f4449345a4759344d6a566a4f546735\"\n+            \"5a4749344f54566c0d0a436f6e74656e742d4c656e6774683a2034360d0a0d0a7b\"\n+            \"226d6574686f64223a22676574626c6f636b636f756e74222c22706172616d7322\"\n+            \"3a5b5d2c226964223a317d0a\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(full_request).value()};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"POST\");\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 1);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzo5OGQ5ODQ3MWNmNjg0NzAzYTkzN2EzNzk0ZDFlODQ1NjZmYTRkZjJiMzFkYjhhODI4ZGY4MjVjOTg5ZGI4OTVl\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 46);\n+        BOOST_CHECK_EQUAL(req.m_body, \"{\\\"method\\\":\\\"getblockcount\\\",\\\"params\\\":[],\\\"id\\\":1}\\n\");\n+    }\n+    {\n+        const std::string too_short_request_line = \"GET/HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(too_short_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP / 1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/11\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/1.x\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string ok_request_line = \"GET / HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(ok_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"GET\");\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 0);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        // no body is OK\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string malformed_headers = \"GET / HTTP/1.0\\r\\nHost=127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK_THROW(req.LoadHeaders(reader), std::runtime_error);\n+    }\n+    {\n+        // We might not have received enough data from the client which is not\n+        // an error. We return false so the caller can try again later when the\n+        // buffer has more data.\n+        const std::string incomplete_headers = \"GET / HTTP/1.0\\r\\nHost: \";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(incomplete_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(!req.LoadHeaders(reader));\n+    }\n+    {\n+        const std::string no_content_length = \"GET / HTTP/1.0\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(no_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        // Don't try to read request body if Content-Length is missing\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string bad_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: eleven\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(bad_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK_THROW(req.LoadBody(reader), std::runtime_error);\n+    }\n+    {\n+        // Content-Length indicates more data than we have in the buffer.\n+        // Again, not an error just try again later.\n+        const std::string excessive_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: 1024\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";",
      "path": "src/test/httpserver_tests.cpp",
      "position": 325,
      "original_position": 141,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "12430fe99e9ceaa0dd6885a3b9dc27421c260401",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Maybe also add a negative value test case for version and content-length.",
      "created_at": "2026-01-24T17:07:21Z",
      "updated_at": "2026-01-24T22:14:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2724375360",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724375360"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 339,
      "original_line": 253,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724396339",
      "pull_request_review_id": 3701930019,
      "id": 2724396339,
      "node_id": "PRRC_kwDOABII586iYv0z",
      "diff_hunk": "@@ -904,4 +907,87 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n \n     return true;\n }\n+\n+util::Result<void> HTTPServer::BindAndStartListening(const CService& to)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    auto sa = static_cast<sockaddr*>(static_cast<void*>(&storage));\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(sa, &len)) {\n+        return util::Error{Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()))};\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        return util::Error{Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                                    to.ToStringAddrPort(),\n+                                                    NetworkErrorString(WSAGetLastError())))};\n+    }\n+\n+    int socket_option_true{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, &socket_option_true, sizeof(socket_option_true)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::HTTP,\n+                 \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\",\n+                 to.ToStringAddrPort(),\n+                 NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, &socket_option_true, sizeof(socket_option_true)) == SOCKET_ERROR) {\n+            LogDebug(BCLog::HTTP,\n+                     \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\",\n+                     to.ToStringAddrPort(),\n+                     NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             &prot_level,\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogDebug(BCLog::HTTP,\n+                     \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\",\n+                     to.ToStringAddrPort(),\n+                     NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(sa, len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            return util::Error{strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                            to.ToStringAddrPort(),\n+                                            CLIENT_NAME)};\n+        } else {\n+            return util::Error{strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                            to.ToStringAddrPort(),\n+                                            NetworkErrorString(err))};\n+        }\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        return util::Error{strprintf(_(\"Cannot listen on %s: %s\"),\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError()))};\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));",
      "path": "src/httpserver.cpp",
      "position": 797,
      "original_position": 95,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "0cbe102bf2bc5bbfa1c49e8f383422e1df06dc54",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Hm, kind of surprised that htis works because it seems this is adding the unique ptr to a vector of shared ptr. ",
      "created_at": "2026-01-24T17:22:01Z",
      "updated_at": "2026-01-24T22:14:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2724396339",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724396339"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 663,
      "original_line": 984,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724408893",
      "pull_request_review_id": 3701930019,
      "id": 2724408893,
      "node_id": "PRRC_kwDOABII586iYy49",
      "diff_hunk": "@@ -990,4 +990,33 @@ void HTTPServer::StopListening()\n {\n     m_listen.clear();\n }\n+\n+std::unique_ptr<Sock> HTTPServer::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    // Make sure we only operate on our own listening sockets\n+    Assume(std::ranges::any_of(m_listen, [&](const auto& sock) { return sock.get() == &listen_sock; }));\n+\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    auto sa = static_cast<sockaddr*>(static_cast<void*>(&storage));\n+\n+    auto sock{listen_sock.Accept(sa, &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogDebug(BCLog::HTTP,\n+                     \"Cannot accept new connection: %s\\n\",\n+                     NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(sa, len)) {\n+        LogDebug(BCLog::HTTP,\n+                 \"Unknown socket family\\n\");",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 28,
      "commit_id": "3002fbe0d97243d3534a53240d5574d0d4194bba",
      "original_commit_id": "afe4c81f82df2b35a87e3ee3010e407567831176",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The `\\n` isn't needed anymore with all the new logging as far as I know, here and in other places.",
      "created_at": "2026-01-24T17:29:11Z",
      "updated_at": "2026-01-24T22:14:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2724408893",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724408893"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1017,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724413170",
      "pull_request_review_id": 3701930019,
      "id": 2724413170,
      "node_id": "PRRC_kwDOABII586iYz7y",
      "diff_hunk": "@@ -616,6 +616,21 @@ SocketTestingSetup::~SocketTestingSetup()\n     CreateSock = m_create_sock_orig;\n }\n \n+void SocketTestingSetup::ConnectClient() const\n+{\n+    // I/O pipes for a mock Connected Socket we can read and write to.\n+    auto connected_socket_pipes(std::make_shared<DynSock::Pipes>());\n+\n+    // TODO: Insert a payload\n+\n+    // Create the Mock Connected Socket that represents a client.\n+    // It needs I/O pipes but its queue can remain empty\n+    std::unique_ptr<DynSock> connected_socket{std::make_unique<DynSock>(connected_socket_pipes, std::make_shared<DynSock::Queue>())};\n+\n+    // Push into the queue of Accepted Sockets returned by the local CreateSock()\n+    m_accepted_sockets->Push(std::move(connected_socket));",
      "path": "src/test/util/setup_common.cpp",
      "position": 36,
      "original_position": 16,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "afe4c81f82df2b35a87e3ee3010e407567831176",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I guess this means it's not `const`?",
      "created_at": "2026-01-24T17:31:11Z",
      "updated_at": "2026-01-24T22:14:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2724413170",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724413170"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 642,
      "original_line": 631,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724653547",
      "pull_request_review_id": 3701930019,
      "id": 2724653547,
      "node_id": "PRRC_kwDOABII586iZunr",
      "diff_hunk": "@@ -1597,4 +1604,101 @@ bool HTTPClient::MaybeSendBytesFromBuffer()\n \n     return true;\n }\n+\n+bool InitHTTPServer()\n+{\n+    if (!InitHTTPAllowList()) {\n+        return false;\n+    }\n+\n+    // Create HTTPServer, using a dummy request handler just for this commit\n+    g_http_server = std::make_unique<HTTPServer>([&](std::unique_ptr<HTTPRequest> req){});\n+\n+    // Bind HTTP server to specified addresses\n+    std::vector<std::pair<std::string, uint16_t>> endpoints{GetBindAddresses()};\n+    bool bind_success{false};\n+    for (std::vector<std::pair<std::string, uint16_t>>::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\n+        LogInfo(\"Binding RPC on address %s port %i\\n\", i->first, i->second);\n+        const std::optional<CService> addr{Lookup(i->first, i->second, false)};\n+        if (addr) {\n+            if (addr->IsBindAny()) {\n+                LogWarning(\"The RPC server is not safe to expose to untrusted networks such as the public internet\\n\");\n+            }\n+            auto result{g_http_server->BindAndStartListening(addr.value())};\n+            if (!result) {\n+                LogWarning(\"Binding RPC on address %s failed: %s\\n\", addr->ToStringAddrPort(), util::ErrorString(result).original);\n+            } else {\n+                bind_success = true;\n+            }\n+        } else {\n+            LogWarning(\"Binding RPC on address %s port %i failed.\\n\", i->first, i->second);\n+        }\n+    }\n+\n+    if (!bind_success) {\n+        LogError(\"Unable to bind any endpoint for RPC server\\n\");\n+        return false;\n+    }\n+\n+    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n+    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n+    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+\n+    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n+\n+    return true;\n+}\n+\n+static std::vector<std::thread> g_thread_http_workers;\n+\n+void StartHTTPServer()\n+{\n+    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n+    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n+    g_http_server->StartSocketsThreads();\n+\n+    for (int i = 0; i < rpcThreads; i++) {\n+        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+    }\n+}\n+\n+void InterruptHTTPServer()\n+{\n+    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n+    if (g_http_server) {\n+        // Reject all new requests\n+        g_http_server->SetRequestHandler(RejectAllRequests);\n+    }\n+    if (g_work_queue) {\n+        // Stop workers, killing requests we haven't processed or responded to yet\n+        g_work_queue->Interrupt();\n+    }\n+}\n+\n+void StopHTTPServer()\n+{\n+    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n+    if (g_work_queue) {\n+        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n+        for (auto& thread : g_thread_http_workers) {\n+            thread.join();\n+        }\n+        g_thread_http_workers.clear();\n+    }\n+    if (g_http_server) {\n+        // Disconnect clients as their remaining responses are flushed\n+        g_http_server->DisconnectAllClients();\n+        // Wait for all disconnections\n+        while (g_http_server->GetConnectionsCount() != 0) {\n+            std::this_thread::sleep_for(50ms);",
      "path": "src/httpserver.cpp",
      "position": 1442,
      "original_position": 111,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "04a01ed1c18cce76b03b58a7f1b4e799e4d124d9",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Should this loop get an interrupt/timeout to not run forever?",
      "created_at": "2026-01-24T22:06:31Z",
      "updated_at": "2026-01-24T22:14:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2724653547",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2724653547"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1154,
      "original_line": 1693,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2747665089",
      "pull_request_review_id": 3730014021,
      "id": 2747665089,
      "node_id": "PRRC_kwDOABII586jxgrB",
      "diff_hunk": "@@ -781,3 +781,68 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n         pathHandlers.erase(i);\n     }\n }\n+\n+namespace http_bitcoin {\n+std::optional<std::string> HTTPHeaders::Find(const std::string& key) const\n+{\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return it->second;\n+}\n+\n+void HTTPHeaders::Write(const std::string& key, const std::string& value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = existing_value.value() + \", \" + value;\n+    } else {\n+        m_map[key] = value;\n+    }\n+}\n+\n+void HTTPHeaders::Remove(const std::string& key)\n+{\n+    m_map.erase(key);\n+}\n+\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n+\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n+\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n+\n+        // Whitespace is optional\n+        std::string key = util::TrimString(std::string_view(line).substr(0, pos));",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 48,
      "commit_id": "3002fbe0d97243d3534a53240d5574d0d4194bba",
      "original_commit_id": "d549f01caab659f1c431ccabf0f5ff1800debcfe",
      "in_reply_to_id": 2724314025,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Good catch thanks, added the check and a test.",
      "created_at": "2026-01-30T19:29:09Z",
      "updated_at": "2026-02-02T00:30:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2747665089",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2747665089"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 828,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2749675087",
      "pull_request_review_id": 3730014021,
      "id": 2749675087,
      "node_id": "PRRC_kwDOABII586j5LZP",
      "diff_hunk": "@@ -781,3 +781,68 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n         pathHandlers.erase(i);\n     }\n }\n+\n+namespace http_bitcoin {\n+std::optional<std::string> HTTPHeaders::Find(const std::string& key) const\n+{\n+    const auto it = m_map.find(key);\n+    if (it == m_map.end()) return std::nullopt;\n+    return it->second;\n+}\n+\n+void HTTPHeaders::Write(const std::string& key, const std::string& value)\n+{\n+    // If present, append value to list\n+    const auto existing_value = Find(key);\n+    if (existing_value) {\n+        m_map[key] = existing_value.value() + \", \" + value;",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 18,
      "commit_id": "3002fbe0d97243d3534a53240d5574d0d4194bba",
      "original_commit_id": "d549f01caab659f1c431ccabf0f5ff1800debcfe",
      "in_reply_to_id": 2724354027,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This is a really good catch and is big bug in what I had. To match spec and libevent behavior I had to replace the `unordered_map` with `vector <pair of strings>` to allow duplicate headers. Libevent's getters are more like \"find first and return early\" so I'll do that as well. In that sense we will match the looser protocol enforcement. This also means that since I'm not using a map anymore, I don't need the comparator/hasher added in #34242 so I'll revert that with a new utility commit in this branch. I'm just gonna move the `CaseInsensitiveEqual()` function from test utilities to `src/`.\r\n\r\n",
      "created_at": "2026-01-31T15:24:13Z",
      "updated_at": "2026-02-02T00:30:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2749675087",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2749675087"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 798,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2749677116",
      "pull_request_review_id": 3730014021,
      "id": 2749677116,
      "node_id": "PRRC_kwDOABII586j5L48",
      "diff_hunk": "@@ -96,4 +98,27 @@ BOOST_AUTO_TEST_CASE(http_headers_tests)\n         BOOST_CHECK(!headers.Find(\"Pizza\"));\n     }\n }\n+\n+BOOST_AUTO_TEST_CASE(http_response_tests)\n+{\n+    // Typical HTTP 1.1 response headers\n+    HTTPHeaders headers{};\n+    headers.Write(\"Content-Length\", \"41\");\n+    // Response points to headers which already exist because some of them\n+    // are set before we even know what the response will be.\n+    HTTPResponse res;\n+    res.m_version_major = 1;\n+    res.m_version_minor = 1;\n+    res.m_status = HTTP_OK;\n+    res.m_reason = HTTPReason.find(res.m_status)->second;\n+    res.m_body = StringToBuffer(\"{\\\"result\\\":865793,\\\"error\\\":null,\\\"id\\\":null\\\"}\");",
      "path": "src/test/httpserver_tests.cpp",
      "position": 1,
      "original_position": 33,
      "commit_id": "3002fbe0d97243d3534a53240d5574d0d4194bba",
      "original_commit_id": "5aae24049f9c05a69783883a8b41eb52b2d1cfe2",
      "in_reply_to_id": 2724359103,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "thanks, fixed",
      "created_at": "2026-01-31T15:27:19Z",
      "updated_at": "2026-02-02T00:30:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2749677116",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2749677116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2749800387",
      "pull_request_review_id": 3730014021,
      "id": 2749800387,
      "node_id": "PRRC_kwDOABII586j5p_D",
      "diff_hunk": "@@ -202,6 +202,15 @@ class HTTPEvent\n };\n \n namespace http_bitcoin {\n+using util::LineReader;\n+\n+//! Shortest valid request line, used by libevent in evhttp_parse_request_line()\n+static const size_t MIN_REQUEST_LINE_LENGTH{strlen(\"GET / HTTP/1.0\")};",
      "path": "src/httpserver.h",
      "position": 1,
      "original_position": 7,
      "commit_id": "3002fbe0d97243d3534a53240d5574d0d4194bba",
      "original_commit_id": "12430fe99e9ceaa0dd6885a3b9dc27421c260401",
      "in_reply_to_id": 2724366697,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Thanks took this, couldn't keep `strlen` for compile time  but C++17 allows `string_view::size()`. 5 minutes of research suggest that `strlen` should be allwed by C++20 but its not on AppleClang? _Anyway..._",
      "created_at": "2026-01-31T17:58:25Z",
      "updated_at": "2026-02-02T00:30:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2749800387",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2749800387"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 208,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2751344438",
      "pull_request_review_id": 3730014021,
      "id": 2751344438,
      "node_id": "PRRC_kwDOABII586j_i82",
      "diff_hunk": "@@ -121,4 +124,139 @@ BOOST_AUTO_TEST_CASE(http_response_tests)\n         \"Content-Length: 41\\r\\n\"\n         \"\\r\\n\");\n }\n+\n+BOOST_AUTO_TEST_CASE(http_request_tests)\n+{\n+    {\n+        // Reading request captured from bitcoin-cli\n+        const std::string full_request =\n+            \"504f5354202f20485454502f312e310d0a486f73743a203132372e302e302e310d\"\n+            \"0a436f6e6e656374696f6e3a20636c6f73650d0a436f6e74656e742d547970653a\"\n+            \"206170706c69636174696f6e2f6a736f6e0d0a417574686f72697a6174696f6e3a\"\n+            \"204261736963205831396a6232397261575666587a6f354f4751354f4451334d57\"\n+            \"4e6d4e6a67304e7a417a59546b7a4e32457a4e7a6b305a44466c4f4451314e6a5a\"\n+            \"6d5954526b5a6a4a694d7a466b596a68684f4449345a4759344d6a566a4f546735\"\n+            \"5a4749344f54566c0d0a436f6e74656e742d4c656e6774683a2034360d0a0d0a7b\"\n+            \"226d6574686f64223a22676574626c6f636b636f756e74222c22706172616d7322\"\n+            \"3a5b5d2c226964223a317d0a\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{TryParseHex<std::byte>(full_request).value()};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"POST\");\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 1);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Connection\").value(), \"close\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Type\").value(), \"application/json\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Authorization\").value(), \"Basic X19jb29raWVfXzo5OGQ5ODQ3MWNmNjg0NzAzYTkzN2EzNzk0ZDFlODQ1NjZmYTRkZjJiMzFkYjhhODI4ZGY4MjVjOTg5ZGI4OTVl\");\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Content-Length\").value(), \"46\");\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 46);\n+        BOOST_CHECK_EQUAL(req.m_body, \"{\\\"method\\\":\\\"getblockcount\\\",\\\"params\\\":[],\\\"id\\\":1}\\n\");\n+    }\n+    {\n+        const std::string too_short_request_line = \"GET/HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(too_short_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP / 1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/11\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string malformed_request_line = \"GET / HTTP/1.x\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK_THROW(req.LoadControlData(reader), std::runtime_error);\n+    }\n+    {\n+        const std::string ok_request_line = \"GET / HTTP/1.0\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(ok_request_line)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        BOOST_CHECK_EQUAL(req.m_method, \"GET\");\n+        BOOST_CHECK_EQUAL(req.m_target, \"/\");\n+        BOOST_CHECK_EQUAL(req.m_version_major, 1);\n+        BOOST_CHECK_EQUAL(req.m_version_minor, 0);\n+        BOOST_CHECK_EQUAL(req.m_headers.Find(\"Host\").value(), \"127.0.0.1\");\n+        // no body is OK\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string malformed_headers = \"GET / HTTP/1.0\\r\\nHost=127.0.0.1\\r\\n\\r\\n\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(malformed_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK_THROW(req.LoadHeaders(reader), std::runtime_error);\n+    }\n+    {\n+        // We might not have received enough data from the client which is not\n+        // an error. We return false so the caller can try again later when the\n+        // buffer has more data.\n+        const std::string incomplete_headers = \"GET / HTTP/1.0\\r\\nHost: \";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(incomplete_headers)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(!req.LoadHeaders(reader));\n+    }\n+    {\n+        const std::string no_content_length = \"GET / HTTP/1.0\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(no_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK(req.LoadBody(reader));\n+        // Don't try to read request body if Content-Length is missing\n+        BOOST_CHECK_EQUAL(req.m_body.size(), 0);\n+    }\n+    {\n+        const std::string bad_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: eleven\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";\n+        HTTPRequest req;\n+        std::vector<std::byte> buffer{StringToBuffer(bad_content_length)};\n+        LineReader reader(buffer, MAX_HEADERS_SIZE);\n+        BOOST_CHECK(req.LoadControlData(reader));\n+        BOOST_CHECK(req.LoadHeaders(reader));\n+        BOOST_CHECK_THROW(req.LoadBody(reader), std::runtime_error);\n+    }\n+    {\n+        // Content-Length indicates more data than we have in the buffer.\n+        // Again, not an error just try again later.\n+        const std::string excessive_content_length = \"GET / HTTP/1.0\\r\\nContent-Length: 1024\\r\\n\\r\\n{\\\"method\\\":\\\"getblockcount\\\"}\";",
      "path": "src/test/httpserver_tests.cpp",
      "position": 325,
      "original_position": 141,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "12430fe99e9ceaa0dd6885a3b9dc27421c260401",
      "in_reply_to_id": 2724375360,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "good idea, added tests and also changed the type to unsigned int, added extra checks to match libevent. Note that \"HTTP/2\" does not use text format\r\n\r\n```c\r\n\tif (n != 2 || major > '1' || major < '0' || minor > '9' || minor < '0') {\r\n\t\tevent_debug((\"%s: bad version %s on message %p from %s\",\r\n```",
      "created_at": "2026-02-01T15:06:47Z",
      "updated_at": "2026-02-02T00:30:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2751344438",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2751344438"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 339,
      "original_line": 253,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2751429586",
      "pull_request_review_id": 3730014021,
      "id": 2751429586,
      "node_id": "PRRC_kwDOABII586j_3vS",
      "diff_hunk": "@@ -904,4 +907,87 @@ bool HTTPRequest::LoadBody(LineReader& reader)\n \n     return true;\n }\n+\n+util::Result<void> HTTPServer::BindAndStartListening(const CService& to)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    auto sa = static_cast<sockaddr*>(static_cast<void*>(&storage));\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(sa, &len)) {\n+        return util::Error{Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()))};\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        return util::Error{Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                                    to.ToStringAddrPort(),\n+                                                    NetworkErrorString(WSAGetLastError())))};\n+    }\n+\n+    int socket_option_true{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, &socket_option_true, sizeof(socket_option_true)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::HTTP,\n+                 \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\",\n+                 to.ToStringAddrPort(),\n+                 NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, &socket_option_true, sizeof(socket_option_true)) == SOCKET_ERROR) {\n+            LogDebug(BCLog::HTTP,\n+                     \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\",\n+                     to.ToStringAddrPort(),\n+                     NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             &prot_level,\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogDebug(BCLog::HTTP,\n+                     \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\",\n+                     to.ToStringAddrPort(),\n+                     NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(sa, len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            return util::Error{strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                            to.ToStringAddrPort(),\n+                                            CLIENT_NAME)};\n+        } else {\n+            return util::Error{strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                            to.ToStringAddrPort(),\n+                                            NetworkErrorString(err))};\n+        }\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        return util::Error{strprintf(_(\"Cannot listen on %s: %s\"),\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError()))};\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));",
      "path": "src/httpserver.cpp",
      "position": 797,
      "original_position": 95,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "0cbe102bf2bc5bbfa1c49e8f383422e1df06dc54",
      "in_reply_to_id": 2724396339,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Good catch, this is the same move we make in `net.cpp::BindListenPort()` as well. My understanding from https://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr.html (and also GPT) is that what we are actually doing here is constructing a new `shared_ptr` with the current `unique_ptr` as an argument. Ownership is transferred and the `unique_ptr` is nullified",
      "created_at": "2026-02-01T15:39:12Z",
      "updated_at": "2026-02-02T00:30:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2751429586",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2751429586"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 663,
      "original_line": 984,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2751431571",
      "pull_request_review_id": 3730014021,
      "id": 2751431571,
      "node_id": "PRRC_kwDOABII586j_4OT",
      "diff_hunk": "@@ -990,4 +990,33 @@ void HTTPServer::StopListening()\n {\n     m_listen.clear();\n }\n+\n+std::unique_ptr<Sock> HTTPServer::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    // Make sure we only operate on our own listening sockets\n+    Assume(std::ranges::any_of(m_listen, [&](const auto& sock) { return sock.get() == &listen_sock; }));\n+\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    auto sa = static_cast<sockaddr*>(static_cast<void*>(&storage));\n+\n+    auto sock{listen_sock.Accept(sa, &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogDebug(BCLog::HTTP,\n+                     \"Cannot accept new connection: %s\\n\",\n+                     NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(sa, len)) {\n+        LogDebug(BCLog::HTTP,\n+                 \"Unknown socket family\\n\");",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 28,
      "commit_id": "3002fbe0d97243d3534a53240d5574d0d4194bba",
      "original_commit_id": "afe4c81f82df2b35a87e3ee3010e407567831176",
      "in_reply_to_id": 2724408893,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Thanks, fixed.",
      "created_at": "2026-02-01T15:40:16Z",
      "updated_at": "2026-02-02T00:30:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2751431571",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2751431571"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1017,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2751837252",
      "pull_request_review_id": 3730014021,
      "id": 2751837252,
      "node_id": "PRRC_kwDOABII586kBbRE",
      "diff_hunk": "@@ -1597,4 +1604,101 @@ bool HTTPClient::MaybeSendBytesFromBuffer()\n \n     return true;\n }\n+\n+bool InitHTTPServer()\n+{\n+    if (!InitHTTPAllowList()) {\n+        return false;\n+    }\n+\n+    // Create HTTPServer, using a dummy request handler just for this commit\n+    g_http_server = std::make_unique<HTTPServer>([&](std::unique_ptr<HTTPRequest> req){});\n+\n+    // Bind HTTP server to specified addresses\n+    std::vector<std::pair<std::string, uint16_t>> endpoints{GetBindAddresses()};\n+    bool bind_success{false};\n+    for (std::vector<std::pair<std::string, uint16_t>>::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\n+        LogInfo(\"Binding RPC on address %s port %i\\n\", i->first, i->second);\n+        const std::optional<CService> addr{Lookup(i->first, i->second, false)};\n+        if (addr) {\n+            if (addr->IsBindAny()) {\n+                LogWarning(\"The RPC server is not safe to expose to untrusted networks such as the public internet\\n\");\n+            }\n+            auto result{g_http_server->BindAndStartListening(addr.value())};\n+            if (!result) {\n+                LogWarning(\"Binding RPC on address %s failed: %s\\n\", addr->ToStringAddrPort(), util::ErrorString(result).original);\n+            } else {\n+                bind_success = true;\n+            }\n+        } else {\n+            LogWarning(\"Binding RPC on address %s port %i failed.\\n\", i->first, i->second);\n+        }\n+    }\n+\n+    if (!bind_success) {\n+        LogError(\"Unable to bind any endpoint for RPC server\\n\");\n+        return false;\n+    }\n+\n+    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n+    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n+    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);\n+\n+    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);\n+\n+    return true;\n+}\n+\n+static std::vector<std::thread> g_thread_http_workers;\n+\n+void StartHTTPServer()\n+{\n+    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n+    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n+    g_http_server->StartSocketsThreads();\n+\n+    for (int i = 0; i < rpcThreads; i++) {\n+        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);\n+    }\n+}\n+\n+void InterruptHTTPServer()\n+{\n+    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n+    if (g_http_server) {\n+        // Reject all new requests\n+        g_http_server->SetRequestHandler(RejectAllRequests);\n+    }\n+    if (g_work_queue) {\n+        // Stop workers, killing requests we haven't processed or responded to yet\n+        g_work_queue->Interrupt();\n+    }\n+}\n+\n+void StopHTTPServer()\n+{\n+    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n+    if (g_work_queue) {\n+        LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n+        for (auto& thread : g_thread_http_workers) {\n+            thread.join();\n+        }\n+        g_thread_http_workers.clear();\n+    }\n+    if (g_http_server) {\n+        // Disconnect clients as their remaining responses are flushed\n+        g_http_server->DisconnectAllClients();\n+        // Wait for all disconnections\n+        while (g_http_server->GetConnectionsCount() != 0) {\n+            std::this_thread::sleep_for(50ms);",
      "path": "src/httpserver.cpp",
      "position": 1442,
      "original_position": 111,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "04a01ed1c18cce76b03b58a7f1b4e799e4d124d9",
      "in_reply_to_id": 2724653547,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Really good catch and actually as written, this sustains a bug in the libevent implementation on master, documented in https://github.com/bitcoin/bitcoin/pull/31929 (h/t @hodlinator). That PR adds a maximum 30 second timeout to `WaitUntilEmpty()` which is analogous to this line here. I'll hard-code the 30s as well unless someone thinks it needs to be configurable. I'll try to write a test that covers this as well, something that intentionally and reliably hangs on master during shutdown.",
      "created_at": "2026-02-01T19:16:06Z",
      "updated_at": "2026-02-02T00:30:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2751837252",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2751837252"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1154,
      "original_line": 1693,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2751851861",
      "pull_request_review_id": 3730014021,
      "id": 2751851861,
      "node_id": "PRRC_kwDOABII586kBe1V",
      "diff_hunk": "@@ -616,6 +616,21 @@ SocketTestingSetup::~SocketTestingSetup()\n     CreateSock = m_create_sock_orig;\n }\n \n+void SocketTestingSetup::ConnectClient() const\n+{\n+    // I/O pipes for a mock Connected Socket we can read and write to.\n+    auto connected_socket_pipes(std::make_shared<DynSock::Pipes>());\n+\n+    // TODO: Insert a payload\n+\n+    // Create the Mock Connected Socket that represents a client.\n+    // It needs I/O pipes but its queue can remain empty\n+    std::unique_ptr<DynSock> connected_socket{std::make_unique<DynSock>(connected_socket_pipes, std::make_shared<DynSock::Queue>())};\n+\n+    // Push into the queue of Accepted Sockets returned by the local CreateSock()\n+    m_accepted_sockets->Push(std::move(connected_socket));",
      "path": "src/test/util/setup_common.cpp",
      "position": 36,
      "original_position": 16,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "afe4c81f82df2b35a87e3ee3010e407567831176",
      "in_reply_to_id": 2724413170,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It does compile without warnings though, because the member is itself a pointer:\r\n\r\n```cpp\r\n    std::shared_ptr<DynSock::Queue> m_accepted_sockets{std::make_shared<DynSock::Queue>()};\r\n```\r\n\r\nBUT if you still think I should remove the const label for readability, I will.",
      "created_at": "2026-02-01T19:33:45Z",
      "updated_at": "2026-02-02T00:30:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2751851861",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2751851861"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 642,
      "original_line": 631,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2804115631",
      "pull_request_review_id": 3797179359,
      "id": 2804115631,
      "node_id": "PRRC_kwDOABII586nI2iv",
      "diff_hunk": "@@ -325,378 +222,945 @@ static bool HTTPBindAddresses(struct evhttp* http)\n             std::string host;\n             if (!SplitHostPort(strRPCBind, port, host)) {\n                 LogError(\"%s\\n\", InvalidPortErrMsg(\"-rpcbind\", strRPCBind).original);\n-                return false;\n+                return {}; // empty\n             }\n             endpoints.emplace_back(host, port);\n         }\n     }\n+    return endpoints;\n+}\n \n-    // Bind addresses\n-    for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\n-        LogInfo(\"Binding RPC on address %s port %i\", i->first, i->second);\n-        evhttp_bound_socket *bind_handle = evhttp_bind_socket_with_handle(http, i->first.empty() ? nullptr : i->first.c_str(), i->second);\n-        if (bind_handle) {\n-            const std::optional<CNetAddr> addr{LookupHost(i->first, false)};\n-            if (i->first.empty() || (addr.has_value() && addr->IsBindAny())) {\n-                LogWarning(\"The RPC server is not safe to expose to untrusted networks such as the public internet\");\n-            }\n-            // Set the no-delay option (disable Nagle's algorithm) on the TCP socket.\n-            evutil_socket_t fd = evhttp_bound_socket_get_fd(bind_handle);\n-            int one = 1;\n-            if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, reinterpret_cast<char*>(&one), sizeof(one)) == SOCKET_ERROR) {\n-                LogInfo(\"WARNING: Unable to set TCP_NODELAY on RPC server socket, continuing anyway\\n\");\n-            }\n-            boundSockets.push_back(bind_handle);\n-        } else {\n-            LogWarning(\"Binding RPC on address %s port %i failed.\", i->first, i->second);\n-        }\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n+{\n+    LogDebug(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LOCK(g_httppathhandlers_mutex);\n+    pathHandlers.emplace_back(prefix, exactMatch, handler);\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    LOCK(g_httppathhandlers_mutex);\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogDebug(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n     }\n-    return !boundSockets.empty();\n }\n \n-/** libevent event log callback */\n-static void libevent_log_cb(int severity, const char *msg)\n+namespace http_bitcoin {\n+using util::Split;\n+std::optional<std::string> HTTPHeaders::FindFirst(const std::string& key) const\n {\n-    switch (severity) {\n-    case EVENT_LOG_DEBUG:\n-        LogDebug(BCLog::LIBEVENT, \"%s\", msg);\n-        break;\n-    case EVENT_LOG_MSG:\n-        LogInfo(\"libevent: %s\", msg);\n-        break;\n-    case EVENT_LOG_WARN:\n-        LogWarning(\"libevent: %s\", msg);\n-        break;\n-    default: // EVENT_LOG_ERR and others are mapped to error\n-        LogError(\"libevent: %s\", msg);\n-        break;\n+    for (const auto &item : m_map) {\n+        if (CaseInsensitiveEqual(key, item.first)) {\n+            return item.second;\n+        }\n     }\n+    return std::nullopt;\n }\n \n-bool InitHTTPServer(const util::SignalInterrupt& interrupt)\n+void HTTPHeaders::Write(const std::string& key, const std::string& value)\n {\n-    if (!InitHTTPAllowList())\n-        return false;\n+    m_map.emplace_back(key, value);\n+}\n \n-    // Redirect libevent's logging to our own log\n-    event_set_log_callback(&libevent_log_cb);\n-    // Update libevent's log handling.\n-    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));\n+bool HTTPHeaders::RemoveFirst(const std::string& key)\n+{\n+    for (auto it = m_map.begin(); it != m_map.end(); ++it) {\n+        if (CaseInsensitiveEqual(key, it->first)) {\n+            m_map.erase(it);\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n \n-#ifdef WIN32\n-    evthread_use_windows_threads();\n-#else\n-    evthread_use_pthreads();\n-#endif\n+bool HTTPHeaders::Read(util::LineReader& reader)\n+{\n+    // Headers https://httpwg.org/specs/rfc9110.html#rfc.section.6.3\n+    // A sequence of Field Lines https://httpwg.org/specs/rfc9110.html#rfc.section.5.2\n+    do {\n+        auto maybe_line = reader.ReadLine();\n+        if (!maybe_line) return false;\n+        const std::string& line = *maybe_line;\n+\n+        // An empty line indicates end of the headers section https://www.rfc-editor.org/rfc/rfc2616#section-4\n+        if (line.length() == 0) break;\n+\n+        // Header line must have at least one \":\"\n+        // keys are not allowed to have delimiters like \":\" but values are\n+        // https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        const size_t pos{line.find(':')};\n+        if (pos == std::string::npos) throw std::runtime_error(\"HTTP header missing colon (:)\");\n+\n+        // Whitespace is optional\n+        std::string key = util::TrimString(std::string_view(line).substr(0, pos));\n+        std::string value = util::TrimString(std::string_view(line).substr(pos + 1));\n+\n+        // Header keys are Field Names: https://httpwg.org/specs/rfc9110.html#fields.names\n+        // which consist of \"tokens\": https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.2\n+        // that can not be empty.\n+        if (key.empty()) throw std::runtime_error(\"Empty HTTP header name\");\n+\n+        Write(key, value);\n+    } while (true);\n \n-    raii_event_base base_ctr = obtain_event_base();\n+    return true;\n+}\n \n-    /* Create a new evhttp object to handle requests. */\n-    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n-    struct evhttp* http = http_ctr.get();\n-    if (!http) {\n-        LogError(\"Couldn't create evhttp. Exiting.\");\n-        return false;\n+std::string HTTPHeaders::Stringify() const\n+{\n+    std::string out;\n+    for (const auto& [key, value] : m_map) {\n+        out += key + \": \" + value + \"\\r\\n\";\n     }\n \n-    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n-    evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);\n+    // Headers are terminated by an empty line\n+    out += \"\\r\\n\";\n \n-    if (!HTTPBindAddresses(http)) {\n-        LogError(\"Unable to bind any endpoint for RPC server\");\n-        return false;\n+    return out;\n+}\n+\n+std::string HTTPResponse::StringifyHeaders() const\n+{\n+    return strprintf(\"HTTP/%d.%d %d %s\\r\\n%s\", m_version_major, m_version_minor, m_status, m_reason, m_headers.Stringify());\n+}\n+\n+bool HTTPRequest::LoadControlData(LineReader& reader)\n+{\n+    auto maybe_line = reader.ReadLine();\n+    if (!maybe_line) return false;\n+    const std::string& request_line = *maybe_line;\n+\n+    // Request Line aka Control Data https://httpwg.org/specs/rfc9110.html#rfc.section.6.2\n+    // Three words separated by spaces, terminated by \\n or \\r\\n\n+    if (request_line.length() < MIN_REQUEST_LINE_LENGTH) throw std::runtime_error(\"HTTP request line too short\");\n+\n+    const std::vector<std::string_view> parts{Split<std::string_view>(request_line, \" \")};\n+    if (parts.size() != 3) throw std::runtime_error(\"HTTP request line malformed\");\n+\n+    if (parts[0] == \"GET\") {\n+        m_method = HTTPRequestMethod::GET;\n+    } else if (parts[0] == \"POST\") {\n+        m_method = HTTPRequestMethod::POST;\n+    } else if (parts[0] == \"HEAD\") {\n+        m_method = HTTPRequestMethod::HEAD;\n+    } else if (parts[0] == \"PUT\") {\n+        m_method = HTTPRequestMethod::PUT;\n+    } else {\n+        m_method = HTTPRequestMethod::UNKNOWN;\n     }\n \n-    LogDebug(BCLog::HTTP, \"Initialized HTTP server\\n\");\n-    g_max_queue_depth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    LogDebug(BCLog::HTTP, \"set work queue of depth %d\\n\", g_max_queue_depth);\n+    m_target = parts[1];\n+\n+    if (parts[2].rfind(\"HTTP/\") != 0) throw std::runtime_error(\"HTTP request line malformed\");\n+\n+    // Version is exactly two decimal digits separated by a decimal point\n+    // https://httpwg.org/specs/rfc9110.html#rfc.section.2.5\n+    const std::vector<std::string_view> version_parts{Split<std::string_view>(parts[2].substr(5), \".\")};\n+    if (version_parts.size() != 2) throw std::runtime_error(\"HTTP request line malformed\");\n+    auto major = ToIntegral<uint8_t>(version_parts[0]);\n+    auto minor = ToIntegral<uint8_t>(version_parts[1]);\n+    if (!major || !minor || major > 1 || minor > 9) throw std::runtime_error(\"HTTP bad version\");\n+    m_version_major = major.value();\n+    m_version_minor = minor.value();\n \n-    // transfer ownership to eventBase/HTTP via .release()\n-    eventBase = base_ctr.release();\n-    eventHTTP = http_ctr.release();\n     return true;\n }\n \n-void UpdateHTTPServerLogging(bool enable) {\n-    if (enable) {\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n+bool HTTPRequest::LoadHeaders(LineReader& reader)\n+{\n+    return m_headers.Read(reader);\n+}\n+\n+bool HTTPRequest::LoadBody(LineReader& reader)\n+{\n+    // https://httpwg.org/specs/rfc9112.html#message.body\n+    auto transfer_encoding_header = m_headers.FindFirst(\"Transfer-Encoding\");\n+    if (transfer_encoding_header && ToLower(transfer_encoding_header.value()) == \"chunked\") {\n+        // Transfer-Encoding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-3.3.1\n+        // Chunked Transfer Coding: https://datatracker.ietf.org/doc/html/rfc7230.html#section-4.1\n+        // see evhttp_handle_chunked_read() in libevent http.c\n+        while (reader.Remaining() > 0) {\n+            auto maybe_chunk_size = reader.ReadLine();\n+            if (!maybe_chunk_size) return false;\n+\n+            const auto chunk_size{ToIntegral<uint64_t>(maybe_chunk_size.value(), /*base=*/16)};\n+            if (!chunk_size) throw std::runtime_error(\"Cannot parse chunk length value\");\n+\n+            bool last_chunk{*chunk_size == 0};\n+\n+            if (!last_chunk) {\n+                // We are still expecting more data for this chunk\n+                if (reader.Remaining() < *chunk_size) {\n+                    return false;\n+                }\n+                // Pack chunk onto body\n+                m_body += reader.ReadLength(*chunk_size);\n+            }\n+\n+            // Even though every chunk size is explicitly declared,\n+            // they are still terminated by a CRLF we don't need.\n+            auto crlf = reader.ReadLine();\n+            if (!crlf || !crlf.value().empty()) throw std::runtime_error(\"Improperly terminated chunk\");\n+\n+            if (last_chunk) return true;\n+        }\n+\n+        // We read all the chunks but never got the last chunk, wait for client to send more\n+        return false;\n     } else {\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n+        // No Content-length or Transfer-Encoding header means no body, see libevent evhttp_get_body()\n+        auto content_length_value{m_headers.FindFirst(\"Content-Length\")};\n+        if (!content_length_value) return true;\n+\n+        const auto content_length{ToIntegral<uint64_t>(content_length_value.value())};\n+        if (!content_length) throw std::runtime_error(\"Cannot parse Content-Length value\");\n+\n+        // Not enough data in buffer for expected body\n+        if (reader.Remaining() < *content_length) return false;\n+\n+        m_body = reader.ReadLength(*content_length);\n+\n+        return true;\n     }\n }\n \n-static std::thread g_thread_http;\n+void HTTPRequest::WriteReply(HTTPStatusCode status, std::span<const std::byte> reply_body)\n+{\n+    HTTPResponse res;\n+\n+    // Some response headers are determined in advance and stored in the request\n+    res.m_headers = std::move(m_response_headers);\n+\n+    // Response version matches request version\n+    res.m_version_major = m_version_major;\n+    res.m_version_minor = m_version_minor;\n+\n+    // Add response code and look up reason string\n+    res.m_status = status;\n+    res.m_reason = HTTPReason.find(status)->second;\n+\n+    // See libevent evhttp_response_needs_body()\n+    // Response headers are different if no body is needed\n+    bool needs_body{status != HTTP_NO_CONTENT && (status < 100 || status >= 200)};\n+\n+    // See libevent evhttp_make_header_response()\n+    // Expected response headers depend on protocol version\n+    if (m_version_major == 1) {\n+        // HTTP/1.0\n+        if (m_version_minor == 0) {\n+            auto connection_header{m_headers.FindFirst(\"Connection\")};\n+            if (connection_header && ToLower(connection_header.value()) == \"keep-alive\") {\n+                res.m_headers.Write(\"Connection\", \"keep-alive\");\n+                res.m_keep_alive = true;\n+            }\n+        }\n+\n+        // HTTP/1.1\n+        if (m_version_minor >= 1) {\n+            const int64_t now_seconds{TicksSinceEpoch<std::chrono::seconds>(NodeClock::now())};\n+            res.m_headers.Write(\"Date\", FormatRFC1123DateTime(now_seconds));\n \n-void StartHTTPServer()\n+            if (needs_body) {\n+                res.m_headers.Write(\"Content-Length\", strprintf(\"%d\", reply_body.size()));\n+            }\n+\n+            // Default for HTTP/1.1\n+            res.m_keep_alive = true;\n+        }\n+    }\n+\n+    if (needs_body && !res.m_headers.FindFirst(\"Content-Type\")) {\n+        // Default type from libevent evhttp_new_object()\n+        res.m_headers.Write(\"Content-Type\", \"text/html; charset=ISO-8859-1\");\n+    }\n+\n+    auto connection_header{m_headers.FindFirst(\"Connection\")};\n+    if (connection_header && ToLower(connection_header.value()) == \"close\") {\n+        // Might not exist already but we need to replace it, not append to it\n+        while (res.m_headers.RemoveFirst(\"Connection\")) {} ;\n+\n+        res.m_headers.Write(\"Connection\", \"close\");\n+        res.m_keep_alive = false;\n+    }\n+\n+    m_client->m_keep_alive = res.m_keep_alive;\n+\n+    // Serialize the response headers\n+    const std::string headers{res.StringifyHeaders()};\n+    const auto headers_bytes{std::as_bytes(std::span(headers.begin(), headers.end()))};\n+\n+    bool send_buffer_was_empty{false};\n+    // Fill the send buffer with the complete serialized response headers + body\n+    {\n+        LOCK(m_client->m_send_mutex);\n+        send_buffer_was_empty = m_client->m_send_buffer.empty();\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), headers_bytes.begin(), headers_bytes.end());\n+\n+        // We've been using std::span up until now but it is finally time to copy\n+        // data. The original data will go out of scope when WriteReply() returns.\n+        // This is analogous to the memcpy() in libevent's evbuffer_add()\n+        m_client->m_send_buffer.insert(m_client->m_send_buffer.end(), reply_body.begin(), reply_body.end());\n+    }\n+\n+    LogDebug(\n+        BCLog::HTTP,\n+        \"HTTPResponse (status code: %d size: %lld) added to send buffer for client %s (id=%lld)\",\n+        status,\n+        headers_bytes.size() + reply_body.size(),\n+        m_client->m_origin,\n+        m_client->m_id);\n+\n+    // If the send buffer was empty before we wrote this reply, we can try an\n+    // optimistic send akin to CConnman::PushMessage() in which we\n+    // push the data directly out the socket to client right now, instead\n+    // of waiting for the next iteration of the I/O loop.\n+    if (send_buffer_was_empty) {\n+        m_client->MaybeSendBytesFromBuffer();\n+    } else {\n+        // Inform HTTPServer I/O that data is ready to be sent to this client\n+        // in the next loop iteration.\n+        m_client->m_send_ready = true;\n+    }\n+\n+    // Signal to the I/O loop that we are ready to handle the next request.\n+    m_client->m_req_busy = false;\n+}\n+\n+CService HTTPRequest::GetPeer() const\n {\n-    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n-    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);\n-    g_threadpool_http.Start(rpcThreads);\n-    g_thread_http = std::thread(ThreadHTTP, eventBase);\n+    return m_client->m_addr;\n }\n \n-void InterruptHTTPServer()\n+std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n {\n-    LogDebug(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n-    if (eventHTTP) {\n-        // Reject requests on current connections\n-        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n+    return GetQueryParameterFromUri(GetURI(), key);\n+}\n+\n+// See libevent http.c evhttp_parse_query_impl()\n+// and https://www.rfc-editor.org/rfc/rfc3986#section-3.4\n+std::optional<std::string> GetQueryParameterFromUri(const std::string& uri, const std::string& key)\n+{\n+    // Handle %XX encoding\n+    std::string decoded_uri{UrlDecode(uri)};\n+\n+    // find query in URI\n+    size_t start = decoded_uri.find('?');\n+    if (start == std::string::npos) return std::nullopt;\n+    size_t end = decoded_uri.find('#', start);\n+    if (end == std::string::npos) {\n+        end = decoded_uri.length();\n     }\n-    // Interrupt pool after disabling requests\n-    g_threadpool_http.Interrupt();\n+    const std::string_view query{decoded_uri.data() + start + 1, end - start - 1};\n+    // find requested parameter in query\n+    const std::vector<std::string_view> params{Split<std::string_view>(query, \"&\")};\n+    for (const std::string_view& param : params) {\n+        size_t delim = param.find('=');\n+        if (key == param.substr(0, delim)) {\n+            if (delim == std::string::npos) {\n+                return \"\";\n+            } else {\n+                return std::string(param.substr(delim + 1));\n+            }\n+        }\n+    }\n+    return std::nullopt;\n }\n \n-void StopHTTPServer()\n+std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const\n {\n-    LogDebug(BCLog::HTTP, \"Stopping HTTP server\\n\");\n+    std::optional<std::string> found{m_headers.FindFirst(hdr)};\n+    if (found.has_value()) {\n+        return std::make_pair(true, found.value());\n+    } else\n+        return std::make_pair(false, \"\");\n+}\n \n-    LogDebug(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n-    g_threadpool_http.Stop();\n+void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n+{\n+    m_response_headers.Write(hdr, value);\n+}\n \n-    // Unlisten sockets, these are what make the event loop running, which means\n-    // that after this and all connections are closed the event loop will quit.\n-    for (evhttp_bound_socket *socket : boundSockets) {\n-        evhttp_del_accept_socket(eventHTTP, socket);\n+util::Result<void> HTTPServer::BindAndStartListening(const CService& to)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    auto sa = static_cast<sockaddr*>(static_cast<void*>(&storage));\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(sa, &len)) {\n+        return util::Error{Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()))};\n     }\n-    boundSockets.clear();\n-    {\n-        if (const auto n_connections{g_requests.CountActiveConnections()}; n_connections != 0) {\n-            LogDebug(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections);\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        return util::Error{Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                                    to.ToStringAddrPort(),\n+                                                    NetworkErrorString(WSAGetLastError())))};\n+    }\n+\n+    int socket_option_true{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, &socket_option_true, sizeof(socket_option_true)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::HTTP,\n+                 \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\",\n+                 to.ToStringAddrPort(),\n+                 NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, &socket_option_true, sizeof(socket_option_true)) == SOCKET_ERROR) {\n+            LogDebug(BCLog::HTTP,\n+                     \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\",\n+                     to.ToStringAddrPort(),\n+                     NetworkErrorString(WSAGetLastError()));\n         }\n-        g_requests.WaitUntilEmpty();\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             &prot_level,\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogDebug(BCLog::HTTP,\n+                     \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\",\n+                     to.ToStringAddrPort(),\n+                     NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n     }\n-    if (eventHTTP) {\n-        // Schedule a callback to call evhttp_free in the event base thread, so\n-        // that evhttp_free does not need to be called again after the handling\n-        // of unfinished request connections that follows.\n-        event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {\n-            evhttp_free(eventHTTP);\n-            eventHTTP = nullptr;\n-        }, nullptr, nullptr);\n+\n+    if (sock->Bind(sa, len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            return util::Error{strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                            to.ToStringAddrPort(),\n+                                            CLIENT_NAME)};\n+        } else {\n+            return util::Error{strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                            to.ToStringAddrPort(),\n+                                            NetworkErrorString(err))};\n+        }\n     }\n-    if (eventBase) {\n-        LogDebug(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n-        if (g_thread_http.joinable()) g_thread_http.join();\n-        event_base_free(eventBase);\n-        eventBase = nullptr;\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        return util::Error{strprintf(_(\"Cannot listen on %s: %s\"),\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError()))};\n     }\n-    LogDebug(BCLog::HTTP, \"Stopped HTTP server\\n\");\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return {};\n }\n \n-struct event_base* EventBase()\n+void HTTPServer::StopListening()\n {\n-    return eventBase;\n+    m_listen.clear();\n }\n \n-static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n+void HTTPServer::StartSocketsThreads()\n {\n-    // Static handler: simply call inner handler\n-    HTTPEvent *self = static_cast<HTTPEvent*>(data);\n-    self->handler();\n-    if (self->deleteWhenTriggered)\n-        delete self;\n+    m_thread_socket_handler = std::thread(&util::TraceThread,\n+                                          \"http\",\n+                                          [this] { ThreadSocketHandler(); });\n }\n \n-HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):\n-    deleteWhenTriggered(_deleteWhenTriggered), handler(_handler)\n+void HTTPServer::JoinSocketsThreads()\n {\n-    ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n-    assert(ev);\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n }\n-HTTPEvent::~HTTPEvent()\n+\n+std::unique_ptr<Sock> HTTPServer::AcceptConnection(const Sock& listen_sock, CService& addr)\n {\n-    event_free(ev);\n+    // Make sure we only operate on our own listening sockets\n+    Assume(std::ranges::any_of(m_listen, [&](const auto& sock) { return sock.get() == &listen_sock; }));\n+\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    auto sa = static_cast<sockaddr*>(static_cast<void*>(&storage));\n+\n+    auto sock{listen_sock.Accept(sa, &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogDebug(BCLog::HTTP,\n+                     \"Cannot accept new connection: %s\",\n+                     NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(sa, len)) {\n+        LogDebug(BCLog::HTTP,\n+                 \"Unknown socket family\");\n+    }\n+\n+    return sock;\n }\n-void HTTPEvent::trigger(struct timeval* tv)\n+\n+HTTPServer::Id HTTPServer::GetNewId()\n {\n-    if (tv == nullptr)\n-        event_active(ev, 0, 0); // immediately trigger event in main thread\n-    else\n-        evtimer_add(ev, tv); // trigger after timeval passed\n+    return m_next_id.fetch_add(1, std::memory_order_relaxed);\n }\n-HTTPRequest::HTTPRequest(struct evhttp_request* _req, const util::SignalInterrupt& interrupt, bool _replySent)\n-    : req(_req), m_interrupt(interrupt), replySent(_replySent)\n+\n+void HTTPServer::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& them)\n {\n+    if (!sock->IsSelectable()) {\n+        LogDebug(BCLog::HTTP,\n+                 \"connection from %s dropped: non-selectable socket\",\n+                 them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &SOCKET_OPTION_TRUE, sizeof(SOCKET_OPTION_TRUE)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::HTTP, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    m_connected.push_back(std::make_shared<HTTPClient>(id, them, std::move(sock)));\n+    // Report back to the main thread\n+    m_connected_size.fetch_add(1, std::memory_order_relaxed);\n+\n+    LogDebug(BCLog::HTTP,\n+             \"HTTP Connection accepted from %s (id=%d)\",\n+             them.ToStringAddrPort(), id);\n }\n \n-HTTPRequest::~HTTPRequest()\n+void HTTPServer::SocketHandlerConnected(const IOReadiness& io_readiness) const\n {\n-    if (!replySent) {\n-        // Keep track of whether reply was sent to avoid request leaks\n-        LogWarning(\"Unhandled HTTP request\");\n-        WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\");\n+    for (const auto& [sock, events] : io_readiness.events_per_sock) {\n+        if (m_interrupt_net) {\n+            return;\n+        }\n+\n+        auto it{io_readiness.httpclients_per_sock.find(sock)};\n+        if (it == io_readiness.httpclients_per_sock.end()) {\n+            continue;\n+        }\n+        const std::shared_ptr<HTTPClient> client{it->second};\n+\n+        bool send_ready = events.occurred & Sock::SEND; // Sock::SEND could only be set if ShouldTryToSend() has returned true in GenerateWaitSockets().\n+        bool recv_ready = events.occurred & Sock::RECV; // Sock::RECV could only be set if ShouldTryToRecv() has returned true in GenerateWaitSockets().\n+        bool err_ready = events.occurred & Sock::ERR;\n+\n+        if (send_ready) {\n+            // Try to send as much data as is ready for this client.\n+            // If there's an error we can skip the receive phase for this client\n+            // because we need to disconnect.\n+            if (!client->MaybeSendBytesFromBuffer()) {\n+                recv_ready = false;\n+            }\n+        }\n+\n+        if (recv_ready || err_ready) {\n+            std::byte buf[0x10000]; // typical socket buffer is 8K-64K\n+\n+            const ssize_t nrecv{WITH_LOCK(\n+                client->m_sock_mutex,\n+                return client->m_sock->Recv(buf, sizeof(buf), MSG_DONTWAIT);)};\n+\n+            if (nrecv < 0) { // In all cases (including -1 and 0) EventIOLoopCompletedForOne() should be executed after this, don't change the code to skip it.\n+                const int err = WSAGetLastError();\n+                if (err != WSAEWOULDBLOCK && err != WSAEMSGSIZE && err != WSAEINTR && err != WSAEINPROGRESS) {\n+                    LogDebug(\n+                        BCLog::HTTP,\n+                        \"Permanent read error from %s (id=%lld): %s\",\n+                        client->m_origin,\n+                        client->m_id,\n+                        NetworkErrorString(err));\n+                    client->m_disconnect = true;\n+                }\n+            } else if (nrecv == 0) {\n+                LogDebug(\n+                    BCLog::HTTP,\n+                    \"Received EOF from %s (id=%lld)\",\n+                    client->m_origin,\n+                    client->m_id);\n+                client->m_disconnect = true;\n+            } else {\n+                // Reset idle timeout\n+                client->m_idle_since = Now<SteadySeconds>();\n+\n+                // Prevent disconnect until all requests are completely handled.\n+                client->m_prevent_disconnect = true;\n+\n+                // Copy data from socket buffer to client receive buffer\n+                client->m_recv_buffer.insert(\n+                    client->m_recv_buffer.end(),\n+                    buf,\n+                    buf + nrecv);\n+            }\n+        }\n+        // Process as much received data as we can.\n+        // This executes for every client whether or not reading or writing\n+        // took place because it also (might) parse a request we have already\n+        // received and pass it to a worker thread.\n+        MaybeDispatchRequestsFromClient(client);\n     }\n-    // evhttpd cleans up the request, as long as a reply was sent.\n }\n \n-std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const\n+void HTTPServer::SocketHandlerListening(const Sock::EventsPerSock& events_per_sock)\n {\n-    const struct evkeyvalq* headers = evhttp_request_get_input_headers(req);\n-    assert(headers);\n-    const char* val = evhttp_find_header(headers, hdr.c_str());\n-    if (val)\n-        return std::make_pair(true, val);\n-    else\n-        return std::make_pair(false, \"\");\n+    for (const auto& sock : m_listen) {\n+        if (m_interrupt_net) {\n+            return;\n+        }\n+        const auto it = events_per_sock.find(sock);\n+        if (it != events_per_sock.end() && it->second.occurred & Sock::RECV) {\n+            CService addr_accepted;\n+\n+            auto sock_accepted{AcceptConnection(*sock, addr_accepted)};\n+\n+            if (sock_accepted) {\n+                NewSockAccepted(std::move(sock_accepted), addr_accepted);\n+            }\n+        }\n+    }\n }\n \n-std::string HTTPRequest::ReadBody()\n+HTTPServer::IOReadiness HTTPServer::GenerateWaitSockets() const\n {\n-    struct evbuffer* buf = evhttp_request_get_input_buffer(req);\n-    if (!buf)\n-        return \"\";\n-    size_t size = evbuffer_get_length(buf);\n-    /** Trivial implementation: if this is ever a performance bottleneck,\n-     * internal copying can be avoided in multi-segment buffers by using\n-     * evbuffer_peek and an awkward loop. Though in that case, it'd be even\n-     * better to not copy into an intermediate string but use a stream\n-     * abstraction to consume the evbuffer on the fly in the parsing algorithm.\n-     */\n-    const char* data = (const char*)evbuffer_pullup(buf, size);\n-    if (!data) // returns nullptr in case of empty buffer\n-        return \"\";\n-    std::string rv(data, size);\n-    evbuffer_drain(buf, size);\n-    return rv;\n+    IOReadiness io_readiness;\n+\n+    for (const auto& sock : m_listen) {\n+        io_readiness.events_per_sock.emplace(sock, Sock::Events{Sock::RECV});\n+    }\n+\n+    for (const auto& http_client : m_connected) {\n+        // Safely copy the shared pointer to the socket\n+        std::shared_ptr<Sock> sock{WITH_LOCK(http_client->m_sock_mutex, return http_client->m_sock;)};\n+\n+        // Check if client is ready to send data. Don't try to receive again\n+        // until the send buffer is cleared (all data sent to client).\n+        Sock::Event event = (http_client->m_send_ready ? Sock::SEND : Sock::RECV);\n+        io_readiness.events_per_sock.emplace(sock, Sock::Events{event});\n+        io_readiness.httpclients_per_sock.emplace(sock, http_client);\n+    }\n+\n+    return io_readiness;\n }\n \n-void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n+void HTTPServer::ThreadSocketHandler()\n {\n-    struct evkeyvalq* headers = evhttp_request_get_output_headers(req);\n-    assert(headers);\n-    evhttp_add_header(headers, hdr.c_str(), value.c_str());\n-}\n-\n-/** Closure sent to main thread to request a reply to be sent to\n- * a HTTP request.\n- * Replies must be sent in the main loop in the main http thread,\n- * this cannot be done from worker threads.\n- */\n-void HTTPRequest::WriteReply(int nStatus, std::span<const std::byte> reply)\n-{\n-    assert(!replySent && req);\n-    if (m_interrupt) {\n-        WriteHeader(\"Connection\", \"close\");\n-    }\n-    // Send event to main http thread to send reply message\n-    struct evbuffer* evb = evhttp_request_get_output_buffer(req);\n-    assert(evb);\n-    evbuffer_add(evb, reply.data(), reply.size());\n-    auto req_copy = req;\n-    HTTPEvent* ev = new HTTPEvent(eventBase, true, [req_copy, nStatus]{\n-        evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);\n-        // Re-enable reading from the socket. This is the second part of the libevent\n-        // workaround above.\n-        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02010900) {\n-            evhttp_connection* conn = evhttp_request_get_connection(req_copy);\n-            if (conn) {\n-                bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n-                if (bev) {\n-                    bufferevent_enable(bev, EV_READ | EV_WRITE);\n-                }\n-            }\n+    while (!m_interrupt_net) {\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            m_interrupt_net.sleep_for(SELECT_TIMEOUT);\n         }\n-    });\n-    ev->trigger(nullptr);\n-    replySent = true;\n-    req = nullptr; // transferred back to main thread\n+\n+        // Service (send/receive) each of the already connected sockets.\n+        SocketHandlerConnected(io_readiness);\n+\n+        // Accept new connections from listening sockets.\n+        SocketHandlerListening(io_readiness.events_per_sock);\n+\n+        // Disconnect any clients that have been flagged.\n+        DisconnectClients();\n+    }\n }\n \n-CService HTTPRequest::GetPeer() const\n+void HTTPServer::MaybeDispatchRequestsFromClient(std::shared_ptr<HTTPClient> client) const\n {\n-    evhttp_connection* con = evhttp_request_get_connection(req);\n-    CService peer;\n-    if (con) {\n-        // evhttp retains ownership over returned address string\n-        const char* address = \"\";\n-        uint16_t port = 0;\n+    // Try reading (potentially multiple) HTTP requests from the buffer\n+    while (!client->m_recv_buffer.empty()) {\n+        // Create a new request object and try to fill it with data from the receive buffer\n+        auto req = std::make_unique<HTTPRequest>(client);\n+        try {\n+            // Stop reading if we need more data from the client to parse a complete request\n+            if (!client->ReadRequest(req)) break;\n+        } catch (const std::runtime_error& e) {\n+            LogDebug(\n+                BCLog::HTTP,\n+                \"Error reading HTTP request from client %s (id=%lld): %s\",\n+                client->m_origin,\n+                client->m_id,\n+                e.what());\n+\n+            // We failed to read a complete request from the buffer\n+            req->WriteReply(HTTP_BAD_REQUEST);\n+            client->m_disconnect = true;\n+            break;\n+        }\n+\n+        // We read a complete request from the buffer into the queue\n+        LogDebug(\n+            BCLog::HTTP,\n+            \"Received a %s request for %s from %s (id=%lld)\",\n+            RequestMethodString(req->m_method),\n+            req->m_target,\n+            client->m_origin,\n+            client->m_id);\n+\n+        // add request to client queue\n+        client->m_req_queue.push_back(std::move(req));\n+    }\n \n-#ifdef HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n-        evhttp_connection_get_peer(con, &address, &port);\n-#else\n-        evhttp_connection_get_peer(con, (char**)&address, &port);\n-#endif // HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR\n+    // If we are already handling a request from\n+    // this client, do nothing. We'll check again on the next I/O\n+    // loop iteration.\n+    if (client->m_req_busy) return;\n \n-        peer = MaybeFlipIPv6toCJDNS(LookupNumeric(address, port));\n+    // Otherwise, if there is a pending request in the queue, handle it.\n+    if (!client->m_req_queue.empty()) {\n+        client->m_req_busy = true;\n+        m_request_dispatcher(std::move(client->m_req_queue.front()));\n+        client->m_req_queue.pop_front();\n     }\n-    return peer;\n }\n \n-std::string HTTPRequest::GetURI() const\n+void HTTPServer::DisconnectClients()\n {\n-    return evhttp_request_get_uri(req);\n+    const auto now{Now<SteadySeconds>()};\n+    size_t erased = std::erase_if(m_connected,\n+                                  [&](auto& client) {\n+                                        // Disconnect this client if it is flagged individually or if the\n+                                        // server is flagged to disconnect all...\n+                                        if (((client->m_disconnect || m_disconnect_all_clients) &&\n+                                            // ...but not if this client is specifically flagged to prevent disconnect!\n+                                            // It is probably still busy.\n+                                            !client->m_prevent_disconnect) ||\n+                                            // No matter what, always disconnect if client has timed out.\n+                                            now - client->m_idle_since > m_rpcservertimeout) {\n+                                            LogDebug(BCLog::HTTP,\n+                                                     \"Disconnected HTTP client %s (id=%d)\",\n+                                                     client->m_origin,\n+                                                     client->m_id);\n+                                            return true;\n+                                        } else {\n+                                            return false;\n+                                        }});\n+    if (erased > 0) {\n+        // Report back to the main thread\n+        m_connected_size.fetch_sub(erased, std::memory_order_relaxed);\n+    }\n }\n \n-HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod() const\n+bool HTTPClient::ReadRequest(const std::unique_ptr<HTTPRequest>& req)\n {\n-    switch (evhttp_request_get_command(req)) {\n-    case EVHTTP_REQ_GET:\n-        return GET;\n-    case EVHTTP_REQ_POST:\n-        return POST;\n-    case EVHTTP_REQ_HEAD:\n-        return HEAD;\n-    case EVHTTP_REQ_PUT:\n-        return PUT;\n-    default:\n-        return UNKNOWN;\n-    }\n+    LineReader reader(m_recv_buffer, MAX_HEADERS_SIZE);\n+\n+    if (!req->LoadControlData(reader)) return false;\n+    if (!req->LoadHeaders(reader)) return false;\n+    if (!req->LoadBody(reader)) return false;\n+\n+    // Remove the bytes read out of the buffer.\n+    // If one of the above calls throws an error, the caller must\n+    // catch it and disconnect the client.\n+    m_recv_buffer.erase(\n+        m_recv_buffer.begin(),\n+        m_recv_buffer.begin() + (reader.it - reader.start));\n+\n+    return true;\n }\n \n-std::optional<std::string> HTTPRequest::GetQueryParameter(const std::string& key) const\n+bool HTTPClient::MaybeSendBytesFromBuffer()\n {\n-    const char* uri{evhttp_request_get_uri(req)};\n+    // Send as much data from this client's buffer as we can\n+    LOCK(m_send_mutex);\n+    if (!m_send_buffer.empty()) {\n+        // Socket flags (See kernel docs for send(2) and tcp(7) for more details).\n+        // MSG_NOSIGNAL: If the remote end of the connection is closed,\n+        //               fail with EPIPE (an error) as opposed to triggering\n+        //               SIGPIPE which terminates the process.\n+        // MSG_DONTWAIT: Makes the send operation non-blocking regardless of socket blocking mode.\n+        // MSG_MORE:     We do not set this flag here because http responses are usually\n+        //               small and we want the kernel to send them right away. Setting MSG_MORE\n+        //               would \"cork\" the socket to prevent sending out partial frames.\n+        int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+\n+        // Try to send bytes through socket\n+        ssize_t bytes_sent;\n+        {\n+            LOCK(m_sock_mutex);\n+            bytes_sent = m_sock->Send(m_send_buffer.data(),\n+                                      m_send_buffer.size(),\n+                                      flags);\n+        }\n+\n+        if (bytes_sent < 0) {\n+            // Something went wrong\n+            const int err{WSAGetLastError()};\n+            // These errors can be safely ignored, and we should try the send again\n+            // on the next I/O loop. See send(2) for more details.\n+            // EWOULDBLOCK: The requested operation would block.\n+            //              The non-blocking socket operation cannot complete immediately.\n+            // EMSGSIZE:    Message too large. The receive buffer is too small for the incoming message.\n+            // EINTR:       Interrupted function call. The socket operation was interrupted by another thread.\n+            // EINPROGRESS: A socket operation in already progress.\n+            if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+                return true;\n+            }\n \n-    return GetQueryParameterFromUri(uri, key);\n+            // Unrecoverbale error, log and disconnect client.",
      "path": "src/httpserver.cpp",
      "position": 1276,
      "original_position": 1276,
      "commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "original_commit_id": "d48c18b88c64839fd48647a8bb10db4fa266f3e9",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Possible typos and grammar issues:\r\n\r\n    Unrecoverbale -> Unrecoverable [spelling error in comment; could cause momentary confusion]\r\n    datasent -> data sent [missing space / concatenated words in comment; minor typo impacting readability]\r\n\r\nPossible places where comparison-specific test macros should replace generic comparisons:\r\n\r\n    src/test/httpserver_tests.cpp: BOOST_CHECK_THROW(req.LoadHeaders(reader), std::runtime_error) -> Replace with BOOST_CHECK_EXCEPTION(req.LoadHeaders(reader), std::runtime_error, HasReason{\"HTTP header missing colon (:)\"}\r\n\r\n2026-02-12 16:33:30",
      "created_at": "2026-02-13T13:02:18Z",
      "updated_at": "2026-02-13T13:02:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2804115631",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2804115631"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32061"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1020,
      "original_line": 1020,
      "side": "RIGHT"
    }
  ]
}